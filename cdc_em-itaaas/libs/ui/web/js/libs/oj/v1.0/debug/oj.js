(function(){/*
** Copyright (c) 2008, 2012, Oracle and/or its affiliates. All rights reserved.
**
**34567890123456789012345678901234567890123456789012345678901234567890123456789
*/
/*jslint browser: true*/
/*global define: false,goog: true,self:true*/

/**
 * Defines the oj namespace
 */

/**
 * @private
 */
var _scope = {};

// Bug 16874826 - check if the window object is available
// Note that the 'typeof' check  is required
if (typeof window !== 'undefined')
{
  _scope = window;
}
else if (typeof self !== 'undefined')
{
  _scope = self;
}

/**
 * @private
 */
var _oldVal = _scope['oj'];

/**
 * Global exported Oracle JET namespace
 * @property {String} version JET version number
 * @property {String} build JET build number
 * @property {String} revision JET source code revision number
 */
var oj = _scope['oj'] =
{
  'version': "1.0",
  'build' : "2494",
  'revision': "7206",
          
  // This function is only meant to be used outside the library, so quoting the name
  // to avoid renaming is appropriate
  'noConflict': function()
  {
    _scope['oj'] = _oldVal;
  }

};
// Copyright (c) 2011, 2013, Oracle and/or its affiliates. 
// All rights reserved.

/*jslint browser: true*/

/**
 * @class  A wrapper above different output writers. The default writer is the native browser console. 
 * It also supports a custom writer objects that are compatible with JET logger API. 
 * In order to be compatible with JET logger API the writer should implement the following methods: log(), info(), warn(), error()
 * @export
 */ 
oj.Logger = {}; 
/**
 * Log level none
 * @const
 * @export 
 */
oj.Logger.LEVEL_NONE = 0;
/**
 * Log level error
 * @const
 * @export 
 */
oj.Logger.LEVEL_ERROR = 1;
/**
 * Log level warning
 * @const
 * @export 
 */
oj.Logger.LEVEL_WARN = 2;
/**
 * Log level info
 * @const
 * @export 
 */
oj.Logger.LEVEL_INFO = 3;
/**
 * Log level - general message
 * @const
 * @export 
 */
oj.Logger.LEVEL_LOG = 4;

/* private constants*/
oj.Logger._METHOD_ERROR = "error";
oj.Logger._METHOD_WARN = "warn";
oj.Logger._METHOD_INFO = "info";
oj.Logger._METHOD_LOG = "log";
oj.Logger._defaultOptions = {'level': oj.Logger.LEVEL_ERROR, 'writer': null};
oj.Logger._options = oj.Logger._defaultOptions;


/*public members*/
/**
 * Writes an error message.  
 * @param {...Object|string} obj 
 * @export 
 */
oj.Logger.error = function(obj)
{
  oj.Logger._write(oj.Logger.LEVEL_ERROR, oj.Logger._METHOD_ERROR, arguments);
};

/**
 * Writes an informational  message. 
 * @param {...Object|string} obj
 * @export 
 */
oj.Logger.info = function(obj)
{
  oj.Logger._write(oj.Logger.LEVEL_INFO, oj.Logger._METHOD_INFO, arguments);
};

/**
 * Writes a warning message.
 * @param {...Object|string} obj
 * @export 
 */
oj.Logger.warn = function(obj)
{
  oj.Logger._write(oj.Logger.LEVEL_WARN, oj.Logger._METHOD_WARN, arguments);
};

/**
 * Writes a general message. 
 * @param {...Object|string} obj 
 * @export 
 */
oj.Logger.log = function(obj)
{
  oj.Logger._write(oj.Logger.LEVEL_LOG, oj.Logger._METHOD_LOG, arguments);
};

/**
 * Method for setting and getting logger option/options
 * @param {Object|string=} key
 * @param {Object|string=} value 
 * @export
 */
oj.Logger.option = function (key, value)
{
  //getters
  var ret = {}, opt;
  if (arguments.length == 0) {
     for (opt in oj.Logger._options) {
      if (oj.Logger._options.hasOwnProperty(opt)) {
        ret[opt]=oj.Logger._options[opt];
      }
     }
     return ret;
  }
  if (typeof key === "string" && value === undefined) {
     return oj.Logger._options[key] === undefined ? null : oj.Logger._options[key];
  }
     
  //setters
  if (typeof key === "string") {
    oj.Logger._options[key] = value;
  }
  else { // case when all options are set in one call
    var options = key;
    for (opt in options) {
      if (options.hasOwnProperty(opt)) {
        oj.Logger.option(opt, options[opt]);
      }
    }
  }
};

/* private members*/
/*
 * Helper method - calls a specified method on the available writer (console or custom) 
 * if the logging level is sufficient
 */
oj.Logger._write = function(level, method, args)
{
  if (oj.Logger.option("level") < level) {
    return;
  }

  var writer = oj.Logger._getWriter();
  if (writer != null) {
    if (args.length == 1 && (args[0] instanceof Function)) {
      var msg = args[0]();
      args = [msg];
    }
    if (writer[method] && writer[method].apply) {
      writer[method].apply(writer, args);
    }
    else if (writer[method]) {
      writer[method] = Function.prototype.bind.call(writer[method], writer);
      oj.Logger._write(level, method, args);
    } 
  }
};

/*
 * Helper method - returns available writer (console or custom) 
 */
oj.Logger._getWriter = function()
{
  var writer = null;
  if (oj.Logger.option("writer")) {
    writer =  oj.Logger.option("writer");
  }
  else if (window !== undefined && window.console !== undefined) {
    writer = window.console;
  }
  return writer;
};

/*
 * Helper method - validates an option against default options
 * Returns true if the option(key) is a default option
 */
oj.Logger._validateOption = function(key)
{
  return oj.Logger._defaultOptions[key] !== undefined; 
};
/*
** Copyright (c) 2008, 2012, Oracle and/or its affiliates. All rights reserved.
**
**34567890123456789012345678901234567890123456789012345678901234567890123456789
*/
/*jslint browser: true*/
/*global define: false,goog: true*/

/**
 * Base class of all OJET Objects.
 * <p>
 * To create a subclass of another oj.Object, use oj.Object.createSubclass.
 * The subclass can specify class-level initialization by implementing an
 * <code>InitClass()</code> method on its constructor.  <code>InitClass</code>
 * is guaranteed to be called only once per class.  Further, a class'
 * <code>InitClass</code> method is guranteed to be called only after its
 * superclass' class initialization has been called.  When <code>InitClass</code>
 * is called, <code>this</code> is the class' constructor.  This allows class
 * initialization implementations to be shared in some cases.
 * </p>
 * @author Blake Sullivan
 */


/**
 * @constructor
 * @export
 */
oj.Object = function()
{
  this.Init();
};
 
oj.Object.superclass = null;

/**
 * @private
 */
oj.Object._typeName = "oj.Object";

// regular expressicloneon for stripping out the name of a function
/**
 * @private
 */
oj.Object._GET_FUNCTION_NAME_REGEXP = /function\s+([\w\$][\w\$\d]*)\s*\(/;
// oj.Object._TRIM_REGEXP = /(^\s*)|(\s*$)/g; this.replace(/(^\s*)|(\s*$)/g, "");

oj.Object.prototype = {};
oj.Object.prototype.constructor = oj.Object;


/**
 * Calls to  this method are added by the Closure Compiler pass during JET's build process.
 * It should never be called by the Application code
 * 
 * The method delegates to goog.exportProperty() for exporting a symbol with Closure compiler,
 * while recoreding a map of the renamed names to an original names and a map of original names to the renamed names
 * @param {string} name - name of the property ('CCCC.prototype.FFFF' is expected)
 * @param {Object} valueMapping - a name-value pair, where tke key is the renamed name (renamed FFFF), and the value is the refernce to the member function
 * whose name was exported
 */
oj.Object.exportPrototypeSymbol = function(name, valueMapping)
{
  var renamed = null;
  var val = null, prop;
  for (prop in valueMapping)
  {
    if (valueMapping.hasOwnProperty(prop)) {
        renamed = prop;
        val = valueMapping[prop];
        break;
    }
  }

  var tokens = name.split('.');

  var constructor = oj[tokens[0]];
  var original = tokens[2];

  // Do nothing if we are exporting a function that has not been renamed
  if (renamed == original || renamed == null)
  {
    return;
  }

  var renameMap = constructor._r2o;
  if (!renameMap)
  {
     renameMap = {};
     constructor._r2o = renameMap;
  }

  renameMap[renamed] = original;

  goog.exportProperty(constructor.prototype, original, val);
};

/**
 * Creates a subclass of a baseClass
 * @export
 */
oj.Object.createSubclass = function(
  extendingClass,
  baseClass,
  typeName)  // optional name to name this class
{
  oj.Assert.assertFunction(extendingClass);
  oj.Assert.assertFunctionOrNull(baseClass);
  oj.Assert.assertStringOrNull(typeName);

  if (baseClass === undefined)
  {
    // assume oj.Object
    baseClass = oj.Object;
  }

  oj.Assert.assert(extendingClass !== baseClass, "Class can't extend itself");

  // use a temporary constructor to get our superclass as our prototype
  // without out having to initialize the superclass
  /**
   * @private
   * @constructor
   */
  var TempConstructor = oj.Object._tempSubclassConstructor;

  TempConstructor.prototype = baseClass.prototype;
  extendingClass.prototype = new TempConstructor();

  extendingClass.prototype.constructor = extendingClass;
  extendingClass.superclass = extendingClass["superclass"] = baseClass.prototype;

  if (typeName) {
    extendingClass._typeName = typeName;
  }
};

/**
 * Copies properties from the source object to the prototype of the target class
 * Only properties 'owned' by the source object will be copied, i.e. the properties
 * from the source object's prototype chain will not be included.
 * To copy properties from another class with methods defined on the prototype, pass
 * otherClass.prototype as the source.
 * @param {Function} targetClass - the function whose prototype will be used a 
 * copy target
 * @param {Object} source - object whose properties will be copied
 * @export
 */
oj.Object.copyPropertiesForClass = function(targetClass, source) 
{ 
  var prop;
  oj.Assert.assertFunction(targetClass);
  oj.Assert.assert(source != null, "source object cannot be null");
  
  for(prop in source) 
  { 
    if(source.hasOwnProperty(prop)) 
    { 
      targetClass.prototype[prop] = source[prop]; 
    } 
  } 
};

/**
 * @private
 */
oj.Object._tempSubclassConstructor = function(){};




/**
 * @final
 * @export
 */
oj.Object.prototype.getClass = function(
  otherInstance)
{
  if (otherInstance === undefined) {
    otherInstance = this;
  }
  else if (otherInstance === null)
  {
    return null;
  }

  return otherInstance["constructor"];
};


/**
 * Adopt the properties of another object as our own
 * @export
 */
oj.Object.prototype.adopt = function(
  theRawObject
  )
{
  oj.CollectionUtils.copyInto(this, theRawObject);
};

/**
 * Returns a clone of this object.  The default implementation is a shallow
 * copy.  Subclassers can override this method to implement a deep copy.
 * @export
 */
oj.Object.prototype.clone = function()
{
  var clone = new this.constructor();

  oj.CollectionUtils.copyInto(clone, this);

  return clone;
};

/**
 * @export
 */
oj.Object.prototype.toString = function()
{
  return this.toDebugString();
};

/**
 * @export
 */
oj.Object.prototype.toDebugString = function()
{
  return this.getTypeName() + " Object";
};


/**
 * Returns the type name for a class derived from oj.Object
 * @param {Function!|null} clazz Class to get the name of
 * @return {String} name of the Class
 * @export
 */
oj.Object.getTypeName = function(clazz)
{
  oj.Assert.assertFunction(clazz);

  var typeName = clazz._typeName, constructorText, matches;

  if (typeName == null)
  {
    constructorText = clazz.toString();
    matches = oj.Object._GET_FUNCTION_NAME_REGEXP.exec(constructorText);

    if (matches)
    {
      typeName = matches[1];
    }
    else
    {
      typeName = "anonymous";
    }

    // cache the result on the function
    clazz._typeName = typeName;
  }

  return typeName;
};

/**
 * Returns the type name for this instance
 * @return {String} name of the Class
 * @final
 * @export
 */
oj.Object.prototype.getTypeName = function()
{
  return oj.Object.getTypeName(this.constructor);
};

/**
 * Initializes the instance.  Subclasses of oj.Object must call
 * their superclass' Init
 * @export
 */
oj.Object.prototype.Init = function()
{
  if (oj.Assert.DEBUG) {
    oj.Assert.assert(this["getTypeName"], "Not an oj.Object");
  }

  // do any class initialization.  This code is duplicated from
  // oj.Object.ensureClassInitialization()

  var currClass = this.constructor;
  if (!currClass._initialized) {
    oj.Object._initClasses(currClass);
  }
};

/**
 * Ensures that a class is initialized.  Although class initialization occurs
 * by default the first time that an instance of a class is created, classes that
 * use static factory methods to create their instances may
 * still need to ensure that their class has been initialized when the factory
 * method is called.
 *
 * @param {Function} clazz The class to ensure initialization of
 * @export
 */
oj.Object.ensureClassInitialization = function(clazz)
{
  oj.Assert.assertFunction(clazz);

  if (!clazz._initialized) {
    oj.Object._initClasses(clazz);
  }
};

/**
 * Returns the specified Map property.  If createIfNonexistent is true and
 * the property doesn't exist, an empty Object will be created, and returned.
 */
/*oj.Object.prototype.GetLazyMapProperty = function(
  propName,
  createIfNonexistent,
  otherInstance)
{
  if (otherInstance == undefined)
    otherInstance = this;

  var property = otherInstance[propName];

  if ((property == undefined) && createIfNonexistent)
  {
    property = new Object();
    otherInstance[propName] = property;
  }

  return property;
}*/

/**
 * Returns the specified array property.  If createIfNonexistent is true and
 * the property doesn't exist, it will be created, and returned.
 */
 /*
oj.Object.prototype.GetLazyArrayProperty = function(
  propName,
  createIfNonexistent,
  otherInstance)
{
  if (otherInstance == undefined)
    otherInstance = this;

  var property = otherInstance[propName];

  if ((property == undefined) && createIfNonexistent)
  {
    property = new Array();
    otherInstance[propName] = property;
  }

  return property;
}*/

/**
 * Indicates whether some other oj.Object is "equal to" this one.
 * Method is equivalent to java ".equals()" method.
 * @export
 */
oj.Object.prototype.equals = function(
  object)
{
  return this === object;
};

/**
 * Creates a function instance that will callback the passed in function
 * with the given "obj".  This is extremely useful for creating callbacks
 * @export
 */
oj.Object.createCallback = function(obj, func)
{
  oj.Assert.assertFunction(func);
  var funcName = func[oj.Assert.FUNC_NAME_PROPERTY], proxyFunction;

  // =-=  bts theoretically, we could call the same code we use
  //          to generate the FUNC_NAME_PROPERTY in the first place
  //          if this property isn;t set/
  oj.Assert.assertString(funcName);

  // create a function that sets up "obj" and delegates all of the parameters
  // to the passed in function
  /*jslint evil:true */
  proxyFunction = new Function(
    "var f=arguments.callee; return f._func.apply(f._owner, arguments);");

  // attach ourselves as "this" to the created function
  proxyFunction["_owner"] = obj;

  // attach function to delegate to
  proxyFunction["_func"] = func;

  return proxyFunction;
};

/**
 * Convenience function for creating an Object initialized with key values pairs
 * as alternating parameters.  All off the even parameters must be keys
 * represented as Strings, with the odd parameters, their values.
 * @export
 */
oj.Object.createInitializedObject = function()
{
  var argCount = arguments.length, newObject, i, currKey;

  oj.Assert.assert(argCount % 2 === 0, "every key must have a value");

  newObject = {};

  for (i = 0; i < argCount; i=i+1)
  {
    currKey = arguments[i];
    oj.Assert.assertString(currKey);

    // move to value
    i=i+1;

    // assign key/value pair
    newObject[currKey] = arguments[i];
  }

  return newObject;
};

/**
 * @private
 */
oj.Object._applyFunctionProperties = function(
  target,
  className)
{
  var funcNameProperty = oj.Assert.FUNC_NAME_PROPERTY, classNameProperty = oj.Assert.CLASS_NAME_PROPERTY, currPropName, currProp;

  for (currPropName in target)
  {
    if (target.hasOwnProperty(currPropName)) {
        currProp = target[currPropName];

        if ((typeof currProp) === "function")
        {
          // we only care about methods defined on our object
          if (!currProp.hasOwnProperty(funcNameProperty))
          {
            currProp[funcNameProperty] = currPropName;
            currProp[classNameProperty] = className;
          }
        }
    }
  }
};

/**
 * @private
 */
oj.Object._initClasses = function(currClass)
{
  if (oj.Assert.DEBUG)
  {
    oj.Assert.assertFunction(currClass);
    oj.Assert.assert(!currClass._initialized);
  }

  currClass._initialized = true;

  var superclass = currClass.superclass, superclassConstructor, typeName, InitClassFunc;

  // initialize the superclass if necessary
  if (superclass)
  {
    superclassConstructor = superclass.constructor;

    if (superclassConstructor && !superclassConstructor._initialized) {
      oj.Object._initClasses(superclassConstructor);
    }
      
    oj.Object._applyRenamesToSubclass(currClass);
  }

  typeName = oj.Object.getTypeName(currClass);

  try
  {
    // if the class has an initialization function, call it
    InitClassFunc = currClass["InitClass"] || null;
    
    // Check for the quoted name in case InitClass is renamed by Closure compiler
    if (!InitClassFunc)
    {
      InitClassFunc = currClass["InitClass"];
    }

    if (InitClassFunc)
    {
      InitClassFunc.call(currClass);
    }
  }
  finally
  {
    // set names on all of the functions so that we can pick them up for
    // stack dumps.  By the time the subclasses have inited, we should
    // have all of our functions
    if (oj.Assert.DEBUG)
    {
      // apply the stack information to our instance's instance methods
      oj.Object._applyFunctionProperties(currClass.prototype, typeName);

      // apply the stack information to our class's static methods
      oj.Object._applyFunctionProperties(currClass, "static " + typeName);
    }
  }
};

/**
 * Compares 2 values using strict equality except for the case of 
 * 1) Specific API invocation for Array [order matters], Date, and Object 
 * 
 * @expose
 */
oj.Object.compareValues = function (obj1, obj2)
{
  if (obj1 === obj2) 
  {
    return true;
  }
  
  var obj1Type = typeof obj1,
      obj2Type = typeof obj2;
  
  if (obj1Type !== obj2Type) 
  {
    //of different type so consider them unequal
    return false;
  }
  
  //At this point means the types are equal
  
  //note that if the operand is an array or a null then typeof is an object
  //check if either is null and if so return false [i.e. case where one might be a null and another an object]
  //and one wishes to avoid the null pointer in the following checks. Note that null === null has been already tested 
  if(obj1 === null || obj2 === null) 
  {
    return false;
  }
  
  //now check for constructor since I think by here one has ruled out primitive values and if the constructors 
  //aren't equal then return false
  if(obj1.constructor === obj2.constructor) 
  {
    
    //these are special cases and will need to be modded on a need to have basis
    if(Array.isArray(obj1))
    {
      return oj.Object._compareArrayValues(obj1, obj2);
    }
    else if(obj1.constructor === Object)
    {
      //for now invoke innerEquals and in the future if there are issues then resolve them
      return oj.Object.innerEquals(obj1, obj2);
    }
    else if(obj1["valueOf"] && typeof obj1["valueOf"] === "function") 
    {
      //test cases for Boolean, String, Number, Date
      //Note if some future JavaScript constructors 
      //do not impl it then it's their fault
      return obj1.valueOf() === obj2.valueOf();
    }
    
  }
  
  return false;
};

oj.Object._compareArrayValues = function (array1, array2) 
{
  if (array1.length !== array2.length)
  {
    return false;
  }

  for (var i = 0, j = array1.length;i < j;i++)
  {
    //recurse on each of the values, order does matter for our case since do not wish to search 
    //for the value [expensive]
    if (!oj.Object.compareValues(array1[i], array2[i]))
    {
      return false;
    }
  }
  return true;
}

oj.Object.innerEquals = function (obj1, obj2) {
  var prop, hasProperties = false;

  if (obj1 === obj2) {
    return true;
  }

  if (!(obj1 instanceof Object) || !(obj2 instanceof Object)) {
    return false;
  }

  if (obj1.constructor !== obj2.constructor) 
  {
    return false;
  }

  for (prop in obj1) 
  {
    if (!hasProperties)
    {
      hasProperties = true;
    }
    if (obj1.hasOwnProperty(prop)) {        
      if (!obj2.hasOwnProperty(prop)) 
      {
        return false;
      }

      if (obj1[prop] !== obj2[prop]) 
      {
        if (typeof(obj1[prop]) !== 'object') {
          return false;
        }

        if (!oj.Object.innerEquals(obj1[prop], obj2[prop])) 
        {
          return false;
        }
      }
    }
  }
  
  for (prop in obj2) 
  {
    if (!hasProperties)
    {
      hasProperties = true;
    }
    
    if (obj2.hasOwnProperty(prop) && !obj1.hasOwnProperty(prop)) {
      return false;
    }
  }
  
  if (!hasProperties)
  {
    // we are dealing with objects that have no properties like Number or Date.
    return JSON.stringify(obj1) === JSON.stringify(obj2);
  }
  
  return true;
};

oj.Object.isEmpty = function(object) {
    var prop;
    // Test if an object is empty
    if (object === undefined || object === null) {
        return true;
    }
    
    for (prop in object) {
        if (object.hasOwnProperty(prop)) {
            return false;
        }
    }
    return true;
};

/**
 * @private
 */
oj.Object._applyRenamesToSubclass = function (currClass)
{
  // Check whether any renames actually happened
  if (!oj.Object._r2o)
  {
    return;
  }
  var ancestor = currClass.superclass;
  oj.Object._applyRenamesFromChain(currClass, ancestor);
};

/**
 * @private
 */
oj.Object._applyRenamesFromChain = function(currClass, superclass)
{
  if (!superclass)
  {
    return;
  }
  
  var ancestor = superclass.constructor;
  
  
  //Recurse up the inheritance chain first
  oj.Object._applyRenamesFromChain(currClass, ancestor.superclass);
  
  var renameMap = ancestor._r2o, alias;
  if (renameMap)
  {
    for (alias in renameMap)
    {
      if (renameMap.hasOwnProperty(alias)) {
        var orig = renameMap[alias];
        if (alias != orig)
        {
          var prot = currClass.prototype;
          if (!prot.hasOwnProperty(alias) && prot.hasOwnProperty(orig))
          {
            prot[alias] = prot[orig];
          }
          else if(!prot.hasOwnProperty(orig) && prot.hasOwnProperty(alias))
          {
            prot[orig] = prot[alias];
          }
        }
      }  
    }
  }
};

/**
 * @private
 * @return  {boolean} true if AMD Loader (such as Require.js) is present, 
 *                    false otherwise
 */
oj.__isAmdLoaderPresent = function()
{
  return (typeof define === 'function' && define['amd']);
};




/*
** Copyright (c) 2008, 2011, Oracle and/or its affiliates. All rights reserved.
*/

/*jslint browser: true*/

/**
 * Assertion utilities.
 * The container is expected to have already initialized the oj.Assert Object before this
 * code is executed and initialized the oj.Assert.DEBUG flag/
 * @author Blake Sullivan
 * @constant {Object|Boolean} DEBUG <code>true</code> if assertions are enabled.
 * @export
 * @ignore
 */
oj.Assert = {};


/**
 * Forces DEBUG to be set to true
 * @export
 */
oj.Assert.forceDebug = function()
{
  oj.Assert.DEBUG = oj.Assert["DEBUG"] = true;
};

// name of property on function objects that stack dumping will look for
// to get the function name
oj.Assert.FUNC_NAME_PROPERTY = "_funcName";

// name of property on function objects that stack dumping will look for
// to get the class name
oj.Assert.CLASS_NAME_PROPERTY = "_className";

// maximum stack depth that we will generate a stack trace for
oj.Assert._MAX_STACK_DEPTH_LIMIT = 20;

/**
 * Asserts that a condition is true.  If the condition does not
 * evaluate to true, an exception is thrown with the optional message
 * and reason
 * @param {boolean} condition condition to test
 * @param {string=} message message to display
 * @export
 */
oj.Assert.assert = function(
  condition,
  message
  )
{
  if (oj.Assert.DEBUG && !condition)
  {
    var myMessage = message || "", i;
    if (arguments.length > 2)
    {      
      myMessage += "(";
      for(i=2; i<arguments.length; i=i+1)
      {
        myMessage += arguments[i];
      }
      myMessage += ")";
    }
    oj.Assert.assertionFailed(myMessage, 1);
  }
};

/**
 * Convenience function for asserting when an abstact function is called
 * @export
 */
oj.Assert.failedInAbstractFunction = function()
{
  if (oj.Assert.DEBUG)
  {
    oj.Assert.assertionFailed("Abstract function called", 1);
  }
};



/**
 * Asserts that the the target object has the same prototype as the example
 * type
 * @param {Object} target description
 * @param {Function} theConstructor
 * @param {string=} reason
 * @export
 */
oj.Assert.assertPrototype = function(
  target,
  theConstructor,
  reason
  )
{
  var thePrototype;
  
  if (oj.Assert.DEBUG)
  {
    if (target !== null)
    {
      oj.Assert.assertType(theConstructor, "function", null, 1, false);
      thePrototype = theConstructor.prototype;
    
      if (!thePrototype.isPrototypeOf(target))
      {
        oj.Assert.assertionFailed("object '" + target + "' doesn't match prototype "
                               + thePrototype,
                               1,
                               reason);
      }
    }
    else
    {
      oj.Assert.assertionFailed("null object doesn't match prototype " + thePrototype, 1, reason);
    }
  }
};

/**
 * Asserts that the the target object has the same prototype as the example
 * type or is null.
 * @export
 */
oj.Assert.assertPrototypeOrNull = function(
  target,
  theConstructor,
  reason
  )
{
  var thePrototype;
  
  if (oj.Assert.DEBUG && (target !== null))
  {
    if (target !== null)
    {
      oj.Assert.assertType(theConstructor, "function", null, 1, false);
      thePrototype = theConstructor.prototype;
    
      if (!thePrototype.isPrototypeOf(target))
      {
        oj.Assert.assertionFailed("object '" + target + "' doesn't match prototype "
                               + thePrototype,
                               1,
                               reason);
      }
    }
    else
    {
      oj.Assert.assertionFailed("null object doesn't match prototype " + thePrototype, 1, reason);
    }
  }
};

/**
 * Asserts that the the target object has the same prototype as the example
 * types
 * @export
 */
oj.Assert.assertPrototypes = function(
  target,
  instanceOne,
  instanceTwo,
  reason
  )
{
  if (oj.Assert.DEBUG)
  {
    var thePrototype = instanceOne.prototype, thePrototypeTwo = instanceTwo.prototype;
    
    if (!(thePrototype.isPrototypeOf(target) ||
          thePrototypeTwo.isPrototypeOf(target)))
    {
      oj.Assert.assertionFailed("object '" + target + "' doesn't match prototype "
                             + thePrototype + " or " + thePrototypeTwo,
                             1,
                             reason);
    }
  }
};


/**
 * Asserts that the target is a DOM Node or Null
 * @export
 */
oj.Assert.assertDomNodeOrNull = function(target, depth)
{
  if (oj.Assert.DEBUG && target)
  {
    if (target["nodeType"] === undefined)
    {
      oj.Assert.assertionFailed(target + " is not a DOM Node", depth + 1);
    }
  }
};

/**
 * Asserts that the target is a DOM Node
 * @export
 */
oj.Assert.assertDomNode = function(target, depth)
{
  if (oj.Assert.DEBUG)
  {
    if (!target || (target["nodeType"] === undefined))
    {
      oj.Assert.assertionFailed(target + " is not a DOM Node", depth + 1);
    }
  }
};

/**
 * Asserts that the target is a DOM Element and optionally has the specified
 * element name
 * @param {Object} target target object
 * @param {string=} nodeName name of the element
 * @export
 */
oj.Assert.assertDomElement = function(target, nodeName)
{
  if (oj.Assert.DEBUG)
  {
    oj.Assert.assertDomNode(target, 1);

    if (target.nodeType !== 1)
    {
      oj.Assert.assertionFailed(target + " is not a DOM Element", 1);
    }
    else if (nodeName && (target.nodeName !== nodeName))
    {      
      oj.Assert.assertionFailed(target + " is not a " + nodeName + " Element", 1);
    }
  }
};

/**
 * Asserts that the target is a DOM Element and optionally has the specified
 * element name
 * @export
 */
oj.Assert.assertDomElementOrNull = function(target, nodeName)
{
  if (oj.Assert.DEBUG && (target !== null))
  {
    oj.Assert.assertDomNode(target, 1);

    if (target.nodeType !== 1)
    {
      oj.Assert.assertionFailed(target + " is not a DOM Element", 1);
    }
    else if (nodeName && (target.nodeName !== nodeName))
    {
      oj.Assert.assertionFailed(target + " is not a " + nodeName + " Element", 1);
    }
  }
};


/**
 * Asserts that the target object has the typeof specified
 * 
 * @param {Object} target 
 * @param {string} type typeof type that statisfies this condition
 * @param {string|undefined|null} prefix
 * @param {number} depth stack depth to skip when printing stack traces
 * @param {boolean} nullOK true if a null value satisfies this condition
 * @export
 */
oj.Assert.assertType = function(target,type,prefix,depth, nullOK)
{
  if (oj.Assert.DEBUG)
  {
    // either the target is null and null is OK, or the target better
    // be of the correct type
    var message, targetType = typeof target;
    if (!(((target === null) && nullOK) || (targetType === type)))
    {
      message = target + " is not of type " + type;
      
      if (prefix) {
        message = prefix + message;
      }
        
      if (!depth) {
        depth = 0;
      }
        
      oj.Assert.assertionFailed(message, depth + 1);
    }
  }
};

/**
 * Asserts that the target is an Object
 * @param {Object} target description
 * @param {string=} prefix
 * @export
 */
oj.Assert.assertObject = function(target, prefix)
{
  if (oj.Assert.DEBUG)
  {
    oj.Assert.assertType(target, "object", prefix, 1, false);
  }
};

/**
 * Asserts that the target is an Object or null
 * @param {Object} target description
 * @param {string=} prefix
 * @export
 */
oj.Assert.assertObjectOrNull = function(target, prefix)
{
  if (oj.Assert.DEBUG)
  {
    oj.Assert.assertType(target, "object", prefix, 1, true);
  }
};

/**
 * Asserts that the target is a non-empty String
 * @export
 */
oj.Assert.assertNonEmptyString = function(target, prefix)
{
  if (oj.Assert.DEBUG)
  {
    oj.Assert.assertType(target, "string", prefix, 1, false);
    oj.Assert.assert(target.length > 0, "empty string"); 
  }
};

/**
 * Asserts that the target is a String
 * @param {Object} target target object
 * @param {string=} prefix prefix string
 * @export
 */
oj.Assert.assertString = function(target, prefix)
{
  if (oj.Assert.DEBUG)
  {
    oj.Assert.assertType(target, "string", prefix, 1, false);
  }
};

/**
 * Asserts that the target is a String or null
 * @param {Object} target target object
 * @param {string=} prefix prefix string
 * @export
 */
oj.Assert.assertStringOrNull = function(target, prefix)
{
  if (oj.Assert.DEBUG)
  {
    oj.Assert.assertType(target, "string", prefix, 1, true);
  }
};

/**
 * Asserts that the target is a Function
 * @param {Object} target target object
 * @param {string=} prefix prefix string
 * @export
 */
oj.Assert.assertFunction = function(target, prefix)
{
  if (oj.Assert.DEBUG)
  {
    oj.Assert.assertType(target, "function", prefix, 1, false);
  }
};

/**
 * Asserts that the target is a Function or null
 * @param {Object} target target object
 * @param {string=} prefix prefix
 * @export
 */
oj.Assert.assertFunctionOrNull = function(target, prefix)
{
  if (oj.Assert.DEBUG)
  {
    oj.Assert.assertType(target, "function", prefix, 1, true);
  }
};

/**
 * Asserts that the target is a boolean 
 * @param {Object} target description
 * @param {string=} prefix
 * @export
 */
oj.Assert.assertBoolean = function(target, prefix)
{
  if (oj.Assert.DEBUG)
  {
    oj.Assert.assertType(target, "boolean", prefix, 1, false);
  }
};

/**
 * Asserts that the target is a number
 * @export
 */
oj.Assert.assertNumber = function(target, prefix)
{
  if (oj.Assert.DEBUG)
  {
    oj.Assert.assertType(target, "number", prefix, 1, false);
  }
};

/**
 * Asserts that the target is a number or Null
 * @export
 */
oj.Assert.assertNumberOrNull = function(target, prefix)
{
  if (oj.Assert.DEBUG)
  {
    oj.Assert.assertType(target, "number", prefix, 1, true);
  }
};


/**
 * Asserts that the target object is an Array
 * @param {Object} target target object
 * @param {string=} message optional message
 * @export
 */
oj.Assert.assertArray = function(
  target,
  message
  )
{
  if (oj.Assert.DEBUG)
  {
    if (!Array.isArray(target))
    {
      if (message === undefined) {
        message = target + " is not an array";
      }
        
      oj.Assert.assertionFailed(message, 1);
    }
  }
};

/**
 * Asserts that the target object is an Array or null
 * @param {Object} target target object
 * @param {string=} message optional message
 * @export
 */
oj.Assert.assertArrayOrNull = function(
  target,
  message)
{
  if (oj.Assert.DEBUG && (target !== null))
  {
    if (!Array.isArray(target))
    {
      if (message === undefined) {
        message = target + " is not an array";
      }
        
      oj.Assert.assertionFailed(message, 1);
    }
  }
};


/**
 * Asserts that the target object is not either a number, or convertible to a number
 * @param {Object} target target object
 * @param {string=} message optional message
 * @export
 */
oj.Assert.assertNonNumeric = function(
  target,
  message
  )
{
  if (oj.Assert.DEBUG)
  { 
    if (!isNaN(target))
    {
      if (message === undefined) {
        message = target + " is convertible to a number";
      }
        
      oj.Assert.assertionFailed(message, 1);
    }
  }
};

/**
 * Asserts that the target object is either a number, or convertible to a number
 * @param {Object} target target object
 * @param {string=} message optional message
 * @export
 */
oj.Assert.assertNumeric = function(
  target,
  message
  )
{
  if (oj.Assert.DEBUG)
  {
    if (isNaN(target))
    {
      if (message === undefined) {
        message = target + " is not convertible to a number";
      }
        
      oj.Assert.assertionFailed(message, 1);
    }
  }
};

/**
 * Asserts that value String is in the Set
 * @param {Object} value value to check
 * @param {Object} set set to check
 * @param {string=} message optional message
 * @export
 */
oj.Assert.assertInSet = function(
  value,
  set,
  message)
{
  var keyString, k;
  if ((value === null) || (set[value.toString()] === undefined))
  {
    if (message === undefined)
    {
      keyString = " is not in set: {";
      
      for (k in set)
      {
        if (set.hasOwnProperty(k)) {
            keyString += k;
            keyString += ",";
        }
      }
      
      keyString += "}";
      
      message = value + keyString;
    }
      
    oj.Assert.assertionFailed(message, 1);
  }
};

/**
 * Base assertion failure support that supports specifying the stack skipping
 * level
 * @param {string} message Message to display
 * @param {number} skipLevel assertion level
 * @param {string=} reason reason to display
 * @export
 */
oj.Assert.assertionFailed = function(
  message,
  skipLevel,
  reason)
{  
  if (!skipLevel) {
    skipLevel = 0;
  }

  var errorMessage = "Assertion", stackTrace, stackTraceString, error;
  
  if (reason)
  {
    errorMessage += " (" + reason + ")";
  }
  
  errorMessage += " failed: ";
  
  if (message !== undefined)
  {
    errorMessage += message;
  }
    
  stackTrace = oj.Assert._getStackTrace(skipLevel + 1);
  
  stackTraceString = oj.Assert._getStackString(stackTrace);
  
  errorMessage += "\nStackTrace:\n" + stackTraceString;

  error = new Error(errorMessage);
  
  
  window.alert(errorMessage);

  throw error;
};

/**
 * Returns the name of a function, or <code>null</code> if the
 * name can't be determined
 * @export
 */
oj.Assert.getFunctionName = function(func)
{
  // check if the function name has been stored on the function already
  var funcName = func[oj.Assert.FUNC_NAME_PROPERTY], functionString, startFuncParamsIndex, startFuncNameIndex;

  if (funcName === undefined)
  {
    functionString = func.toString();
    startFuncParamsIndex = functionString.indexOf('(');
    
    // back up to the first space
    startFuncNameIndex = functionString.lastIndexOf(" ", startFuncParamsIndex);

    // the function name is contained in the portion of the function string between
    // the beginning of the function and the first "("
    funcName = functionString.substring(startFuncNameIndex + 1, startFuncParamsIndex);
             
    if (!funcName.length) {
      funcName = null;
    }
      
    // store the derived function name or null if the function
    // name can't be determined
    func[oj.Assert.FUNC_NAME_PROPERTY] = funcName;
  }
  
  return funcName;
};

/**
 * Returns the stack trace as a string
 * @export
 */
oj.Assert.getStackString = function(depth)
{
  if (depth === null) {
    depth = 1;
  }
    
  return oj.Assert._getStackString(oj.Assert._getStackTrace(1));
};

/**
 * Returns the stack trace as an array of function callers
 */
oj.Assert._getStackTrace = function(
  skipLevel)
{
  if (skipLevel === undefined) {
    skipLevel = 0;
  }
    
  oj.Assert.assert(skipLevel >= 0);
  
  var stackTrace = [], currCaller;
  
  // crawl up starting at our caller
  try
  {
    currCaller = oj.Assert._getStackTrace.caller;
    
    while (currCaller && (stackTrace.length < oj.Assert._MAX_STACK_DEPTH_LIMIT))
    {    
      if (!skipLevel)
      {
        stackTrace.push(currCaller);
      }
      else
      {
        skipLevel=skipLevel-1;
      }
  
      currCaller = currCaller.caller;
    }
  }
  catch (e)
  {
    // just eat it because we have no place to log this
  }
  
  
  return stackTrace;
};

/**
 * Returns the param String for a function, or null if there are no parameters
 */
oj.Assert._getFuncParams = function(func)
{
  // check if the function parameters have been stored on the function already
  var funcParams = func[oj.Assert._PARAMS_NAME_PROPERTY], currFunctionString, startFuncParams, endFuncParams;

  if (funcParams === undefined)
  {
    currFunctionString = func.toString();
    startFuncParams    = currFunctionString.indexOf('(');
    endFuncParams      = currFunctionString.indexOf(')', startFuncParams + 1);
    
    funcParams = currFunctionString.substring(startFuncParams, endFuncParams + 1);

    // remove all whitespace
    funcParams = funcParams.replace(/\s+/g, "");
    
    if (!funcParams.length) {
      funcParams = null;
    }
      
    // store the derived function name or null if the function
    // parameters don't exist
    func[oj.Assert._PARAMS_NAME_PROPERTY] = funcParams;
  }
  
  return funcParams;
};

oj.Assert._getStackString = function(
  stackTrace
  )
{  
  if (!stackTrace) {
    return "";
  }
    
  var functionCount = stackTrace.length, stackStrings = [], stackIndex, currFunction,
      funcName, className, funcParams, functionArgs, argCount, argsArray,
      argIndex, currArg, argFuncName, argFuncParams, stackStringArray;
  
  for (stackIndex = 0; stackIndex < functionCount; stackIndex=stackIndex+1)
  {
    currFunction = stackTrace[stackIndex];

    funcName = oj.Assert.getFunctionName(currFunction);
    
    if (!funcName) {
      funcName = "anonymous";
    }
      
    // try to pull the class name off of the function object
    className = currFunction[oj.Assert.CLASS_NAME_PROPERTY];
    
    // try to pull the class name off of the function object.  If we have one,
    // prepend it to the function name
    if (className) {
      funcName = className + "." + funcName;
    }

    funcParams = oj.Assert._getFuncParams(currFunction);

    functionArgs = currFunction['arguments'];
    argCount     = functionArgs.length;
    argsArray    = null;    
    
    // copy arguments into an array so that we can call join on it
    if (argCount)
    {
      // copy the entries the lame way
      argsArray = [];
              
      for (argIndex = 0; argIndex < argCount; argIndex=argIndex+1)
      {
        currArg = functionArgs[argIndex];
        
        if (typeof currArg === "function")
        {
          argFuncName = oj.Assert.getFunctionName(currArg);
   
          if (!argFuncName) {
            argFuncName = "anonymous";
          }

          argFuncParams = oj.Assert._getFuncParams(currArg);

          currArg = "function " + argFuncName + argFuncParams;
        }
        
        argsArray[argIndex] = currArg;
      }
    }

    // concatenate the pieces together
    stackStringArray = [];
    
    stackStringArray[0] = funcName;
    stackStringArray[1] = funcParams;
    
    // add in the arguments, if any
    if (argsArray)
    {
      stackStringArray[2] = "\n";
      stackStringArray[3] = "[";
      stackStringArray[4] = oj.Assert._safeJoin(argsArray, ",");
      stackStringArray[5] = "]";      
    }
    
        
    stackStrings[stackIndex] = stackStringArray.join("");
  }
  
  return stackStrings.join("\n");
};

// Joins the array elements into a single string, checking for the
// presence of toString() on each element.
oj.Assert._safeJoin = function(arr, sep)
{
  var length = arr.length, joinedString = "", i, ele, str;
  for (i = 0; i < length; i=i+1)
  {
    ele = arr[i];
    str = ele ? (ele.toString ? ele.toString() : "Unknown") : "(empty)";

    // If we care about performance, we should use a string buffer
    joinedString += str;
    
    if (sep)
    {
      if (i < length - 1) {
        joinedString += sep;
      }
    }
  }
  
  return joinedString;
};

// name of property on function objects that stack dumping will look for
// the param names
oj.Assert._PARAMS_NAME_PROPERTY = "_funcParams";

/*
** Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.
**
**34567890123456789012345678901234567890123456789012345678901234567890123456789
*/
/*jslint browser: true*/
/*global require:false,ojt:true */

/**
 * @class Services for setting and retrieving configuration options
 * @export
 */
oj.Config = {};

/**
 * Retrieves the current locale
 * @return {string} current locale
 * @export 
 */
oj.Config.getLocale = function()
{
  var rl, loc;
  if (oj.__isAmdLoaderPresent())
  {
    oj.Assert.assert(ojt !== undefined, "ojtranslations module must be defined");
    rl = ojt['_ojLocale_'];
    
    // If Require.js internationalziation plugin resolved the locale to "root" (presumably because "lang" attribute was not
    // set, and neither navigator.language or navigator.userLanguage were not available), return "en"
    return (rl == "root") ? "en" : rl;
  }
    loc = oj.Config._locale;
    if (loc == null)
    {
      loc = document.documentElement.lang;
      if (!loc)
      {
         loc = navigator === undefined ? "en" :
                            (navigator['language'] ||
                             navigator['userLanguage'] || "en").toLowerCase();
      }
      oj.Config._locale = loc = loc.toLowerCase();
    }
    return loc;
};

/**
 * Changes the current locale
 * @param {string} locale (language code and subtags separated by dash)
 * @param {Function} callback - for applications running with an AMD Loader (such as Require.js), this optional callback 
 * will be invoked when the framework is done loading its translated resources and Locale Elements for the newly specified locale. 
 * For applications running without an AMD loader, this optional callback will be invoked immediately
 * @export
 */
oj.Config.setLocale = function(locale, callback)
{
  if (oj.__isAmdLoaderPresent())
  {
    var prefix = "ojL10n!ojtranslations/nls/",
        requestedBundles = [prefix + locale + "/ojtranslations"];
    
    // Request LocaleElements only if ojlocaledata module is loaded
    if (oj.LocaleData) 
    {
      requestedBundles.push(prefix + locale + "/localeElements");    
    }
    
    require(requestedBundles,
      function(translations, localeElements)
      {
        ojt = translations;
        
        if (localeElements)
        {
          oj.LocaleData.__updateBundle(localeElements);
        }
        
        if (callback)
        {
          callback();
        }
      }
    );
  }
  else
  {
    oj.Config._locale = locale;
    if (callback)
    {
      callback();
    }
  }
};

/**
 * Retrieves a URL for loading a component-specific resource.
 * The URL is resolved as follows:
 * 1. If the application has specified a base URL with setResourceBaseUrl(), the return values will be
 * a relative path appended to the base URL.
 * 2. Otherwise, if the application running with an AMD Loader (such as Require.js), the parent folder of the 
 * ojs/ojcore module will be used as a base URL.
 * 3. Otherwise, the original relative path will be returned.
 * 
 * @param {string} relativePath resource path
 * @return {string} resource URL
 * @see oj.Config.setResourceBaseUrl
 * @export
 */
oj.Config.getResourceUrl = function(relativePath)
{
  // Returning null and full URLs (containing protocol or a leading slash) as is
  var fullUrlExp = /^\/|:/, base, modulePath;
  if (relativePath == null || fullUrlExp.test(relativePath))
  {
    return relativePath;
  }
  
  base = oj.Config._resourceBaseUrl;
  
  if (base)
  {
    return base + (base.charAt(base.length-1) == '/' ? "" : '/') + relativePath;
  }
  
  if (oj.__isAmdLoaderPresent())
  {
    modulePath = require.toUrl("ojs/ojcore");
    return modulePath.replace(/[^\/]*$/, "../" + relativePath);
  }
  
  return relativePath;
};

/**
 * Sets the base URL for retrieving component-specific resources
 * @param {string} baseUrl base URL
 * @see oj.Config.getResourceUrl
 * @export
 */
oj.Config.setResourceBaseUrl = function(baseUrl)
{
  oj.Config._resourceBaseUrl = baseUrl;  
};



/*
** Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
*/
/**
 * String utilities.
 * @export
 * @ignore
 */
oj.StringUtils = {};

oj.StringUtils._TRIM_ALL_RE = /^\s*|\s*$/g;

/**
  * Returns true if the value is null or if the trimmed value is of zero length.
  * 
  * @param {Object|null} value
  * @returns {boolean} true if the string or Object (e.g., Array) is of zero length.
  * @export
  */        
 oj.StringUtils.isEmpty = function(value)
 {    
   if (value === null)
   {
     return true;
   }

   value = oj.StringUtils.trim(value);
   return (value.length === 0);
 };
 
 oj.StringUtils.isEmptyOrUndefined = function (value)
 {
   if (value === undefined || oj.StringUtils.isEmpty(value))
   {
     return true;
   }
   
   return false;
 };

/**
 * Test if an object is a string (either a string constant or a string object)
 * @param {Object|string} obj object to test
 * @return {boolean} true if a string constant or string object
 * @export
 */
oj.StringUtils.isString = function(obj)
{
  return obj !== null && ((typeof obj === 'string') || obj instanceof String);
};

/**
 * Remove leading and trailing whitespace
 * @param {Object|string} data to trim
 * @export
 */
oj.StringUtils.trim = function(data)
{
  if (oj.StringUtils.isString(data))
  {
    return data.replace(oj.StringUtils._TRIM_ALL_RE, '');
  }

  return data;
};
/*
** Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
*/

/**
 * Utilities for working with collections
 * @export
 */
oj.CollectionUtils = {};


/**
 * Copies all of the properties of source into target and return the target
 * 
 * @param {Object} target - target collection
 * @param {Object} source - source collection
 * @param {function(string)=} keyConverter a callback for converting the key
 * @param {boolean=} recurse - true if this method should recurse into plain Javascript object properties
 * @param {number=} maxRecursionDepth - the maximum depth of the recursion into plain Javascript object properties
 * @return target collection
 * @export
 */
oj.CollectionUtils.copyInto = function(
  target,
  source,
  keyConverter,
  recurse,
  maxRecursionDepth)
{
  return oj.CollectionUtils._copyIntoImpl(
                                          target,
                                          source,
                                          keyConverter,
                                          recurse,
                                          maxRecursionDepth,
                                          0);
};

/**
 * Checks whether the object is a direct instance of Object
 * @param {Object} obj - object to test
 * 
 * @return {boolean} true if the object is a direct instance of Object, false otherwise
 * @export
 */
oj.CollectionUtils.isPlainObject = function(obj)
{
  if (typeof obj === 'object')
  {
    try
    {
      if (obj.constructor && obj.constructor.prototype.hasOwnProperty("isPrototypeOf"))
      {
        return true;
      }
    }
    catch(e){}
  }
  
  return false;
};


/**
 * @private
 */
oj.CollectionUtils._copyIntoImpl = function(
  target,
  source,
  keyConverter,
  recurse,
  maxRecursionDepth,
  currentLevel)
{
  var k, targetKey;
  if (target && source && (target !== source))
  {    
    for (k in source)
    {      
      if (source.hasOwnProperty(k)) {
        // allow the key mapping to be overridden
        if (keyConverter)
        {
          targetKey = keyConverter(k);
        }
        else
        {
          targetKey = k;
        }
        
        var sourceVal = source[k];
        
        var recursed = false;
        
        if (recurse && currentLevel < maxRecursionDepth)
        {
          var targetVal = target[targetKey];
          if (oj.CollectionUtils.isPlainObject(targetVal) && oj.CollectionUtils.isPlainObject(sourceVal))
          {
            recursed = true;
            oj.CollectionUtils._copyIntoImpl(
                                            targetVal,
                                            sourceVal,
                                            keyConverter,
                                            true,
                                            maxRecursionDepth,
                                            currentLevel + 1);
          }
        }
        if (!recursed)
        {
          try
          {
            target[targetKey] = sourceVal;
          }
          catch (e)
          {
            // consume errors caused by read-only properties
          }
        }
      }
    }
  }
  
  return target;
};

/*
** Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.
**
**34567890123456789012345678901234567890123456789012345678901234567890123456789
*/

/*global ojt:false*/

/**
 * @class Services for Retrieving Translated Resources
 * @export
 */
oj.Translations = {};

/**
 * Sets the translation bundle used by JET
 * If an AMD loader (such as Require.js) is not present, this method should be called by the application to provide
 * translated strings for JET.
 * This method may also be used by an application that wants to completely replace the resource bundle that is automatically
 * fetched by an AMD loader.
 * @param {Object} bundle resource bundle that should be used by the framework
 * @export
 */
oj.Translations.setBundle = function(bundle)
{
  oj.Translations._bundle = bundle;
};

/**
 * Retrives a translated resource for a given key
 * @param {string} key
 * @return {Object|string|null} resource associated with the key or null if none was found
 * @export
 */
oj.Translations.getResource = function(key)
{
  return oj.Translations._getResourceString(key);
};

/**
 * Applies parameters to a format pattern
 * @param {string} pattern. Tokens ike {0}, {1}, {name} within the pattern 
 * will be used to define string keys for retrieving values from the parameters
 * object. Token strings should not contain comma (') 
 * or space characters, since they are reserved for future format type enhancements. 
 * The reserved characters within a pattern are:
 * $ { } [ ]  
 * These characters will not appear in the formatted output unless they are escaped
 * with a dollar character ('$').
 * 
 * @param {Object|Array} parameters to be inserted into the string. Both arrays and
 * Javascript objects with string keys are accepted.
 * 
 * @return formatted message or null if the pattern argument was null
 * @export
 */
oj.Translations.applyParameters = function(pattern, parameters)
{
  return (pattern == null) ? null : oj.Translations._format(pattern, parameters);
};

/**
 * Retrieves a translated string after inserting optional parameters
 * @param {string} key - translations resource key
 * The key is used to retrieve a format pattern from the resource bundle.
 * Tokens like {0}, {1}, {name} within the pattern will be used to define placement
 * for the optional parameters.  Token strings should not contain comma (,) 
 * or space characters, since they are reserved for future format type enhancements.
 * The reserved characters within a pattern are:
 * $ { } [ ]  
 * These characters will not appear in the formatted output unless they are escaped
 * with a dollar character ('$').
 * 
 * @param {...string|Object|Array} var_args  - optional parameters to be inserted into the 
 * translated pattern.
 * 
 * If more than one var_args arguments are passed, they will be treated as an array 
 * for replacing positional tokens like {0}, {1}, etc.
 * If a single argument is passed, it will be treated as a Javascript Object whose
 * keys will be matched to tokens within the pattern. Note that an Array is just
 * a special kind of such an Object.
 * 
 * For backward compatibility, a var_args argument whose type is neither 
 * Object or Array will be used to replace {0} in the pattern.
 * 
 * @return formatted translated string
 * @export
 */
oj.Translations.getTranslatedString = function(key, var_args)
{  
  var val = oj.Translations._getResourceString(key);
  
  if (val == null)
  {
    return key;
  }
  
  var params = {};
  
  if (arguments.length > 2)
  {
    params = Array.prototype.slice.call(arguments, 1);
  }
  else if (arguments.length == 2)
  {
    params = arguments[1];
    if (typeof params !== 'object' && !(params instanceof Array))
    {
      params = [params];
    }
      
  }
  
  return oj.Translations.applyParameters(val, params);
};


/**
 * Provides a key-to-value map of the translated resources for a given component name
 * @param {string} componentName
 * @return a map of translated resources
 * @export
 */
oj.Translations.getComponentTranslations = function(componentName)
{
  var bundle = oj.Translations._getBundle()[componentName], translations, k;
  
  if (bundle == null)
  {
    return {};
  }
  
  // Assume that the set of keys remains constant regardless of the current locale
  translations = {};
  for(k in bundle)
  {
    if (bundle.hasOwnProperty(k)) {
        translations[k] = bundle[k];
    }
  }
  return translations;
};

/**
 * Retrives a translated resource for a given key, accounting for nested keys
 * @param {string} key
 * @returns {string|null} resource associated with the key or null if none was found
 */
oj.Translations._getResourceString = function(key)
{
  // Account for dot separated nested keys
  var keys = key ? key.split(".") : [], bundle = oj.Translations._getBundle(), 
          iteration = keys.length, index = 0, subkey = keys[index];
  oj.Assert.assertObject(bundle);
  
  // even though we start with a valid bundle it's possible that part or all of the key is invalid, 
  // so check we have a valid bundle in the while loop
  while (--iteration > 0 && bundle) 
  {
    // if we have a key like a.b.c
    bundle = bundle[subkey];
    index++;
    subkey = keys[index];
  }
    
  return bundle ? (bundle[subkey] || null) : null;
};

oj.Translations._format = function(formatString, parameters)
{
  var formatLength = formatString.length;
  
  // Use the javascript StringBuffer technique.
  var buffer = [];
  
  var token = null;
  
  
  var escaped = false;
  var isToken = false;
  var isGroup = false;
  var isExcluded = false;
  
  var tokenTerminated; // this will be set to true when a comma or space is 
                       // encountered in teh token
  var i;
  
  for (i = 0; i < formatLength; i++)
  {
    var ch = formatString.charAt(i);
    
    var accumulate = false;
    
    if (!escaped)
    {
      switch(ch)
      {
        case '$':
          escaped = true;
          break;
          
        case '{':
          if (!isExcluded)
          {
            if (!isToken)
            {
              tokenTerminated = false;
              token = [];
            }
            isToken = true;
          }
          break;
          
        case '}':
          if (isToken && token.length > 0)
          {
            var val = parameters[token.join('')];
            buffer.push((val === undefined) ? "null" : val);
          }
          isToken = false;
          break;
          
        case '[':
          if (!isToken)
          {
            if (isGroup)
            {
              isExcluded = true;
            }
            else
            {
              isGroup = true;
            }
          }
          break;
          
        case ']':
          if (isExcluded)
          {
            isExcluded = false;
          }
          else
          {
            isGroup = false;
          }
          break;
        
        default:
          accumulate = true;
      }
    }
    else
    {
      accumulate = true;
      escaped = false;  
    }
    
    if (accumulate)
    {
      if (isToken)
      {
        if (ch == ',' || ch ==' ')
        {
          tokenTerminated = true;
        }
        else if (!tokenTerminated)
        {
          token.push(ch);
        }
      }
      else if (!isExcluded)
      {
        buffer.push(ch);
      }
    } 
  }

  // Use the javascript StringBuffer technique for toString()
  return buffer.join("");
};


oj.Translations._getBundle = function()
{
  var b = oj.Translations._bundle;
  if (b)
  {
    return b;
  }
  
  if (oj.__isAmdLoaderPresent()) {
    oj.Assert.assert(ojt !== undefined, "ojtranslations module must be defined");
    return ojt;
  }
  return {};
};
/*jslint browser: true*/
/**
 * @constructor
 * @class
 * @mixin
 */
oj.Events = window['oj']['Events'] =
/** @lends oj.Events */
{        
    /**
     * Add an event handler for an event type to the model or collection object.
     * @param {String|Object} eventType Types of event handlers to add (may be a single event type, a space-delimited set of event types, or an object mapping events to callbacks). 
     * @param {function(String, Object)} callback User's event handler callback function (called with the eventType and model or collection object as parameters--the context will be the model or collection unless specified by context, below). 
     * @param {Object=} context A context for the event 
     */
    'on': function (eventType, callback, context) {
            return this.OnInternal(eventType, callback, context, false, false);
        },

    /**
     * Remove an event handler for an event type from the model or collection object.
     * @param {String|Object=} eventType Types of event handlers to remove (may be a single event type, a space-delimited set of event types, or a map of events to callbacks). If omitted, remove all event handlers. 
     * @param {function(String, Object)=} callback If provided, remove handlers only for eventType events with the given callback function. 
     * @param {Object=} context If provided, remove handlers only for eventType events with the given callback function and context object. 
     */
    'off': function(eventType, callback, context) {
             return this._offInternal(eventType, callback, context, false);
        },
    
    /**
     * Fire the given event type(s) for all registered handlers.
     * @param {String} eventType Types of event handlers to fire (may be a single event type or a space-delimited set of event types). 
     */        
    'trigger': function(eventType) {
                 var args = Array.prototype.slice.call(arguments);
                 // Inject a silent setting in there: if this is being called outside we want to fire all relevant events
                 args.unshift(false);
                 return oj.Events.TriggerInternal.apply(this, args);
             },
            
    /**
     * Add an event handler for an event type to the model or collection object, but only fire it once, then remove it from the list of handlers.
     * @param {String} eventType Types of event handlers to add (may be a single event type or a space-delimited set of event types). 
     * @param {function(String, Object)} callback User's event handler callback function (called with the eventType and model or collection object as parameters--the context will be the model or collection unless specified by context, below). 
     * @param {Object=} context A context for the event
     */
    'once': function(eventType, callback, context) {
                return this._onceInternal(eventType, callback, context, false);
            },
               
    /**
     * Add an event handler for an event type to a second model or collection object ("otherObj"), but track it on the called object.
     * @param {Object} otherObj Model or collection object on which to add this event handler. 
     * @param {String} eventType Types of event handlers to add (may be a single event type or a space-delimited set of event types). 
     * @param {function(String, Object)} callback User's event handler callback function (called with the eventType and model or collection object as parameters--the context will be the model or collection unless specified by context, below). 
     */
    'listenTo': function(otherObj, eventType, callback) {
                var eventArray, e, event, attr, eventString, listenerObj, index, prop, eventMap = {};

                if (eventType.constructor === String) {
                    // Create a map out of it
                    eventMap[eventType] = callback;
                }
                else {
                    eventMap = eventType;
                }
        
                for (prop in eventMap) {
                    if (eventMap.hasOwnProperty(prop)) {
                        eventArray = oj.Events._getEvents(prop);
                        for (e = 0; e < eventArray.length; e=e+1) {
                            event = eventArray[e].event;
                            attr = eventArray[e].attribute;
                            listenerObj = {event: event, attribute: attr, object: otherObj, callback: eventMap[prop]};
                            index = this._checkForHandler(this.listeningList, listenerObj, oj.Events._listenersIdentical);
                            eventString = attr ? event + ":" + attr : event;    
                            if (this.listeningList === undefined) {
                                this.listeningList = [];
                            }
//                            if (index === -1) {
                                this.listeningList.push(listenerObj);    
/*                           }
                            else {
                                // Replace it
                                this.listeningList[index] = listenerObj;
                                otherObj.off(eventString);
                            }*/
                            // fire
                            otherObj.OnInternal(eventString, eventMap[prop], null, true, false);
                        }
                    }
                }
                return this;
            },

    /**
     * Add an event handler for an event type to a second model or collection object ("otherObj"), but track it on the called object.  Only fire once.
     * @param {Object} otherObj Model or collection object on which to add this event handler. 
     * @param {String} eventType Types of event handlers to add (may be a single event type or a space-delimited set of event types). 
     * @param {function(String, Object)} callback User's event handler callback function (called with the eventType and model or collection object as parameters--the context will be the model or collection unless specified by context, below). 
     */
    'listenToOnce': function(otherObj, eventType, callback) {
                var eventArray, e, event, attr, eventString, listenerObj, index, prop, eventMap = {};

                if (eventType.constructor === String) {
                    // Create a map out of it
                    eventMap[eventType] = callback;
                }
                else {
                    eventMap = eventType;
                }
        
                for (prop in eventMap) {
                    if (eventMap.hasOwnProperty(prop)) {
                        eventArray = oj.Events._getEvents(prop);
                        for (e = 0; e < eventArray.length; e=e+1) {
                            event = eventArray[e].event;
                            attr = eventArray[e].attribute;
                            listenerObj = {event: event, attribute: attr, object: otherObj, callback: eventMap[prop]};
                            index = this._checkForHandler(this.listeningList, listenerObj, oj.Events._listenersIdentical);
                            eventString = attr ? event + ":" + attr : event;    
                            if (this.listeningList === undefined) {
                                this.listeningList = [];
                            }
//                            if (index === -1) {
                                this.listeningList.push(listenerObj);    
/*                            }
                            else {
                                // Replace it
                                this.listeningList[index] = listenerObj;
                                otherObj.off(eventString);
                            }*/
                            // fire
                            otherObj._onceInternal(eventString, eventMap[prop], null, true);
                        }
                    }
                }
                return this;
            },
            
    /**
     * Remove event handlers from a model or collection object. If the arguments are omitted, removes all event handlers from the model or collection.
     * @param {Object=} otherObj If specified, remove event handlers that target otherObj from this model or collection. 
     * @param {String=} eventType If specified, remove the event handlers for the given event types from this model or collection 
     * @param {function(String, Object)=} callback If specified, remove event handlers that call the given user callback function from this model or collection 
     */
    'stopListening': function(otherObj, eventType, callback) {
                        var eventArray, actualType, eventMap = {}, e, oneEvent, oneAttr, event, objEqual,
                                eventEqual, callbackEqual, attrEqual, i, prop, len, cb;
                        
                        if (arguments == null || arguments.length == 0) {
                            len = this.listeningList ? this.listeningList.length : 0;
                            // Remove everything
                            for (i = 0; i < len; i++) {
                                cb = this.listeningList[i].object._offInternal;
                                cb.apply(this.listeningList[i].object, [this.listeningList[i].event, this.listeningList[i].callback, this.listeningList[i].context, true]);
                            }
                            this.listeningList = [];
                            return this;
                        }

                        actualType = eventType;
                        // Account for missing otherObj
                        if (otherObj && otherObj.constructor === String) {
                            actualType = otherObj;
                        }
                        
                        if (actualType.constructor === String) {
                            // Create a map out of it
                            eventMap[actualType] = callback;
                        }
                        else {
                            eventMap = actualType;
                        }
        
                        for (prop in eventMap) {
                            if (eventMap.hasOwnProperty(prop)) {
                                eventArray = oj.Events._getEvents(prop);
                                for (e = 0; e < eventArray.length; e=e+1) {
                                    oneEvent = eventArray[e].event;
                                    oneAttr = eventArray[e].attribute;
                                    len = this.listeningList ? this.listeningList.length : 0;
                                    for (i = len-1; i >= 0; i=i-1) {
                                        event = this.listeningList[i];
                                        objEqual = otherObj ? otherObj === event.object : true;
                                        eventEqual = oneEvent ? oneEvent === event.event : true;
                                        callbackEqual = callback ? eventMap[prop] === event.callback : true;
                                        attrEqual = oneAttr ? oneAttr === event.attribute : true;
                                        if (objEqual && eventEqual && callbackEqual && attrEqual) {
                                            cb = this.listeningList[i].object._offInternal;
                                            cb.apply(this.listeningList[i].object, [this.listeningList[i].event, this.listeningList[i].callback, this.listeningList[i].context, true]);
                                            this.listeningList.splice(i, 1);
                                        }
                                    }                        
                                }
                            }        
                        }
                    return this;
                }
};

// Aliases for backward compatibility
oj.Events['bind'] =  oj.Events['on'];
oj.Events['unbind'] = oj.Events['off'];

/**
 * @export
 * Event types
 * @enum {string}
 */
  oj.Events.EventType = {
        /** Triggered when a model is added to a collection */
        'ADD' : "add",
        /** Triggered when a model is removed from a collection */
        'REMOVE' : "remove",
        /** Triggered when a collection is reset (see oj.Collection.reset) */
        'RESET' : "reset",
        /** Triggered when a collection is refreshed (see oj.Collection.refresh) */
        'REFRESH' : "refresh",
        /** Triggered when a collection is sorted.  If the second argument to the callback is set (options) and 'add' is true, it means this sort event was triggered as a result of an add */
        'SORT' : "sort",
        /** Triggered when a model's attributes are changed */
        'CHANGE' : "change",
        /** Triggered when a model is deleted from the data service (and thus from its Collection) */
        'DESTROY' : "destroy",
        /** Triggered when a model or collection has sent a request to the data service */
        'REQUEST' : "request",
        /** Triggered when a model or collection has been updated from the data service */
        'SYNC' : "sync",
        /** Triggered when a model has failed to update on the data service */
        'ERROR' : "error",
        /** Triggered when a model being saved has been invalidated by the caller */
        'INVALID' : "invalid",
        /** Triggered for any of the above events */
        'ALL' : "all"
    };
            

/**
 * @private
 * @param {Object} myClass
 * @param {Object=} source
 */
oj.Events.Mixin = function(myClass, source) {
    var methodName, obj = source || this;
    for (methodName in obj ) {
        if (typeof obj[methodName] === 'function' /*&& !Object.hasOwnProperty(myClass.prototype, methodName)*/ ) {
            myClass[methodName] = obj[methodName];
        }
    }
    // Make sure actual vars are own copies
    myClass.eventHandlers = {};
    myClass.listeningList = [];
};

oj.Events._onceInternal = function(eventType, callback, context, listenTo) {
    var eventArray, e, event, attr, eventMap, prop;
    
    eventMap = this._getEventMap(eventType, callback, context);

    for (prop in eventMap) {
        if (eventMap.hasOwnProperty(prop)) {
            eventArray = this._getEvents(prop);
    
            for (e = 0; e < eventArray.length; e=e+1) {
               event = eventArray[e].event;
               attr = eventArray[e].attribute;
               if (this.eventHandlers === undefined) {
                   this.eventHandlers = [];
               }
               if (this.eventHandlers[event] === undefined) {
                   this.eventHandlers[event] = [];
               }

               this.eventHandlers[event].push({callback: eventMap[prop], context: context, attribute: attr, once: true, fired: false, listen:listenTo});    
            }
        }
   }
   return this;
};

oj.Events._shouldFire = function(handler) {
    if (handler.once) {
        if (!handler.fired) {
            handler.fired = true;
            return true;
        }
        return false;
    }
    return true;
};

oj.Events.TriggerInternal = function(silent, eventType) {
    var eventArray = this._getEvents(eventType), e, event, attr, eventsToFire, handlers, i, args, allHandlers, callback;
                  
    eventsToFire = [];                  
    for (e = 0; e < eventArray.length; e=e+1) {  
        event = eventArray[e].event;
        attr = eventArray[e].attribute;
        // Do specific event...
        eventsToFire.push({event:event, attribute:attr});
    }
    for (e = 0; e < eventsToFire.length; e=e+1) {
      allHandlers = this._getHandlers(this.eventHandlers, oj.Events.EventType['ALL']);
      handlers = oj.Events._getHandlers(this.eventHandlers, eventsToFire[e].event, false);
      for (i=0; i < (handlers ? handlers.length : 0); i=i+1) {
            if (handlers[i].attribute === eventsToFire[e].attribute && handlers[i].callback) {
                args = Array.prototype.slice.call(arguments);                
                if (handlers && handlers[i] && handlers[i].once) {
                      // Remove it: only want to fire once--make sure we remove it from the original
                      //oj.Events._getHandlers(this.eventHandlers, eventsToFire[e].event, true).splice(i, 1);
                      this._removeHandler(oj.Events._getHandlers(this.eventHandlers, eventsToFire[e].event, true), handlers[i]);
                }
                if (handlers && handlers[i] && this._shouldFire(handlers[i])) {
                  callback = handlers[i].callback;
                  // If this isn't a silent firing or this handler always wants to be called, make the call
                  if (!silent || handlers[i].ignoreSilent) {
                    callback.apply(handlers[i].context || this, args.slice(2));
                  }
                }
            }
      }
            // Handle all
         for (i=0; i < (allHandlers ? allHandlers.length : 0); i=i+1) {
               args = Array.prototype.slice.call(arguments);
               if (args.length > 0) {
                   if (eventsToFire[e].attribute) {
                       args[1] = eventsToFire[e].event + ":" + eventsToFire[e].attribute;
                   }
                   else {
                      args[1] =  eventsToFire[e].event;
                   }
               }
               // All case--make sure to pass event name
               if (allHandlers && allHandlers[i] && allHandlers[i].callback && this._shouldFire(allHandlers[i])) {
                   callback = allHandlers[i].callback;
                   // If this isn't a silent firing or this handler always wants to be called, make the call
                   if (!silent || allHandlers[i].ignoreSilent) {
                      callback.apply(allHandlers[i].context || this, args.slice(1));
                   }
               }
               if (allHandlers && allHandlers[i] && allHandlers[i].once) {
                   // Remove it: only want to fire once
                   //this._getHandlers(this.eventHandlers, oj.Events.EventType['ALL'], true).splice(i, 1);
                   this._removeHandler(this._getHandlers(this.eventHandlers, oj.Events.EventType['ALL'], true), allHandlers[i]);
               }
           }

    }
    return this;    
};

oj.Events.OnInternal = function(eventType, callback, context, listenTo, ignoreSilent) {
    var eventMap, prop, eventArray, i, event, attr, eventObj;

    eventMap = this._getEventMap(eventType, callback, context);

    for (prop in eventMap) {
        if (eventMap.hasOwnProperty(prop)) {
            eventArray = this._getEvents(prop);

            for (i = 0; i < eventArray.length; i=i+1)
            {
                event = eventArray[i].event;
                attr = eventArray[i].attribute;
                if (this.eventHandlers === undefined) {
                    this.eventHandlers = [];
                }
                if (this.eventHandlers[event] === undefined) {
                    this.eventHandlers[event] = [];
                }

                eventObj = {callback: eventMap[prop], context: context, attribute:attr, listen: listenTo, ignoreSilent:ignoreSilent};
                if (this._checkForHandler(this.eventHandlers[event], eventObj, oj.Events._handlersIdentical) === -1) {
                    this.eventHandlers[event].push(eventObj);    
                }
            }
        }
    }
    return this;
};

oj.Events._offInternal = function(eventType, callback, context, listen) {
    var eventMap, prop;
     if (arguments == null || arguments.length == 0) {
         // Remove everything
         this.eventHandlers = {};
         return this;
     }

     if (eventType == null) {
         this._removeEvent(eventType, callback, context, listen);
         return this;
     }

     eventMap = this._getEventMap(eventType, callback, context);

     for (prop in eventMap) {
         if (eventMap.hasOwnProperty(prop)) {
             this._removeEvent(prop, eventMap[prop], context, listen);
         }
     }
     return this;
};
 


oj.Events._getEventMap = function(eventType, callback, context) {
    var eventMap = {};
    
    if (eventType.constructor === String) {
        // Create a map out of it
        eventMap[eventType] = callback;
    }
    else {
        eventMap = eventType;
        // If eventType is a map of events->callbacks, then the callback argument is now context
        context = callback;
    }
    return eventMap;
};

oj.Events._removeEvent = function(eventType, callback, context, listen) {
    var eventArray = [], e, i, event, attr, handlers, callbacks, contexts, attrs, listenEq;
    
    if (eventType) {
        eventArray = oj.Events._getEvents(eventType);
    }
    else {
        // Walk entire eventHandlers property list
        if (this.eventHandlers !== undefined) {
            for (event in this.eventHandlers) {
                if (this.eventHandlers.hasOwnProperty(event)) {
                    eventArray.push({event:event});
                }
            }
        }
    }
    
    for (e = 0; e < eventArray.length; e=e+1) {
        event = eventArray[e].event;
        attr = eventArray[e].attribute;
        if (this.eventHandlers !== undefined && this.eventHandlers[event] instanceof Array) {
            handlers = this.eventHandlers[event];
            for (i=handlers.length-1; i >= 0; i=i-1){
                callbacks = (callback === undefined || callback === null || handlers[i].callback == callback);

                contexts = (context === undefined || context === null || handlers[i].context == context);
                attrs = (attr === undefined || attr === null || handlers[i].attribute == attr);
                listenEq = (listen === undefined || listen === null || handlers[i].listen == listen);
                if (callbacks && contexts && attrs && listenEq){
                    handlers.splice(i, 1);
                    //break;
                }
            }
            if (handlers.length === 0) {
                // Delete the entry
                delete this.eventHandlers[event];
            }
        }
    }   
};

oj.Events._removeHandler = function(handlers, handler) {
    var i, callbacks, contexts, attrs, listenEq, onceEq;
    
    for (i=handlers.length-1; i >= 0; i=i-1){
        callbacks = (handler.callback === undefined || handler.callback === null || handlers[i].callback == handler.callback);

        contexts = (handler.context === undefined || handler.context === null || handlers[i].context == handler.context);
        attrs = (handler.attribute === undefined || handler.attribute === null || handlers[i].attribute == handler.attribute);
        listenEq = (handler.listen === undefined || handler.listen === null || handlers[i].listen == handler.listen);
        onceEq = (handler.once === undefined || handler.once === null || handlers[i].once == handler.once);
        if (callbacks && contexts && attrs && listenEq && onceEq){
            handlers.splice(i, 1);
        }
    }    
};

oj.Events._getEvents = function(eventString) {    
    var eventList = eventString ? eventString.split(" ") : [], retList = [], i, eventWithAttr, name, attr;
    for (i = 0; i < eventList.length; i=i+1) {
        eventWithAttr = eventList[i].split(":");
        name = eventWithAttr[0];
        attr = eventWithAttr.length > 1 ? eventWithAttr[1] : null;
        retList.push({event:name, attribute:attr});
    }
    return retList;
};

oj.Events._handlersIdentical = function(handler1, handler2) {
   return (handler1.callback === handler2.callback) && (handler1.attribute === handler2.attribute) && (handler1.context === handler2.context) && (handler1.listen === handler2.listen) && (handler1.once === handler2.once);
};

oj.Events._listenersIdentical = function(listener1, listener2) {
   return (listener1.event === listener2.event) && (listener1.attribute === listener2.attribute) && (listener1.context === listener2.context) && (listener1.object === listener2.object);    
};

oj.Events._checkForHandler = function(handlerList, handler, handlerTest) {
    var i;
    if (handlerList === undefined) {
        return -1;        
    }
    
    for (i = 0; i < handlerList.length; i=i+1) {
        if (handlerTest(handlerList[i], handler)) {
            return i;
        }
    }
    return -1;
};

oj.Events._getHandlers = function(handlers, eventType, original) {
    if (handlers && handlers[eventType] instanceof Array) {
        if (original) {
            return handlers[eventType];
        }
        // Make a copy
        var handlerReturn = [], i;
        for (i = 0; i < handlers[eventType].length; i++) {
            handlerReturn.push(handlers[eventType][i]);
        }
        return handlerReturn;
    }
    return null;
};

/*jslint browser: true*/

/**
 * @export
 * @class oj.Model
 * @classdesc Object representing name/value pairs for a data service record
 *
 * @param {Object=} attributes Initial set of attribute/value pairs with which to seed this Model object 
 * @param {Object=} options 
 *                  collection: collection for this model
 * @constructor
 * @mixes oj.Events
 */
oj.Model = function (attributes, options) {
    oj.Model._init(this, attributes, options, null);
};


// Subclass from oj.Object 
oj.Object.createSubclass(oj.Model, oj.Object, "Model.Model");
  
oj.Model.prototype.Init = function()
{
    oj.Model.superclass.Init.call(this);
};

/**
 * 
 * @export
 * @desc Attribute/value pairs held by the Model.
 * 
 * @type Object
 */
oj.Model.prototype.attributes = {};

/**
 * @export
 * @desc The set of attribute/value pairs that serve as default values when new Model objects are created.
 * 
 * @type Object
 */
oj.Model.prototype.defaults = {};

/**
 * @export
 * @desc The Model's unique ID.  This can be set by the application or retrieved from the data service. This ID will be appended to the URL for single-record data operations (update, delete). 
 * 
 * @type String
 */
oj.Model.prototype.id = null;

/**
 * @export
 * @desc The name of the model property to be used as the unique ID. See property id. This defaults to a value of "id".
 *  
 * @type String
 */
oj.Model.prototype.idAttribute = null;

/**
 * @export
 * @desc The base url on the data service used to perform CRUD operations on models.  If not defined, the Model will look to its collection.  One or the other must be defined before CRUD operations can succeed.
 * 
 * @type String
 */
oj.Model.prototype.urlRoot = null;

/**
 * @export
 * @desc A callback to allow users to completely customize the data service URLs
 * The callback has the following parameters:
 * operation (String): one of create, read, update, patch, or delete indicating the type of operation for which to return the URL<p>
 * model (Object): the oj.Model object requesting the URL<p>
 * options (Object) : one or more of the following properties:<p>
 * recordID : id of the record involved, if relevant<p>
 * 
 * customURL functions should return either: null, in which case the default will be used; a string, which will be used with the standard
 * HTTP method for the type of operation, or an Object with any ajax attributes.  This must at minimum include the URL:<p>
 *  url: giving the custom URL string<p>
 *  type: (optional) a string indicating the type of HTTP method to use (GET, POST, DELETE, etc.)<p>
 *  (other): (optional) any other ajax attributes to pass in the ajax call
 *  
 * @type (function(string,Object):(string|null)|null)
 */
oj.Model.prototype.customURL = null;

oj.Model._idCount = 0;

oj.Model._init = function(model, attributes, options, properties) {
    var prop = null, parse, attrCopy;

    if (oj.Model._justExtending) {
        return;
    }

    model.Init();
    
    // Augment with Event
    oj.Events.Mixin(model);

    model._clearChanged();
    model.previousAttrs = {};
    model.nestedSet = false;
    model.index = -1;

    options = options || {};

    // Deep copy actual data if found

    model.attributes = {};
    if (model['defaults']) {
        model.attributes = oj.Model._cloneAttributes(oj.Model.IsFunction(model['defaults']) ? model['defaults']() : model['defaults'], null);
    }

    // First, copy all properties passed in
    for (prop in properties) {
        if (properties.hasOwnProperty(prop)) {
            model[prop] = properties[prop]; 
        }
    }

    if (attributes) {
        parse = options['parse'];
        if (oj.Model.IsFunction(parse)) {
            model['parse'] = parse;
        }
 
        attrCopy = oj.Model._cloneAttributes(attributes, model.attributes);
        
        attrCopy = parse ? model['parse'](attrCopy) : attrCopy;
        if (attrCopy == null || attrCopy === undefined) {
            // Reset it
            model.attributes = {};
        }
        else {
            // Move them in
            for (prop in attrCopy) {
                if (attrCopy.hasOwnProperty(prop)) {
                    model._setProp(prop, attrCopy[prop], false, false, options);
                }
            }
        }
    }

    model.SetCid();

    // Grab collection option, if there
    model.SetCollection(options['collection']);

    if (options['customURL']) {
        model['customURL'] = options['customURL'];
    }
    
    // If URL is set, use that
    if (options['url']) {
        model['url'] = options['url'];
    }

    if (options['urlRoot']) {
        model['urlRoot'] = options['urlRoot'];
    }

    if (model['initialize']) {
        model['initialize'](attributes, options);
    }
    
    model.SetupId();
};


/**
 * Create a new, specific type of Model object to represent single records from a JSON data set.
 * @param {Object=} properties Properties for the new Model class.<p>
 *                  defaults: an Object containing starting attribute/value pairs for some or all of the record's potential attributes<p>
 *                  parse: a user callback function to allow parsing of JSON record objects as they are returned from the data service<p>
 *                  parseSave: a user callback function to allow conversion of Models back into a format appropriate for the data service on save calls<p>
 *                  urlRoot: the URL to use to get records from the data service in the abscence of a collection (when an id is appended)<p>
 *                  initialize: a user callback function to be called when this model is created<p>
 *                  validate: a user callback function that will be called before a save to the data service occurs. The callback is passed the current set of attributes and save options. 
 * @param {Object=} classProperties properties that attach to the whole class
 * @return {function(new:Object, ...)} new Model object
 * @export
 * @this {Object}
 */
oj.Model.extend = function (properties, classProperties) {
    oj.Model._justExtending = true;
    var obj, prop;

    obj = new oj.Model();
    oj.Model._justExtending = false;

    // Add regular properties from this "parent"
    oj.Events.Mixin(obj, this.prototype);

    // Grab properties
    properties = properties || {};
    for (prop in properties) {
        if (properties.hasOwnProperty(prop)) {
            obj[prop] = properties[prop];
        }
    }

    var Model;
    
    if (properties && properties['constructor'] && properties.hasOwnProperty('constructor')) {
        Model =  properties['constructor'];
    }
    else {
        Model = function(attributes, options) {
            oj.Model._init(this, attributes, options, properties);
        }
    }

    Model.prototype = obj;
    
    // Allow extending resulting obj
    Model.extend = oj.Model.extend;

    Model.prototype.constructor = Model;
    

    // Add class properties from this
    oj.Events.Mixin(Model, this);
    
    if (classProperties) {
        for (prop in classProperties) {
            if (classProperties.hasOwnProperty(prop)) {
                Model[prop] = classProperties[prop];
            }
        }
    }

        
    return Model;
};

// Placeholder for event mixins
oj.Model.prototype.TriggerInternal = function (silent, event, arg1, arg2, options) {};

oj.Model.prototype.SetCid = function () {
    // Create cid property if necessary
    if (!this.GetCid()) {
        this['cid'] = 'id' + oj.Model._idCount;
        oj.Model._idCount = oj.Model._idCount+1;
    }
};

oj.Model.prototype.GetCid = function () { 
    return this['cid'];
};

// Index within collection
oj.Model.prototype.SetIndex = function(index) {
    this.index = index;
};

oj.Model.prototype.GetIndex = function() {
    return this.index;
};

// LRU functions
oj.Model.prototype.SetNext = function(model) {
    var retVal = this.next;
    this.next = model;
    return retVal;
};

oj.Model.prototype.GetNext = function() {
    return this.next;
};

oj.Model.prototype.SetPrevious = function(model) {
    var retVal = this.previous;
    this.previous = model;
    return retVal;
};

oj.Model.prototype.GetPrevious = function() {
    return this.previous;
};

// Might be a property value or a function
oj.Model.prototype._getProp = function(prop) {
    if (oj.Model.IsFunction(this[prop])) {        
        return this[prop]();
    }
    return this[prop];
};


// Merge the given model's attributes with this model's attributes
oj.Model.prototype.Merge = function(model, comparator) {
    var prop, needSort = false, isStringComparator = oj.StringUtils.isString(comparator),
        valueChange;
    
    for (prop in model.attributes) {
        if (model.attributes.hasOwnProperty(prop)) {
            valueChange = (this.attributes[prop] != model.attributes[prop]);
            if (isStringComparator) {
                // We have a string comparator--does it match this property?  If we hit a property that doesn't match, we need sort
                if (prop === comparator) {
                    // The property matches the comparator property: are we changing the value?
                    if (valueChange) {
                        needSort = true;
                    }
                }
            }
            else {
                if (valueChange) {
                    needSort = true;
                }
            }
            if (valueChange) {
                this.attributes[prop] = model.attributes[prop];
                this._addChange(prop, model.attributes[prop]);
            }                
        }
    }
    this.SetupId();
    return needSort;
};

oj.Model._hasProperties = function(object) {
    var prop;
    if (object && object instanceof Object) {
        for (prop in object) {
            if (object.hasOwnProperty(prop)) {
                return true;
            }
        }
    }
    return false;
};

oj.Model.prototype.SetCollection = function(coll) {
    if (coll == null) {
        delete this['collection'];
        return;
    }
    this['collection'] = coll;
};

oj.Model.prototype.GetCollection = function() {
    return this['collection'];
};

oj.Model.prototype._fireAttrChange = function(prop, value, options, silent) {
    if (prop != null) {
        this.TriggerInternal(silent, oj.Events.EventType['CHANGE'] + ":" + prop, this, value, options);    
    }    
};

oj.Model.prototype._fireChange = function(options, silent) {
    var coll;
    
    this.TriggerInternal(silent, oj.Events.EventType['CHANGE'], this, options, null);        
    coll = this.GetCollection();
    if (coll) {
        coll.TriggerInternal(silent, oj.Events.EventType['CHANGE'], this, coll, options, null);
    }
};
    
oj.Model.prototype.SetupId = function() {
    // Replicate id attribute at top level
    var idAttr = this._getIdAttr();
    // Supposedly this should always be model.id...who knew?
    this['id'] = this.attributes[idAttr];
};

oj.Model.prototype._setPropInternal = function(prop, value, copyRegardless) {
    var equality = oj.Object.innerEquals(this.attributes[prop], value);
    if (copyRegardless || !equality) {
        this.attributes[prop] = value;
        this.SetupId();
        // Return value management here seems bizarre due to backbone tests: do the direct set if copyRegardless, but only return if the
        // inner equals was different
        return !equality;
    }
    return false;
};

oj.Model.prototype._clearChanged = function() {
    this['changed'] = {};
};

oj.Model.prototype._addChange = function(property, value) {
    this['changed'][property] = value;
};

/**
 * @param {Object||string} prop
 * @param {Object} value
 * @param {boolean} copyRegardless
 * @param {boolean} propertyBag
 * @param {Object=} options
 * @returns {boolean}
 */
oj.Model.prototype._setProp = function(prop, value, copyRegardless, propertyBag, options) {
    if (prop == null) {
        return true;
    }
    
    var attrs = {}, p, isNested = this.nestedSet, opts;
    opts = oj.Model._copyOptions(options);

    if (!propertyBag) {
        attrs[prop] = value;
    }
    else {
        // We've passed in a whole property bag at once: validate all together
        for (p in prop) {
            if (prop.hasOwnProperty(p)) {
                attrs[p] = prop[p];
            }
        }
    }
    opts = opts || {};    
    
    if (!this._checkValid(attrs, {'validate':opts['validate']}, false)) {
        return false;
    }
    
    if (!isNested) {
        this._clearChanged();
        this.changes = [];
    }
    
    // Store old value
    if (!this.nestedSet) {
        this.previousAttrs = oj.Model._cloneAttributes(this.attributes, null);
    }
    
    this.nestedSet = true;
    for (p in attrs) {
        if (attrs.hasOwnProperty(p)) {
            if (this._setPropInternal(p, attrs[p], copyRegardless)) {    
                // Trigger changes
                this._addChange(p, attrs[p]);
                this.changes.push(p);
            }
            else {
                delete attrs[p];
            }
        }
    }
    // Fire events: don't fire if silent 
    var silent = opts['silent'];
    for (p in attrs) {
        if (attrs.hasOwnProperty(p)) {
            if (!silent && (this.changes.length > 0 || (isNested && this.changes.indexOf(p) === -1))) {
                this.pendingChanges = true;
            }
            this._fireAttrChange(p, attrs[p], opts, silent);
        }
    }
    
    if (isNested) {
        return true;
    }
    if (!silent && !isNested) {
        while (this.pendingChanges) {
            this.pendingChanges = false;
            this._fireChange(opts, silent);
        }
    }    
    
    this.nestedSet = false;
    return true;
};

oj.Model.prototype._areTherePendingChanges = function() {
};

/**
 * @export
 * Clears all attributes from the model and fires a change event
 * @param {Object=} options silent: if true, do not fire the change event
 *                          validate: if true, validate the unsetting of all properties
 * @return {Object||boolean} the Model, or false if validation on clear fails
 */
oj.Model.prototype.clear = function(options) {
    // Use unset to silently clear, to track changes to attributes
    var prop, unsetOpt = {'silent':true}, silent;
    options = options || {};
    silent = options['silent'];
    unsetOpt['validate'] = options['validate'];
    this._clearChanged();
    
    for (prop in this.attributes) {
        if (this.attributes.hasOwnProperty(prop)) {
            if (!this._unsetInternal(prop, unsetOpt, true)) {
                return false;
            }
            //if (!silent) {
                this.TriggerInternal(silent, oj.Events.EventType['CHANGE'] + ":" + prop, this, undefined, null);    
            //}            
        }
    }
    this.attributes = {};
    this.SetupId();
    
    //if (!silent) {
        this._fireAttrChange(null, null, null, silent);
        this._fireChange(null, silent);
    //}
    return this;
};

oj.Model._cloneAttributes = function(oldData, newData) {    
    var prop;
    if (oldData === null) {
        return null;
    }
    newData = newData || {};
    for (prop in oldData) { 
        if (oldData.hasOwnProperty(prop)){// && oldData[prop] !== undefined) {
            if (typeof(oldData[prop]) !== 'object') {
                // Only overwrite if not undefined
                if (newData.hasOwnProperty(prop)) {
                    if (oldData[prop] !== undefined) {
                        newData[prop] = oldData[prop];
                    }
                }
                else {
                    newData[prop] = oldData[prop];
                }
            }
            else {
                if (oj.Model.IsArray(oldData[prop])) {
                    // Handle arrays
                    if (oldData[prop] === null) {
                        newData[prop] = null;
                    }
                    else {
                        newData[prop] = [];
                        // Special case zero length array because of backbone unit test checking actual object value--strange
                        if (oldData[prop].length === 0) {
                            newData[prop] = oldData[prop];
                        }
                        else {
                            for (var i = 0; i < oldData[prop].length; i++) {
                                newData[prop].push(oj.Model._cloneAttributes(oldData[prop][i], null));
                            }
                        }
                    }
                }
                else {
                    newData[prop] = oj.Model._cloneAttributes(oldData[prop], null);
                }
            }
        }
    }
    return newData;
};

/**
 * @export
 * Return a copy of the Model with identical attributes and settings
 */
oj.Model.prototype.clone = function() {
    var c = new this.constructor(), prop;
    
    for (prop in this) {
        // Shallow copy all but data
        if (this.hasOwnProperty(prop) && this[prop] !== this.attributes) {
            c[prop] = this[prop];
        }
    }
    // Deep copy data
    c.attributes = oj.Model._cloneAttributes(this.attributes, null);

    // Remove the cid--this should be unique
    delete c['cid'];    
    // Set a new cid
    c.SetCid();
    
    c.SetupId();
    
    return c;
};

// Does this model match the given id or cid?
oj.Model.prototype.Match = function(id, cid) {
    var modId = this.GetId(), modCid;
    if (modId !== undefined && modId == id) {
        return true;          
    }
    modCid = this['cid'];
    if (modCid !== undefined && modCid == cid) {
        return true;
    }
    return false;
};

/**
 * Set the value(s) of one or more attributes of the model, and fire events.
 * @param {string||Object} property Property attribute name to set, or an Object containing attribute/value pairs
 * @param {Object=} value Value for property if property is not an Object containing attribute/value pairs
 * @param {Object=} options Options may be passed in including "silent" to prevent events from firing, or "unset" to delete all the properties passed in rather than setting them
 * @returns {Object||boolean} the model itself, false if validation failed on set
 * @export
 */
oj.Model.prototype.set = function (property, value, options) {
    var opts = {}, ignoreLastArg = false, prop, i, valid = true;
    
    if (arguments) {
        if (arguments.length > 0) {
            // Check if the last argument is not the first argument
            if (arguments.length > 1) {
                if (arguments[arguments.length-1]) {
                    // Last arg is options: ignore later
                    ignoreLastArg = true;
                    opts = arguments[arguments.length-1] || {};
                }
            }
            // Check if first arg is property bag
            if (oj.Model._hasProperties(property)) {
                // For set, pass entire thing to setProp
                if (opts['unset']) {
                    for (prop in property) {
                        if (property.hasOwnProperty(prop)) {
                            this._unsetInternal(prop, null, false);
                        }
                    }
                }
                else {
                    if (!this._setProp(property, null, true, true, opts)) {
                        valid = false;
                    }
                }
            }
            else {
                // Not a property bag?  We assume it's a series of property/value arguments
                for (i = 0; i < arguments.length; i+=2) {
                    // Process the arg as long as its: defined, and isn't the last argument where we're supposed to ignore the last argument
                    // due to it being 'options'
                    if (arguments[i] !== undefined || i < arguments.length-1 || (!ignoreLastArg && i === arguments.length-1)) {
                        if (opts['unset']) {
                            this._unsetInternal(arguments[i], null, false);
                        }
                        else {
                            if (!this._setProp(arguments[i], arguments[i+1], false, false, opts)) {
                                valid = false;
                            }
                        }
                    }
                }
            }
        }
    }
    if (valid) {
        return this;
    }
    return false;
};

/**
 * Deletes the given property from the Model.
 * @param {string} property Property to remove from model 
 * @param {Object=} options do not fire change events if "silent" is set to true
 * @returns {boolean} false if validation of the unset fails
 * @export
 */
oj.Model.prototype.unset = function (property, options) {
    return this._unsetInternal(property, options, false);
};


oj.Model.prototype._unsetInternal = function (property, options, clear) {
    options = options || {};
    var silent = options['silent'], attrs = {};
    
    if (this.has(property)) {
        if (!this._checkValid(attrs, options, false)) {
            return false;
        }
        if (!clear) {
            this._clearChanged();
        }
        
        //attrs[property] = undefined;
        delete this.attributes[property];
        this._addChange(property, undefined);
        //if (!silent) {
            this._fireAttrChange(property, null, null, silent);
            this._fireChange(null, silent);
        //}
    }
    this.SetupId();
    return true;    
};

/**
 * Returns the value of the property from the Model.
 * @param {string} property Property to get from model 
 * @return {Object} value of property
 * @export
 */
oj.Model.prototype.get = function (property) {
    return this.attributes[property];
};

/**
 * Determines if the Model has a certain property set, vs. undefined.
 * @param {string} property Property to check for
 * @return {boolean} true if the model contains the given property
 * @export
 */
oj.Model.prototype.has = function (property) {
    return this.attributes[property] !== undefined && this.attributes[property] !== null;
};

/**
 * Loads the Model object from the data service URL. Performs a data "read."
 * @param {Object=} options Options to control fetch<p>
 * success: a user callback called when the fetch has completed successfully. This makes the fetch an asynchronous process. The callback is called passing the Model object, raw response, and the fetch options argument.<p>
 * error: a user callback function called if the fetch fails. The callback is called passing the model object, xhr, and options arguments. 
 * @export
 */
oj.Model.prototype.fetch = function (options) { 
    options = options || {};
    var success = options['success'], userErr = options['error'], self = this, opts;

    opts = oj.Model._copyOptions(options);
    opts['error'] = function(xhr, status, err) {
                        // Trigger an error event
                        self.TriggerInternal(false, oj.Events.EventType['ERROR'], self, xhr, options);

                        if (userErr) {
                            userErr.call(self, arguments);
                        }
                    };

    opts['success'] = function (response) {
            oj.Model._fireSyncEvent(self, response, opts, false);
            
            if (oj.Model.IsFunction(this['parse'])) {
                this.set(this['parse'](response), opts);
            }
             if (success) {
                 success.call(self, this, response, options);
             }};
    oj.Model._internalSync("read", this, opts);
};

oj.Model.prototype['parse'] = function (rawData) {
    this.attributes = rawData;
    this.SetupId();
    return this.attributes;
};

/**
 * @export
 * Return the URL used to access this model in the data source
 * 
 * @returns {string|null} url to access this model in the data source
 */
oj.Model.prototype.url = function() {
    var urlRoot = this._getUrlRoot(), id = this.GetId(), coll, collUrl, slash;
    if (urlRoot) {
        return id ? urlRoot + '/' + encodeURIComponent(id) : urlRoot;
    }
    
    coll = this['collection'];
    if (coll) {
        if (oj.Model.IsFunction(coll['url'])) {
            collUrl = coll['url']();
        }
        else {
            collUrl = coll['url'];
        }
        if (id && collUrl) {
            slash = oj.Model._getLastChar(collUrl) == '/' ? '' : '/';
            return collUrl + slash + encodeURIComponent(this.GetId());
        }
        return collUrl;
    }
    
    throw "No URL defined";
};

/**
 * @export
 * Return all of the model's attributes as an array
 * 
 * @returns {Array} array of all the model's attributes
 */
oj.Model.prototype.keys = function() {
    var prop, retArray = [];
    
    for (prop in this.attributes) {
        if (this.attributes.hasOwnProperty(prop)) {
            retArray.push(prop);
        }
    }
    return retArray;
};


/**
 * @export
 * Return all of the model's attributes values as an array
 * 
 * @returns {Array} array of all the model's attributes values
 */
oj.Model.prototype.values = function() {
    var prop, retArray = [];
    
    for (prop in this.attributes) {
        if (this.attributes.hasOwnProperty(prop)) {
            retArray.push(this.get(prop));
        }
    }
    return retArray;
};

/**
 * @export
 * Return an array of attributes/value pairs found in the model 
 * 
 * @returns {Object} returns the model's attribute/value pairs as an array
 */
oj.Model.prototype.pairs = function() {
    var prop, retObj = {};
    for (prop in this.attributes) {
        if (this.attributes.hasOwnProperty(prop)) {
            retObj[prop] = this.get(prop);
        }
    }
    return retObj;
};

/**
 * @export
 * Return attribute/value pairs for the model minus those attributes listed in keys
 * 
 * @param {Array||Object} keys keys to exclude from the returned attribute/value pairs
 * 
 * @returns {Object} array of the model's attribute/value pairs except those listed in keys
 */
oj.Model.prototype.omit = function(keys) {
    var keyArr = [], i, prop, retObj = {};
    
    if (keys instanceof Array) {
        keyArr = keys;
    }
    else {
        if (arguments) {
            for (i = 0; i < arguments.length; i++) {
                keyArr.push(arguments[i]);
            }
        }
        else {
            return this.pairs();
        }
    }
    for (prop in this.attributes) {
        if (this.attributes.hasOwnProperty(prop)) {
            if (keyArr.indexOf(prop) == -1) {
                retObj[prop] = this.get(prop);
            }
        }
    }
    return retObj;
};

/**
 * @export
 * Return attribute/value pairs for the model for the keys
 * 
 * @param {Array||Object} keys keys for which to return attribute/value pairs
 * 
 * @returns {Object} array of the model's attribute/value pairs filtered by keys
 */
oj.Model.prototype.pick = function(keys) {
    var keyArr = [], i, retObj = {};
    
    if (keys instanceof Array) {
        keyArr = keys;
    }
    else {
        if (arguments) {
            for (i = 0; i < arguments.length; i++) {
                keyArr.push(arguments[i]);
            }
        }
        else {
            return this.pairs();
        }
    }
    for (i = 0; i < keyArr.length; i++) {
        if (this.attributes.hasOwnProperty(keyArr[i])) {
            retObj[keyArr[i]] = this.get(keyArr[i]);
        }
    }
    return retObj;
};

/**
 * @export
 * Return an array of value/attribute pairs found in the model 
 * 
 * @returns {Object} returns the model's value/attribute pairs as an array
 */
oj.Model.prototype.invert = function() {
    var prop, retObj = {}, val;
    for (prop in this.attributes) {
        if (this.attributes.hasOwnProperty(prop)) {
            val = this.get(prop);
            retObj[val] = prop;
        }
    }
    return retObj;
};

oj.Model._getLastChar = function(str) {
    return str.charAt(str.length-1);
};

oj.Model.prototype._saveUrl = function() {
    var urlRoot = this._getUrlRoot();
    if (urlRoot) {
        return urlRoot;
    }
    
    if (this.GetCollection()) {
        return this.GetCollection()['url'];
    }
    
    return null;
    
};

oj.Model.prototype._getUrlRoot = function() {
    if (oj.Model.IsFunction(this['urlRoot'])) {
        return this['urlRoot']();
    }
    return this['urlRoot'];
};

oj.Model.prototype['parseSave'] = function (modelData) {
    return modelData;
};

/**
 * @export
 * Check to see if the model is valid by running the validate callback, if it exists
 * 
 * @returns {boolean} true if validate passes or if no validate callback
 */
oj.Model.prototype.isValid = function() {
    var options = {};
    options['validate'] = this['validate'];
    return this._checkValid(this.attributes, options, false);
};

oj.Model._isValidateSet = function(options, save) {
    options = options || {};
    if (options['validate'] !== undefined && options['validate'] !== null) {
        return options['validate'];
    }
    // The "default" is different for save vs. set
    return save;
};

oj.Model.prototype._checkValid = function(attributes, options, save) {  
    var validate = this['validate'];
    if (validate && oj.Model._isValidateSet(options, save)) {
        // If we have a validate override and it returns something, don't save
        this['validationError'] = validate.call(this, attributes, options);
        if (this['validationError']) {
            this.TriggerInternal(false, oj.Events.EventType['INVALID'], this, this['validationError'], options);
            return false;
        }
    }        
    return true;
};

oj.Model._processArgs = function(args) {
    var ignoreLastArg = false, options = {}, prop, attributes = {}, i;
    
    if (args) {
        if (args.length > 0) {
            // Check if the last argument is not the first argument
            if (args.length > 1) {
                if (args[args.length-1] && oj.Model._hasProperties(args[args.length-1])) {
                    // Last arg is options: ignore later
                    ignoreLastArg = true;
                    options = args[args.length-1] || {};
                }
            }
            if (args[0] == null) {
                return {attributes:null,options:options};
            }
            
            // Check if first arg is property bag
            if (oj.Model._hasProperties(args[0])) {
                for (prop in args[0]) {
                    if (args[0].hasOwnProperty(prop)) {
                        attributes[prop] = args[0][prop];
                    }
                }
            }
            else {
                // Not a property bag?  We assume arguments are a series of attr/values
                for (i = 0; i < args.length; i+=2) {
                    // Process the arg as long as its: defined, and isn't the last argument where we're supposed to ignore the last argument
                    // due to it being 'options'
                    if (args[i] !== undefined || i < args.length-1 || (!ignoreLastArg && i === args.length-1)) {
                        attributes[args[i]] = args[i+1];
                    }
                }
            }
        }
    }    
    return {attributes:attributes, options:options};
};

oj.Model._copyOptions = function(options) {
    var optReturn = {}, prop;
    options = options || {};
    
    for (prop in options) {
        if (options.hasOwnProperty(prop)) {
            optReturn[prop] = options[prop];
        }
    }
    return optReturn;
};

/**
 * Saves the current Model object to the data service. Performs a data "update."
 * @param {Object=} attributes One or more attribute name/value pairs to set on the Model before the save. 
 * @param {Object=} options Options to control save<p>
 * success: a user callback called when the save has completed successfully. This makes the save an asynchronous process. The callback is called passing the Model object, response from the AJAX call, and the fetch options argument.<p>
 * error: a user callback function called if the save fails. 
 * contextType: in case the user's REST service requires a different POST content type than the default, 'application/json'
 * validate: should the validation routine be called if available
 * patch: should only changed attributes be sent via a PATCH?
 * @return {Object|boolean} returns false if validation failed
 * @export
 */
oj.Model.prototype.save = function (attributes, options) {    
    var forceNew, success, callback, self, userErr, patch, argResults = oj.Model._processArgs(arguments), opts, oldAttrs, attrArgs;
    attrArgs = attributes === undefined ? undefined : argResults.attributes;
    opts = oj.Model._copyOptions(argResults.options);

    if (!opts['wait']) {
        this.set(attrArgs);
    }
    
    if (!this._checkValid(this.attributes, opts, true)) {
        return false;
    }
    
    forceNew  = opts['forceNew'] === undefined ? false : opts['forceNew'];
    self = this;
    userErr = opts['error'];
    patch = opts['patch'];

    opts['error'] = function(xhr, status, err) {
                            // Trigger an error event
                            self.TriggerInternal(false, oj.Events.EventType['ERROR'], self, xhr, options);

                            if (userErr) {
                                userErr.call(self, arguments);
                            }
                        };
                        
    opts['saveAttrs'] = opts['wait'] ? this._attrUnion(attrArgs) : this.attributes;
    
    // Must temporarily at least set attrs for toJSON()
    oldAttrs = this.attributes;
    // Swap in what's to be saved and call toJSON()
    this.attributes = opts['saveAttrs'];
    opts['saveAttrs'] = this.toJSON();    
    this.attributes = oldAttrs;
    
    if (!forceNew && !this.isNew()) {
        success = opts['success'];
        opts['success'] = 
            function (resp, textStatus, jqXHR) {
                var attrs;
                
                if (resp) {
                    if (oj.Model.IsFunction(this['parse'])) {
                        attrs = this['parse'](resp);
                    }
                    else {
                        attrs = resp;
                    }
                    
                    self.attributes = attrs;
                    self.SetupId();
                }
                
                oj.Model._fireSyncEvent(self, resp, opts, false);
                if (success) {
                     success.call(oj.Model.GetContext(opts, self), self, resp, options);
                }
                self._clearChanged();
            };        
        if (attrArgs === undefined) {
            opts['attrs'] = undefined;
        }
        else {
            opts['attrs'] = patch ? attrArgs : opts['saveAttrs'];
        }
        return oj.Model._internalSync(patch ? "patch" : "update", this, opts);
    }
    
    callback = oj.Model._getSuccess(opts);
    opts['success'] = function(resp, status, xhr) {
       var attrs;
       if (resp) {
            if (oj.Model.IsFunction(self['parse'])) {
                attrs = self['parse'](resp);
            }
            else {
                attrs = resp;
            }
            if (!self._checkValid(attrs, opts, true)) {
                return;
            }
            self.attributes = attrs;
            self.SetupId();
       }
       if (opts['wait']) {
           self.set(attrArgs);
       }
       oj.Model._fireSyncEvent(self, resp, opts, false);
       
        if (callback) {
            callback.call(oj.Model.GetContext(opts, self), self, resp, options);
        }
        self._clearChanged();        
    };

    opts['attrs'] = opts['saveAttrs'];
    
    // Turn on parse flag
    opts['parse'] = true;

    return oj.Model._internalSync("create", this, opts);
};

oj.Model.prototype._attrUnion = function(attrs) {
    var attrReturn = {}, prop;
    
    for (prop in this.attributes) {
        if (this.attributes.hasOwnProperty(prop)) {
            attrReturn[prop] = this.attributes[prop];
        }
    }
    for (prop in attrs) {
        if (attrs.hasOwnProperty(prop)) {
            attrReturn[prop] = attrs[prop];
        }
    }
    return attrReturn;
};

oj.Model.IsArray = function(obj) {
    return obj != null && obj.constructor === Array;
};

oj.Model.IsFunction = function(obj) {
    return obj instanceof Function;
};

oj.Model.IsComplexValue = function(val) {
    return val && val.hasOwnProperty("value") && val.hasOwnProperty("comparator");
};
    
// Does this model contain all of the given attribute/value pairs?
oj.Model.prototype._hasAttrs = function(attrs) {
    var prop;
    for (prop in attrs) {
        if (attrs.hasOwnProperty(prop)) {
            if (!this.attributes.hasOwnProperty(prop)) {
                return false;
            }

            var val = oj.Model.IsArray(attrs[prop]) ? attrs[prop] : [attrs[prop]];
            for (var i = 0; i < val.length; i++) {
                if (oj.Model.IsComplexValue(val[i])) {
                    var comparator = val[i]['comparator'];
                    var value = val[i]['value'];
                    if (oj.StringUtils.isString(comparator)) {
                        throw new Error("String comparator invalid for local where/findWhere");
                    }
                    if (!comparator(this, prop, value)) {
                        return false;
                    }
                } else {
                    // Array case meaningless here.  Model can't be == value1 and value2
                    if (attrs[prop] !== this.attributes[prop]) {
                        return false;
                    }
                }
            }
        }
    }    
    return true;
};

// See if this model contains any of the given attribute/value pairs 
oj.Model.prototype.Contains = function(attrs) {
    var attrList = (attrs.constructor === Array) ? attrs : [attrs], i;
    
    for (i = 0; i < attrList.length; i++) {
        if (this._hasAttrs(attrList[i])) {
            return true;
        }
    }
    return false;
};

oj.Model._getSuccess = function(options) {
    return options != null && options['success'] ? options['success'] : null;
};

oj.Model.GetContext = function(options, model) { 
    if (options !== undefined && options['context'] !== undefined) {
        return options['context'];
    }
    return model;
};

/**
 * Determines if this Model object has been assigned an id value yet. This indicates whether or not the Model's data has been saved to or fetched from the data service at any point.
 * @returns {boolean} true if the Model object has not had its id set yet, false if not.
 * @export
 */
oj.Model.prototype.isNew = function() {
    return this.GetId() == undefined;
};

oj.Model.prototype._getIdAttr = function () {
    return this['idAttribute'] || 'id';
};

oj.Model.prototype.GetId = function () {
    return this['id'];
};

/**
 * Return the set of attributes and values that have changed since the last fetch, or since the Model object was created. If attribute/value pairs are passed in, check those to see if they're different than the model.
 * Return false if there were no changes
 * @param {Object=} attributes One or more attribute/value pairs to check against the model for changes 
 * @return {Object||boolean} the set of all attribute value pairs that have changed since last update or save, if no attributes passed in; the set of all attribute value pairs that are different than those listed in the attributes parameter, if present.  False if no changes
 * @export
 */
oj.Model.prototype.changedAttributes = function(attributes) {
    if (attributes) {
        var internalChanges = {}, prop;
        for (prop in attributes) {
            if (attributes.hasOwnProperty(prop)) {
                if (!oj.Object.innerEquals(attributes[prop], this.attributes[prop])) {
                    internalChanges[prop] = attributes[prop];
                }
            }
        }
        return oj.Object.isEmpty(internalChanges) ? false : internalChanges;
    }
    return oj.Object.isEmpty(this['changed']) ? false : this['changed'];
};

/**
 * Return true if the Model object has had any changes made to its values, or if any changes have been made to the optional set of attributes passed in.
 * @param {Array=} attribute One or more attributes to check for changes 
 * @returns {boolean} true if the Model object has had any changes since retrieval or last update at all (if no attributes parameter); true if the Model object has had changes to one or more of the passed-in attributes since retrieval or last update (if attributes parameter present).
 * @export
 */
oj.Model.prototype.hasChanged = function(attribute) {
    if (attribute !== undefined) {
        return oj.Model._hasProperties(this['changed']) && this['changed'].hasOwnProperty(attribute);
    }
    return oj.Model._hasProperties(this['changed']);
};

/**
 * Fire attribute change events to all registered listeners.
 * @export
 */
oj.Model.prototype.change = function() {
    var prop;
    for (prop in this['changed']) {
        if (this['changed'].hasOwnProperty(prop)) {
            this._fireAttrChange(prop, this.get(prop), null, false);
            this._fireChange(null, false);
        }
    }        
};

/**
 * Delete the record represented by this Model object from the data service.
 * @param {Object=} options Options for the destroy operation. They include success and/or error callback function upon the delete or failure of the delete. 
 * @export
 */
oj.Model.prototype.destroy = function (options) {
    options = options || {};
    var isWait = options['wait'], callback, context, userErr = options['error'], self = this, xhr, opts;
    
    opts = oj.Model._copyOptions(options);
    callback = oj.Model._getSuccess(opts);
    context = oj.Model.GetContext(opts, this);
    
    opts['success'] = function(data, status, xhr) {
        if (isWait) {
            self._fireDestroy(false);
        }
        oj.Model._fireSyncEvent(self, data, opts, false);
    
        if (callback) {
            callback.call(oj.Model.GetContext(opts, self), self, data, options);
        }
    };
    opts['error'] = function(xhr, status, err) {
                            // Trigger an error event
                            self.TriggerInternal(false, oj.Events.EventType['ERROR'], self, xhr, opts);

                            if (userErr) {
                                userErr.call(self, arguments);
                            }
                        };

    if (!this.isNew()) {
        xhr = oj.Model._internalSync("delete", this, opts);
        if (!isWait) {
            this._fireDestroy(false);
        }
        return xhr;
    }
    if (!isWait) {
        this._fireDestroy(false);
    }
    if (callback) {
        callback.call(oj.Model.GetContext(opts, self), self, null, options);
    }
    return false;
};

// Fire destroy event to all listeners
oj.Model.prototype._fireDestroy = function (silent) {
    this.TriggerInternal(silent, oj.Events.EventType['DESTROY'], this, this['collection'], null);
};

// Fire sync event to all listeners
oj.Model._fireSyncEvent = function(model, resp, options, silent) {
    model.TriggerInternal(silent, oj.Events.EventType['SYNC'], model, resp, options);
};

/**
 * Return a copy of Model's current attribute/value pairs
 * @return {Object} a copy of the Model's current set of attribute/value pairs.
 * @export
 */
oj.Model.prototype.toJSON = function() {
    var retObj = {}, prop;
    for (prop in this.attributes) {
        if (this.attributes.hasOwnProperty(prop)) {
            if (Array.isArray(this.attributes[prop])) {
                retObj[prop] = this.attributes[prop].slice(0);
            }
            else {
                retObj[prop] = this.attributes[prop];
            }
        }
    }
    return retObj;
};

/**
 * @export
 * Return the previous value of the given attribute, if any.
 * 
 * @param {string} attr
 * @returns {Object} previous value of attr, if any.  If the attribute has not changed, returns undefined
 */
oj.Model.prototype.previous = function(attr) {
    return this.previousAttrs[attr];
};

/**
 * @export
 * Return a copy of the model's previously set attributes
 * 
 * @returns {Object} a copy of the model's previous attributes
 */
oj.Model.prototype.previousAttributes = function() {
    return this.previousAttrs;
};

/**
 * @export
 * Return the previous values of any attributes that have been set
 * 
 * @returns {Object} an object containing all the previous values of chnaged attributes
 */
oj.Model.prototype.previousChanges = function() {
    return this.previousAttrs;
};

/**
 * Performs communications with the server.  Can be overridden/replaced by clients
 * 
 * @param {string} method "create", "read", "update", or "delete"
 * @param {Object} model Model to be read/saved/deleted/created
 * @param {Object=} options to control sync
 * success: called if sync succeeds
 * error: called if sync fails
 * others are passed to jQuery
 * 
 * @return {Object} xhr object
 */
oj.Model.prototype['sync'] = function(method, model, options) {    
    return window['oj']['sync'](method, model, options);
};

// Internal processing before sync-- we want this stuff to happen even if user replaces sync
oj.Model._internalSync = function(method, model, options) {
    options = options || {};
    // If Model/Collection has OAuth object, then create Authorization header (see oj.RestImpl.addOptions)
    if(model['oauth']) {
            options['oauthHeader'] = model['oauth'].getHeader();
    }
    	
	// Make sure to transfer the data type if it's set on the calling object
    if (!options['dataType'] && model['dataType']) {
        options['dataType'] = model['dataType'];
    }
    if (!options['jsonpCallback'] && model['jsonpCallback']) {
        options['jsonpCallback'] = model['jsonpCallback'];
    }
    
    // Do parsing if necessary and tuck it on options
    if (method === "create" || method === "patch" || method === "update") {
        options.parsedData = model['parseSave'].call(model, method==="patch" ? model['changed'] : options['saveAttrs']);
    }
    return model['sync'](method, model, options);
};

/**
 * @export
 * Master server access method for all models and collections
 * @param {string} method "create", "read", "update", "patch", or "delete"
 * @param {Object} model Model (or Collection to be read) to be read/saved/deleted/created
 * @param {Object=} options to control sync
 * success: called if sync succeeds
 * error: called if sync fails
 * others are passed to jQuery
 * 
 * @return {Object} xhr object
 */
oj.sync = function(method, model, options) {
    options = options || {};
    var restService, success = options['success'], error = options['error'], cors, customURL;
    
    cors = options['dataType'] === 'jsonp' ? false : true;
    customURL = model['customURL'];
    
    if (method.valueOf() === "create") {
      restService = new oj.RestImpl(model._saveUrl(), customURL);
      return restService.addRecord(options.parsedData, error, options, model);
    }

    if (method.valueOf() === "read") {
        if (model instanceof oj.Model) {
            restService = new oj.RestImpl(model.url(), customURL);
            return restService.getRecord(success, error, model.GetId(), options, oj.Model.GetContext(options, model));
        }
        // Collection fetch
        restService = new oj.RestImpl(model.GetCollectionFetchUrl(options), customURL);
        return restService.getRecords(success, error, options, model);
    }
    
    restService = new oj.RestImpl(model.url(), customURL);
    var recordId = null;
    if (model instanceof oj.Model) {
        recordId = model.GetId();
    }
    if (method.valueOf() === "update") {
        return restService.updateRecord(success, recordId, options.parsedData, error, options, model, false);
    }
    if (method.valueOf() === "patch") {
        return restService.updateRecord(success, recordId, options.parsedData, error, options, model, true);
    }
    if (method.valueOf() === "delete") {
        return restService.deleteRecord(recordId, error, options, model);
    }
    return null;
};

oj.ajax = function() {
    return $.ajax.apply(window['oj'], arguments);
};
/*jslint browser: true*/

/**
 * @export
 * @class oj.Collection 
 * @classdesc Collection of Model objects 
 * 
 * @param {Array=} models Set of model objects to put into collection at construction time 
 * @param {Object=} options Passed through to the user's initialize routine, if any, upon construction 
 * @constructor
 * @mixes oj.Events
 */
oj.Collection = function(models, options) {
    if (oj.Collection._justExtending) {
        return;
    }

    // Initialize
    oj.Collection._init(this, models, options, null);
};

/**
 * @export
 * @desc Property specifying the model class object contained/used by the collection
 * 
 * @type Object
 */
oj.Collection.prototype.model = null;


/**
 * @export
 * @desc Total number of models in the collection (note that when the collection is virtual, not all may be available or currently fetched)
 * 
 * @type number
 */
oj.Collection.prototype.length = 0;

/**
 * @export
 * @desc Direct access to the Collection's list of Models.<br/>
 * Note that this property should not be used directly when a collection is paging (virtual).<br/>
 * Automatic fetches will not be triggered for undefined elements in the model.  Use at() instead.
 * 
 * @type Array 
 */
oj.Collection.prototype.models = [];

/**
 * @export
 * @desc The data service's URL on the server.
 * 
 * @type String
 */
oj.Collection.prototype.url = null;

/**
 * A callback to allow users to completely customize the data service URLs
 * @param {String} operation one of create, read, update, patch, or delete indicating the type of operation for which to return the URL<p>
 * @param {Object} collection the oj.Collection object requesting the URL<p>
 * @param {Object} options any of the following properties:<p>
 * recordID : id of the record involved, if relevant<p>
 * fetchSize : how many records to return.  If not set, return all.<p>
 * startIndex: Starting record number of the set to return.<p>
 * startID: Retrieve records starting with the record with the given unique ID. <p>
 * since: Retrieve records with timestamps after the given timestamp.<p>
 * until: Retrieve records with timestamps up to the given timestamp.  Default is "until"<p>
 * sort:  field(s) by which to sort, if set<p>
 * sortDir: sort ascending or descending (asc/dsc) <p>
 * query: a set of attributes indicating filtering that should be done on the server.  @see (@link where) for complete documentation of query values<p>
 * all: true (along with 'query', above) indicates that this is a findWhere or where type call that is expecting all models meeting the query condition to be returned<p>
 * 
 * @return {(function(string,Object,Object):(string|Object|null))|null} customURL callbacks should return either: null, in which case the default will be used; a string, which will be used with the standard
 * HTTP method for the type of operation, or an Object with any ajax attributes.  This must at minimum include the URL:<p>
 *  url: giving the custom URL string<p>
 *  type: (optional) a string indicating the type of HTTP method to use (GET, POST, DELETE, etc.)<p>
 *  (other): (optional) any other ajax attributes to pass in the ajax call
 * @export
 */
oj.Collection.prototype.customURL = function(operation, collection, options) {
    return null;
};

/**
 * A callback allowing users to extract their own paging/virtualization return values from their response
 * The callback is made with the raw data response to the collection fetch
 * @param {Object} response the raw data response coming back from the fetch
 * 
 * @return {(function(Object):(Object|null)|null)} customPagingOptions callbacks should return either null, in which case the Collection will look for the simple default properties, or
 * an object containing the one or more of the following attribute/value pairs (note that the Collection will look back to the response for default paging return properties if 
 * not returned in this object):<p>
 * 
 *                  totalResults: the total number of records available on the server side, not just in the current result.  Default is "totalResults"<p>
 *                  limit: the actual fetchSize used by the server in generating the result.  This may not be the client's fetchSize or the number of records in the current result.  Default is "limit".  This becomes the collection's "lastFetchSize" property<p>
 *                  count: the actual number of records returned by the server in the last result.  This becomes the collection's "lastFetchCount"<p>
 *                  offset: the actual starting record number of the current result.  Default is "offset"<p>
 *                  hasMore: boolean indicating whether or not there are more records available beyond the current result.  Default is "hasMore"<p>
 *                  
 * 
 * @export
 */
oj.Collection.prototype.customPagingOptions = function(response) {
    return null;
};


/**
 * @export
 * @desc The number of records brought back on the last fetch.
 * 
 * @type number
 */
oj.Collection.prototype.lastFetchSize = 0;

/**
 * @export
 * @desc Indicates whether or not there are more records available on the server, beyond the latest fetch.
 * 
 * @type boolean
 */
oj.Collection.prototype.hasMore = false;

/**
 * @export
 * @desc The total number of records available for this collection regardless of whether they have been fetched or not.  For non-virtual collections this will equal the length.
 * 
 * @type number
 */
oj.Collection.prototype.totalResults = 0;

/**
 * 
 * @export
 * @desc The number of records actually fetched the last time the collection went to the server.  This may or may not match fetchSize or limit
 * 
 * @type number
 */
oj.Collection.prototype.lastFetchCount = 0;

/**
 * @export
 * @desc The number of records to be kept in memory at any one time.  The default of -1 indicates that no records are thrown out
 * 
 * @type number
 */
oj.Collection.prototype.modelLimit = -1;

/**
 * @export
 * @desc The actual starting record number of the last fetch from the server.
 * 
 * @type number
 */
oj.Collection.prototype.offset = 0;

/**
 * @export
 * @desc The number of records to be fetched from the server in any one round trip.  The server's fetch size comes back as the "limit" property.  The default value of -1 indicates that virtualization/paging is not being used or is not available, and all records will be fetched.
 * and the number of records actually fetched comes back as "count"
 * 
 * @type number
 */
oj.Collection.prototype.fetchSize = -1;

/**
 * @export
 * @desc Sort direction for string-based field comparators.  A value of 1 (the default), indicates ascending sorts, -1 indicates descending
 * 
 * @type number
 */
oj.Collection.prototype.sortDirection = 1;

/**
 * @export
 * @desc If set, sort the collection using the given attribute of a model (if string); function(Model) returning a string attribute
 * by which the sort should take place; function(Model1, Model2) if a user-defined function comparing Model1 and Model2 (see the
 * JavaScript array.sort() for details)
 * 
 * @type {String|function(Object)|function(Object,Object)}
 */
oj.Collection.prototype.comparator = null;

/**
 * @export
 * @desc Set to true if sort is supported.  This will only be false if the collection is connected to a paging REST service that does 
 * not support sorting
 * 
 * @type boolean
 */
oj.Collection.prototype.sortSupported = true;


// Subclass from oj.Object 
oj.Object.createSubclass(oj.Collection, oj.Object, "Collection.Collection");

oj.Collection.prototype.Init = function()
{
    oj.Collection.superclass.Init.call(this);
};

/**
 * Create a new, specific type of Collection object to represent a collection of records from a JSON data set.
 * @param {Object=} properties Properties for the new Collection class.<p>
 *                  parse: a user callback function to allow parsing of the JSON collection after it's returned from the data service<p>
 *                  model: the specific type of Model object to use for each member of the Collection<p>
 *                  url: the URL to use to get the record collection from the data service<p>
 *                  initialize: a user callback function to be called when this collection is created<p>
 *                  comparator: a user callback used on sort calls. May also be set to false to prevent sorting.<p>
 *                  fetchSize: the number of records to be fetched on each round trip to the server.  If not set, none of the paging/virtualization API will be invoked<p>
 *                  modelLimit: the number of records to be held in memory at any one time, if virtualization is in force.  The default is all records.  This uses an LRU algorithm to determine which to roll off as more records are added.<p>
 * @return {function(new:Object, ...)} new Collection object
 * @export
 */
oj.Collection.extend = function(properties)
{
    oj.Collection._justExtending = true;
    var obj = new oj.Collection();
    oj.Collection._justExtending = false;
          
    var Collection;
    if (properties && properties['constructor'] && properties.hasOwnProperty('constructor')) {
        Collection =  properties['constructor'];
    }
    else {
        Collection = function(models, options) {
                        oj.Collection._init(this, models, options, properties);
                    }
    }

    Collection.prototype = obj;
    
    Collection.prototype.constructor = Collection;
    return Collection;    
};


oj.Collection._init = function(collection, models, options, properties) {
    var prop, i, optionlist, modelList;

    collection.Init();
    
    // Augment with Event    
    oj.Events.Mixin(collection);

    // First, copy all properties passed in
    if (properties) {
        for (prop in properties) {
            if (properties.hasOwnProperty(prop)) {
                collection[prop] = properties[prop];
            }
        }        
    }

    // Check options
    options = options || {};
    optionlist = ["url", "comparator", "model", oj.Collection._FETCH_SIZE_PROP, "modelLimit", "customURL"];
    for (i = 0; i < optionlist.length; i++) {            
        if (options.hasOwnProperty(optionlist[i]) && options[optionlist[i]] !== undefined) {
            collection[optionlist[i]] = options[optionlist[i]];            
        }
    }
    if (collection._getFetchSize(null) === undefined) {
        collection.setFetchSize(-1);
    }
    if (collection['modelLimit'] === undefined) {
        collection.setModelLimit(-1);
    }
    collection['hasMore'] = false;
    collection.lruCount = 0;

    collection._setModels([]);
    if (options['parse']) {
        models = collection['parse'](models);
    }
    if (models != null && models !== undefined) {
        modelList = (models instanceof Array) ? models : [models];    
        for (i = 0; i < modelList.length; i=i+1) {
            collection.add(modelList[i], options);
        }
    }
    collection._setLength();
    
    if (properties && properties['initialize']) {
        properties['initialize'].call(collection, models, options);
    }    
};


// Placeholder for event mixins
oj.Collection.prototype.on = function (event, callback) {};
oj.Collection.prototype.OnInternal = function(event, callback, context, listenTo, ignoreSilent) {};
oj.Collection.prototype.TriggerInternal = function (silent, event, arg1, arg2, options) {};

oj.Collection.prototype._setModels = function(models) {
    this['models'] = models;
};

oj.Collection.prototype._getModels = function() {
    return this['models'];
};

oj.Collection.prototype._getModelsLength = function() {
    return this._getModels().length;
};

// Designed to check if index exceeds the length of the models.  If we're in a virtual and "no totalResults" case, we're never over the upper limit
oj.Collection.prototype._overUpperLimit = function(index) {
    if (index < this._getModelsLength()) {
        return false;
    }
    if (this._isVirtual()) {
        if (!this._hasTotalResults() || this._getModelsLength() === 0) {
            return false;
        }
    }
    return true;
};

oj.Collection.prototype._hasTotalResults = function() {
    return this['totalResults'] !== undefined && this['totalResults'] != null;
}

oj.Collection.prototype._pushModels = function(model) {
    // Model is being added to the end, it should be made the head
    this._makeModelHead(model);
    this._getModels().push(model);
    this.lruCount++;
    model.SetIndex(this._getModelsLength()-1);
};

oj.Collection.prototype._reduceLRU = function(removed) {
    if (removed) {
        for (var i = 0; i < removed.length; i++) {
            if (removed[i]) {
                this.lruCount--;
            }
        }
    }    
};

/**
 * @private
 * @param {number} start
 * @param {number} count
 * @param {Object=} model
 */
oj.Collection.prototype._spliceModels = function(start, count, model) {
    // Clean up prev/next links for models being removed
    for (var i = start; i < start + count; i++) {
        this._removePrevNext(this._getModels()[i]);
    }
    if (model === undefined) {
        this._reduceLRU(this._getModels().splice(start, count));
    }
    else {
        this._reduceLRU(this._getModels().splice(start, count, model));
        this._makeModelHead(model);
    }
    if (this.lruCount < 0) {
        this.lruCount = 0;
    }
    this._realignModelIndices(start);
};

oj.Collection.prototype._getModel = function(index) {
    return this._getModels()[index];
};

// Realign all the indices of the models (after sort for example)
oj.Collection.prototype._realignModelIndices = function(start) {
    var model;
    for (var i = start; i < this._getModelsLength(); i++) {
        model = this._getModel(i);
        if (model) {
            model.SetIndex(i);
        }
    }
};

// Update next/prev pointers as though the given model were being removed
oj.Collection.prototype._removePrevNext = function(model) {
    if (!model) {
        return;
    }
    
    var oldPrev = model.GetPrevious();
    var oldNext = model.GetNext();
    // Link the two surrounding previous/next elements to each other, because this one is being replaced and moved
    // to the head
    if (oldPrev) {
        oldPrev.SetNext(oldNext);        
    }
    else {
        // This element used to be the head
        this.head = oldNext;
    }
    if (oldNext) {
        oldNext.SetPrevious(oldPrev);
    }
    else {
        // This element used to be the tail
        this.tail = oldPrev;
    }    
};

oj.Collection.prototype._makeModelHead = function(model) {
    // Make this new model the most recently used: the head
    model.SetNext(this.head);
    if (this.head) {
        this.head.SetPrevious(model);
    }
    else {
        // No head: list is empty-->make tail the same element
        this.tail = model;
    }
    model.SetPrevious(null);
    this.head = model;    
};

oj.Collection.prototype._setModel = function(index, model) {
    var oldModel = this._getModels()[index];
    this._removePrevNext(oldModel);
    if (!oldModel) {
        // Newly "inserted" model
        this.lruCount++;
    }
    this._getModels()[index] = model;
    model.SetIndex(index);
    this._makeModelHead(model);
};

// Clean off n models from tail (oldest) of prev/next list
oj.Collection.prototype._clearOutModels = function(n) {
    var current = this.tail, index, model;
    var i = 0;
    this.tail = null;
    while (current && i < n) {
        // Erase this model from collection, iff it hasn't changed
        index = current.GetIndex();
        model = this._getModels()[index];
        if (!(model && model.hasChanged())) {
            this.lruCount--;
            if (index > -1) {
                this._getModels()[index] = undefined;
            }

            // Clear its pointers
            current.SetNext(null);
            current = current.SetPrevious(null);
            i++;
        }
        else {
            // Lock down the tail to this one we're not deleting
            if (!this.tail) {
                this.tail = current;
            }
            current = current.GetPrevious();
        }
    }
    // Make sure we set tail if not already set
    if (!this.tail) {
        this.tail = current;
    }
    if (this.lruCount < 0) {
        this.lruCount = 0;
    }
    if (this.lruCount === 0) {
        this.head = null;
        this.tail = null;
    }
};


// Reset the LRU list
oj.Collection.prototype._resetLRU = function() {
    this.lruCount = 0;
    this.head = null;
    this.tail = null;
};

// Make sure we have room in the LRU
oj.Collection.prototype._manageLRU = function(incoming) {
    if (this._isVirtual()) {
        var limit = this._getModelLimit();
        if (limit > -1) {
            if (this.lruCount + incoming > limit) {
                // Must flush the amount over the limit
                this._clearOutModels(this.lruCount + incoming - limit);
            }
        }
    }
};

/**
 * @export
 * Return a copy of the Collection 
 * @return {Object} copy of the Collection
 */
oj.Collection.prototype.clone = function() {
    return this._cloneInternal(true);
};

oj.Collection.prototype._cloneInternal = function(withProperties) {
    var c = new this.constructor(), i;

    // Only copy locally if virtual
    var model;
    if (this._isVirtual()) {
        c = this._copyProperties(c);
        c._resetModelsToFullLength();
    }
        
    if (withProperties) {
        // Try to copy models only if told to--we may only need the shell of the collection with properties
        for (i = 0; i < this._getLength(); i=i+1) {
            model = this._atInternal(i, null, true, false);
            if (model) {
                c._addInternal(model.clone(), {'at':i}, true, false);
            }
        }
    }
    return c;
};
    
// Copy critical properties in clone
oj.Collection.prototype._copyProperties = function(collection) {
    var props = ['totalResults', 'hasMore', oj.Collection._FETCH_SIZE_PROP], prop, i;
    for (i = 0; i < props.length; i++) {
        prop = props[i];
        collection[prop] = this[prop];
    }
    return collection;
};

oj.Collection.prototype._getLength = function() {
    return this['length'];
};

oj.Collection.prototype._setLength = function()
{
    var modelsLen = this._getModelsLength();
    this['length'] = modelsLen;    
    if (!this._isVirtual()) {
        this['totalResults'] = modelsLen;
    }
};


oj.Collection.prototype._newModel = function(m, options) {
    var newModel = null, validationValue;
    if (m instanceof oj.Model) {
        newModel = m;
    }
    else {
        if (this['model']) {
            // model is defined
            if (oj.Model.IsFunction(this['model'])) {
                newModel = new this['model'](m, options);
            }
            else {
                newModel = new this['model'].constructor(m, options);
            }
        }
        else {
            newModel = new oj.Model(m, options);
        }
    }    
    // Validate
    options = options || {};
    if (options['validate'] && newModel['validate']) {
        validationValue = newModel['validate'](newModel.attributes);
        if (validationValue) {
            options['validationError'] = validationValue;
            this.TriggerInternal(false, oj.Events.EventType['INVALID'], this, validationValue, options);
            return null;
        }
    }
    return newModel;
};

/**
 * Add an instance of this collection's model(s) to the end of the collection.
 * Note that for virtual collections, if a new model is added after being saved up to the server, no add event will be fired as the 
 * collection will already "see" the model as existing. 
 * @param {Object|Array} m Model object (or array of models) to add. These can be already-created instance of the oj.Model object, or sets of attribute/values, which will be wrapped by add() using the collection's model.
 * @param {Object=} options silent: if set, do not fire an add event<p>
 *                          at: splice the new model into the collection at the value given (at:index) <p>
 *                          merge: if set, and if the given model already exists in the collection (matched by id), then merge the attribute/value sets, firing change events<p>
 *                          sort: if set, do not re-sort the collection even if the comparator is set. <p>
 *                          force: if set to true, do an add to the collection no matter whether the item is found or not <p>
 *                          deferred: if true, return a promise as though this collection were virtual whether it is or not
 * 
 * @returns {Object} if deferred or virtual, return a promise when the set has completed
 * @export
 */
oj.Collection.prototype.add = function(m, options) {    
    this._manageLRU(1);
    var opt = options || {};
    return this._addInternal(m, options, false, opt['deferred']);
};

// fillIn: true indicates that we're just trying to use add() after a fetch to 
// insert into a preallocated list of models, not truly do an add/merge from the API
oj.Collection.prototype._addInternal = function(m, options, fillIn, deferred) {
    // Get options
    options = options || {};
    var modelArray = [], 
        at = options['at'],
        silent = options['silent'],
        force = options['force'],
        i, index, cid,
        merge = options['merge'] || false,
        sort = options['sort'], needSort = true, added = false;


    if (m instanceof Array) {
        modelArray = m;
    }
    else {
        modelArray.push(m);
    }
    
    function addToCollection(collection, newModel, existingModel) {
        if (existingModel === undefined) {
            if (at === undefined) {
                collection._pushModels(newModel);
                index = collection._getModelsLength()-1;
                collection._getModel(index).SetCid();
            }
            else {
                index = at;
                if (collection._isVirtual() && fillIn) {
                    // Array has been preallocated in this case
                    collection._setModel(index, newModel);
                }                        
                else {
                    collection._spliceModels(index, 0, newModel);
                }
                collection._getModel(index).SetCid();
                // Increment at so that later models will be added right after their predecessors, if an array is passed in
                at = at + 1;
            }
            if (newModel.GetCollection() === undefined) {
                newModel.SetCollection(collection);
            }
            collection._setLength();
            collection._listenToModel(newModel);
            added = true;
        }
    }

    function resortAndFireEvents(collection, existingModel, modelFoundInCollection, newModel, deferred) {
        // Now resort if required (don't resort if either told not to, or if 'at' option is set) and if there's more than one model
        if (fillIn) {
            options = options || {};
            options['fillIn'] = true;
        }
        if (needSort && existingModel === undefined && !sort && at === undefined && collection._getLength() > 1) {
            if (index > -1) {
                cid = collection._getModel(index)['cid'];
            }
            var sortOpt = {};
            oj.CollectionUtils.copyInto(sortOpt, options);            
            sortOpt['add'] = true;
            collection.sort(sortOpt);
            // Reset index
            if (index > -1) {
                index = collection.indexOf(collection.getByCid(cid), deferred);
            }
        }

        if (/*!silent && */added) {
            if (newModel) {
                newModel.TriggerInternal(silent, oj.Events.EventType['ADD'], newModel, collection, options);
            }
            else {
                modelFoundInCollection.TriggerInternal(silent, oj.Events.EventType['ADD'], modelFoundInCollection, collection, options);
            }
        }    
    }
    
    function mergeAttrs(collection, modelToTryAndMerge, modelFoundInCollection, newModel, deferred) {
        var existingModel;
        
        if (!force && merge && modelFoundInCollection) {
            // Try to merge the attributes--we're merging and the model (by id) was already in the collection
            needSort = modelFoundInCollection.Merge(modelToTryAndMerge, collection['comparator']);
        }
        else {
            // Make sure model is not already in there
            if (!force) {
                existingModel = collection._getLocal(newModel);
            }

            addToCollection(collection, newModel, existingModel);
        }        

        resortAndFireEvents(collection, existingModel, modelFoundInCollection, newModel, deferred);
    }

    function doAdd(collection, model, deferred) {
        var newModel = collection._newModel(model, options), modelToTryAndMerge = null, modelFoundInCollection = null;
        if (newModel != null) {
            index = -1;
            // Make sure ID is up to date
            newModel.SetupId();

            // Use original model array not cloned model if merging--otherwise we won't find the model in the collection
            modelToTryAndMerge = model instanceof oj.Model ? model : newModel;
            if (deferred) {
                if (force) {
                    mergeAttrs(collection, modelToTryAndMerge, undefined, newModel, deferred);
                    return $.Deferred().resolve();
                }
                return collection._getInternal(modelToTryAndMerge, null, deferred, true).done(function (modInfo) {
                                                                    modelFoundInCollection = modInfo['m'];
                                                                    return mergeAttrs(collection, modelToTryAndMerge, modelFoundInCollection, newModel, deferred);
                                                                 });
            }
            modelFoundInCollection = fillIn ? collection._getLocal(modelToTryAndMerge) : collection.get(modelToTryAndMerge);
            mergeAttrs(collection, modelToTryAndMerge, modelFoundInCollection, newModel, deferred);
        }
    }
    
    if (!fillIn && (this._isVirtual() || deferred)) {
        var self = this;
        
        var doTask = function(index) {
                        var defer = $.Deferred();
                        doAdd(self, modelArray[index], true).done(function() {
                            defer.resolve(index);
                        });
                        return defer.promise();
        };

        var currentStep = doTask(0);
        var nextTask = function(j) {
                            return doTask(j+1);
        };

        for (i = 1; i < modelArray.length; i++) {
            currentStep = currentStep.then(nextTask);
        }
        return $.when(currentStep).promise();        
    }
    for (i = 0; i < modelArray.length; i++) {
        doAdd(this, modelArray[i], false);
    }
};


oj.Collection.prototype._hasComparator = function() {
    var comparator = this['comparator'];
    return comparator !== undefined && comparator !== null;
};

/**
 * @export
 * Sort the models in the collection
 * 
 * @param {Object=} options silent: if true, do not fire the sort event
 */
oj.Collection.prototype.sort = function(options) {
    options = options || {};
    var silent = options['silent'], comparator = this['comparator'], self;
    
    // Check for comparator
    if (!this._hasComparator()) {
        return;
    }
    
    // Unless all models are on the client, this is a no-op in case of virtualization: we should just clear things out so that
    // any elements will be refetched
    if (this._isVirtual() && this._hasMore()) {        
        var totalResults =  this['totalResults'];
        if (totalResults !== undefined) {
            // Make sure to set up the array if the length changes (i.e., from 0 to totalResults--need to preallocate)
            this._setModels(new Array(totalResults));
        }
        else {
            // No totalresults
            this._setModels([]);
            this._resetLRU();
            this._setLength();
        }
        return;
    }
    
    self = this;
    this._getModels().sort(function(a, b) {
                            return oj.Collection.SortFunc(a, b, comparator, self, self);
                        });
    this._realignModelIndices(0);
    // Indicate this sort is due to an add
    var eventOpts = options['add'] ? {'add':true} : null;
    this.TriggerInternal(silent, oj.Events.EventType['SORT'], this, eventOpts, null);
};

oj.Collection._getKey = function(val, attr) {
    if (val instanceof oj.Model) {
        return val.get(attr);
    }
    if (oj.Model.IsFunction(val[attr])) {
        return val[attr]();
    }
    return val[attr];
};

oj.Collection.SortFunc = function(a, b, comparator, collection, self) {
    var keyA, keyB, i, retVal;
    
    if (oj.Model.IsFunction(comparator)) {        
        // How many args?
        if (comparator.length === 1) {
            // "sortBy" comparator option
            keyA = comparator.call(self, a);
            keyB = comparator.call(self, b);
            var attrs1 = oj.StringUtils.isString(keyA) ? keyA.split(",") : [keyA];
            var attrs2 = oj.StringUtils.isString(keyB) ? keyB.split(",") : [keyB];
            for (i = 0; i < attrs1.length; i++) {                
                retVal = oj.Collection._compareKeys(attrs1[i], attrs2[i], collection['sortDirection']);
                if (retVal !== 0) {
                    return retVal;
                }
            }
        }
        // "sort" comparator option
        return comparator.call(self, a, b);
    }
    // String option
    if (oj.StringUtils.isString(comparator)) {
        var attrs = comparator.split(",");
        
        for (i = 0; i < attrs.length; i++) {
            keyA = oj.Collection._getKey(a, attrs[i]);
            keyB = oj.Collection._getKey(b, attrs[i]);
            retVal = oj.Collection._compareKeys(keyA, keyB, collection['sortDirection']);            
            if (retVal !== 0) {
                return retVal;
            }
        }
    }
    return 0;    
};

/**
 * @export
 * Return the index at which the given model would be inserted, using the collection comparator
 * 
 * @param {Object} model model for which to determine the insert point
 * @returns {number} index at which model would be inserted.  -1 if no comparator
 */
oj.Collection.prototype.sortedIndex = function(model) {
    var comparator = this['comparator'], self, test;
    
    // Check for comparator
    if (!this._hasComparator()) {
        return -1;
    }
    
    this._throwErrIfVirtual("sortedIndex");
    
    self = this;
    test = function(a, b) {
            var keyA, keyB;

            if (oj.Model.IsFunction(comparator)) {        
                // How many args?
                if (comparator.length === 1) {
                    // "sortBy" comparator option
                    keyA = comparator.call(self, a);
                    keyB = comparator.call(self, b);
                    var attrs1 = oj.StringUtils.isString(keyA) ? keyA.split(",") : [keyA];
                    var attrs2 = oj.StringUtils.isString(keyB) ? keyB.split(",") : [keyB];
                    var retVal, i;
                    for (i = 0; i < attrs1.length; i++) {                
                        retVal = oj.Collection._compareKeys(attrs1[i], attrs2[i], self['sortDirection']);
                        if (retVal !== 0) {
                            return retVal;
                        }
                    }
                }
                // "sort" comparator option
                return comparator.call(self, a, b);
            }
            // String option
            if (oj.StringUtils.isString(comparator)) {
                keyA = a.get(comparator);
                keyB = b.get(comparator);
                return oj.Collection._compareKeys(keyA, keyB, self['sortDirection']);            
            }
            return 0;
        };
    return oj.Collection._find(this._getModels(), model, comparator);
};


// Binary search and return the index at which model would be inserted into sorted modelArray
oj.Collection._find = function(modelArray, model, comparator) {
    function search(min, max) {
        var cid, id, mid;
        
        if (min > max) {
            return -1;
        }
        
        cid = model.GetCid();
        id = model.GetId();
        if (modelArray[min].Match(id, cid)) {
            return min;
        }
        if (modelArray[max].Match(id, cid)) {
            return max;
        }
        
        mid = Math.floor((max+min)/2);
        if (comparator(modelArray[mid], model) === -1) {
            return search(min+1, mid);
        }
        if (comparator(modelArray[mid], model) === 1) {
            return search(mid, max-1);
        }
        return mid;
    }
    
    return search(0, modelArray.length-1);
};

oj.Collection._compareKeys = function(keyA, keyB, sortDirection) {
    if (sortDirection === -1) {
        if (keyA < keyB) {        
            return 1;
        }
        if (keyB < keyA) {
            return -1;
        }
    }
    else {
        if (keyA > keyB) {        
            return 1;
        }
        if (keyB > keyA) {
            return -1;
        }
    }
    return 0;    
};


/**
 * @export
 * Add the given model to the front of the collection
 * @param {Object} m model to add to the beginning of the collection
 * @param {Object=} options see add
 * @return {Object} If this is a paging/virtual collection, this will return a jQuery promise that will be called when the
 *                  operation is done.  Otherwise undefined
 */
oj.Collection.prototype.unshift = function(m, options) {
    // Like an add but set 'at' to zero if not specified
    var opt = {};
    oj.CollectionUtils.copyInto(opt, options || {});
    if (!opt['at']) {
        opt['at'] = 0;
    }
    this._manageLRU(1);
    return this._addInternal(m, opt, false, opt['deferred']);
};

/**
 * @export
 * Remove the first model from the collection and return it
 * @param {Object=} options same as remove, plus: <p>
 *                          deferred: if true, return a promise as though this collection were virtual whether it is or not
 * @return {Object} model that was removed.  If this is a paging/virtual collection, this will return a jQuery promise
 *                  which will call its done function, passing the model value that was removed
 */
oj.Collection.prototype.shift = function(options) {
    var deferred = this._getDeferred(options);
    if (this._isVirtual() || deferred) {
        var self = this;
        return this.at(0, options).then(function (model) {             
            return self._removeInternal(model, 0, options);
        });
    }
    return this._removeInternal(this.at(0), 0, options);
};

/**
 * @export
 * Return an array of models found in the Collection, excepting the last n.
 * @param {number=} n number of models to leave off the returned array; defaults to 1
 * @return {Object} array of models from 0 to the length of the collection - n - 1
 */
oj.Collection.prototype.initial = function(n) {
    if (n === undefined) {
        n = 1;
    }
    
    var array = [], i;
    for (i = 0; i < this._getLength() - n; i=i+1) {
        array.push(this.at(i));
    }
    return array;
};

oj.Collection.prototype._getDeferred = function(options) {
   var opt = options || {};
   return opt['deferred'];
};

/**
 * @export
 * Return the last model in the Collection.  If n is passed in, then the last n models are returned as an array
 * Note that if the collection is virtual, and totalResults is not returned by the server, the results returned by last can be
 * difficult to predict.  They depend on the fetch sizes, last known offset of a fetch, etc.  If code is using a server that does not return
 * totalResults the use of last is not recommended.
 * @param {number=} n number of models to return.  Defaults to 1
 * @param {Object=} options deferred: if true, return a promise as though this collection were virtual whether it is or not
 * @return {Object|Array|null} array of n models from the end of the Collection.  If this is a paging/virtual collection,
 *                             this will return a jQuery promise which will call its done function, passing the array or single model
 */
oj.Collection.prototype.last = function(n, options) {
    var deferred = this._getDeferred(options);
    if (n === undefined) {
        n = 1;
    }
    
    if (n === 1) {
        var len = this._getModelsLength();
        if (len === 0) {
            len = n;
        }
        if (len > 0) {
            return this.at(len-1, deferred);
        }
        return null;
    }
    
    var array = [], i;
    var len = this._getLength();    
    if (deferred || this._isVirtual()) {
        // Loop using deferred
        var start = len-n;        
        
        // Handle edge or no totalResults cases
        if (start < 0) {
            start = 0;
        }
        if (len === 0) {
            // No totalresults, probably
            len = n;
        }

        return this._iterativeAt(start, len);
    }
                    
    for (i = len - n; i < len; i=i+1) {
        array.push(this.at(i));
    }
    return array;
};

// Loop calling at() in a deferred way and return a promise to be resolved when all the elements are sequentially fetched
oj.Collection.prototype._iterativeAt = function (start, end) {
    var array = [], i;
    var self = this;
    var doTask = function(index) {
                    var defer = $.Deferred();
                    self._deferredAt(index, null).done(function(model) {
                        array.push(model);
                        defer.resolve(index);
                    });
                    return defer.promise();
    };
                                
    var currentStep = doTask(start);
    var nextTask = function(j) {
                        return doTask(j+1);
    };
    
    for (i = start+1; i < end; i++) {
        currentStep = currentStep.then(nextTask);
    }
    return $.when(currentStep).then(function() {
                            return array;
                          });
};

oj.Collection.prototype._getDefaultFetchSize = function(n) {
    if (n === undefined || n === null) {
        return this[oj.Collection._FETCH_SIZE_PROP];
    }
    else {
        return n;
    }
};

oj.Collection.prototype._calculateNextStart = function() {
    var lastFetch = this['lastFetchCount'];
    if (lastFetch === undefined || lastFetch === null) {
        lastFetch = this[oj.Collection._FETCH_SIZE_PROP];
    }
    if (this['offset'] === undefined || this['offset'] === null) {
        // Assume zero offset (0+lastFetch)
        return lastFetch;
    }
    return this['offset'] + lastFetch;   
};

/**
 * @export
 * Fetch the next set of models from the server.
 * 
 * @param {number} n number of models to fetch.  If undefined or null, the collection will attempt to use the overall fetchSize property value
 * @param {Object=} options Options to control next<p>
 *                  success: a user callback called when the fetch has completed successfully. This makes the fetch an asynchronous process. The callback is called passing the Collection object, raw response, and the options argument.<p>
 *                  error: a user callback function called if the fetch fails. The callback is called passing the collection object, xhr, and options arguments.<p>
 * @return {Object} xhr object; null if nothing to fetch (the success callback will still be called)
 */
oj.Collection.prototype.next = function(n, options) {
    options = options || {};
    options[oj.Collection._FETCH_SIZE_PROP] = this._getDefaultFetchSize(n);
    
    var start = this._calculateNextStart();
    var length = this._getLength();
    if (length === 0 && options[oj.Collection._FETCH_SIZE_PROP] > 0) {
        // If we have a fetch size and we have no length let next() do a fetchSize fetch starting at zero to kick things off
        start = 0;
    } else if (start >= length) {
        // No op -- still call success because the items are already fetched.  
        var self = this;
        if (options['success']) {
            options['success'].call(oj.Model.GetContext(options, self), self, null, options);
        }
        
        return null;
    }
    options['startIndex'] = start;
    return this.fetch(options);
};

oj.Collection.prototype._calculatePrevStart = function(n) {
    if (this['offset'] === undefined || this['offset'] === null) {
        // Assume zero: we can't back up beyond that so if the offset wasn't set there's nothing to do
        return 0;
    }
    return this['offset'] - n;
};

/**
 * @export
 * Fetch the previous set of models from the server.
 * 
 * @param {number} n number of models to fetch.  If undefined or null, the collection will attempt to use the overall fetchSize property value
 * @param {Object=} options Options to control previous<p>
 *                  success: a user callback called when the fetch has completed successfully. This makes the fetch an asynchronous process. The callback is called passing the Collection object, raw response, and the options argument.<p>
 *                  error: a user callback function called if the fetch fails. The callback is called passing the collection object, xhr, and options arguments.<p>
 * @return {Object} xhr object, or null if there is nothing earlier to fetch (no fetch has happened or the last fetch started at 0).  The success callback will still be called
 */
oj.Collection.prototype.previous = function(n, options) {
    options = options || {};
    if (this['offset'] === 0) {
        // No op -- still call success (if we've fetched before--lastFetchCount is other than zero) because the items are already fetched.  
        var self = this;
        if (options['success'] && this['lastFetchCount']) {
            options['success'].call(oj.Model.GetContext(options, self), self, null, options);
        }
        
        return null;
    }
    options[oj.Collection._FETCH_SIZE_PROP] = this._getDefaultFetchSize(n);
    var start = this._calculatePrevStart(options[oj.Collection._FETCH_SIZE_PROP]);
    if (start < 0) {
        // Only fetch from 0 to the last fetch's starting point...
        options[oj.Collection._FETCH_SIZE_PROP] = this['offset'];
        start = 0;
    }
    options['startIndex'] = start;
    return this.fetch(options);
};


/**
 * @export
 * Set or change the number of models held at any one time
 * 
 * @param {number} n maximum number of models to keep at a time
 */
oj.Collection.prototype.setModelLimit = function(n) {
    this['modelLimit'] = n;
    // Clean out down to the new limit, if necessary
    this._manageLRU(0);
};

oj.Collection.prototype._getModelLimit = function() {
    return this['modelLimit'];
};

/**
 * Set or change the number of models to fetch with each server request
 * 
 * @param {number} n number of models to fetch with each request
 * @export
 */
oj.Collection.prototype.setFetchSize = function(n) {
    this[oj.Collection._FETCH_SIZE_PROP] = n;
};



/**
 * @export
 * Return the array of models found in the Collection starting with index n.
 * @param {number=} n index at which to start the returned array of models.  Defaults to 1.
 * @param {Object=} options deferred: if true, return a promise as though this collection were virtual whether it is or not
 * @return {Object} array of models from the Collection
 */
oj.Collection.prototype.rest = function(n, options) {
    var deferred = this._getDeferred(options);
    if (n === undefined) {
        n = 1;
    }
    
    var array = [], i;
    if (this._isVirtual() || deferred) {
        return this._iterativeAt(n, this._getLength());
    }
    
    for (i = n; i < this._getLength(); i=i+1) {
        array.push(this.at(i));
    }
    return array;
};

/**
 * Remove a model from the collection, if found.
 * @param {Object|Array} m Model object or array of Models to remove. 
 * @param {Object=} options silent: if set, do not fire a remove event 
 * @export
 */
oj.Collection.prototype.remove = function(m, options)
{
    options = options || {};
    var modArray = [], mod;
    
    if (m instanceof Array) {
        modArray = m;
    }
    else {
        modArray.push(m);
    }
    
    for (mod = modArray.length-1; mod >= 0; mod=mod-1) {
        this._removeInternal(modArray[mod], -1, options);
    }
};

oj.Collection.prototype._removeInternal = function(model, index, options) {
    options = options || {};
    var modInfo = index == -1 ? this._getInternal(model) : oj.Collection._getModinfo(index, model), 
        silent = options['silent'];
    
    index = modInfo.index;
    if (index > -1) {
        var mod = modInfo['m'];
        // only unset the collection setting if it's mine
        if (mod !== undefined && mod.GetCollection() === this) {
            mod.SetCollection(null);
        }
        this._spliceModels(index, 1);
        this._setLength();
        //if (!silent) {
            var opt = {};
            oj.CollectionUtils.copyInto(opt, options);
            opt['index'] = index;
            if (mod !== undefined) {
                mod.TriggerInternal(silent, oj.Events.EventType['REMOVE'], mod, this, opt);
            }
      //  }
        // Unlisten after event fired
        this._unlistenToModel(mod);        
    }
    return modInfo['m'];
};


oj.Collection.prototype._unlistenToModel = function(m) {
    if (m !== undefined) {
        m.off(null, null, this);
    }
};

oj.Collection.prototype._listenToModel = function(m) {
    m.OnInternal(oj.Events.EventType['ALL'], this._modelEvent, this, false, true);
    //m.on(oj.Events.EventType['ALL'], this._modelEvent, this);
};

// Handle model destroyed events via the all listener
oj.Collection.prototype._modelEvent = function(event, model, collection, options) {
    var args;
    
    if (event === oj.Events.EventType['DESTROY']) {
        this.remove(model);
    }
    
    // Don't process general events if we're not the target
    if (collection !== undefined && collection !== this) {
        return;
    }

    // Throw up to the collection
    args = Array.prototype.slice.call(arguments);
    var silent = options && options['silent'];
    this.TriggerInternal(silent, event, model, collection, options);
};

/**
 * Clear all data from the collection and refetch (if non-virtual).  If virtual, clear all data.  In both cases, fire a refresh event
 * if silent is not set
 * @param {Object=} options user options<p>
 *                          silent: if set, do not fire a refresh event<p>
 * @return {Object} promise object triggering done when complete (in case there is a fetch for non-virtual mode)
 * @export
 */
oj.Collection.prototype.refresh = function(options)
{
    options = options || {};
    
    var dfd = $.Deferred();
    if (!this._isVirtual()) {
        // Do a reset, with silent
        this.reset(null, {'silent':true});
        // Local: do a fetch to fill back up
        this.fetch({'success': function () {
                        var silent = options['silent'] !== undefined && options['silent'];
                        this.TriggerInternal(silent, oj.Events.EventType['REFRESH'], this, options, null);
                        dfd.resolve();                                    
                    }});
        return dfd;        
    }
    // Virtual
    var totalResults =  this['totalResults'];
    if (totalResults !== undefined) {
        this._setModels(new Array(totalResults));
        this._resetLRU();
    }
    var silent = options['silent'] !== undefined && options['silent'];
    this.TriggerInternal(silent, oj.Events.EventType['REFRESH'], this, options, null);
    return dfd.resolve();
};

/**
 * Remove and replace the collection's entire list of models with a new set of models, if provided. Otherwise, empty the collection.
 * @param {Object=} data Array of model objects or attribute/value pair objects with which to replace the collection's data. 
 * @param {Object=} options user options, passed to event, unless silent<p>
 *                          silent: if set, do not fire an add event<p>
 * @export
 */
oj.Collection.prototype.reset = function(data, options)
{
    var i;
    
    options = options || {};    
    options['previousModels'] = this._getModels();
    
    if (data === undefined || data == null || (data instanceof Array && data.length == 0)) {
        for (i = 0; i < this._getModelsLength(); i=i+1) {
            if (this._getModel(i)) {
                this._getModel(i).SetCollection(null);
            }
        }
        this._setModels([]);
        this._resetLRU();
    } else {
        this._setModels([]);
        this._resetLRU();
        
        // Parse collection
        if (options['parse']) {
            data = this['parse'](data);
        }
        
        if (data instanceof Array) {
            this._manageLRU(data.length);
            for (i = 0; i < data.length; i=i+1) {
                this._addInternal(data[i], options, true, false);
            }
        }
        else {
            this._manageLRU(1);
            this._addInternal(data, options, true, false);
        }
    }
    this._setLength();
    
    var silent = options['silent'] !== undefined && options['silent'];
    this.TriggerInternal(silent, oj.Events.EventType['RESET'], this, options, null);
};

/**
 * Return the model object found at the given index of the collection, or a promise object that will return the model to a function
 * in the done() call.
 * 
 * @param {number} index Index for which to return the model object. 
 * @param {Object=} options <p>
 *                  fetchSize: fetch size to use if the call needs to fetch more records from the server, if virtualized.  Overrides the overall fetchSize setting <p>
 *                  deferred: if true, return a deferred/promise object as described below.  If not specified, the return value will
 *                   be determined by whether or not the collection is virtual
 * @return {Object} Model object located at index. If index is out of range, returns null.  If this is a paging/virtual collection or
 *                  if deferred is specified and true, at will return a jQuery promise object which will call its done function,
 *                  passing the value at(index) 
 * @export
 */
oj.Collection.prototype.at = function(index, options)
{
    var deferred = this._getDeferred(options);
    return this._atInternal(index, options, false, deferred);
};

// Local indicates that only what's stored locally should be returned (if true)--no fetching
oj.Collection.prototype._atInternal = function(index, options, local, deferred) {
    if (index < 0 || this._overUpperLimit(index)) {
        return null;
    }
    if (!local && (this._isVirtual() || deferred)) {
        return this._deferredAt(index, options).promise();
    }
    return this._getModel(index);
};

oj.Collection.prototype._deferredAt = function(index, options) {
    var self = this;
    var dfd = $.Deferred();
    var resp = function () {
                    dfd.resolve(self._getModel(index));
               };
               
    // If it's virtual, we need to see if this item has been fetched or not: if not, we need to fetch it + fetchSize
    var model = this._getModel(index);
    if (model === undefined) {
        // Go fetch
        var opts = {};
        oj.CollectionUtils.copyInto(opts, options || {});
        opts['context'] = this;
        opts['startIndex'] = index;
        this._fetchInternal(opts, false).then(resp);
        return dfd;
    }
    return $.Deferred().resolve(model);               
};

/**
 * Return the first model object from the collection whose client ID is the given model cid
 * @param {string} clientId Client ID (see Model cid) for which to return the model object, if found. 
 * @return {Object} First model object in the collection where model.cid = clientId. If none are found, returns null.
 * 
 * @throws {Error} when called on a virtual/paging Collection if the item isn't found in memory
 * @export
 */
oj.Collection.prototype.getByCid = function(clientId)
{
    var i, model;
    for (i = 0; i < this._getModelsLength(); i=i+1)
    {
        model = this._getModel(i);
        if (model !== undefined && clientId === model['cid']) {
            return model;
        }
    }
    if (this._isVirtual()) {
        throw new Error("Not found locally and not supported by server for virtual collections");
    }
    return null;
};


/**
 * Return the first model object from the collection whose model id value is the given id or cid, or the id or cid from a passed in model
 * Note this method will not function as expected if the id or cid is not set
 * @param {Object|string} id ID, cid, or Model (see Model id or cid) for which to return the model object, if found. 
 * @param {Object=} options <p>
 *                  fetchSize: fetch size to use if the call needs to fetch more records from the server, if virtualized.  Overrides the overall fetchSize setting<p>
 *                  deferred: if true, return a promise as though this collection were virtual whether it is or not
 * @return {Object} First model object in the collection where model.id = id or model.cid = id. If none are found, returns null.
 *                  If deferred or virtual, return a promise passing the model when done
 * @export
 */
oj.Collection.prototype.get = function(id, options)
{
    var deferred = this._getDeferred(options);
    var internalGet = this._getInternal(id, options, deferred);
    if (internalGet) {
        // Is this a deferred object?
        if ($.isFunction(internalGet.promise)) {
            return internalGet.then(function(modInfo) {
                return modInfo['m'];
            });
        }
        if (this._isVirtual()) {
            return $.Deferred().resolve(internalGet['m']);
        }
        if (internalGet.hasOwnProperty('m')) {
            return internalGet['m'];
        }
    }
    return null;
};

oj.Collection.prototype._getLocal = function(id) {
    var internalGet = this._getLocalInternal(id);
    if (internalGet) {
        return internalGet['m'];
    }
    return null;
};

oj.Collection.prototype._getLocalInternal = function(id) {
    var i, cid = id;
    var len = this._getModelsLength(), model;
    if (id instanceof oj.Model) {
        // Get the cid
        cid = id.GetCid();
        // Get the id
        id = id.GetId();
    }
    else if (id !== undefined && id != null && id['id'] !== undefined) {
        id = id['id'];
    }
    for (i = 0; i < len; i=i+1)
    {        
        model = this._getModel(i);
        if (model !== undefined && model.Match(id, cid)) {
            return oj.Collection._getModinfo(i, model);
        }
    }
    return oj.Collection._getModinfo(-1, undefined);
};

/**
 * @private
 * @param {Object|null|string} id
 * @param {Object=} options
 * @param {boolean=} deferred
 * @param {boolean=} fillIn
 * @returns {Object}
 */
oj.Collection.prototype._getInternal = function(id, options, deferred, fillIn) {
    var i, cid = id;
    if (fillIn === undefined) {
        fillIn = false;
    }
    if (id instanceof oj.Model) {
        // Get the cid
        cid = id.GetCid();
        // Get the id
        id = id.GetId();
    }
    else if (id !== undefined && id != null && id['id'] !== undefined) {
        id = id['id'];
    }
    
    var model;
    for (i = 0; i < this._getModelsLength(); i=i+1)
    {        
        model = this._getModel(i);
        if (model !== undefined && model.Match(id, cid)) {
            var retObj =  oj.Collection._getModinfo(i, model);
            if (deferred) {
                return $.Deferred().resolve(retObj);
            }
            return retObj;
        }
    }
    
    // If virtual, might be undefined because it needs to be fetched
    if (this._isVirtual()) {
        // Try to fetch using start ID.  cid not supported
        if (id === undefined && cid !== undefined) {
            //throw new Error("cid not supported on virtual get by ID: only id supported");
            var dfd = $.Deferred();
            return dfd.resolve(oj.Collection._getModinfo(-1, undefined));
        }
        var dfd = $.Deferred();
        var self = this;
        var resp = function (resp) {
                        if (resp != null) {                            
                            var index = self._getOffset();
                            // Check that the model at index is the right one
                            var model = self._getModel(index);
                            if (model !== undefined && model.Match(id, cid)) {
                                dfd.resolve(oj.Collection._getModinfo(index, model));
                            }
                            else {
                                dfd.resolve(oj.Collection._getModinfo(-1, undefined));
                            }
                        }
                        else {
                            dfd.resolve(oj.Collection._getModinfo(-1, undefined));
                        }
                   };
               
        // Go fetch
        var opts = {};
        oj.CollectionUtils.copyInto(opts, options || {});
        opts['context'] = this;
        opts['startID'] = id;
        
        this._fetchInternal(opts, fillIn).then(resp);
        return dfd;        
    }
    
    var undefinedModInfo = oj.Collection._getModinfo(-1, undefined);
    if (deferred) {
        return $.Deferred().resolve(undefinedModInfo);
    }
    return undefinedModInfo;
};

oj.Collection._getModinfo = function(index, model) {
    return {index: index, 'm': model};
};

oj.Collection.prototype['parse'] = function (response) {
    var prop;
    
    // Try to interpret ADFbc like controls where a collection is hanging off a property
    if (response instanceof Array) {
        return response;
    }
    
    if (!response) {
        return response;
    }
    
    // See if any of the properties contain arrays
    for (prop in response) {
        if (response.hasOwnProperty(prop)) {
            if (response[prop] instanceof Array) {
                return response[prop];
            }
        }
    }
    return response;
};

/**
 * 
 * @export
 * Tell the Collection to try and ensure that the given range is available locally.  
 * 
 * @param {number} start starting index to make local
 * @param {number} count number of elements to make local
 * @return {Object} a promise Object that calls done upon completion
 */
oj.Collection.prototype.setRangeLocal = function(start, count) {
    var self = this;
    var dfd = $.Deferred();
    if (this.isRangeLocal(start, count)) {
        return $.Deferred().resolve();
    }
    
    var resp = function () {
                    dfd.resolve();
               };
               
    // Go fetch
    var limit = this._getMaxLength(start, count);   
    // Get the greater of the limit-start or fetchSize
    if (this[oj.Collection._FETCH_SIZE_PROP] && this[oj.Collection._FETCH_SIZE_PROP] > limit-start) {
        limit = this[oj.Collection._FETCH_SIZE_PROP] + start;
    }
    // Adjust for no totalResults
    if (!this._hasTotalResults() && limit < start + count) {
        // We shouldn't be limited by the size of the current storage
        limit = start+count;
    }
    var opts = this._isVirtual() ? {'context': this, 'startIndex': start, 'fetchSize': limit-start} : {'context': this};
    this._fetchInternal(opts, false).then(resp);
    return dfd;
};

oj.Collection.prototype._getMaxLength = function(start, count) {
    var len = this._getModelsLength();
    return start + count > len ? len : start + count;    
};

/**
 * @export
 * Determine if every element of the given range is filled in locally
 * 
 * @param {number} start starting index to make local
 * @param {number} count number of elements to make local
 * @return {boolean} true if all elements are local, false otherwise
 */
oj.Collection.prototype.isRangeLocal = function(start, count) {
    // Not virtual, local if there are any models
    if (!this._isVirtual()) {
        return this._getModelsLength() > 0;
    }
    var limit = this._getMaxLength(start, count);
    // Adjust for no totalResults
    if (!this._hasTotalResults() && limit < start + count) {
        // We don't know if it's local or not
        return false;
    }
    if (limit === 0) {
        // There nothing here
        return false;
    }
    for (var i = start; i < limit; i++) {
        if (this._getModel(i) === undefined) {
            return false;
        }
    }
    return true;
};

/**
 * Loads the Collection object from the data service URL. Performs a data "read."
 * @param {Object=} options Options to control fetch<p>
 *                  success: a user callback called when the fetch has completed successfully. This makes the fetch an asynchronous process. The callback is called passing the Collection object, raw response, and the fetch options argument.<p>
 *                  error: a user callback function called if the fetch fails. The callback is called passing the collection object, xhr, and options arguments.<p>
 *                  add: if set, new records retrieved from the data service will be added to those models already in the collection. If not set, the records retrieved will be passed to the reset() method, effectively replacing the previous contents of the collection with the new data.  Not supported for virtual/paging cases.<p>
 *                  startIndex: numeric index with which to start fetching Models from the server.  The page setting controls the number of Models to be fetched.  startID takes precedence over startIndex if both are specified.  If both are specified and startID isn't supported then startIndex will be used instead.<p>
 *                  startID: unique ID of the Model to start fetching from the server.  The page setting controls the number of Models to be fetched.  Note if this is not supported by the server then startID will be ignored.<p>
 *                  since: fetch records having a timestamp since the given UTC time
 *                  until: fetch records having a timestamp up to the given UTC time
 *                  fetchSize: use specified page size instead of collection's setting
 * @return {Object} xhr object
 * @export
 */
oj.Collection.prototype.fetch = function (options) {
    return this._fetchInternal(options, false);
};

// fillIn is used to indicate that this fetch is just the result of a get() or part of an add(), etc., when virtual
oj.Collection.prototype._fetchInternal = function(options, fillIn) {
    function doReset(collection, opt, fillIn) {
        if (!collection._isVirtual()) {
           if (!opt['add']) {
                // Reset with internal model
                collection.reset();
            }
        }
        else {
            if (!fillIn) {
               collection._resetModelsToFullLength();
            }
        }
    }
    
    var opt = options || {},
        success = opt['success'], 
        parsedModel, self;

    if (opt['parse'] === undefined) {
        opt['parse'] = true;
    }
    self = this;
    
    opt['success'] = function (response, status, xhr) {
        var i, modelInstance;
        // Pull any virtualization properties out of the response
        self._setPagingReturnValues(response, options);
        
        var data = self['parse'](response, options);
        var dataList = null;
                
        if (!opt['add'] && !self['model']) {
            dataList = (data instanceof Array) ? data : [data];  
            
             // Reset with no internal model
             if (!fillIn) {
                if (self._isVirtual()) {
                    // Insert into collection with no model
                    doReset(self, opt, fillIn);
                    
                    if (data) {
                       var addOpt = {}, offset = self._getOffset();
                       self._manageLRU(dataList.length);
                       for (i = 0; i < dataList.length; i=i+1) {
                           if (self._isVirtual()) {
                               addOpt = {'at': offset+i};
                           }
                           // Don't fire add events
                           addOpt['silent'] = true;
                           self._addInternal(dataList[i], addOpt, true, false);
                       }
                    }                    
                }
                else {
                    self.reset(data);             
                }
             }
         }
         else {             
             doReset(self, opt, fillIn);
             
             modelInstance = oj.Collection._createParsingModel(self);
             
             if (data) {
                dataList = (data instanceof Array) ? data : [data];  
                
                var addOpt = {}, offset = self._getOffset();
                self._manageLRU(dataList.length);
                for (i = 0; i < dataList.length; i=i+1) {
                    if (modelInstance && opt['parse']) {
                        parsedModel = modelInstance.parse(dataList[i]);
                    }
                    else {
                        parsedModel = dataList[i];
                    }
                                        
                    if (self._isVirtual()) {
                        addOpt = {'at': offset+i};
                    }
                    // Don't fire add events
                    addOpt['silent'] = true;
                    self._addInternal(parsedModel, addOpt, true, false);
                }
             }
         }
         if (self._isVirtual()) {
             // Take in the number of records actually fetched
             if (dataList) {
                 self['lastFetchCount'] = dataList.length;
             }
         }
         
         self.TriggerInternal(false, oj.Events.EventType['SYNC'], self, response, opt);
         if (success) {
              success.call(oj.Model.GetContext(options, self), self, response, opt);
         }
     };
     return this._fetchCall(opt);
};

// Used in virtualization to conduct server-based searches: returns list of fetched models via a promise but does not add them to the collection
// model list
oj.Collection.prototype._fetchOnly = function(options) {
    var opt = options || {},
        success = opt['success'], 
        parsedModel, self;

    if (opt['parse'] === undefined) {
        opt['parse'] = true;
    }
    self = this;
    
    opt['success'] = function (response, status, xhr) {
        var i, modelInstance;
        
        var data = self['parse'](response, options), dataList = null, fetchedModels = [];
                
        if (!opt['add'] && !self['model']) {
            dataList = (data instanceof Array) ? data : [data];              
         }
         else {
             modelInstance = oj.Collection._createParsingModel(self);
             
             if (data) {
                dataList = (data instanceof Array) ? data : [data];  
                
                for (i = 0; i < dataList.length; i=i+1) {
                    if (modelInstance && opt['parse']) {
                        parsedModel = modelInstance.parse(dataList[i]);
                    }
                    else {
                        parsedModel = dataList[i];
                    }
                    fetchedModels.push(self._newModel(parsedModel));
                }
             }
         }
         
         self.TriggerInternal(false, oj.Events.EventType['SYNC'], self, response, opt);
         if (success) {
              success.call(oj.Model.GetContext(options, self), self, fetchedModels, opt);
         }
     };
     return this._fetchCall(opt);
};

oj.Collection._createParsingModel = function(collection) {
    if (collection['model']) {
        // Create model instance to use for parsing
        if (oj.Model.IsFunction(collection['model'])) {
           return new collection['model']();
        }
        return new collection['model'].constructor();
    }
};

oj.Collection.prototype._fetchCall = function(opt) {
     try {
        return oj.Model._internalSync("read", this, opt);
     }
     catch (e) {
         // Some kind of error: trigger an error event
        this.TriggerInternal(false, oj.Events.EventType['ERROR'], this, null, opt);
        throw e;
     }
 };

oj.Collection.prototype._resetModelsToFullLength = function() {
    var totalResults =  this['totalResults'];
    if (totalResults !== undefined && this._getModelsLength() !== totalResults) {
        // Make sure to set up the array if the length changes (i.e., from 0 to totalResults--need to preallocate)
        this._setModels(new Array(totalResults));
        this._resetLRU();
        return true;
    }
    return false;
};

oj.Collection.prototype._getFetchSize = function(options) {
    options = options || {};
    return options[oj.Collection._FETCH_SIZE_PROP] || this[oj.Collection._FETCH_SIZE_PROP];
};

// Are there more results on the server?
oj.Collection.prototype._hasMore = function() {
    return this['hasMore'] !== undefined && this['hasMore'];
};

// Are we doing virtualization/paging?
oj.Collection.prototype._isVirtual = function() {
    return this._getFetchSize(null) > -1;
};

oj.Collection.prototype._getReturnProperty = function(customObj, response, property, optionValue, defaultValue) {
    var value = parseInt(oj.Collection._getProp(customObj, response, property), 10);
    if (value === undefined || value === null || isNaN(value)) {
        // use fetchsize            
        return optionValue ? optionValue : defaultValue;
    }
    return value;
};

// Parse out some of the paging return values we might expect in a virtual response
oj.Collection.prototype._setPagingReturnValues = function(response, options) {
    var customObj = {};
    // See if there's a custom call out
    if (this['customPagingOptions']) {
        customObj = this['customPagingOptions'].call(this, response);
        if (!customObj) {
            customObj = {};
        }
    }
    // What limit was actually used to generate this response?
    options = options || {};
    this['lastFetchSize'] = this._getReturnProperty(customObj, response, 'limit', options['fetchSize'], this['fetchSize']);
    
/*    this['limit'] = parseInt(oj.Collection._getProp(customObj, response, 'limit'), 10);
    if (this['limit'] === undefined || this['limit'] === null || isNaN(this['limit'])) {
        // use fetchsize            
        this['limit'] = options['fetchSize'] ? options['fetchSize'] : this['fetchSize'];
    }*/
    // What offset was actually used to generate this response?
    this['offset'] = this._getReturnProperty(customObj, response, 'offset', options['startIndex'], 0);
/*    this['offset'] = parseInt(oj.Collection._getProp(customObj, response, 'offset'), 10);
    if (this['offset'] === undefined || this['offset'] === null || isNaN(this['offset'])) {
        this['offset'] = options['startIndex'] ? options['startIndex'] : 0;
    }*/
    // How many records actually came back?
    this['lastFetchCount'] = this._getReturnProperty(customObj, response, 'count', this['lastFetchCount'], this['lastFetchCount']);
    
    // What is the total number of records possible for this collection?
    this['totalResults'] = this._getReturnProperty(customObj, response, 'totalResults', this['totalResults'], this['totalResults']);
    
    // Is there more?
    this['hasMore'] = this._getHasMore(oj.Collection._getProp(customObj, response, 'hasMore'), 
                                       this['offset'], this['lastFetchSize'], this['totalResults']);
                                       
    // Was fetchSize set?  If not, set it to limit
    if (!this._isVirtual() && this['lastFetchSize']) {
        this.setFetchSize(this['lastFetchSize']);
    }
};

oj.Collection.prototype._getHasMore = function(hasMore, offset, lastFetchSize, totalResults) {
    if (hasMore && hasMore !== undefined) {
        return hasMore;        
    }
    // Not there: figure it out.  It's true unless we're walking off the end
    return (offset + lastFetchSize > totalResults) ? false : true;
};

oj.Collection._getProp = function(custom, response, prop) {
    return custom[prop] ? custom[prop] : (response ? response[prop] : undefined);
};

oj.Collection.prototype._getOffset = function() {
    return (this['offset'] !== undefined ? this['offset'] : 0);
};

/**
 * Creates a new model, saves it to the data service, and adds it on to the collection.
 * @param {Object=} attributes Set of attribute/value pairs with which to initialize the new model object, or a new Model object
 * @param {Object=} options Options to control save (see oj.Model.save).  Plus:<p>
 *                          deferred: if true, return a promise as though this collection were virtual whether it is or not
 * @return {Object|boolean} new model or false if validation failed.  If virtual, returns a promise that calls with the new model
 * @export
 */
oj.Collection.prototype.create = function (attributes, options) {
    function doSave(collection, newModel, validate, opt) {
        if (newModel.save(attributes instanceof oj.Model ? null : attributes, opt) === false) {
            // Invalid
            options['validationError'] = newModel['validationError'];
            collection.TriggerInternal(false, oj.Events.EventType['INVALID'], collection, newModel['validationError'], opt);
            if (validate) {
                collection._unlistenToModel(newModel);
                collection.remove(newModel);
                return false;
            }
        }
        return newModel;
    }
    
    var deferred = this._getDeferred(options);
    options = options || {};
    // Save the user's context and callback, if any
    var newModel = this._newModel(attributes, options),
        callback = options['success'],
        context = options['context'], validate = options['validate'];
    options['context'] = this;
    options['success'] = function(model, resp, options) {
            if (callback) {
                callback.call(context != null ? context : this, model, resp, options);
            }
        };
        
    // Did validation pass?
    if (newModel == null) {       
        return false;
    }
    
    // Force a save in case user has set value of idAttribute on the new Model
    options['forceNew'] = newModel.GetId() != null;
    
    newModel.SetCollection(this);
    var self = this;
    if (deferred || this._isVirtual()) {
        var defer = $.Deferred();
        this.add(newModel, {'merge':true, 'deferred':true})
                .done(function() {
                        options['success'] = function(model, resp, options) {
                                if (callback) {
                                    callback.call(context != null ? context : this, model, resp, options);
                                }
                                defer.resolve(model);
                            };
                            var model = doSave(self, newModel, validate, options);
                            // make sure that success is called first if successful...promise resolved
                            // second
                            if (!model) {
                                // Failed: make sure we resolve the promise.  Otherwise promise will
                                // be resolved by success call, above
                                defer.resolve(model);
                            }
                        });
         return defer.promise();           
    }
    
    this.add(newModel, {merge:true});
    return doSave(this, newModel, validate, options);
};

/**
 * @export
 * Return a list of all the values of attr found in the Collection
 * 
 * @param {string} attr attribute to return
 * @return {Object} array of values of attr
 * 
 * @throws {Error} when called on a virtual/paging Collection
 */
oj.Collection.prototype.pluck = function(attr) {
    var arr = [], i;
    
    this._throwErrIfVirtual("pluck");
    
    for (i = 0; i < this._getLength(); i=i+1) {
        arr.push(this.at(i).get(attr));
    }
    return arr;
};

/**
 * @export
 * Return an array of models that contain the given attribute/value pairs.  Note that this function, along with findWhere, expects server-resolved
 * filtering to return *all* models that meet the criteria, even in virtual cases.  The fetchSize will be set to the value of totalResults for this call to indicate that
 * all should be returned.
 * 
 * @param {Object|Array} attrs attribute/value pairs to find.  The attribute/value pairs are ANDed together.  If attrs is an array of attribute/value pairs, then these are ORed together
 *                             If the value is an object (or an array of objects, in which case the single attribute must meet all of the value/comparator conditions), then if it has both 'value' and 'comparator' parameters these will be interpreted as
 *                             expressions needing custom commparisons.  The comparator value may either be a string or a comparator callback function.
 *                             Strings are only valid where the filtering is sent back to the data service (virtual collections).  In the case of a comparator
 *                             function, the function always takes the signature function(model, attr, value), and for non-virtual collections, is called for each 
 *                             Model in the collection with the associated attribute and value.  The function should return true if the model meets the attribute/value
 *                             condition, and false if not.  For cases where the filtering is to be done on the server, the function will be called once per attr/value pair
 *                             with a null model, and the function should return the string to pass as the comparison in the expression for the filtering parameter
 *                             in the URL sent back to the server.  Note that the array of value object case is really only meaningful for server-evaluated filters where
 *                             a complex construction on a single attribute might be needed (e.g., x>v1 && x <=v2)
 *                             For example:<p>
 *                             {Dept:53,Name:'Smith'}<p>
 *                             will return an array of models that have a Dept=53 and a Name=Smith, or, for server-filtered
 *                             collections, a ?q=Dept=53+Name=Smith parameter will be sent with the URL.<p>
 *                             [{Dept:53},{Dept:90}]<p>
 *                             will return all models that have a Dept of 53 or 90.  Or, ?q=Dept=53,Dept=90 will be sent to the server.<p>
 *                             {Dept:{value:53,comparator:function(model, attr, value) { return model.get(attr) !== value;}}}<p>
 *                             will return all models that do not have a Dept of 53.<p>
 *                             {Dept:{value:53,comparator:'<>'}}<p>
 *                             For server-evaluated filters, a parameter ?q=Dept<>53 will be sent with the URL.  This form is an
 *                             error on locally-evaluated colleection filters<p>
 *                             {Dept:{value:53,comparator:function(model, attr, value) { return "<>";}}}<p>
 *                             expresses the same thing for server-evaluated filters<p>
 *                             {Dept:[{value:53,comparator:'<'},{value:90,comparator:'<'}]}<p>
 *                             For server-evaluated filters, a parameter ?q=Dept>53+Dept<93 will be sent to the server<p>
 * @param {Object=} options deferred: if true, return a promise as though this collection were virtual whether it is or not<p>
 * 
 * @return {Object} array of models.  If virtual or deferred, a promise that calls with the returned array from the server
 */
oj.Collection.prototype.where = function(attrs, options) {
    options = options || {};
    var deferred = this._getDeferred(options);
    if (this._isVirtual()) {
        var defer = $.Deferred();
        var success = function(collection, fetchedModels, options) {
            defer.resolve(fetchedModels);
        };
        // Send the attributes for a server-based filter; also indicate that we need *all* the attributes.  In the standard
        // REST URL construction this is accomplished by leaving off fetchSize/start indices, etc.
        var opt = {'query':attrs,  
                   'all': true,
                   'success': success};
        this._fetchOnly(opt);
        return defer.promise();
    }
    
    var arr = [], i, m;
    for (i = 0; i < this._getLength(); i=i+1) {
        m = this.at(i);
        if (m.Contains(attrs)) {
            arr.push(m);
        }
    }
    if (deferred) {
        return $.Deferred().resolve(arr);
    }
    return arr;
};

/**
 * @export
 * Return a collection only containing models that contain the given attribute/value pairs
 * Note that this returns a non-virtual collection with all the models returned by the server
 * even if the original collection is virtual.  Virtual collections doing filtering on the server should return all models that meet
 * the critera.  @see (@link where)
 * @see (@link where) for complete documentation of the parameters
 *
 * @return {Object} A collection, or if virtual or deferred, a promise that calls with the Collection
 */
oj.Collection.prototype.whereToCollection = function(attrs, options) {
    options = options || {};
    var deferred = this._getDeferred(options);
    var self = this;
    if (this._isVirtual() || deferred) {
        var defer = $.Deferred();
        this.where(attrs, options).done(function (models) {
                                            var collection = self._makeNewCollection(models);
                                            defer.resolve(collection);
                                        });
        return defer.promise();
    }
    else {
        var models = this.where(attrs, options);
        var newCollection = this._makeNewCollection(models);
        newCollection[oj.Collection._FETCH_SIZE_PROP] = -1;
        newCollection._setLength();
        return newCollection;
    }
};
    
oj.Collection.prototype._makeNewCollection = function(models) {
    var collection = this._cloneInternal(false);
    collection._setModels(models);
    collection._resetLRU();
    collection._setLength();
    return collection;
};

oj.Collection.prototype._throwErrIfVirtual = function(func) {
    if (this._isVirtual()) {
        throw new Error(func + " not valid on a virtual Collection");
    }
};

/**
 * @export
 * Return an array whose entries are determined by the passed-in iterator function.  The iterator will be called for each model in the collection
 * 
 * @param {function(Object)} iterator function to determine the mapped value for each model
 * @param {Object=} context context with which to make the calls on iterator
 * @returns {Array} array of values determined by calls to iterator for each model
 * 
 * @throws {Error} when called on a virtual/paging Collection
 */
oj.Collection.prototype.map = function(iterator, context) {
    var retArr = [], value, i;
    
    this._throwErrIfVirtual("map");
    
    for (i = 0; i < this._getModelsLength(); i=i+1) {
        value = iterator.call(context || this, this._getModel(i));
        retArr.push(value);
    }    
    return retArr;
};

/**
 * @export
 * Iterates over the models in the collection and calls iterator
 * 
 * @param {function(Object)} iterator function to call for each model
 * @param {Object=} context context with which to make the calls on iterator
 * 
 * @throws {Error} when called on a virtual/paging Collection
 */
oj.Collection.prototype.each = function(iterator, context) {
    this._throwErrIfVirtual("each");
    
    this._getModels().forEach(iterator, context);
};

/**
 * @export
 * Return the length of the collection
 * @returns {number} length of the collection
 */
oj.Collection.prototype.size = function() { 
    return this._getLength();
};

/**
 * @export
 * Return the models sorted determined by the iterator function (or property, if a string value)
 * 
 * @param {String|function(Object)} iterator method called or property used to get the sorting value
 * @param {Object=} context context with which to make the calls on iterator
 * @returns {Object} models sorted using iterator
 */
oj.Collection.prototype.sortBy = function(iterator, context) {
    var i, retArr = [], self;

    this._throwErrIfVirtual("sortBy");
    
    for (i = 0; i < this._getModelsLength(); i=i+1) {
        retArr.push(this._getModel(i));
    }
    self = this;
    
    retArr.sort(function(a, b) {
            var keyA, keyB;

            if (oj.Model.IsFunction(iterator)) {        
                // "sortBy" comparator option
                keyA = iterator.call(context || self, a);
                keyB = iterator.call(context || self, b);
                return oj.Collection._compareKeys(keyA, keyB, self['sortDirection']);
            }
            // String option
            keyA = a.get(iterator);
            keyB = b.get(iterator);
            return oj.Collection._compareKeys(keyA, keyB, self['sortDirection']);            
        });

    return retArr;
};

/**
 * @export
 * Return the collection with models grouped into sets determined by the iterator function (or property, if a string value)
 * 
 * @param {String|function(Object)} iterator method called or property used to get the group key
 * @param {Object=} context context with which to make the calls on iterator
 * @returns {Object} models grouped into sets
 * 
 * @throws {Error} when called on a virtual/paging Collection
 */
oj.Collection.prototype.groupBy = function(iterator, context) {
    var i, retObj = {}, groupVal;
    
    this._throwErrIfVirtual("groupBy");
    
    for (i = 0; i < this._getModelsLength(); i=i+1) {
        if (oj.Model.IsFunction(iterator)) {
            groupVal = iterator.call(context || this, this._getModel(i));
        }
        else {
            groupVal = this._getModel(i).get(iterator);
        }
        if (retObj[groupVal] === undefined) {
            retObj[groupVal] = [];
        }
        retObj[groupVal].push(this._getModel(i));
    }
    return retObj;    
};

/**
 * @export
 * Return the "minimum" model in the collection, as determined by calls to iterator.  The return value of iterator (called with a model passed in) will be compared against the current minimum
 * 
 * @param {function(Object)} iterator function to determine a model's value for checking for the minimum
 * @param {Object=} context context with which to make the calls on iterator
 * @returns {Object} "Minimum" model in the collection
 * 
 * @throws {Error} when called on a virtual/paging Collection
 */
oj.Collection.prototype.min = function(iterator, context) { 
    var i, minModel = {}, minModelValue, currValue;
    
    this._throwErrIfVirtual("min");
    
    if (this._getModelsLength() == 0) {
        return null;        
    }
    // Get vals started
    minModel = this._getModel(0);
    minModelValue = iterator.call(context || this, this._getModel(0));
    
    for (i = 1; i < this._getModelsLength(); i=i+1) {
        currValue = iterator.call(context || this, this._getModel(i));
        if (currValue < minModelValue) {
            minModel = this._getModel(i);
            minModelValue = currValue;
        }
    }
    return minModel;
};

/**
 * @export
 * Return the "maximum" model in the collection, as determined by calls to iterator.  The return value of iterator (called with a model passed in) will be compared against the current maximum
 * 
 * @param {function(Object)} iterator function to determine a model's value for checking for the maximum
 * @param {Object=} context context with which to make the calls on iterator
 * @returns {Object} "Maximum" model in the collection
 * 
 * @throws {Error} when called on a virtual/paging Collection
 */
oj.Collection.prototype.max = function(iterator, context) { 
    var i, maxModel = {}, maxModelValue, currValue;
    
    this._throwErrIfVirtual("max");
    if (this._getModelsLength() == 0) {
        return null;        
    }
    // Get vals started
    maxModel = this._getModel(0);
    maxModelValue = iterator.call(context, this._getModel(0));
    
    for (i = 1; i < this._getModelsLength(); i=i+1) {
        currValue = iterator.call(context || this, this._getModel(i));
        if (currValue > maxModelValue) {
            maxModel = this._getModel(i);
            maxModelValue = currValue;
        }
    }
    return maxModel;
};

/**
 * @export
 * Return an array of models that cause iterator to return true
 * 
 * @param {function(Object)} iterator function to determine if a model should be included or not
 * @param {Object=} context context with which to make the calls on iterator
 * @returns {Array} array of models that cause iterator to return true
 * 
 * @throws {Error} when called on a virtual/paging Collection
 */
oj.Collection.prototype.filter = function(iterator, context) {
    var i, retArr = [];
    
    this._throwErrIfVirtual("filter");
    
    for (i = 0; i < this._getModelsLength(); i=i+1) {
        if (iterator.call(context || this, this._getModel(i))) {
            retArr.push(this._getModel(i));
        }
    }
    return retArr;
};

/**
 * @export
 * Return an array of models minus those passed in as arguments
 * @param {...Object} var_args models models to remove from the returned array
 * @returns {Array} array of models from the collection minus those passed in to models
 * 
 * @throws {Error} when called on a virtual/paging Collection
 */
oj.Collection.prototype.without = function(var_args) {
    var retArr = [], i, j, id, cid, add;
    
    this._throwErrIfVirtual("without");
    
    if (arguments) {
        for (i = 0; i < this._getModelsLength(); i=i+1) {
            add = true;
            for (j = 0; j < arguments.length; j=j+1) {
                // Get the cid
                cid = arguments[j].GetCid();
                // Get the id
                id = arguments[j].GetId();                
                if (this._getModel(i).Match(arguments[j].GetId(), arguments[j].GetCid())) {
                    add = false;
                    break;
                }
            }
            if (add) {
                retArr.push(this._getModel(i));
            }
        }
        return retArr;
    }
    
    // Nothing to remove if nothing passed in
    return this._getModels();
};

/**
 * @export
 * Determine if the collection has any models
 * 
 * @returns {boolean} true if collection is empty
 */
oj.Collection.prototype.isEmpty = function() {
    return this._getLength() === 0;
};

/**
 * @export
 * Return true if any of the models in the collection pass the test in the iterator function
 * 
 * @param {function(Object)} iterator function to determine if a model 'passes'
 * @param {Object=} context context with which to make the calls on iterator
 * @returns {boolean} true if any of the models cause the iterator function to return true
 * 
 * @throws {Error} when called on a virtual/paging Collection
 */
oj.Collection.prototype.any = function(iterator, context) {
    var i;
    
    this._throwErrIfVirtual("any");
    
    for (i = 0; i < this._getModelsLength(); i=i+1) {
        if (iterator.call(context || this, this._getModel(i))) {
            return true;
        }
    }        
    return false;
};

/**
 * @export
 * A version of where that only returns the first element found
 * 
 * @param {Object|Array} attrs attribute/value pairs to find.  
 * @see (@link where) for more details and examples.
 * @param {Object=} options deferred: if true, return a promise as though this collection were virtual whether it is or not<p>
 * 
 * @returns {Object} first model found with the attribute/value pairs.  If virtual or deferred, a promise that calls with the returned array from the server
 */
oj.Collection.prototype.findWhere = function(attrs, options) {
    var deferred = this._getDeferred(options);
    if (this._isVirtual() || deferred) {
        var defer = $.Deferred();
        this.where(attrs, options).done(function(modelList) {
                                                    if (modelList && modelList.length > 0) {
                                                        defer.resolve(modelList[0]);
                                                    }
                                                    defer.resolve(null);
                                                });
        return defer.promise();
    }
    
    var arr = this.where(attrs);
    if (arr.length > 0) {
        return arr[0];
    }
    return null;
};

/**
 * @export
 * Return a shallow copy of the models from start to end (if specified), in an array
 * 
 * @param {number} start model to start the return array with
 * @param {number=} end model to end the return array with, if specified (not inclusive).  If not, returns to the end of the collection
 * @param {Object=} options deferred: if true, return a promise as though this collection were virtual whether it is or not
 * @return {Array} array of model objects from start to end, or a promise that calls specifying the returned array when done
 */
oj.Collection.prototype.slice = function(start, end, options) {
    var deferred = this._getDeferred(options);
    var ret = [], i;
    if (end === undefined) {
        if (this._isVirtual && !this._hasTotalResults()) {
            // We can't set the end: throw an error
            throw new Error("End must be set for virtual collections with no totalResults");
        }
        end = this._getModelsLength();
    }

    if (deferred || this._isVirtual()) {
        // Loop using deferred
        return this._iterativeAt(start, end);
    }

    for (i = start; i < end; i=i+1) {
        ret.push(this._getModel(i));
    }
    return ret;
};

/**
 * @export
 * Update the collection with a model or models.  Depending on the options, new models will be added, existing models will be merged, and unspecified models will be removed.
 * The model cid is used to determine whether a given model exists or not.
 * 
 * @param {Object} models an array of or single model with which to update the Collection
 * @param {Object=} options add:false stops the addition of new models<p>
 *                          remove: false stops the removal of missing models<p>
 *                          merge:false prevents the merging of existing models<p>
 *                          silent: true prevents notifications on adds, removes, etc.<p>
 *                          deferred: if true, return a promise as though this collection were virtual whether it is or not
 * 
 * @returns {Object|null} if deferred or virtual, return a promise when the set has completed
*/
oj.Collection.prototype.set = function(models, options) {
    var deferred = this._getDeferred(options);
    return this._setInternal(models, options, deferred);
};

oj.Collection._removeAfterSet = function(collection, remove, foundModels, options) {
    // Now remove models that weren't found
    // get an array of all models
    if (remove) {    
        var i;
        for (i = collection._getModelsLength()-1; i >= 0; i=i-1) {
            if (foundModels.indexOf(i) == -1) {
                //collection.remove(allModels[i], options);
                collection._removeInternal(collection._getModel(i), i, options);
            }
        }
    }       
};

oj.Collection.prototype._setInternal = function(models, options, deferred) {
    // Determine if any of the options are set
    options = options || {};
    var add = options['add'] === undefined ? true : options['add'],
        remove = options['remove'] === undefined ? true : options['remove'],
        merge = options['merge'] === undefined ? true : options['merge'],
        parse = options['parse'],
        foundModels = [], currModel = null, i, modelList;        

    if (parse) {
        models = this['parse'](models);
    }

    modelList = oj.Model.IsArray(models) ? models : [models];

    if (this._isVirtual() || deferred) {
        return this._deferredSet(modelList, options, remove, add, merge);
    }
    
    // Go through the passed in models and determine what to do
    for (i = 0; i < modelList.length; i=i+1) {
        currModel = this._updateModel(this._newModel(modelList[i], options), add, merge, deferred);
        if (currModel !== -1) {
            foundModels.push(currModel);
        }
    }
        
    oj.Collection._removeAfterSet(this, remove, foundModels, options);
};

// Handle the updates/removes on virtual collections
oj.Collection.prototype._deferredSet = function(modelList, options, remove, add, merge) {
    var foundModels = [], i;
      
    // Go through the passed in models and determine what to do
    var self = this;
    var doTask = function(index) {
                    var defer = $.Deferred();
                    self._updateModel(self._newModel(modelList[index], options), add, merge, true).done(function (currModel) {
                                        if (currModel !== -1) {
                                            foundModels.push(currModel);
                                        }
                                        defer.resolve(index);                                        
                                    });
                    return defer.promise();
    };
    
    var currentStep = doTask(0);
    var nextTask = function(j) {
                        return doTask(j+1);
    };
    
    for (i = 1; i < modelList.length; i=i+1) {
       currentStep = currentStep.then(nextTask);
    }
    return $.when(currentStep).then(function() {
        oj.Collection._removeAfterSet(self, remove, foundModels, options);
    });
};


// Return the index of the given model after updating it, if it was found.  Otherwise it is added and a -1 is returned
oj.Collection.prototype._updateModel = function(model, add, merge, deferred) {
    function update(collection, found, deferred) {
        var index = found ? found.index : -1;
        var foundModel = found ? found['m'] : null;

        if (foundModel) {
            if (merge) {
                // Do merge if not overridden
                var opt = {'merge':merge};
                if (deferred) {
                    var defer = $.Deferred();
                    
                    //collection.add(model, opt, true).done(function() {
                    collection._addInternal(model, opt, false, true).done(function() {
                        defer.resolve(index);
                    });
                    return defer.promise();
                }
                collection.add(model, opt);
            }
        }
        else if (add) {
            if (deferred) {
                var defer = $.Deferred();
                collection.add(model, {'deferred':true}).done(function() {
                    //return collection._getLength()-1;
                    defer.resolve(collection._getLength()-1);
                });
                return defer.promise();
            }
            collection.add(model);
            index = collection._getLength()-1;
        }
        return index;
    }
    
    // Check to see if this model is in the collection
    if (deferred || this._isVirtual()) {
        var self = this;
        
        var defer = $.Deferred();
        this._getInternal(model, null, deferred).done(function(found) {
            
            update(self, found, true).done(function (index) {
                defer.resolve(index);
            });
        });
        return defer.promise();
    }
    
    var found = this._getInternal(model);
    return update(this, found, false);
};

/**
 * Return a copy of the Collection's list of current attribute/value pairs.
 * @return {Object} a copy of all the Collection's current sets of attribute/value pairs.
 * 
 * @throws {Error} when called on a virtual/paging Collection
 * @export
 */
oj.Collection.prototype.toJSON = function() {
    var retArr = [], i;
    
    this._throwErrIfVirtual("toJSON");
    
    for (i = 0; i < this._getModelsLength(); i=i+1) {
        retArr.push(this._getModel(i).toJSON());
    }
    return retArr;
};

/**
 * Return the first model object in the collection, or an array of the first n model objects from the collection.
 * @param {number=} n Number of model objects to include in the array, starting with the first. 
 * @param {Object=} options deferred: if true, return a promise as though this collection were virtual whether it is or not
 * @return {Array|null} An array of n model objects found in the collection, starting with the first. If n is not included,
 *                      returns all of the collection's models as an array.  Returns a promise that returns the array or model if deferred or virtual
 * @export
 */
oj.Collection.prototype.first = function(n, options) {
    var deferred = this._getDeferred(options);
    var elementCount = this._getLength(),
        retArray = [], 
        i;

    if (n) {
        elementCount = n;
    }
    else {
        n = 1;
    }
    
    var virtual = this._isVirtual() || deferred;
    
    if (n === 1) {
        if (virtual) {
            return this._deferredAt(0, null).promise();
        }
        
        if (this._getModelsLength() > 0) {
            return this._getModel(0);
        }
        return null;
    }
   
    if (elementCount > this._getModelsLength()) {
        if (this._isVirtual() && !this._hasTotalResults()) {
            // Virtual, no total results: don't restrict elementCount
        }
        else {
            elementCount = this._getModelsLength();
        }
    }
    
    if (virtual) {
        return this._iterativeAt(0, elementCount);
    }
    
    for (i = 0; i < elementCount; i=i+1) {
        retArray.push(this._getModel(i));
    }
    return retArray;
};

/**
 * Return the array index location of the given model object.
 * @param {Object} model Model object to locate 
 * @param {Object=} options deferred: if true, return a promise as though this collection were virtual whether it is or not

 * @return {number} The index of the given model object, or a promise that will call with the index when complete.
 *                  If the object is not found, returns -1.
 * @export
 */
oj.Collection.prototype.indexOf = function(model, options) {
    var location;
    var deferred = this._getDeferred(options);
    
    if (this._isVirtual() || deferred) {
        return this._getInternal(model, null, true).then(function(loc) {
                                                            return loc.index;
                                                        });
    }
    location = this._getInternal(model);
    
    return location.index;
};

// Only look on models already fetched
oj.Collection.prototype._localIndexOf = function(model) {
    var location = this._getLocalInternal(model);
    
    return location !== undefined ? location.index : -1;
};

/**
 * @export
 * Remove the last model in the collection and return it
 * @param {Object=} options silent: if set, do not fire a remove event <p>
 *                  deferred: if true, return a promise as though this collection were virtual whether it is or not
 * @return {Object} the model that was removed, or a promise that will call with the model that was removed when complete
 */
oj.Collection.prototype.pop = function(options) {
    var deferred = this._getDeferred(options);
    if (this._isVirtual() || deferred) {
        var self = this;
        return this.at(this._getLength()-1, {'deferred':deferred}).then(function (model) {             
            self.remove(model, options);
            return model;
        });        
    }
    
    var m = this.at(this._getLength()-1);
    this.remove(m, options);
    return m;
};

/**
 * @export
 * Add the given model to the end of the Collection
 * @param {Object} m model to add to the end of the Collection
 * @param {Object=} options same options as add<p>
 *                  deferred: if true, return a promise as though this collection were virtual whether it is or not
 * @return {Object} if deferred or virtual, a promise that will be called when the function is done.  Otherwise undefined
 */
oj.Collection.prototype.push = function(m, options) {
    var deferred = this._getDeferred(options);
    this._manageLRU(1);
    return this._addInternal(m, options, false, deferred);
};

/**
 * @export
 * Returns the index of the last location of the given model.  Not supported in virtual cases.
 * @param {Object} model Model object to locate
 * @param {number=} fromIndex optionally start search at the given index
 * @return {number} The last index of the given model object.  If the object is not found, returns -1.
 */
oj.Collection.prototype.lastIndexOf = function(model, fromIndex) {
    var i;
    
    this._throwErrIfVirtual("lastIndexOf");
    
    if (fromIndex === undefined) {
        fromIndex = 0;
    }
    
    for (i = this._getLength()-1; i >= fromIndex; i=i-1) {
        if (oj.Object.innerEquals(model, this.at(i))) {
            return i;
        }
    }
    return -1;
};

oj.Collection.prototype._getSortAttrs = function(sortStr) {
    if (sortStr === undefined) {
        return [];
    }
    return sortStr.split(",");
};

// Return a URL query string based on an array of or a single attr/value pair set
oj.Collection._getQueryString = function(q) {
    function expression(left, right, compare) {
        return left + compare + right;
    }
    
    var queries = oj.Model.IsArray(q) ? q : [q];
    var str = "", query, exp, i, prop;
    for (i = 0; i < queries.length; i++) {
        query = queries[i];
        for (prop in query) {
            if (query.hasOwnProperty(prop)) {
                var val = oj.Model.IsArray(query[prop]) ? query[prop] : [query[prop]];
                for (var j = 0; j < val.length; j++) {
                    if (oj.Model.IsComplexValue(val[j])) {
                        var value = val[j]['value'];
                        var compare = null;
                        var comparator = val[j]['comparator'];
                        if (oj.Model.IsFunction(comparator)) {
                            compare = comparator(null, prop, value);
                        }
                        else {
                            compare = comparator;
                        }
                        exp = expression(prop, value, compare);
                    }
                    else {
                        exp = expression(prop, query[prop], "=");
                    }
                    str += exp + "+";
                }
            }
        }
        // Remove trailing '+'
        str = str.substring(0, str.length-1) + ",";
    }
    // Remove trailing ','
    if (str.substring(str.length-1) === ",") {
        return str.substring(0, str.length-1);
    }
    return str;
};

oj.Collection.prototype.ModifyOptionsForCustomURL = function(options) {
    var opt = {};
    for (var prop in options) {
        if (options.hasOwnProperty(prop)) {
            opt[prop] = options[prop];
        }
    }
    var comparator = this['comparator'];
    if (comparator) {
        var attrs = this._getSortAttrs(comparator);        
        for (var i = 0; i < attrs.length; i++) {
            if (i === 0) {
                opt['sort'] = attrs[i];
            }
            else {
                opt['sort'] += "," + attrs[i];
            }
        }
        opt['sortDir'] = this._getSortDirStr();
    }
    // Put fetchSize on if set
    if (this._isVirtual()) {
        opt[oj.Collection._FETCH_SIZE_PROP] = this._getFetchSize(null);
    }
    return opt;
};

// Build a URL with parameters for the collection fetch
oj.Collection.prototype.GetCollectionFetchUrl = function(options) {
    var url = oj.Model.IsFunction(this['url']) ? this['url']() : this['url'];
    
    // Adorn it with options, if any
    if (this._isVirtual()) {
        var all = options['all'];
        
        // Put in page size
        var limit = null;
        if (all) {
            var totalResults = this['totalResults'];
            limit = totalResults ? totalResults : this._getFetchSize(options);
        }
        else {
            limit = this._getFetchSize(options);
        }
        url += "?limit=" + limit;

        if (!all) {
            if (options['startIndex']) {
                url += "&offset=" + options['startIndex'];
            }
            if (options['startID']) {
                url += "&fromID=" + options['startID'];
            }
            if (options['since']) {
                url += "&since=" + options['since'];
            }
            if (options['until']) {
                url += "&until=" + options['until'];
            }
        }
        // Query
        if (options['query']) {
            var queryString = oj.Collection._getQueryString(options['query']);
            if (queryString && queryString.length > 0) {
                url += "&q=" + queryString;
            }
        }
        
        // Add sorting
        var comparator = this['comparator'];
        if (comparator) {
            var attrs = this._getSortAttrs(comparator);
            var sortDirStr = this._getSortDirStr(), i;
            for (i = 0; i < attrs.length; i++) {
                if (i === 0) {
                    url += "&orderBy=" + attrs[i] + ":" + sortDirStr;
                }
                else {
                    url += "," + attrs[i] + ":" + sortDirStr;
                }
            }
        }
        // Always ask for totalresults
        url +="&totalResults=true";        
    }
    return url;
};

oj.Collection.prototype._getSortDirStr = function() {
    if (this['sortDirection'] === -1) {
        return "dsc";
    }
    return "asc";
};

/**
 * Called to perfrom server interactions, such as reading the collection.  Designed to be overridden by users
 * 
 * @param {string} method "read"
 * @param {Object} collection the Collection to be read
 * @param {Object=} options to control sync
 * success: called if sync succeeds
 * error: called if sync fails
 * others are passed to jQuery
 * @return {Object} xhr response
 */
oj.Collection.prototype['sync'] = function(method, collection, options) {
    return window['oj']['sync'](method, collection, options);
};

// Constants
oj.Collection._FETCH_SIZE_PROP = 'fetchSize';

/*jslint browser: true*/
/*global jQuery:false*/
/**
 * @private
 * @constructor
 */
oj.RestImpl = function(rootURL, custom) {
    this.rootURL = rootURL;
    this.customURL = custom;
    jQuery.support['cors'] = true;    
};

oj.RestImpl._HEADER_PROP = "headers";

// Add the properties in options to starter, if not already there
oj.RestImpl.addOptions = function(starter, options, customOptions) {
    var prop;
    starter = $.extend(true, starter, customOptions);
    for (prop in options) {
        if (options.hasOwnProperty(prop) && prop !== 'oauthHeader') {
            if (!starter.hasOwnProperty(prop)) {
                starter[prop] = options[prop];
            }
            if (prop === oj.RestImpl._HEADER_PROP) {
                // Deep merge
                starter[prop] = $.extend(true, starter[prop], options[prop]);
            }
        }
    }
	
	if(options['oauthHeader']) {
		// if there are no any headers then create a new one.
		if(!starter[oj.RestImpl._HEADER_PROP]) starter[oj.RestImpl._HEADER_PROP] = {}; 	
		for (prop in options['oauthHeader']) {
			if (options['oauthHeader'].hasOwnProperty(prop)) {
				if (!starter[oj.RestImpl._HEADER_PROP].hasOwnProperty(prop)) {
					starter[oj.RestImpl._HEADER_PROP][prop] = options['oauthHeader'][prop];
				}
			}
		}
	}
		
    return starter;
};

oj.RestImpl.prototype.getRecords = function(callback, errFunc, options, context) {
        options = options || {};
        var isJsonp = options['dataType'] === 'jsonp';
        var urlInfo = this._getURL("read", this.rootURL, this.customURL, null, context, options);
        var ajaxOptions = {
                'crossDomain': options['crossDomain'] || !isJsonp,
		'dataType': options['dataType'] || "json",
                'jsonpCallback' : options['jsonpCallback'],
                'context': context !== null ? context : this,
		'success':  callback,
                'error': errFunc
	};
        ajaxOptions = this._addHeaderProp(ajaxOptions);
        ajaxOptions = oj.RestImpl.addOptions(ajaxOptions, options, urlInfo);
	options.xhr = this.ajax(ajaxOptions);
        return options.xhr;
};

oj.RestImpl.prototype._addHeaderProp = function(options) {
    options[oj.RestImpl._HEADER_PROP] = {'Accept-Language': this.getLocale()};
    return options;
};

oj.RestImpl.prototype.getRecord = function(success, error, recordID, options, context) {
        options = options || {};
        var isJsonp = options['dataType'] === 'jsonp';
        var urlInfo = this._getURL("read", this.rootURL, this.customURL, recordID, context, options);
        var ajaxOptions = {
                'crossDomain': options['crossDomain'] || !isJsonp,
		'dataType': options['dataType'] || "json",
                'jsonpCallback' : options['jsonpCallback'],
                'context': context !== null ? context : this,
		'success': success,
                'error': error
	};
        ajaxOptions = this._addHeaderProp(ajaxOptions);
        ajaxOptions = oj.RestImpl.addOptions(ajaxOptions, options, urlInfo);
	options.xhr = this.ajax(ajaxOptions);    
        return options.xhr;
};


oj.RestImpl.prototype.updateRecord = function(callback, recordID, record, error, options, context, patch) {
    options = options || {};
    var isJsonp = options['dataType'] === 'jsonp';
    var urlInfo = this._getURL(patch ? "patch": "update", this.rootURL, this.customURL, recordID, context, options);
    var ajaxOptions = {
        'crossDomain': options['crossDomain'] || !isJsonp,
        'contentType': options['contentType'] || 'application/json',
        'dataType': options['dataType'] || "json",
        'jsonpCallback' : options['jsonpCallback'],
        'data': JSON.stringify(record),
        'success': callback,
        'error': error,
        'context': context !== null ? context : this
    };
    ajaxOptions = this._addHeaderProp(ajaxOptions);
    ajaxOptions = oj.RestImpl.addOptions(ajaxOptions, options, urlInfo);
    options.xhr = this.ajax(ajaxOptions);
    return options.xhr;
};

oj.RestImpl.prototype._getHTTPMethod = function(operation, options) {
    if (options['type']) {
        return options['type'];
    }
    if (operation === "create") {
        return "POST";
    }
    if (operation === "delete") {
        return "DELETE";
    }
    if (operation === "patch") {
        return "PATCH";
    }
    if (operation === "update") {
        return "PUT";
    }
    return "GET";
};

oj.RestImpl.prototype._setCustomURLOptions = function(recordID, context, opt) {
    var options = context instanceof oj.Collection ? context.ModifyOptionsForCustomURL(opt) : {};
    if (recordID) {
        options['recordID'] = recordID;
    }
    return options;
};

oj.RestImpl.prototype._getURL = function(operation, rootURL, customURL, recordID, context, options) {
   if (oj.Model.IsFunction(customURL)) {
       var result = customURL.call(this, operation, context, this._setCustomURLOptions(recordID, context, options));
       if (oj.StringUtils.isString(result)) {
           return {'url': result, 'type' : this._getHTTPMethod(operation, options)};
       }
       else if (result) {
           result['url'] = result.hasOwnProperty('url') ? result['url'] : rootURL;
           result['type'] = result.hasOwnProperty('type') ? result['type'] : this._getHTTPMethod(operation, options);
           return result;
       }
    }
    var http = this._getHTTPMethod(operation, options);
    return {'url': rootURL, 'type': http};
};

oj.RestImpl.prototype.deleteRecord = function(recordID, error, options, context) {
    options = options || {};
    var isJsonp = options['dataType'] === 'jsonp';
    var urlInfo = this._getURL("delete", this.rootURL, this.customURL, recordID, context, options);

    var ajaxOptions = {
        'crossDomain': options['crossDomain'] || !isJsonp,
        'success': options.success,
        'error': error,
        'context': context !== null ? context : this
    };
    ajaxOptions = oj.RestImpl.addOptions(ajaxOptions, options, urlInfo);
    options.xhr = this.ajax(ajaxOptions);
    return options.xhr;
};

oj.RestImpl.prototype.addRecord = function(record, error, options, context) {
    options = options || {};
    var recordStr = JSON.stringify(record), isJsonp = options['dataType'] === 'jsonp';
    var urlInfo = this._getURL("create", this.rootURL, this.customURL, null, context, options);

    var ajaxOptions = {
        'crossDomain': options['crossDomain'] || !isJsonp,
        'contentType': options['contentType'] || 'application/json',
        'dataType': options['dataType'] || "json",
        'jsonpCallback' : options['jsonpCallback'],
        'data': recordStr,
        'success': options.success,
        'error': error,
        'context': context !== null ? context : this
    };
    ajaxOptions = this._addHeaderProp(ajaxOptions);
    ajaxOptions = oj.RestImpl.addOptions(ajaxOptions, options, urlInfo);
    options.xhr = this.ajax(ajaxOptions);  

    return options.xhr;
};

oj.RestImpl.prototype.getLocale = function() {
    return oj.Config.getLocale();
};

oj.RestImpl.prototype.ajax = function(settings) {
    return window['oj']['ajax'](settings);
};



/*jslint browser: true*/
/*global jQuery:false*/

/**
 * @export
 * @class oj.OAuth
 * @classdesc Object representing name/value pairs for a data service record
 *
 * @param {Object} attributes Initial set of attribute/value pairs with which to seed this OAuth object 
 * @param {string} header Actual name for the Authorization header (default 'Authorization') 
 * @example <caption>Initialize OAuth with client credentials</caption>
 * var myOAuth = new oj.OAuth('X-Authorization', {...Clent Credentials ...});
 * 
 * @example <caption>Initialize OAuth with access_token</caption>
 * var myOAuth = new oj.OAuth('X-Authorization', {...Access Token...});
 * 
 * @example <caption>Initialize empty OAuth and set access_token</caption>
 * var myOAuth = new oj.OAuth();
 * myOAuth.setAccessTokenResponse({...Access Token...});
 *
 * @constructor
 */
oj.OAuth = function(header, attributes) 
{
	attributes = attributes || {};
	header = header || 'Authorization';
	oj.OAuth._init(this, attributes, header);
};

// Subclass from oj.Object 
oj.Object.createSubclass(oj.OAuth, oj.Object, "OAuth.OAuth");
oj.OAuth.prototype.Init = function()
{
    oj.OAuth.superclass.Init.call(this);
};

/**
 * Calculates Authorization header based on client credentials or access_token
 * @return {Object} OAuth 2.0 Authorization header
 * @example <caption>Get Authorization header</caption>
 * myOAuth.getHeader();
 *
 * @export
 */
oj.OAuth.prototype.getHeader = function() 
{
	var headers = {};
	if(!this.accessTokenResponse['access_token']) {
		this.clientCredentialGrant();
	}
	headers[this.accessTokenRequest.auth_header]='Bearer '+this.accessTokenResponse['access_token'];
	return headers;
}

/**
 * Check is OAuth initialized (not null access_token).
 * @return {boolean} true/false
 * @example <caption>Check if OAuth initialized</caption>
 * if(myOAuth.isInitialized()) console.log('Initialized');
 *
 * @export
 */
oj.OAuth.prototype.isInitialized = function() 
{
	return (this.accessTokenResponse.access_token) ? true : false;
}

/**
 * Request for access_token(bearer token) using Client Credential Authorization Grant.
 * Initialize response part of the OAuth object (access_token, e.t.c.)
 * @example <caption>Set/Re-set response part of the OAuth object using Client Credentials</caption>
 * myOAuth.clientCredentialGrant();
 *
 * @export
 */
oj.OAuth.prototype.clientCredentialGrant = function() 
{
	var headers = {}, self = this;
	headers[self.accessTokenRequest.auth_header] = 'Basic ' + 
		oj.OAuth._base64_encode(self.accessTokenRequest['client_id']+':'+self.accessTokenRequest['client_secret']);
		
	$.ajax({
		type: 'POST',
		async: false,
		url: this.accessTokenRequest['bearer_url'],
		data: 'grant_type=client_credentials',
		headers: headers,
		success:function(data) {
			oj.OAuth._initAccessToken(self.accessTokenResponse, data);
		},
		error: function(jqXHR, textStatus, errorThrown) {
			throw new Error(jqXHR.responseText);
		}
	});	

}

/**
 * Set response part of the OAuth object (access_token, e.t.c.)
 * @param {Object} data current response
 * @example <caption>'Initialize' response part of the OAuth object with access_token</caption>
 * myOAuth.setAccessTokenResponse({...Access Token...});
 *
 * @export
 */
oj.OAuth.prototype.setAccessTokenResponse = function(data) 
{
	oj.OAuth._initAccessToken(this.accessTokenResponse, data);
}

/**
 * Get response part of the OAuth object (access_token, e.t.c.)
 * @return {Object} cached response
 * @export
 */
oj.OAuth.prototype.getAccessTokenResponse = function()
{
	return this.accessTokenResponse;
}

/**
 * Clean response part of the OAuth object (access_token, e.t.c.)
 * Null and remove all data from response part of the OAuth object
 * @export
 */
oj.OAuth.prototype.cleanAccessTokenResponse = function()
{
	oj.OAuth._cleanAccessToken(this.accessTokenResponse);
}

/**
 * Set request part of the OAuth object (client credentials, uri endpoint)
 * @param {Object} data current client credentials and uri
 * @example <caption>'Initialize' request part of the OAuth object with client credentials and calculate access_token</caption>
 * myOAuth.setAccessTokenRequest({...Clent Credentials ...});
 * myOAuth.clientCredentialGrant();
 *
 * @export
 */
oj.OAuth.prototype.setAccessTokenRequest = function(data) 
{
	oj.OAuth._initAccessToken(this.accessTokenRequest, data);
}

/**
 * Get request part of the OAuth object (client credentials, uri endpoint)
 * @return {Object} cached request
 * @export
 */
oj.OAuth.prototype.getAccessTokenRequest = function()
{
	return this.accessTokenRequest;
}

/**
 * Clean request part of the OAuth object (client credentials, uri endpoint)
 * Null and remove all data from request part of the OAuth object
 * @export
 */
oj.OAuth.prototype.cleanAccessTokenRequest = function()
{
	oj.OAuth._cleanAccessToken(this.accessTokenRequest);
}

/**
 * @private
 * @param {Object} oauth
 * @param {Object} attributes
 * @param {string||null} header
 */
oj.OAuth._init = function(oauth, attributes, header) 
{
	oauth.Init();
	oauth.accessTokenRequest = {};
	oauth.accessTokenResponse = {};
	
	if(attributes['access_token']) { // access_token has higher preference
		oj.OAuth._initAccessToken(oauth.accessTokenResponse, attributes);
	} else if(attributes['client_id'] && attributes['client_secret'] && attributes['bearer_url']) { // Client Credential Grant		
		oj.OAuth._initAccessToken(oauth.accessTokenRequest, attributes);
	}
	oauth.accessTokenRequest.auth_header = header;
}

/**
 * @private
 * @param {Object} oauthObj - Request/Response object to deal with
 * @param {Object} data - object to populate
 */
oj.OAuth._initAccessToken = function(oauthObj, data) {
	var prop;
	data = data || {};
	for (prop in data) {
		oauthObj[prop] = data[prop];
	}
}

/**
 * @private
 * @param {Object} oauthObj - Request/Response object to deal with
 */
oj.OAuth._cleanAccessToken = function(oauthObj) {
	var key;
	for (key in oauthObj) {
		if (oauthObj.hasOwnProperty(key)) {
			if(key !== 'auth_header') {
				oauthObj[key] = null;
				delete oauthObj[key];
			}
		}
	}
}

/**
 * @private
 * @param {string} a The data to calculate the base64 representation from
 * @return {string} The base64 representation
 */
 oj.OAuth._base64_encode = function (a) {
	var d, e, f, b, g = 0,
		h = 0,
		i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
		c = [];
	do {
		d = a.charCodeAt(g++);
		e = a.charCodeAt(g++);
		f = a.charCodeAt(g++);
		b = d << 16 | e << 8 | f;
		d = b >> 18 & 63;
		e = b >> 12 & 63;
		f = b >> 6 & 63;
		b &= 63;
		c[h++] = i.charAt(d) + i.charAt(e) + i.charAt(f) + i.charAt(b);
	} while (g < a.length);
	c = c.join("");
	d = a.length % 3;
	return (d ? c.slice(0, d - 3) : c) + "===".slice(d || 3);	
}

/*
** Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.
**
**34567890123456789012345678901234567890123456789012345678901234567890123456789
*/


/**
 * @class JET Component services
 * @export
 */
oj.Components = {};


/**
 * Sets default options values for JET components.
 * @param {Object} options - property values that will be merged into the values
 * that were previously set using this method. The options object is expected to have the format demonstrated
 * by the following example:
 * <pre>
 * {
 *   'default': // properties for all JET components 
 *   {
 *     'option1': 'somevalue'
 *   },
 *   'editableValue': // properties for editableValue components 
 *   {
 *     'option1': 'somevalue1',
 *     'option2': oj.Components.createDynamicPropertyGetter(function(context){
 *                                 return context['containers'].indexOf('ojTable') >= 0 ? 'tableValue' : 'normalValue'})
 *   },
 *   'ojText': // properties for instances of ojText 
 *   {
 *     'option1': 'somevalue2'
 *   }
 * }
 * </pre>
 * To specify a dynamic getter for the property, pass your callback to oj.Components.createDynamicPropertyGetter(). Note
 * that dynamic getters nested within a complex property value are not supported
 * @see oj.Components.createDynamicPropertyGetter
 * @export
 */
oj.Components.setDefaultOptions = function(options)
{
  oj.Components._defaultProperties = $.widget.extend(oj.Components._defaultProperties || {}, options);
};

/**
 * Retrieves default option values for JET components.
 * @return {Object} default option values
 * @see oj.Components.setDefaultOptions
 * @export
 */
oj.Components.getDefaultOptions = function()
{
  return (oj.Components._defaultProperties || {});
};


/**
 * Creates a dynamic getter that can be used as a property value in oj.Components.setDefaultOptions()
 * @param {!Function} callback - dynamic property callback. The callback will receive a context object as a parameter.
 * The following properties are currently supported on the context object:
 * <ul>
 * <li>containers - an array of component names of the current component's containers that require special behavior from
 * their children</li>
 * </ul>
 * The callback should return the computed property value
 * 
 * @return {Object} - dynamic property getter
 * @see oj.Components.setDefaultOptions
 * @export
 */
oj.Components.createDynamicPropertyGetter = function(callback)
{
  return new __ojDynamicGetter(callback, true);
};

/**
 * Retrieves widget constructor associated with the HTML element
 * or null if none is found. The returned constructor is already bound to the associated 
 * JQuery element, so it can be invoked as a function directly. For example:
 * <pre>
 * widgetConstructor("option", "label", "custom"); // sets label option
 * </pre>
 * If widgetName is not specified, and if more than one widget is associated with the element, 
 * the method will a return the widget that was created first.
 * @param {Element} element - HTML element
 * @param {string=} widgetName - optional widget name
 * @return {Function|null} widget constructor
 * @export
 */
oj.Components.getWidgetConstructor = function(element, widgetName)
{
  var jelem = $(element);
  
  if (widgetName == null)
  {
    var data = jelem.data(_OJ_WIDGET_NAMES_DATA);
    if (data)
    {
      widgetName = data[0]; 
    }
  }
  
  if (widgetName != null)
  {
    var func = jelem[widgetName];
    if ((typeof func) === "function")
    {
      return func.bind(jelem);
    }
  }
  
  return null;
};

/**
 * @constructor
 * @param {Function} callback
 * @param {boolean=} needsDynamicContext
 * @private
 */
function __ojDynamicGetter(callback, needsDynamicContext)
{
  this.getCallback = function()
  {
    return callback;
  }
  this.isDynamicContextNeeded = function()
  {
    return needsDynamicContext;
  }
};


/**
 * @private
 */
oj.Components._OJ_CONTAINER_ATTR = "data-oj-container";

/**
 * @private
 */
var _OJ_WIDGET_NAMES_DATA = "oj-component-names";

/*
** Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.
**
**34567890123456789012345678901234567890123456789012345678901234567890123456789
*/
/*jslint browser: true*/

/**
 * @class
 * @abstract
 * @name oj.baseComponent
 */
$.widget('oj.baseComponent', 
{
  options: 
  {
    /**
     * JQ selector identifying the JET Menu that the component should launch as a context menu on right-click or <kbd>Shift-F10</kbd>. If specified, 
     * the browser's native context menu will be replaced by the specified JET Menu.
     * 
     * <p>To specify a JET context menu on a DOM element that is not a JET component, see the <code class="prettyprint">ojContextMenu</code> binding.  
     * 
     * <p>To make the page semantically accurate from the outset, applications are encouraged to specify the context menu via the standard 
     * HTML5 syntax shown in the below example.  When the component is initialized, the context menu thus specified will be set on the component.
     * 
     * <p>The JET Menu should be initialized before any component using it as a context menu.
     * 
     * @expose
     * @memberof! oj.baseComponent
     * @instance
     * @type {Object}
     * @default <code class="prettyprint">null</code>
     * 
     * @example <caption>Initialize a JET component with a context menu:</caption>
     * // via recommended HTML5 syntax:
     * &lt;div id="myComponent" contextmenu="myMenu" data-bind="ojComponent: { ... }>
     * 
     * // via JET initializer (less preferred) :
     * $( ".selector" ).ojFoo({ "contextMenu": "#myMenu" });
     * 
     * @example <caption>Get or set the <code class="prettyprint">contextMenu</code> option, after initialization:</caption>
     * // getter
     * var menu = $( ".selector" ).ojFoo( "option", "contextMenu" );
     * 
     * // setter
     * $( ".selector" ).ojFoo( "option", "contextMenu", ".my-marker-class" );
     * 
     * @example <caption>Set a JET context menu on an ordinary HTML element:</caption>
     * &lt;a href="#" id="myAnchor" contextmenu="myMenu" data-bind="ojContextMenu: {}">Some text</a>
     */
    contextMenu: null,
    
    /**
     * Attributes specified here will be set on the component's root DOM element at creation time.
     * This is particularly useful for components like Dialog that wrap themselves in a root element
     * at creation time.
     * 
     * <p>The specified <code class="prettyprint">class</code> and <code class="prettyprint">style</code> are 
     * appended to the current class and style, respectively.  All other attributes overwrite any existing value.
     * 
     * <p>Setting this option after component creation has no effect.  
     *
     * @example <caption>Initialize a JET component, specifying a set of attributes to be set
     * on the component's root DOM element:</caption>
     * $( ".selector" ).ojFoo({ "rootAttributes": {
     *   'id': 'myId', 
     *   'style': 'max-width:100%; color:blue;', 
     *   'class': 'my-class'
     * }});
     * 
     * @expose
     * @memberof! oj.baseComponent
     * @instance
     * @type {Object|undefined}
     * @default <code class="prettyprint">undefined</code>
     */
    rootAttributes: undefined
  },
  
  /**
   * Refreshes the widget.
   * 
   * @expose
   * @memberof! oj.baseComponent
   * @instance
   */
  refresh: function()
  {
    this._propertyContext = null;
  },
  
  /**
   * Reads the <code class="prettyprint">rootAttributes</code> option, and sets the root attributes on the 
   * component's root DOM element.
   * 
   * <p><code class="prettyprint">class</code> and <code class="prettyprint">style</code> are appended
   * to the current class and style, respectively.  All other attributes overwrite any existing value.
   * 
   * @memberof! oj.baseComponent
   * @instance
   * @protected
   */
  _SetRootAttributes : function () 
  {
    var value = this.options.rootAttributes;
    if (value)
    {
      var widget = this.widget();
      if (widget == null)
        return;
      
      var classValue = value["class"];
      
      if (classValue)
      {
        widget.addClass(classValue);
      }
      
      var styleValue = value["style"];
      
      if (styleValue)
      {
        var currStyle = widget.attr('style');
        
        if (currStyle)
        {
          widget.attr('style', currStyle + ';' + styleValue);
        }
        else
        {
          widget.attr('style', styleValue);
        }
      }
      
      // make shallow copy, remove class and style from the copy, and set all 
      // remaining attrs on the element
      value = $.extend({}, value); 
      delete value['class'];
      delete value['style'];
      
      widget.attr(value);
    }
  },

  /*
   * It's recommended that you override @link oj.baseComponent#_ComponentCreate and 
   * @link oj.baseComponent#_AfterCreate, instead of this method to render your component. This 
   * method saves off all element attributes (retrieved using 
   * @link oj.baseComponent#_GetSavedAttributes) and then calls _InitOptions(), _ComponentCreate(),
   * _AfterCreate() in that order.
   * 
   * @memberof! oj.baseComponent
   * @instance
   * @protected
   * TODO: JSDoc!!  (with at-protected tag, at-final, etc.)
   */
  _create : function()
  {
    this._SaveAttributes(this.element);
    this._InitOptions();
    this._ComponentCreate();
    this._AfterCreate();
  },
  
  /**
   * Overridden to return component-specific translations and default options specified with 
   * oj.Components.setDefaultOptions()
   * @private
   */
  _getCreateOptions: function()
  {
    var defaults = {};
    
    // Load component translations
    var getters = {};
    this._RegisterTranslatedOptionGetters(getters);
    
    // wrap translation getters in the __ojDynamicGetter wrapper do distinguish them
    // from regular functions
    for (var prop in getters)
    {
      defaults[prop] = new __ojDynamicGetter(getters[prop]);
    }
    
    // Load options specified with oj.Components.setDefaultOptions()
    var widgetHierNames = [];
    var proto = this.constructor.prototype;
    while (proto != null && proto.widgetName)
    {
      widgetHierNames.push(proto.widgetName);
      proto = Object.getPrototypeOf(proto);
    }
    
    widgetHierNames.push('default');
    
    var allProperties = oj.Components.getDefaultOptions();
    
    // merge properties applicable to this component
    for (var i= widgetHierNames.length; i>=0; i--)
    {
      var name = widgetHierNames[i];
      var props = allProperties[name];
      if (props !== undefined)
      {
        defaults = $.widget.extend(defaults, props);
      }
    }
    
    return defaults;
  },

  /**
   * <p>This method is called before <code class="prettyprint">_ComponentCreate</code>, at which point the component has not yet 
   * been rendered.  Component options should be initialized in this method, so that their final values are in place when 
   * <code class="prettyprint">_ComponentCreate</code> is called. 
   * 
   * <p>This includes getting option values from the DOM, where applicable, and coercing option values (however derived) to their 
   * appropriate data type.  No other work should be done in this method.  See below for details.
   * 
   * <p>Overrides of this method should call <code class="prettyprint">this._super</code> first.
   * 
   * <p>Usage:
   * 
   * <ul>
   * <li>If the component has an option like <code class="prettyprint">disabled</code> that can be set from the DOM 
   * at create time, then the "get from DOM" logic should live in this method.  E.g. a typical override might say "if 
   * the <code class="prettyprint">disabled</code> option still has its initial value of <code class="prettyprint">undefined</code>
   * (i.e., the option has not been set), then get the DOM property and set it on the option." (See also next bullet.)</li>
   * 
   * <li>For attributes that live on the component's root node, keep in mind that anything specified via 
   * the <code class="prettyprint">rootAttributes</code> option will not be placed on the DOM until 
   * <code class="prettyprint">_AfterCreate</code>.  So when getting attributes from the root node, components must first look in the 
   * <code class="prettyprint">rootAttributes</code> option, and then, only if the attribute is not found there, look on the component 
   * root (if it already exists).</li>
   * 
   * <li>For options that, unlike <code class="prettyprint">disabled</code>, have no corresponding DOM property, and are not otherwise 
   * set from the DOM, there is nothing to do in this method.</li>
   * 
   * <li>Do NOT set anything on the DOM in this method (like the resolved <code class="prettyprint">disabled</code> value, or any 
   * <code class="prettyprint">rootAttributes</code> values). The resolved option values should be set on the DOM later, in 
   * <code class="prettyprint">_ComponentCreate</code>, and the <code class="prettyprint">rootAttributes</code> values are set in 
   * <code class="prettyprint">baseComponent._AfterCreate</code>.</li>
   * </ul> 
   * 
   * @memberof! oj.baseComponent
   * @instance
   * @protected
   */
  _InitOptions : function ()
  {
    this._setupDynamicProperties();
  },
  
  /**
   * <p>All component create-time initialization lives in this method, except the logic that specifically 
   * needs to live in <code class="prettyprint">_InitOptions</code> or <code class="prettyprint">_AfterCreate</code>, 
   * per the documentation for those methods.  All DOM creation must happen here, since the intent of 
   * <code class="prettyprint">_AfterCreate</code> is to contain superclass logic that must run after that DOM is created.  
   * 
   * <p>Overrides of this method should call <code class="prettyprint">this._super</code> first.
   * 
   * @memberof! oj.baseComponent
   * @instance
   * @protected
   */
  _ComponentCreate : function ()
  {
    this['activeable'] = $();
    this._setupDynamicProperties();
    
    // Store widget name, so that oj.Components.getWidgetConstructor() can get widget from the element
    _storeWidgetName(this.element, this.widgetName);
  },
          
  /**
   * This method is called after <code class="prettyprint">_ComponentCreate</code>.  The JET base component does 
   * tasks here that must happen after the component (subclass) has created itself in its override of 
   * <code class="prettyprint">_ComponentCreate</code>.  Notably, the base component handles the 
   * <code class="prettyprint">rootAttributes</code> and <code class="prettyprint">contextMenu</code> options here, 
   * since those options operate on the component root node, which for some components is created in their override 
   * of <code class="prettyprint">_ComponentCreate</code>. 
   * 
   * <p>Subclasses should override this method only if they have tasks that must happen after a superclass's 
   * implementation of this method, e.g. tasks that must happen after the context menu is set on the component.
   * 
   * <p>Overrides of this method should call <code class="prettyprint">this._super</code> first.
   * 
   * @memberof! oj.baseComponent
   * @instance
   * @protected
   */
  _AfterCreate : function ()
  {
    this._SetRootAttributes(); // do first, since has no dependencies, but other stuff might care about these attrs
    
    // namespace facilitates removing contextMenu handlers separately, if app clears the "contextMenu" option
    this.contextMenuEventNamespace = this.eventNamespace + "contextMenu";
    this._setupContextMenu(); 
  },
  
  /**
   * Saves the element's attributes within an internal variable to be reset during the destroy function
   *
   * The JSON variable will be held as :
   * [
   *   {
   *   "element" : element[i], 
   *   "attributes" : 
   *     {
   *       attributes[m]["name"] : {"attr": attributes[m]["value"], "prop": $(element[i]).prop(attributes[m]["name"])
   *     }
   *   }
   * ]
   *
   * @param {Object} element - jQuery selection to save attributes for
   * @memberof! oj.baseComponent
   * @instance
   * @protected
   */
  _SaveAttributes : function (element)
  {
    var self = this;
    this._savedAttributes = [];

    $.each(element, function (index, ele)
    {
      //need to be able to save for multiple elements 
      var saveAttributes = {},
          save = { "element" : ele, "attributes" : saveAttributes },
          attributes = ele.attributes;
      
      self._savedAttributes.push(save);
      
      $.each(attributes, function (index, attr)
      {
        var attrName = attr["name"], attrValues = { "attr" : attr["value"] };
        
        // for proper access certain so called attributes should be accessed as properties 
        // [i.e. required]
        attrValues["prop"] = $(ele).prop(attrName);
        saveAttributes[attrName] = attrValues;
      });
  
    });
  
  },
  
  /**
   * Gets the saved attributes for the provided element. This is usually the original list of 
   * attributes set on the element.
   *
   * @param {Object} element - jQuery selection, should be a single entry
   * @return {Object} savedAttributes - attributes that were saved for this element. 
   * 
   * @memberof! oj.baseComponent
   * @instance
   * @protected
   */
  _GetSavedAttributes : function (element)
  {
    var savedAttributes = this._savedAttributes;
  
    element = element[0];
  
    for (var i = 0, j = savedAttributes.length;i < j;i++)
    {
      var curr = savedAttributes[i];
      
      if (curr["element"] === element)
      {
        return curr["attributes"];
      }
    }
  
    return {};
  },
  
  /**
   * Restores the saved element's attributes
   *
   * @memberof! oj.baseComponent
   * @instance
   * @protected
   */
  _RestoreAttributes : function ()
  {
    
    $.each(this._savedAttributes, function (index, savedAttr)
    {
      var element = $(savedAttr["element"]), 
          attributes = savedAttr["attributes"];
      
      //sanity check
      if (element.length === 1)
      {
        var currAttr = savedAttr["element"].attributes,
            removeAttr = [];

        //request is to remove any attributes that didn't exist previously
        //need to store the attributes in an array and remove them afterwards as otherwise there are side affects
        for(var i=0, j=currAttr.length; i < j; i++) 
        {
          if(!(currAttr[i]["name"] in attributes)) 
          {
            removeAttr.push(currAttr[i]["name"]);
          }
        }

        for(var i=0, j=removeAttr.length; i < j; i++) 
        {
          element.removeAttr(removeAttr[i]);
        }

        for (var attribute in attributes)
        {
          element.attr(attribute, attributes[attribute]["attr"]);
        }
      }

    });
    
  },
  
  /**
   * Registers getters for the component's translated properties
   * @param {Object} getters - object where the getter functions may be added.
   * Property name should be used as a key, and the getter function should be used as a value
   * The getter will be passed option name as a parameter
   * @memberof! oj.baseComponent
   * @protected
   */
  _RegisterTranslatedOptionGetters: function(getters)
  {
    var sectionName = this._GetTranslationsSectionName();
    
    var translations = oj.Translations.getComponentTranslations(sectionName) || {};
   
    for (var prop in translations)
    {
      getters[prop] = function(name)
                      {
                        return oj.Translations.getComponentTranslations(sectionName)[name];
                      };
    }
  },
  
  /**
   * Determines the name of the translation bundle section for this component
   * @return {string} the name of this component's translations section
   * 
   * @memberof! oj.baseComponent
   * @protected
   */
  _GetTranslationsSectionName: function()
  {
    return this.widgetFullName;
  },
  
  
  /**
   * Retrieves a translated string after inserting optional parameters
   * @param {string} key the translations resource key
   * The key is used to retrieve a format pattern from the component options, or if none
   * is found - from the translated resource bundle.
   * Tokens like {0}, {1}, {name} within the pattern will be used to define placement
   * for the optional parameters.  Token strings should not contain comma (,) 
   * or space characters, since they are reserved for future format type enhancements.
   * The reserved characters within a pattern are:
   * $ { } [ ]  
   * These characters will not appear in the formatted output unless they are escaped
   * with a dollar character ('$').
   * 
   * @param {...string|Object|Array} var_args  - optional parameters to be inserted into the 
   * translated pattern.
   * 
   * If more than one var_args arguments are passed, they will be treated as an array 
   * for replacing positional tokens like {0}, {1}, etc.
   * If a single argument is passed, it will be treated as a Javascript Object whose
   * keys will be matched to tokens within the pattern. Note that an Array is just
   * a special kind of such an Object.
   * 
   * For backward compatibility, a var_args argument whose type is neither 
   * Object or Array will be used to replace {0} in the pattern.
   * @return formatted translated string or the key argument if the resource for the
   * key was not found
   * @private
   */
  getTranslatedString : function (key, var_args)
  {
    var params = {}, pattern;
  
    if (arguments.length > 2)
    {
      params = Array.prototype.slice.call(arguments, 1);
    }
    else if (arguments.length == 2)
    {
      params = arguments[1];
      if (typeof params !== 'object' && !(params instanceof Array))
      {
        params = [params];
      }
        
    }
    pattern = this.options[key];
    // pattern could be undefined
    return (pattern == null) ? key : oj.Translations.applyParameters(pattern.toString(), params);
  },
  
  /**
   * Return the subcomponent node represented by the documented locator attribute values.
   * 
   * @param {Object} locator An Object containing at minimum a subId property whose value is a string, documented by the component, that allows the component to 
   * look up the subcomponent associated with that string.  It contains:<p>
   * component: optional component name - in the future there may be more than one component contained within a page element<p>
   * subId: the string, documented by the component, that the component expects in getNodeBySubId to 
   * locate a particular subcomponent.
   *    
   * @return {Element|null} the subcomponent located by the subId string passed in locator, if found.
   * @expose
   * @memberof! oj.baseComponent
   * @instance
   * 
   */
  getNodeBySubId: function(locator)
  {
    if (locator == null || locator['subId'] == null)
    {
      return this.element ? this.element[0] : null;
    }
    
    // Non-null locators have to be handled by the component subclasses
    return null;
  },
  
  /**
   * Return the subId string for the given child DOM node
   * 
   * @param {!Element} node - child DOM node
   *    
   * @return {string|null} - the subId for the DOM node or null when none is found
   * @expose
   * @memberof! oj.baseComponent
   * @instance
   * 
   */
  getSubIdByNode: function(node)
  {
    return null;
  },
  
  /**
   * Overridden to set oj-hover and oj-focus classes
   * @private
   */
  'destroy': function()
  {
    this._unbindContextMenu();
    this._super();
    
    // clean up states
    this.widget().removeClass( "oj-disabled" );
    this['hoverable'].removeClass( "oj-hover" );
    this['focusable'].removeClass( "oj-focus" );
    this['activeable'].removeClass( "oj-active" );
    
    _removeWidgetName(this.element, this.widgetName);
    
    //this._RestoreAttributes();
  },
  
  /**
   * Overridden to set an instance variable indicating that a particular property
   * is being mutated (for use by _defineDynamicProperty())
   * @private
   */
  option: function(key, value)
  {
    var retval;
    if (arguments.length > 0 &&  typeof key === "string" && value !== undefined)
    {
      var dotIndex = key.indexOf('.');
      if (dotIndex > 0)
      {
        this._settingOption = key.substring(0, dotIndex);
      }
    }
    try
    {
      retval = this._superApply(arguments);
    }
    finally
    {
      this._settingOption = null;
      return retval;
    }
  },
        
  /**
   * This method has several overloads, which gets and set component options.
   * 
   * <p>The first overload accepts a single <code class="prettyprint">optionName</code> param as a string, and returns 
   * the current value of that option.  
   * 
   * <p>The second overload accepts two params, an <code class="prettyprint">optionName</code> string and a new value to 
   * which that option will be set.
   * 
   * <p>The third overload accepts no params, and returns a map of key/value pairs 
   * representing all the component options and their values.
   * 
   * <p>The fourth overload accepts a single map of option-value pairs to set on the component. 
   * 
   * @method
   * @name oj.baseComponent#option
   * @memberof! oj.baseComponent
   * @instance
   * 
   * @param {string|Object=} optionName the option name (string, first two overloads), or the map (Object, last overload).
   *        Omitted in the third overload.
   * @param {Object=} value a value to set for the option.  Second overload only.
   * @return {Object|undefined} The getter overloads return the retrieved value(s).  When called via the public jQuery syntax, the setter overloads 
   *         return the object on which they were called, to facilitate method chaining.
   * 
   * @example <caption>First overload: get one option:</caption>
   * var isDisabled = $( ".selector" ).ojFoo( "option", "disabled" ); // Foo is Button, Menu, etc.
   * 
   * @example <caption>Second overload: set one option:</caption>
   * $( ".selector" ).ojFoo( "option", "disabled", true ); // Foo is Button, Menu, etc.
   * 
   * @example <caption>Third overload: get all options:</caption>
   * var options = $( ".selector" ).ojFoo( "option" ); // Foo is Button, Menu, etc.
   * 
   * @example <caption>Fourth overload: set one or more options:</caption>
   * $( ".selector" ).ojFoo( "option", { disabled: true } ); // Foo is Button, Menu, etc.
   */
  // option() method declared in superclass, but we still want the above API doc.
  
  /**
   * Overridden to set oj-hover and oj-focus classes
   * @private
   */
  _setOption: function( key, value )
  {
    if ( key === "disabled" )
    {
      // The JQUI superclass method has hard-coded style classes in the 'if key === "disabled"' block, so unfortunately 
      // we must copy that logic here with updated style classes, and NOT call _super() for the disabled case.
      // TBD: keep this logic updated if superclass method changes.  
      this.options[ key ] = value;
      
      // TBD: widget() is not always the thing that should have aria-disabled on it.  E.g. for the checkbox/radio flavors of ojButton, 
      // widget() returns the root node, but aria-disabled belongs on the <input>.  We fixed this JQUI bug in ojButton by having ojButton
      // override this method to remove it from the root node and add it to the input.  Would be better for each component to know which 
      // element to apply that to, e.g. an overridable method returning that element, or copying "hoverable" paradigm if appropriate.  
      // In the cases where this.element is different than widget(), this.element is more likely to be the right thing, so maybe change 
      // default to that.
      this.widget()
	  .toggleClass( "oj-disabled", !!value )
	  .attr( "aria-disabled", value );
      
      if (value) 
      {
          this['hoverable'].removeClass( "oj-hover" );
          this['focusable'].removeClass( "oj-focus" );
          // TODO: when we have worked out the 'create' super code change,
          // this this check should not be necessary. Right now, this gets
          // called before _create for radioset (and possibly others) when
          // we create a component like ojRadioset({disabled: true});
          if (!this['activeable'])
            this['activeable'] = $(); 
          this['activeable'].removeClass( "oj-active" );
      }
    }
    else {
      this._super(key, value); // disabled is the only key for which we don't call _super()
      
      if ( key === "contextMenu" )
        this._setupContextMenu();
    }
    
    return this;
  },
  
  /*
   * This method adds/removes a contextMenu listener on the component, based on the component's "contextMenu" option.
   * It is private since the logic that is likely to vary by component is encapsulated in the protected callees 
   * <code class="prettyprint">_listenerNodes()</code> and <code class="prettyprint">_showContextMenu()</code>.
   * 
   * TODO: all API doc at-tags, including @private, then add 2nd star at top.
   */
  _setupContextMenu: function()
  {
    this._unbindContextMenu();
    
    var menu = this.options.contextMenu;
    // menu is selector like "#myMenuId", or null, or some malformed thing.
    
    // TODO: move this part to _InitOptions, in the trxn that handles that refactoring
    if (!menu)
    {
        menu = this.element.attr("contextmenu");
        if (menu)
            menu = "#" + menu;
    }
    
    if ( menu )
        menu = $(menu).data( "oj-ojMenu" ); // if selector finds >1 element, .data() uses the first one.
                                            // if selector finds 0 elements, .data() returns nothing.
    if ( menu )
    {
        var self = this;
        this._listenerNodes().on( "keydown" + this.contextMenuEventNamespace + " " + "contextmenu" + this.contextMenuEventNamespace, function( event ) {
            if (event.type === "contextmenu" || (event.which == 121 && event.shiftKey)) // right-click or Shift-F10
            {
                self._showContextMenu(menu, event);
                return false; // don't show native context menu
            }

            return true;
        });
    }
  },
  
  /* 
   * This method removes contextMenu functionality from the component.
   * 
   * TODO: all API doc at-tags, including @private, then add 2nd star at top.
   */
  _unbindContextMenu: function()
  {
    this._listenerNodes().off( this.contextMenuEventNamespace );
  },
  
  /* 
   * Component developers: This API and functionality is subject to change pending architectural review!
   * 
   * When the <code class="prettyprint">contextMenu</code> option is set, this method is called when the user invokes the context menu.  
   * It may be overridden by components needing to configure the menu specially, e.g. customize the <code class="prettyprint">launcher</code> 
   * or <code class="prettyprint">menuPosition</code>.  Note that for context menus, <code class="prettyprint">"focus"</code> should always 
   * be set to <code class="prettyprint">"menu"</code> as seen here.
   * 
   * TODO: all API doc at-tags, including @protected, then add 2nd star at top.  Update method name once protected naming convention nailed down.
   */
  _showContextMenu: function(menu, event)
  {
    menu.show(event, {"launcher": this.element, "focus": "menu"});
  },
    
  /* 
   * Component developers: This API and functionality is subject to change pending architectural review!
   * 
   * This method identifies the DOM node(s) on which context menu listeners should be set.  It is called whenever the <code class="prettyprint">contextMenu</code>
   * component option is set, whether at create time or later.  It may be overridden by components whose needs differ from the default.  
   * 
   * TODO: all API doc at-tags, including @protected, then add 2nd star at top.  Update method name once protected naming convention nailed down.
   */
  _listenerNodes: function() 
  {
    // .closest() handles components like inputnumber whose root node is an ancestor of the initialization node.
    // TODO: this requires components to call _super() at the *end* of _create(), since at the beginning the oj-component class 
    // hasn't been applied yet.  Is this OK for editableComponents?  This logic works for radioset and inputnumber if I call _super() 
    // at the end, but I didn't keep the change pending discussion with component owners.  ojInputText would have additionally needed 
    // to use oj-component class, after which would have presumably worked.
    // If this is not OK, components' _create methods will have to call 2 superclass methods, not just 1 call to _super(), or stop 
    // using closest.
    // UPDATE: Now that we're saying that widget() must always return the (or at least *a*) component root, just using widget() instead.
    // Once Button becomes single-rooted, we may be able to get rid of this method and just call widget() directly, since no component 
    // should need to override this method.  
    // This eliminates the issue with .oj-component possibly not being set when _create._super() is called, so the only issue is whether 
    // widget() works as expected at the time of that call.  Presumably the only issue is for ancestor-rooted components like inputNumber, 
    // Dialog, and Button that create their own root: widget() can't return that root if it hasn't been created yet.  Assuming 
    // that some components continue to need to call _create._super() at the beginning of _create (before creating the root), a good 
    // solution is probably to have a protected _DelayContextMenuSetup ivar that subclasses can set before calling _create._super.  If they 
    // do so, they must call _setupContextMenu (which becomes protected, not private) before exiting _create().  
    // Until this is all figured out, widget is better than closest(".oj-component") as long as we null-check it, since fewer widgets are affected, 
    // and since when it fails it will be a no-op rather than accidentally setting the listeners on the closest *container* component having .oj-component.
     
    // return this.element.closest(".oj-component");  // Old version, per comments above
    
    var widget = this.widget(); // could be undefined if called too early at create time, e.g. if it returns a created root that isn't yet created
    return widget ? widget : $();
  },
    
  /**
   * Overridden to set oj-hover class
   * @private
   */
  _hoverable: function( element )
  {
    // The JQUI superclass method has hard-coded style classes, so unfortunately 
    // we must copy that logic here with updated style classes, and NOT call _super().
    // TBD: keep this logic updated if superclass method changes.  
    this['hoverable'] = this['hoverable'].add( element );
    this._on( element, {
      mouseenter: function( event ) {
        $( event.currentTarget ).addClass( "oj-hover" );
      },
      mouseleave: function( event ) {
        $( event.currentTarget ).removeClass( "oj-hover" );
      }
    });
  },
  
  /**
   * Overridden to set oj-focus class
   * @private
   */
  _focusable: function( element )
  {
    // The JQUI superclass method has hard-coded style classes, so unfortunately 
    // we must copy that logic here with updated style classes, and NOT call _super().
    // TBD: keep this logic updated if superclass method changes.  
    this['focusable'] = this['focusable'].add( element );
    this._on( element, {
      focusin: function( event ) {
	  $( event.currentTarget ).addClass( "oj-focus" );
	},
	focusout: function( event ) {
	  $( event.currentTarget ).removeClass( "oj-focus" );
	}
    });
  },      
  
  /**
   * Set oj-active class on mousedown  and remove it on mouseup.
   * oj-active is one of JET's 'marker' style classes. It emulates 
   * the css :active pseudo-class.
   * @private
   */
  _activeable: function( element )
  {
    this['activeable'] = this['activeable'].add( element );
    
    this._on( element, {
    mousedown: function( event ) 
    {
      $( event.currentTarget ).addClass( "oj-active" );
    },
    mouseup: function( event ) 
    {
      $( event.currentTarget ).removeClass( "oj-active" );
    }
    });
  },
  
  /**
   * Retrieves a translated resource for a given key
   * @param {string} key
   * @return {Object} resource associated with the key or null if none was found
   * @private
   */
  getResource : function (key)
  {
    return this.options[key];
  },
  
  /**
   * <p>Determines whether the component is LTR or RTL.
   * 
   * <p>Component responsibilities:
   * 
   * <ul>
   * <li>All components must determine directionality exclusively by calling this protected superclass method.
   *     (So that any future updates to the logic can be made in this one place.)</li>
   * <li>Components that need to know the directionality must call this method from <code class="prettyprint">_create()</code> 
   *     and <code class="prettyprint">refresh()</code>, and cache the value.  
   * <li>Components should not call this at other times, and should instead use the cached value.  (This avoids constant DOM 
   *     queries, and avoids any future issues if directional islands and component reparenting (e.g. popups) should coexist.)</li>
   * </ul>
   * 
   * <p>App responsibilities:
   * 
   * <ul>
   * <li>The app specifies directionality by setting the HTML <code class="prettyprint">"dir"</code> attribute on the 
   *     <code class="prettyprint">&lt;html></code> node.  When omitted, the default is <code class="prettyprint">"ltr"</code>.  
   *     (Per-component directionality / directional islands are not currently supported due to inadequate CSS support.)</li>
   * <li>As with any DOM change, the app must <code class="prettyprint">refresh()</code> the component if the directionality changes dynamically. 
   *   (This provides a hook for component housekeeping, and allows caching.)</li>
   * </ul>
   * 
   * @memberof! oj.baseComponent
   * @instance
   * @protected
   * @return {string} the reading direction, either <code class="prettyprint">"ltr"</code> or <code class="prettyprint">"rtl"</code>
   * @default <code class="prettyprint">"ltr"</code>
   */
  _GetReadingDirection: function( )
  {
    return (document.documentElement.dir === "rtl") ? "rtl" : "ltr";
  },
  
  /**
   * @private
   */
  _getDynamicPropertyContext: function()
  {
    if (!this._propertyContext)
    {
      var c = {};
      this._propertyContext = c;
      c['containers'] = _getSpecialContainerNames(this.element[0]);
    }
    return this._propertyContext;
  },
  
  /**
   * @private
   */
  _setupDynamicProperties: function()
  {
    var self = this;
    
    var contextCallback = function()
    {
      return self._getDynamicPropertyContext();
    };
    
    var options = this.options;
    
    for (var prop in options)
    {
      var val = options[prop];
      
      if (typeof val !== 'undefined' && val instanceof __ojDynamicGetter)
      {
        var callback = val.getCallback();
        if ($.isFunction(callback))
        {
          delete options[prop];
          _defineDynamicProperty(this, options, prop, callback, val.isDynamicContextNeeded() ? contextCallback : undefined);
        }
        else 
        {
          oj.Logger.error("Dynamic getter for property %s is not a function", prop);
        }
      }
    }
    
  }
});

/**
 * This method is our version of $.widget, i.e. the static initializer of a component such as ojButton.
 * It calls that method, plus does any other static init we need.
 * 
 * TODO: 
 * - Consider moving this method into its own file.
 * - For base param, make the type oj.baseComponent rather than Object, but need to declare that as a type first.  Review how that's done.
 * 
 * @private
 * @param {string} name typically of the form "oj.ojMenu"
 * @param {Object} base NOT optional (unlike JQUI) 
 * @param {Object} prototype
 */
oj.__registerWidget = function( name, base, prototype )
{
  $.widget( name, base, prototype );

  // create single-OJ pseudo-selector for component, e.g. ":oj-menu", in addition to the ":oj-ojMenu" that $.widget() creates.
  // for private components it will begin with an underscore, e.g.,  ":_oj-radio"
  if (name.substring(0, 5) === "oj.oj" || name.substring(0, 6) === "oj._oj")
  { 
    var nameArray = name.split( "." ); // ["oj", "ojMenu"], ["oj", "_ojRadio"]
    var namespace = nameArray[ 0 ];    // "oj"
    var simpleName = nameArray [ 1 ];  // "ojMenu", "_ojRadio"
    var fullName = namespace + "-" + simpleName; // "oj-ojMenu", "oj-_ojRadio"
    var isPrivate = simpleName.substring(0, 1) === "_";
    // if private, make the single-oj pseudo-selector start with an underscore, like this -> "_oj-radio"
    var modifiedFullName; // "oj-Menu", "_oj-Radio".  Lowercased below.
    if (isPrivate)
    {
      modifiedFullName = "_" + namespace + "-" + simpleName.substring(3); 
    }
    else
    {
      modifiedFullName = namespace + "-" + simpleName.substring(2);
    }

    // Capitalization doesn't seem to matter with JQ pseudos, e.g. for the existing double-oj pseudo, both $(":oj-ojMenu") and $(":oj-ojmenu") work.
    // So, follow JQUI's pattern of using toLowerCase here, which will lowercase not only the "M' in "Menu", but also any camelcased chars after that.
    $.expr[ ":" ][ modifiedFullName.toLowerCase() ] = function( elem ) {
      return !!$.data( elem, fullName );
    };
  }
};



/**
 * @param {Object} self
 * @param {Object!} options
 * @param {string} prop
 * @param {Function} getter
 * @param {Function=} contextCallback
 * @private
 */
 function _defineDynamicProperty(self, options, prop, getter, contextCallback)
 {
   var override = undefined;
   
   Object.defineProperty(options, prop,
     {
       'get': function()
              {
                if (prop === self._settingOption)
                {
                  // The getter is getting called from the option() method that may be mutating the current
                  // object. We need to return only the override portion in this case to avoid the defaults being
                  // reapplied an override
                  
                  return override || {};
                  
                }
                
                if (override !== undefined && !$.isPlainObject(override))
                {
                  return override;
                }
                 
                var defaults = getter(contextCallback? contextCallback() : prop);
                
                if (!$.isPlainObject(defaults))
                {
                  return (override === undefined) ? defaults : override;
                }
                
                return $.widget.extend({}, defaults||{}, override||{});
              },
       'set': function(value)
              {
                override = value;
              },
       'enumerable' : true
     }
   );
 };
 
 /**
  * @private
  */
 function _getSpecialContainerNames(elem)
 {
    var containers = [];
    while (elem)
    {
      var ga =  elem.getAttribute;
      var name = ga ? ga.call(elem, oj.Components._OJ_CONTAINER_ATTR) : null;
      if (name != null)
      {
        containers.push(name);
      }
      elem = elem.parentNode;
    }
    
    return containers;
 };
 
 /**
  * @private
  */
 function _storeWidgetName(element, widgetName)
 {
   var data = element.data(_OJ_WIDGET_NAMES_DATA);
   if (!data)
   {
     data = [];
     element.data(_OJ_WIDGET_NAMES_DATA, data);
   }
   if (data.indexOf(widgetName) < 0)
   {
     data.push(widgetName);
   }
 }
 
 /**
  * @private
  */
 function _removeWidgetName(element, widgetName)
 {
   var data = element.data(_OJ_WIDGET_NAMES_DATA);
   if (data)
   {
     var index = data.indexOf(widgetName);
     if (index >= 0)
     {
       data.splice(index, 1);
       if (data.length === 0)
       {
         element.removeData(_OJ_WIDGET_NAMES_DATA);
     }
   }
 }
 }
/*jslint browser: true*/
/*
** Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
*/
/**
 * String utilities.
 * @ignore
 */
oj.DomUtils = {};

oj.DomUtils._HTML_START_TAG = "\\x3chtml\\x3e";
oj.DomUtils._HTML_END_TAG = "\\x3c/html\\x3e";
oj.DomUtils._LEGAL_ELEMENTS = {"SPAN":1, "B":1, "A":1, "I":1, "EM":1, "BR":1, "HR":1, "LI":1, "OL":1, "UL":1, "P":1, "TT":1, "BIG":1, "SMALL":1, "PRE":1};
oj.DomUtils._LEGAL_ATTRIBUTES = {"class":1, "style":1, "href":1}; 
/**
 * Returns true if the value is null or if the trimmed value is of zero length.
 * 
 * @param {string|null} content
 * @return {boolean} true if the string is wrapped in <html> tag.
 */        
oj.DomUtils.isHTMLContent = function(content)
{    
  if (content.indexOf(oj.DomUtils._HTML_START_TAG) === 0 && 
      content.lastIndexOf(oj.DomUtils._HTML_END_TAG) === content.length - 7) 
  {
    return true;
  }

  return false;
};

oj.DomUtils.cleanHtml = function (value) 
{
  var offSpan = $(document.createElement("span")).get(0);
  offSpan.innerHTML = value;
  if (value && value.indexOf("\\x3c") >= 0) 
  {
    oj.DomUtils._cleanElementHtml(offSpan);
  }
  return offSpan;
}; 

// TODO: Needs to be verified.
oj.DomUtils._cleanElementHtml = function(node) 
{
  var children = node.childNodes, child, attrs, attr, childHasAttr, i;
  var count = children.length - 1;
  while (count >= 0) 
  {
    child = children.item(count);
    if (child.nodeType === 1) 
    {
      if (oj.DomUtils._LEGAL_ELEMENTS[child.nodeName]) 
      {
        attrs = child.attributes;
        for (i = attrs.length - 1;i >= 0;i--) 
        {
          attr = attrs[i];
          // jquery - the .attr() method returns undefined for attributes that have not been set.
          childHasAttr = $(child).attr(attr) !== undefined;
          if (childHasAttr) 
          {
            if (!oj.DomUtils._LEGAL_ATTRIBUTES[attr.name]) 
            {
              child.removeAttribute(attr.nodeName);
            }
          }
        }
      }
      
      oj.DomUtils._cleanElementHtml(child);
    }
    else 
    {
      node.removeChild(child);
    }
  }
  count--;
};

/**
* Checks to see if the "ancestorNode" is a ancestor of "node".
*
* @param {!Element} ancestorNode dom subtree to check to see if the target node exists
* @param {!Element} node target node to check to see if it exists within a subtree rooted at the ancestorNode
* @return {boolean} <code>true</code> if the "ancestorNode" is a ancestor of "node".
*/
oj.DomUtils.isAncestor = function (ancestorNode, node) 
{
  oj.Assert.assertDomElement(ancestorNode);
  oj.Assert.assertDomElement(node);

  var parentNode = node.parentNode;

  while (parentNode) {
    if (parentNode == ancestorNode)
      return true;

    parentNode = parentNode.parentNode;
  }

  return false;
}

/**
* Checks to see if the "ancestorNode" is a ancestor of "node" or if they are the same.
*
* @param {!Element} ancestorNode dom subtree to check to see if the target node exists
* @param {!Element} node target node to check to see if it exists within a subtree rooted at the ancestorNode
* @return {boolean} <code>true</code> if the "ancestorNode" is a ancestor of "node" or if they are the same 
*/
oj.DomUtils.isAncestorOrSelf = function (ancestorNode, node) 
{
  oj.Assert.assertDomElement(ancestorNode);
  oj.Assert.assertDomElement(node);

  return (node == ancestorNode) ?
          true :
          oj.DomUtils.isAncestor(ancestorNode, node);
};


/**
 * Adds a resize listener for a block or inline-block element
 * @param {!Element} elem - node where the listener should be added
 * @param {!Function} listener - listener to be added. The listener will receive
 * two parameters: 1) the new width in pixels; 2) the new height in pixels
 */
oj.DomUtils.addResizeListener = function(elem, listener)
{
  var jelem = $(elem);
  var tracker = jelem.data(oj.DomUtils._RESIZE_TRACKER_KEY);
  if (tracker == null)
  {
    tracker = new oj.DomUtils._ResizeTracker(elem);
    jelem.data(oj.DomUtils._RESIZE_TRACKER_KEY, tracker);
    tracker.start();
  }
  tracker.addListener(listener);
}

/**
 * Removes a resize listener
 * @param {!Element} elem - node whose listener should be removed
 * @param {!Function} listener - listener to be removed
 */
oj.DomUtils.removeResizeListener = function(elem, listener)
{
  var jelem = $(elem);
  var tracker = jelem.data(oj.DomUtils._RESIZE_TRACKER_KEY);
  if (tracker != null)
  {
    tracker.removeListener(listener);
    if (tracker.isEmpty())
    {
      tracker.stop();
      jelem.removeData(oj.DomUtils._RESIZE_TRACKER_KEY);
    }
  }
};

/**
 * @private
 */
oj.DomUtils._invokeAfterPaint =  (window['requestAnimationFrame'] || window['mozRequestAnimationFrame'] || 
                                  window['webkitRequestAnimationFrame'] || 
                                  function(fn){ return window.setTimeout(fn, 0); }
                                  ).bind(window);

/**
 * Utility class for tracking resize events for a given element and  sispatching them
 * to listeners
 * @constructor
 */
oj.DomUtils._ResizeTracker = function(div)
{
  this._listeners = jQuery.Callbacks();
  
  this.addListener = function(listener)
  {
    this._listeners.add(listener);    
  };
  
  this.removeListener = function(listener)
  {
    this._listeners.remove(listener);    
  };
  
  this.isEmpty = function()
  {
    return this._listeners.empty();
  };
  
  this.start = function()
  {
    var firstChild = div.childNodes[0]; // could be undefined, but insertBefore() will deal with it
    
    // This child DIV will track expansion events. It is meant to be 1px taller and wider than the DIV
    // whose resize events we are tracking. After we set its scrollTop and scrollLeft to 1, any increate in size
    // will fire a scroll event
    this._detectExpansion = document.createElement("div");
    this._detectExpansion.className = "oj-helper-detect-resize";
    var expansionChild = document.createElement("div");
    this._detectExpansion.appendChild(expansionChild);
    div.insertBefore(this._detectExpansion, firstChild);
    
    this._scrollListener = this._handleScroll.bind(this); 
    this._detectExpansion.addEventListener("scroll", this._scrollListener, false);
      
      
    // This child DIV will track contraction events. Its height and width are set to 200%. After we set its scrollTop and 
    // scrollLeft to the current height and width of its parent, any decrease in size will fire a scroll event
    this._detectContraction = document.createElement("div");
    this._detectContraction.className = "oj-helper-detect-resize";
    
    var contractionChild = document.createElement("div");
    contractionChild.style.width = "200%";
    contractionChild.style.height = "200%";
    this._detectContraction.appendChild(contractionChild);
    div.insertBefore(this._detectContraction, firstChild);
     
    this._detectContraction.addEventListener("scroll", this._scrollListener, false);
    
    //Size child DIVs adn recored the current size of the tracked DIV
    this._adjust(this._detectExpansion.offsetWidth, this._detectExpansion.offsetHeight);
  };
  
  this.stop = function()
  {
    this._detectExpansion.removeEventListener("scroll", this._scrollListener);
    this._detectContraction.removeEventListener("scroll", this._scrollListener);
    div.removeChild(this._detectExpansion);
    div.removeChild(this._detectContraction);
  };
  
  
  this._handleScroll = function(evt)
  {
    evt.stopPropagation();
    
    var expDiv = this._detectExpansion;
    
    var newWidth = expDiv.offsetWidth;
    var newHeight = expDiv.offsetHeight;
    if (this._oldWidth != newWidth || this._oldHeight != newHeight)
    {
      this._retrySetScroll = 2;
      this._adjust(newWidth, newHeight);
      
      var listeners = this._listeners;
      oj.DomUtils._invokeAfterPaint(
        function()
        {
          listeners.fire(newWidth, newHeight);
        }
      );
    }
    // Workaround for the WebKit issue where scrollLeft gets reset to 0 without the DIV being expanded
    // We will retry to the set the scrollTop only twice to avoid infinite loops
    else if (this._retrySetScroll > 0 && (expDiv.scrollLeft == 0 || expDiv.scrollTop == 0))
    {
      this._retrySetScroll--;
      this._adjust(newWidth, newHeight);
    }
  };
  
  this._adjust = function(width, height)
  { 
    this._oldWidth = width;
    this._oldHeight = height;
    
    var expansionChild = this._detectExpansion.firstChild;
    expansionChild.style.width = width + 1 + 'px';
    expansionChild.style.height = height + 1 + 'px';
    
    this._detectExpansion.scrollLeft = 1;
    this._detectExpansion.scrollTop = 1;
    
    this._detectContraction.scrollLeft = width;
    this._detectContraction.scrollTop = height;
  };
}

oj.DomUtils._RESIZE_TRACKER_KEY = "_ojResizeTracker";
/*jslint browser: true*/
/**
 * Component Messaging Utilities.
 * @param {Object} component instance
 * @protected
 * @constructor
 */
oj.ComponentMessaging = function (component) 
{
  this.Init(component);
};

// Subclass from oj.Object 
oj.Object.createSubclass(oj.ComponentMessaging, oj.Object, "oj.ComponentMessaging");

/**
 * Default display types supported for component messaging.
 * Future: support for inline 
 * @memberof! oj.ComponentMessaging
 * @const
 * @protected
 */
oj.ComponentMessaging._DISPLAY_TYPE = {
  NONE: "none",
  NOTEWINDOW: "notewindow", 
  PLACEHOLDER: "placeholder"
};

/**
 * Tracks the messaging strategy callback function by type, used to instantiate messaging strategies.
 * Implementations register by type. 
 * @memberof! oj.ComponentMessaging
 * @const
 * @protected
 */
oj.ComponentMessaging._DISPLAY_TYPE_TO_CALLBACK = {};
  
/**
 * Stores the constructor function callback object used to constuct a strategy object for the 
 * specified type.
 * 
 * @param {string} type
 * @param {Function} strategyConstructorCallback a constructor callback that can be used to constuct
 * a strategy object for the specified type
 * @returns {undefined}
 */
oj.ComponentMessaging.registerMessagingStrategy = function (type, strategyConstructorCallback)
{
  if (type && typeof strategyConstructorCallback === "function")
  {
    oj.ComponentMessaging._DISPLAY_TYPE_TO_CALLBACK[type] = strategyConstructorCallback;
  }
};

/**
 * Initializes the strategy based on the display options that specify the messaging artifacts that 
 * will be displayed by this strategy.
 * 
 * @param {Object} component widget instance
 * @memberof! oj.ComponentMessaging
 * @instance
 * @protected
 */
oj.ComponentMessaging.prototype.Init = function (component)
{
  oj.ComponentMessaging.superclass.Init.call(this);
  
  this._component = component;
  this._activated = false;
  
  this._initializeMessagingStrategies();
};

/**
 * Utility function that activates messaging on the component using the strategy provided.
 * @param {Object} launcher element(s) to which messaging applies
 * @param {Object} content 
 * @private
 */
oj.ComponentMessaging.prototype.activate = function (launcher, content)
{
  var that = this;
  oj.Assert.assertObject(content);
  
  // if already active, reinitialize strategies based on new messagingDisplay preferences.
  if (!this._isActive())
  {
    $.each(this._strategies, function(i, strategy) 
    {
      strategy.activate(that._component, launcher, content);
    });
    this._activated = true;
  }
  else
  {
    this._reactivate(launcher, content);
  }
};

/**
 * Utility function that updates messaging on the component for the content provided, using the 
 * strategies.
 * 
 * @param {Object} content 
 * @private
 */
// TODO: component messaging could take the component instance
oj.ComponentMessaging.prototype.update = function (content)
{
  oj.Assert.assertObject(content);
  oj.Assert.assertBoolean(this._activated);
  if (this._activated)
  {
    $.each(this._strategies, function(i, strategy) 
      {
        strategy.update(content);
      });
  }
};

/**
 * Utility function that deactivates messaging on the component using the strategy provided.
 * @param {Object} content 
 * @private
 */
oj.ComponentMessaging.prototype.deactivate = function (content)
{
  oj.Assert.assertObject(content);
  
  $.each(this._strategies, function(i, strategy) 
    {
      strategy.deactivate(content);
    });
    
  this._activated = false;
  this._strategies = {};
};

/**
 * Creates a messaging strategy for the specified type, initializing it with the options provided.
 * @param {string|number} type defined by oj.ComponentMessaging._DISPLAY_TYPE
 * @param {Object|undefined} options
 * 
 * @private
 * @instance
 * @memberOf !oj.ComponentMessaging
 */
oj.ComponentMessaging.prototype._createMessagingStrategy = function (type, options)
{
  var callback = oj.ComponentMessaging._DISPLAY_TYPE_TO_CALLBACK[type] || 
          oj.ComponentMessaging._DISPLAY_TYPE_TO_CALLBACK["none"];
  
  // dynamically instantiate the strategy objects
  return new callback(options);
},

/**
 * Whether the component messaging is activated. 
 * @return {boolean}
 * @private
 */
oj.ComponentMessaging.prototype._isActive = function ()
{
  return this._activated;
};

oj.ComponentMessaging.prototype._getResolvedMessagingDisplayOptions = function ()
{
    var artifactsByDisplayType = {}, index, artifactDisplayTypeResolved = false, messagingStrategies = {}, 
      compPH = this._component.options['placeholder'], artifact, key,
      messagingPreferences = this._component.options['messagingDisplayOptions'] || {},
      $messagingPreferences = {}, self = this;
      
    // first resolve primary display options for each artifact.
    // E.g. at the end of this loop you should have something like this
    // {messages: 'notewindow', converterHint: 'placeholder', validatorHint: 'notewindow', title: 'none'}
    $.each(messagingPreferences, function (key, displayTypes)
      {
        // loop over array of displayTypes preferred for artifact.
        // artifacts are 'messages', 'converterHint', 'validatorHint', 'title'
        artifactDisplayTypeResolved = false;
        artifact = key + "";
        // we take either array or string values for messagingDisplayOptions.
        if (Array.isArray(displayTypes))
        {
          $.each(displayTypes, function(index, displayType)
          {
            if (!artifactDisplayTypeResolved)
            {
              artifactDisplayTypeResolved = 
                self._resolveDisplayTypeForArtifact(artifact, displayType, compPH, $messagingPreferences);
            }
          });
        }
        else if (typeof displayTypes === "string")
        {
          if (!artifactDisplayTypeResolved)
          {
            artifactDisplayTypeResolved = 
              self._resolveDisplayTypeForArtifact(artifact, displayTypes, compPH, $messagingPreferences);
          }
        }
        
        // if we couldn't resolve then use "none" as the default. E.g., validationHint: ['placeholder']
        if (!artifactDisplayTypeResolved)
        {
          $messagingPreferences[artifact] = oj.ComponentMessaging._DISPLAY_TYPE.NONE;
        }
      });
    
    // collate by displayType -> artifact. but first reset 
    $.each(oj.ComponentMessaging._DISPLAY_TYPE, function(type, name){
      artifactsByDisplayType[name] = [];
    });
    
    $.each($messagingPreferences, function(artifact, displayType)
    {
      // an artifact eventually resolves to one displayType. 
      artifactsByDisplayType[displayType].push(artifact);        
    });
    
    return artifactsByDisplayType;
},
        
oj.ComponentMessaging.prototype._resolveDisplayTypeForArtifact = function(
  artifact, 
  displayType, 
  compPH,
  $messagingPreferences)
{
  var artifactDisplayTypeResolved = false;
  switch (displayType)
  {
    // placeholder display is special in that it's only supported on 'converterHint'.
    case oj.ComponentMessaging._DISPLAY_TYPE.PLACEHOLDER :

      if (artifact === "converterHint")
      {
        // if placeholder is the first preference for converterHint, it's used under certain 
        // conditions
        // if options.placeholder is not set then use 'converterHint' as the default 
        // 'placeholder'
        // alternately if (options.placeholder), i.e., a custom placeholder is set, then 
        // ignore the placeholder displayType and use the next display type as the default 
        // for the artifact. We may have a fallback displayType in which case we use it, 
        // otherwise we use 'none'. E.g., 
        // {'converterHint': ['placeholder', 'notewindow']} // use notewindow
        // {'converterHint': ['placeholder']}               // use none

        if (!artifactDisplayTypeResolved)
        {
          if (!compPH)
          {
            $messagingPreferences[artifact] = displayType;
            artifactDisplayTypeResolved = true;
            
          }
        }
      }
      else
      {
        // displayType 'placeholder' is not supported on other artifacts
        // ignore if present
        // TODO: In the future we may want to support configuring validatorHint ot title as 
        // placeholder as well.
      }

      break;

    default:
      if (!artifactDisplayTypeResolved)
      {
        $messagingPreferences[artifact] = displayType;
        artifactDisplayTypeResolved = true;
      }
      break;
  }
  
  return artifactDisplayTypeResolved;
  
},

/**
 * Creates a default messaging strategy for the component based on the messagingOptions.
 * @private
 */
oj.ComponentMessaging.prototype._initializeMessagingStrategies = function ()
{
  var artifactsByDisplayType = this._getResolvedMessagingDisplayOptions(), 
    displayInNoteWindow = artifactsByDisplayType[oj.ComponentMessaging._DISPLAY_TYPE.NOTEWINDOW], 
    displayNone = artifactsByDisplayType[oj.ComponentMessaging._DISPLAY_TYPE.NONE], 
    displayInPlaceholder = artifactsByDisplayType[oj.ComponentMessaging._DISPLAY_TYPE.PLACEHOLDER],
    messagingStrategies = {};
    
  // TODO: A component may have both a notewindow and inline messaging strategy
  if (displayInNoteWindow.length > 0)
  {
    messagingStrategies[oj.ComponentMessaging._DISPLAY_TYPE.NOTEWINDOW] = 
      this._createMessagingStrategy(oj.ComponentMessaging._DISPLAY_TYPE.NOTEWINDOW, displayInNoteWindow);
  }
  
  if (displayInPlaceholder.length > 0)
  {
    messagingStrategies[oj.ComponentMessaging._DISPLAY_TYPE.PLACEHOLDER] = 
      this._createMessagingStrategy(oj.ComponentMessaging._DISPLAY_TYPE.PLACEHOLDER, displayInPlaceholder);
  }
  
  if (displayNone.length > 0)
  {
    // if we are not displaying in notewindow, messagingDisplayOptions are probably set to "none" 
    // so use the default messaging strategy
    messagingStrategies[oj.ComponentMessaging._DISPLAY_TYPE.NONE] = 
      this._createMessagingStrategy(oj.ComponentMessaging._DISPLAY_TYPE.NONE, displayNone);
  }
  
  this._strategies = messagingStrategies;
};

/**
 * Reinitializes component messaging with new messagingDisplayOptions.
 * 
 * @param {Object} launcher element(s) to which messaging applies
 * @param {Object} content 
 * @private
 */
oj.ComponentMessaging.prototype._reactivate = function (launcher, content)
{
  var artifactsByDisplayType = this._getResolvedMessagingDisplayOptions(), strategy, cm = this; 
  
  // for every displayType being requested either create the messaging strategy for the type or 
  // then reuse existing strategy if it has already been created. 
  $.each(artifactsByDisplayType, function(type, artifactsForType) {
    strategy = cm._strategies[type];
    if (artifactsForType && artifactsForType.length > 0)
    {
      if (!strategy )
      {
        // if no notewindow strategy exists create a new one 
        strategy = cm._createMessagingStrategy(type, artifactsForType);
        cm._strategies[type] = strategy;
        strategy.activate(cm._component, launcher, content);
      }
      else if (strategy)
      {
        // update the note window strategy with the latest displayOptions if already present. we don;t 
        // want to remove it once activated.
        strategy.reactivate(artifactsForType, content);
      }
    }
    else
    {
      if (strategy)
      {
        // if we have no artifacts to show for a type, then remove the strategy.
        strategy.deactivate(content);
        delete cm._strategies[type];
      }
    }
  });
};

/**
 * A base strategy class that encapsulates the mechanism by which both the messaging content is 
 * built and the messaging content is shown
 * @param {Array} displayOptions an array of messaging artifacts displayed.
 * 
 * @constructor
 * @class oj.MessagingStrategy
 * @private
 */
oj.MessagingStrategy = function (displayOptions)
{
  this.Init(displayOptions);
};

oj.ComponentMessaging.registerMessagingStrategy(oj.ComponentMessaging._DISPLAY_TYPE.NONE, 
                                                oj.MessagingStrategy);

// TODO: Need to retrieve style selectors from a Style Manager
oj.MessagingStrategy._SELECTOR_STATE_INVALID = "oj-invalid";
oj.MessagingStrategy._SELECTOR_STATE_WARNING = "oj-warning";

// Subclass from oj.Object 
oj.Object.createSubclass(oj.MessagingStrategy, oj.Object, "oj.MessagingStrategy");

/**
 * Initializes the strategy based on the display options that specify the messaging artifacts that 
 * will be displayed by this strategy.
 * 
 * @param {Array} displayOptions an array of messaging artifacts displayed.
 * @private
 */
oj.MessagingStrategy.prototype.Init = function (displayOptions)
{
  oj.Assert.assertArray(displayOptions);
  oj.MessagingStrategy.superclass.Init.call(this);
  
  this._displayOptions = displayOptions;
};


// P U B L I C  M E T H O D S

/**
 * Activates messaging artifacts for a specific component instance using the content provided.
 * 
 * @param {Object} component 
 * @param {Object} launcher the element to which the messaging applies.
 * @param {Object} content an Object literal consisting of content that the messaging strategy will 
 * use to initialize. <br/>
 * Accepted keys are 'validityState', 'converterHint', 'validatorHint', 'title'.<br/>
 * The values are Object (instance of oj.ComponentValidity), string, Array of strings and string 
 * respectively.
 * @private
 */
oj.MessagingStrategy.prototype.activate = function (component, launcher, content)
{
  this._launcher = launcher;
  this._component = component; 
  this._updateMessagingContent(content);
};

/**
 * Updates component with instance using the content provided.
 * 
 * @param {Object} content the updated messaging content 
 * @private
 */
oj.MessagingStrategy.prototype.update = function (content)
{
  this._updateMessagingContent(content);
  var launcher = this.GetLauncher(), maxSeverity = this.GetMaxSeverity(), removeClasses = [], addClasses=[], 
      invalid = false, jqRoot = this.GetComponent().widget();
  
  if (!launcher)
  {
    return;
  }
  
  // apply element error styling
  if (!this.IsValid())
  {
    // enable tooltip; set invalid class and aria invalid
    // TODO: oj classes should be set on the root DOM
    removeClasses.push(oj.MessagingStrategy._SELECTOR_STATE_WARNING);
    addClasses.push(oj.MessagingStrategy._SELECTOR_STATE_INVALID);
    invalid = true;
  }
  else
  {
    // TODO: add warning or other severity state
    if (this.HasMessages() && maxSeverity === oj.Message.SEVERITY_LEVEL['WARNING'])
    {
      removeClasses.push(oj.MessagingStrategy._SELECTOR_STATE_INVALID);
      addClasses.push(oj.MessagingStrategy._SELECTOR_STATE_WARNING);
    }
    else
    {
      // for all other messages we remove selectors
      removeClasses.push(oj.MessagingStrategy._SELECTOR_STATE_INVALID);
      removeClasses.push(oj.MessagingStrategy._SELECTOR_STATE_WARNING);
    }
  }
  jqRoot.removeClass(removeClasses.join(" "))
          .addClass(addClasses.join(" ")); // classes added to root
  launcher.attr({"aria-invalid": invalid}); // aria attrs added to the launcher element
  
};

/**
 * Cleans up messaging artifacts that were created on the component instance. E.g., destroys any 
 * widgets it created, removes styles added etc.
 * 
 * @param {Object} content the messaging content
 * @private
 */
oj.MessagingStrategy.prototype.deactivate = function (content)
{
  var jqRoot = this.GetComponent().widget();
  
  jqRoot.removeClass(oj.MessagingStrategy._SELECTOR_STATE_INVALID)
                  .removeClass(oj.MessagingStrategy._SELECTOR_STATE_WARNING);
  this.GetLauncher().removeAttr("aria-invalid")
                  .removeAttr("aria-describedby");
  this._launcher = null;
  this._component = null;
};

/**
 * Reinitializes with the new display options and updates component messaging using the new content. 
 * 
 * @param {Array} newDisplayOptions
 * @param {Object} content
 * @private
 */
oj.MessagingStrategy.prototype.reactivate = function (newDisplayOptions, content)
{
  this.Init(newDisplayOptions);
  this.update(content);
};

// P R O T E C T E D  M E T H O D S 
/**
 * Gets the launcher element for which the messaging is applied.
 * @return {Object} the jquery element of the form element.
 * @private
 */
oj.MessagingStrategy.prototype.GetLauncher = function ()
{
  return this._launcher;
};

/**
 * Gets the component (widget).
 * @return {Object} the jet component instance
 * @private
 */
oj.MessagingStrategy.prototype.GetComponent = function ()
{
  return this._component;
};


/**
 * Returns an array of messages.
 * 
 * @return {Array} of messages each an instance of oj.Message
 * @private
 */
oj.MessagingStrategy.prototype.GetMessages = function ()
{
  return this.GetValidityState().getMessages();
};

oj.MessagingStrategy.prototype.GetMaxSeverity = function ()
{
  return this.GetValidityState().getMaxSeverity();
};

/**
 * Gets the converter hint.
 * 
 * @return {Array} an array of hints, each a string.
 * @private
 */
oj.MessagingStrategy.prototype.GetConverterHint = function ()
{
  var hints = [], converterHint = this._messagingContent['converterHint'], hint;
  if (converterHint)
  {
    hints.push(converterHint);
  }
  
  return hints;
};

oj.MessagingStrategy.prototype.GetValidatorHints = function ()
{
  var hints = [], vHints = this._messagingContent['validatorHint'] || [];
  $.each(vHints, function (index, hint)
    {
      hints.push(hint);
    }
  );
  
  return hints;
};


/**
 * Gets the short description.
 * @return {string} title or ""
 * @private
 */
oj.MessagingStrategy.prototype.GetTitle = function ()
{
  return this._messagingContent['title'] || ""; 
};

/**
 * Gets the validityState.
 * @private
 */
oj.MessagingStrategy.prototype.GetValidityState = function ()
{
  return this._messagingContent['validityState'];
};

/**
 * Whether the strategy is displaying messages or not.
 * @return {boolean} true if strategy has messages to display
 * @private
 */
oj.MessagingStrategy.prototype.HasMessages = function ()
{
  var messages = this.GetMessages();
  return (messages && messages.length > 0) ? true: false;
};

oj.MessagingStrategy.prototype.ShowMessages = function ()
{
  return this._displayOptions.indexOf('messages') !== -1 ? true : false;
};

oj.MessagingStrategy.prototype.ShowConverterHint = function ()
{
  return this._displayOptions.indexOf('converterHint') !== -1 ? true : false;
};

oj.MessagingStrategy.prototype.ShowValidatorHint = function ()
{
  return this._displayOptions.indexOf('validatorHint') !== -1 ? true : false;
};

oj.MessagingStrategy.prototype.ShowTitle = function ()
{
  return this._displayOptions.indexOf('title') !== -1 ? true : false;
};

/**
 * Returns true if component is currently valid; false otherwise.
 * 
 * @return {boolean} true if valid; false if not.
 * @private
 */
oj.MessagingStrategy.prototype.IsValid = function ()
{
  return this.GetValidityState().isValid();
};

/**
 * Sets the component current validityState. 
 * @param {Object} content
 * @private
 */
oj.MessagingStrategy.prototype._updateMessagingContent = function (content)
{
  this._messagingContent = $.extend(this._messagingContent || {}, content);
};

/**
 * A messaging strategy that uses html5 placeholder (for now) to set/remove placeholder content.
 * 
 * @param {Array} displayOptions an array of messaging artifacts displayed in the placeholder.
 * @constructor
 * @extends {oj.MessagingStrategy}
 * @private
 */
oj.PlaceholderMessagingStrategy = function(displayOptions)
{
  this.Init(displayOptions);
};

oj.ComponentMessaging.registerMessagingStrategy(oj.ComponentMessaging._DISPLAY_TYPE.PLACEHOLDER, 
                                                oj.PlaceholderMessagingStrategy);

// Subclass from oj.MessagingStrategy 
oj.Object.createSubclass(oj.PlaceholderMessagingStrategy, oj.MessagingStrategy, "oj.PlaceholderMessagingStrategy");

/**
 * Initializer
 *  
 * @param {Array} displayOptions an array of messaging artifacts displayed in the notewindow.
 * @private
 */
oj.PlaceholderMessagingStrategy.prototype.Init = function (displayOptions) 
{
  oj.PlaceholderMessagingStrategy.superclass.Init.call(this, displayOptions);
};

/**
 * Sets up a placeholder for the component instance using the converter hint.
 * 
 * @param {Object} component widget instance
 * @param {Object} launcher element for which the messaging applies. 
 * @param {Object} content the messaging content
 * @private
 * 
 */
oj.PlaceholderMessagingStrategy.prototype.activate = function (component, launcher, content)
{
  oj.PlaceholderMessagingStrategy.superclass.activate.call(this, component, launcher, content);
  this._refreshPlaceholder();
};

oj.PlaceholderMessagingStrategy.prototype.update = function (content)
{
  oj.PlaceholderMessagingStrategy.superclass.update.call(this, content);
  this._refreshPlaceholder();
};

oj.PlaceholderMessagingStrategy.prototype.deactivate = function (content)
{
  oj.PlaceholderMessagingStrategy.superclass.deactivate.call(this, content);
};

// a default placeholder is set on the component, and that is typically the converter hint
oj.PlaceholderMessagingStrategy.prototype._refreshPlaceholder = function()
{
  var launcher = this.GetLauncher(), jqRoot = this.GetComponent().widget(), content, hints;
  
  if (this.ShowPlaceholderContent() && launcher)
  {
    hints = this.GetConverterHint();
    content = hints.length ? hints[0] : "";
    if (content)
    {
      var values = {};
      values['placeholder'] = content;
      values['_oj_messaging_update'] = true; // to indicate to component that placeholder is being 
                                             // set from messaging module 

      this.GetComponent().option(values);
    }
  }
};

oj.PlaceholderMessagingStrategy.prototype.ShowPlaceholderContent = function ()
{
  // we have a placeholder to set/show if we have converterHint set.
  return this.ShowConverterHint();
};

/**
 * The ComponentValidity object represent a component's current validity state. The instance 
 * provides specific methods to retrieve info such as <p>
 *  - whether the component is valid <p>
 *  - the messages currently tracked on the component.<p>
 *  - the max severity level of the messages, e.g., fatal, error etc. See oj.Message for details
 * 
 * @param {boolean} valid
 * @param {Array} messages
 * @param {number} maxSeverity
 * @constructor
 * @private
 */
oj.ComponentValidity = function(valid, messages, maxSeverity)
{
  // TODO: provide methods that allow model implementations to instruct the elements to showMessages, 
  // especially the ones marked for 'lazy' notification. 
  this.Init(valid, messages, maxSeverity);
};

// Subclass from oj.Object 
oj.Object.createSubclass(oj.ComponentValidity, oj.Object, "oj.ComponentValidity");

/**
 * The jquery element whose validity this object describes
 * @param {boolean} valid
 * @param {Array} messages instances of oj.Message
 * @param {number} maxSeverity
 */
oj.ComponentValidity.prototype.Init = function (valid, messages, maxSeverity) 
{
  oj.ComponentValidity.superclass.Init.call(this);
  this._valid = valid;
  this._messages = messages;
  this._maxSeverity = maxSeverity;
  
};

/**
 * Returns a boolean true if valid; false if element not valid
 * @returns {boolean}
 * @private
 */
oj.ComponentValidity.prototype.isValid = function () 
{
  return this._valid;
};

/**
 * Returns an Array or messages or an empty array.
 * @private
 * @returns {Array}
 */
oj.ComponentValidity.prototype.getMessages = function () 
{
  if (this._messages)
  {
    return this._messages;
  }
  return [];
};

/**
 * Returns the max severity level.
 * @return {number}
 * @private
 */
oj.ComponentValidity.prototype.getMaxSeverity = function () 
{
  return this._maxSeverity;
};

/**
 * Updates the validity state for the component.
 * 
 * @param {boolean} valid
 * @param {Array} messages instances of oj.Message
 * @param {number} maxSeverity
 * @private
 */
oj.ComponentValidity.prototype.update = function (valid, messages, maxSeverity)
{
  this._valid = valid;
  this._messages = messages;
  this._maxSeverity = maxSeverity;
};

/**
 * Returns a cloned object literal representing the current validity of component. 
 * @return {Object} a literal with the following names and values
 * <ul>
 *   <li>'messages': an array of message object, each a object literal containing string name value 
 *   pairs of 'summary', 'detail', 'severity'</li>
 *   <li>'valid': a boolean true if valid; false otherwise</li>
 *   <li>'maxSeverity': a string severity type. Values are as defined in oj.Message.SEVERITY_TYPE</li>
 * </ul>
 * @private 
 */
oj.ComponentValidity.prototype.__getJSON = function () 
{
  // TODO: messages may need to be normalized
  return {
           'messages': $.extend([], this._messages),
           'valid': this._valid,
           'maxSeverity': this._maxSeverity
         };
  
};


// Copyright (c) 2013, Oracle and/or its affiliates. 
// All rights reserved.

/*jslint browser: true*/

/**
 * @export
 * @class
 * Common test support in JavaScript
 */ 
oj.Test = {}; 


/**
 * @export
 * @type {boolean} 
 * A global application flag that can be set by a test to indicate that all page startup processing is done
 * and an external automated test can begin
 */
oj.Test.ready = false;

/**
 * @export
 * Return the node found given the locator
 * @param {Object|string} locator A locator which is either a JSON string (to be parsed using $.parseJSON), or an Object with the following properties:
 *                                             element: the component's selector, determined by the test author when laying out the page
 *                                             component: optional - in the future there may be more than one component contained within a page element
 *                                             subId: the string, documented by the component, that the component expects in getNodeBySubId to locate a particular subcomponent
 *  @returns {Object} the subcomponent located by the subId string passed in locator, if found.
 */
oj.Test.domNodeForLocator = function(locator) {   
    var locObj = locator;
    if (oj.StringUtils.isString(locator)) {
        var locStr = /** @type {string} */ (locator);
        try {
            locObj = $.parseJSON(locStr);
        }
        catch (e) {
            return null;
        }
    }
    if (locObj && locObj['element']) {
        var element = $(locObj['element']);
        if (element) {
            var widgetConst = oj.Components.getWidgetConstructor(element[0], locObj['component']);
            return widgetConst("getNodeBySubId", {'subId' : locObj['subId']});
        }
    }
    return null;
};




/*jslint browser: true*/
/**
 * in some OS/browser combinations you can attempt to detect high contrast mode
 * in javascript, go to the url below and look for "High Contrast"
 * http://www.w3.org/TR/wai-aria-practices/
 * 
 * This function uses a variation of the code in the "High Contrast" section of  
 * the site above to try and detect high contrast mode
 * by script, but it by no means definitively tells you whether or not you
 * are actually in high contrast mode. As discussed at the url above you 
 * may need to have a user preference setting for high contrast.
 * 
 * If the script is able to detect high contrast mode it sets the class 
 * "oj-hicontrast" on the body tag. When "oj-high-contrast" is present 
 * JET provides alternate informational images that are specially designed 
 * for high contrast users. 
 * @private
 */
function _ojHighContrast()
{
  // using a data uri, I googled for shortest uri to get this one since 
  // I don't care about the actual image, but I do want a legit image
  // otherwise I see an error in chrome and I don't want users to be
  // confused by seeing any error.

  var div = $("<div style='border: 1px solid;border-color:red green;position: absolute;top: -999px;background-image: url(data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=);'></div>"), bki;
  div.appendTo("body");

  bki = div.css("backgroundImage");
  //console.log("background-image:" + bki);
  //console.log("borderTopColor == borderRightColor: ", div.css("borderTopColor") == div.css("borderRightColor"));
  if (div.css("borderTopColor") == div.css("borderRightColor") ||
      (bki != null && (bki == 'none' || bki == 'url (invalid-url:)')))
  {
    $('body').addClass("oj-hicontrast");
  }

  div.remove();
}

$(document).ready(function() {
  _ojHighContrast();
});
/*jslint browser: true*/
/**
 * @private
 */
function _ojSlowCSS()
{
  if (navigator.appName == 'Microsoft Internet Explorer')
  {
    $('html').addClass("oj-slow-borderradius oj-slow-cssgradients oj-slow-boxshadow");
  }

}

$(document).ready(function() {
  _ojSlowCSS();
});
/*jslint browser: true*/
/*
** Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
*/
/**
 * Utilities used in conjunction with the jquery positon utility.
 * @ignore
 */
oj.PositionUtils = {};

/**
 * Of the properties on the position object, "my" and "at" are of intrest. The base jquery
 * horizontal alignment mnemonics are "right", "center" and "left". For better Jet RTL
 * support we have added "start" and "end".  Depending on the rtl direction, "start" and
 * "end" will be replaced with "left" or "right". The resultant postion object will
 * be a new instance that extends the postion passed as the first argument.
 * 
 * @param {Object} position source position object
 * @param {boolean} isRtl 
 * @return {Object} position object that has normalized jquery horizontal mnemonics.
 */        
oj.PositionUtils.normalizeHorizontalAlignment = function(position, isRtl)
{
  oj.Assert.assertObject(position, "position");
  var target = $.extend({}, position);  
  for (var i = 0; i < oj.PositionUtils._ALIGN_RULE_PROPERTIES.length; i++)
  {
    var propName = oj.PositionUtils._ALIGN_RULE_PROPERTIES[i];
    var align = target[propName];
    if (align)
      target[propName] = align.replace("start", (isRtl ? "right" : "left"))
                              .replace("end", (isRtl ? "left" : "right"));
  } 

  return target;
};

oj.PositionUtils._ALIGN_RULE_PROPERTIES = ['my', 'at'];
/**
 * A messaging strategy that uses an instance of ojPopup component to show and hide messaging content.
 * 
 * @param {Array} displayOptions an array of messaging artifacts displayed in the popup.
 * @constructor
 * @extends {oj.MessagingStrategy}
 * @private
 */
oj.PopupMessagingStrategy = function (displayOptions)
{
  this.Init(displayOptions);
};

/**
 * Registers the PopupMessagingStrategy constructor function with oj.ComponentMessaging. 
 * 
 * @private
 */
oj.ComponentMessaging.registerMessagingStrategy(oj.ComponentMessaging._DISPLAY_TYPE.NOTEWINDOW, 
                               oj.PopupMessagingStrategy);
                               
// Subclass from oj.MessagingStrategy 
oj.Object.createSubclass(oj.PopupMessagingStrategy, oj.MessagingStrategy, "oj.PopupMessagingStrategy");

/**
 * Messaging popup defaults for components, by component type. A special 'default' type defines the 
 * defaults for most editableValue components. 
 * The following properties are available - 
 * 'events' - these specify the on handlers for events that are setup to open and close popups
 * 'position' - specifies the type of element the popup is positioned against.
 * @private
 */
oj.PopupMessagingStrategy._DEFAULTS_BY_COMPONENT = 
{
  "ojRadioset": 
  {
    position: 'launcher', 
    events: {open: "focusin mouseover", close: "mouseout"}
  },
  "ojCheckboxset": 
  {
    position: 'launcher', 
    events: {open: "focusin mouseover", close: "mouseout"}
  },
  "default": 
  {
    events: {open: "focusin"}
  }
};

/**
 * Initializes the popup messaging strategy.
 *  
 * @param {Array} displayOptions an array of messaging artifacts displayed in the popup.
 * @private
 */
oj.PopupMessagingStrategy.prototype.Init = function (displayOptions) 
{
  oj.PopupMessagingStrategy.superclass.Init.call(this, displayOptions);
};

/**
 * Sets up a tooltip for the component instance using the messaging content provided. 
 * 
 * @param {Object} component widget instance
 * @param {Object} launcher element that laucnhes the messaging popup. 
 * @param {Object} content the messaging content
 * @private
 * 
 */
oj.PopupMessagingStrategy.prototype.activate = function (component, launcher, content)
{
  oj.PopupMessagingStrategy.superclass.activate.call(this, component, launcher, content);
  this._initMessagingPopup();
  
  // Since activate can be called anytime widget is initialized we want to make sure and update its 
  // state
  this.update(content);
};


/**
 * Updates the tooltip content associated to the component instance using the updated messaging 
 * content provided. 
 * 
 * @param {Object} content the messaging content
 * @private
 * 
 */
oj.PopupMessagingStrategy.prototype.update = function (content)
{
  oj.PopupMessagingStrategy.superclass.update.call(this, content);
};

/**
 * Cleans up messages on the component and destroys any widgets it created.
 * 
 * @param {Object} content the messaging content
 * @private
 */
oj.PopupMessagingStrategy.prototype.deactivate = function (content)
{
  var self = this, compDefaults = 
    oj.PopupMessagingStrategy._DEFAULTS_BY_COMPONENT[this.GetComponent().widgetName],
      events = compDefaults ? compDefaults.events : 
                  oj.PopupMessagingStrategy._DEFAULTS_BY_COMPONENT["default"].events;
  
  // Remove event handlers setup on launcher
  if (events['open'])
  {
    this.GetLauncher().off(events['open'], self._openPopup);
  }
  
  if (events['close'])
  {
    this.GetLauncher().off(events['close'], self._closePopup);
  }
  this._destroyTooltip();
  oj.PopupMessagingStrategy.superclass.deactivate.call(this, content);
};

oj.PopupMessagingStrategy.prototype.reinitialize = function (newDisplayOptions)
{
  oj.PopupMessagingStrategy.superclass.reinitialize.call(this, newDisplayOptions);
};

/**
 * 
 * @param {Event} event Opens a popup. This handler is called in the context of 
 * the launcher usually the this.element or some relevant node the messaging 
 * popup is associated to.
 * @property {Object} event.data.strategy the strategy object 
 * @private
 */
oj.PopupMessagingStrategy.prototype._openPopup = function (event)
{
  var self = event.data && event.data['strategy'];
  // window.console.log(event.type + " called: tooltip opened");
  var latestContent = self._buildPopupHtml();
  if (self._isPopupInitialized() && latestContent)
  {
    // replace popup messaging content with new content
    self.$messagingContentRoot.empty();
    self.$messagingContentRoot.append(latestContent);
    self.$messagingContentRoot.ojPopup("open", self.GetLauncher());
  }
};

oj.PopupMessagingStrategy.prototype._closePopup = function (event)
{
  // window.console.log(event.type + " called; tooltip closed");
  //$(this).tooltip("disable").tooltip('close');
  var self = event.data && event.data['strategy'];
  self.$messagingContentRoot.ojPopup("close", self.GetLauncher());
};

oj.PopupMessagingStrategy.prototype._handleMouseLeave = function (e)
{
  // needed to turn off default open of tooltip for mouseleave. 
  // window.console.log(event.type + " called: turning off default open of tooltip");
  e.preventDefault();
  e.stopImmediatePropagation(); 
  return false;
};

// Associates the ojPopup component to the messaging content root.
oj.PopupMessagingStrategy.prototype._initMessagingPopup = function ()
{
  var self = this; 
  if (!this._isPopupInitialized())
  {
    var jqLauncher = this.GetLauncher(), popupOptions, jPositionOf = this._getPopupPosition(),
        compDefaults = 
        oj.PopupMessagingStrategy._DEFAULTS_BY_COMPONENT[this.GetComponent().widgetName],
        events = compDefaults ? compDefaults.events : 
                  oj.PopupMessagingStrategy._DEFAULTS_BY_COMPONENT["default"].events;
    
    // 1. associate the ojPopup component to wrapper <div> for popup content
    // 2. remember the popup content root
    // 3. wire up on() event handlers for registered events that open and close popup. E.g., focusin.
    // 4. autoDismissal happens automatically when focus leaves component. For other events like 
    // mouseover it's required to call off() 
    
    this.$messagingContentRoot = $(this._getPopupContentHtml());
    // append to body instead of component root as styles set on it can bleed through
    $("body").append(this.$messagingContentRoot);
    popupOptions = {initialFocus: 'none', 
                         tail: 'simple', 
                         autoDismiss: 'focusLoss', 
                         position: {my: 'start bottom', at: 'end top', collision: 'flipfit', 
                                    of: jPositionOf}};
               
    this.$messagingContentRoot.ojPopup(popupOptions);
      
    if (events['open'])
    {
      jqLauncher.on(events['open'], {'strategy': self}, self._openPopup);
    }
    if (events['close'])
    {
      jqLauncher.on(events['close'], {'strategy': self}, self._closePopup);
    }
  }
};

/**
 * Returns the jquery element popup should be position on. We always position on tip of component 
 * root unless specifically overridden. Components like radion and checkboxset use the launcher, 
 * which in the inputs
 * @private
 */
oj.PopupMessagingStrategy.prototype._getPopupPosition = function()
{
  var compDefaults = 
    oj.PopupMessagingStrategy._DEFAULTS_BY_COMPONENT[this.GetComponent().widgetName];
  
  if (compDefaults)
  {
    if (compDefaults.position && compDefaults.position === "launcher")
    {
      return this.GetLauncher();
    }
  }
  
  return this.GetComponent().widget();
};

oj.PopupMessagingStrategy.prototype._getPopupContentHtml = function ()
{
  return "" + "<div class='oj-messaging-popup-container'></div>"; 
};

oj.PopupMessagingStrategy.prototype._destroyTooltip = function ()
{
  if (this._isPopupInitialized())
  {
    if (this.$messagingContentRoot)
    {
      this.$messagingContentRoot.ojPopup("destroy");
      this.$messagingContentRoot.remove();
    }
  }
};

/**
 * Returns the content to show inside popup.
 * @private
 * @return {String|string} content
 */
oj.PopupMessagingStrategy.prototype._buildPopupHtml = function ()
{
  var nwHtml = "", component = this.GetComponent(), jDocument = component.document, 
          document = jDocument[0], nwContent = [], addSeparator = false, that = this; 
  
  if (this.ShowMessages()) 
  {
    nwContent.push(this._buildMessagesHtml());
  }
  
  if (this.ShowConverterHint() || this.ShowValidatorHint())
  {
    nwContent.push(this._buildHintsHtml(document));
  }
  if (this.ShowTitle())
  {
    nwContent.push(this._buildTitleHtml(document));
  }
  
  // TODO: Add support for shortDesc, instrcution text etc.
  $.each(nwContent, function(i, content) 
    {
      if (content)
      {
        if (addSeparator)
        {
          nwHtml = nwHtml.concat(that._getSeparatorHtml(document));
        }
        else
        {
          addSeparator = true; 
        }
        
        nwHtml = nwHtml.concat(content);
      }
    });
    
  return nwHtml;
};

/**
 * Returns the content to show inside tooltip.
 * @private
 * @return {string} content
 */
oj.PopupMessagingStrategy.prototype._buildMessagesHtml = function ()
{
  var messages, content = "", i, j, severity, severityStr,severityLevel,
          message, maxSeverity = this.GetMaxSeverity(), summary, detail, messageObj, 
          messagesByTypes={}, messagesByType = [];

  if (this.HasMessages())
  {
    messages = this.GetMessages();
    
    // Step1: build an indexed array of messages by severity level.
    for (i = 0; i < messages.length; i++)
    {
      message = messages[i];
      
      if (!(message instanceof oj.Message))
      {
        messageObj = new oj.Message(message['summary'], message['detail'], message['severity']);
      }
      else
      {
        messageObj = message;
      }
      
      severityLevel = oj.Message.getSeverityLevel(messageObj['severity']);
      if (!messagesByTypes[severityLevel])
      {
        messagesByTypes[severityLevel] = [];
      }
      
      messagesByTypes[severityLevel].push(messageObj);
    }
    
    // Step 2: starting with maxSeverity level build messages with decreasing severity
    for (i = maxSeverity; i >= oj.Message.SEVERITY_LEVEL['CONFIRMATION']; i--)
    {
      messagesByType = messagesByTypes[i] || [];
      
      for (j = 0; j < messagesByType.length; j++)
      {
        message = messagesByType[j];
        oj.Assert.assertPrototype(message, oj.Message);

        severityLevel = oj.Message.getSeverityLevel(message['severity']);
        severityStr = this._getSeverityTranslatedString(severityLevel);
        summary = message['summary'] || severityStr;
        // if detail is empty we don't care to duplicate summary
        detail = message['detail'] || "";
        
        // build message dom
        // (x) <Summary Text>
        // <Detail Text>
        
        content = content.concat("<div class='oj-message'>")
                         .concat("<span class='" + this._getSeverityIconSelector(severityLevel) + 
                                      "' title='" + severityStr + "' role='img'></span>")
                         .concat("<span class='oj-message-content'>")
                         .concat("<div class='oj-message-summary'>" + summary + "</div>");
        if (detail)
        {
          content = content.concat("<div class='oj-message-detail'>" + detail + "</div>");
        }
        
        content = content.concat("</div>"); // end of oj-message
      }
    }
  }  
  return content;
};

/**
 * @param {Document} document
 * @return {string} html content for all hints.
 * @private
 */
oj.PopupMessagingStrategy.prototype._buildHintsHtml = function (document)
{
  var hints = [], jHintsDom, i;
  if (this.ShowConverterHint())
  {
    hints = hints.concat(this.GetConverterHint());
  }
  if (this.ShowValidatorHint())
  {
    hints = hints.concat(this.GetValidatorHints());
  }
  
  if (hints && hints.length > 0)
  {
    jHintsDom = $(document.createElement("div"));
    jHintsDom.addClass("oj-form-control-hint");
    // AdfDomUtils.addCSSClassName(hDom, AdfDhtmlEditableValuePeer._NOTE_WINDOW_HINT_TEXT_STYLE_CLASS);
    
    for(i = 0; i < hints.length;i++) 
    {
      jHintsDom.append(this._getHintDom(document, hints[i]));
    }
  }
  
  return jHintsDom ? jHintsDom.get(0).outerHTML : "";
};

oj.PopupMessagingStrategy.prototype._buildTitleHtml = function (document)
{
  var title = this.GetTitle(), jTitleDom;
  if (title)
  {
    jTitleDom = $(document.createElement("div"));
    jTitleDom.addClass("oj-form-control-title");
    jTitleDom.append(this._getHintDom(document, title));
  }
  
  return jTitleDom ? jTitleDom.get(0).outerHTML : "";
};

oj.PopupMessagingStrategy.prototype._getHintDom = function(document, hintText) 
{
  var jHintDom = null;
  // 
  if (oj.DomUtils.isHTMLContent(hintText)) 
  {
    jHintDom = oj.DomUtils.cleanHtml(hintText.substring(6, hintText.length - 7));
  }
  else 
  {
    jHintDom = $(document.createElement("div"));
    jHintDom.text(hintText);
    jHintDom = jHintDom.get(0);
  }
    
  return jHintDom;
}; 

oj.PopupMessagingStrategy.prototype._getSeparatorHtml = function (document)
{
  var jSeparatorDom; 
  jSeparatorDom = $(document.createElement("hr"));
  
  return jSeparatorDom ? jSeparatorDom.get(0).outerHTML : "";
};


oj.PopupMessagingStrategy.prototype._getSeverityTranslatedString = function (severity)
{
  var sevTypeStr;
  // get the translated string for the severity
  switch (severity)
  {
    case oj.Message.SEVERITY_LEVEL['FATAL']:
      sevTypeStr = oj.Translations.getTranslatedString('oj-message.fatal');
      break;
    case oj.Message.SEVERITY_LEVEL['ERROR']:
      sevTypeStr = oj.Translations.getTranslatedString('oj-message.error');
      break;
    case oj.Message.SEVERITY_LEVEL['WARNING']:
      sevTypeStr = oj.Translations.getTranslatedString('oj-message.warning');
      break;
    case oj.Message.SEVERITY_LEVEL['INFO']:
      sevTypeStr = oj.Translations.getTranslatedString('oj-message.info');
      break;
    case oj.Message.SEVERITY_LEVEL['CONFIRMATION']:
      sevTypeStr = oj.Translations.getTranslatedString('oj-message.confirmation');
      break;
  }
  
  return sevTypeStr;
  
};

oj.PopupMessagingStrategy.prototype._getSeverityIconSelector = function (severity)
{
  var sevIconStr;
  // get the icon selector for the severity
  switch (severity)
  {
    case oj.Message.SEVERITY_LEVEL['FATAL']:
      sevIconStr = 'oj-message-error-icon';
      break;
    case oj.Message.SEVERITY_LEVEL['ERROR']:
      sevIconStr = 'oj-message-error-icon';
      break;
    case oj.Message.SEVERITY_LEVEL['WARNING']:
      sevIconStr = 'oj-message-warning-icon';
      break;
    case oj.Message.SEVERITY_LEVEL['INFO']:
      sevIconStr = 'oj-message-info-icon';
      break;
    case oj.Message.SEVERITY_LEVEL['CONFIRMATION']:
      sevIconStr = 'oj-message-confirmation-icon';
      break;
  }
  
  return "oj-widget-icon" + " " + sevIconStr;
};

oj.PopupMessagingStrategy.prototype._isPopupInitialized = function ()
{
  return (this.$messagingContentRoot) ? 
    this.$messagingContentRoot.is(":oj-popup") : false;
};


/**
 * @class
 * @abstract
 * @name oj.editableValue
 * @augments oj.baseComponent
 * 
 * @description Abstract base class for all editable components that are value holders. Any 
 * component that provides 'value' option to set/get the value(s) will extend from this class. <p>
 * 
 * @example <caption>Initialize component value using options</caption>
 * &lt;input id="foo" type="text"/&gt;
 * &lt;script&gt;
 * &nbsp;&nbsp;$('#foo").ojInputText({'value': 'abc'});
 * &lt;/script&gt;
 * // using knockout ojComponent binding
 * &lt;input id="foo" data-bind="ojComponent: {component: 'ojInputText', value: 'abc'}"/&gt;
 * @example <caption>Initialize component value using ko observable</caption>
 * &lt;input id="foo" data-bind="ojComponent: {component: 'ojInputText', value: salary}"/&gt;
 * &lt;script&gt;
 * &nbsp;&nbsp;var salary = ko.observable('abc');
 * &lt;/script&gt;
 * @example <caption>Initialize component value using element value</caption>
 * &lt;input id="foo" data-bind="ojComponent: {component: 'ojInputText'}" value='abc'/&gt;
 * 
 * @constructor
 */
oj.editableValue = $.widget('oj.editableValue', $['oj']['baseComponent'], 
/** @lends oj.editableValue.prototype */
{
  widgetEventPrefix: "oj",
  
  options: 
  {
    /** 
     * a converter instance, where each instance duck types oj.Converter, or an converter object 
     * literal containing the following name value pair. 
     * <ul>
     *   <li><i>type</i>: the string conveter type registered with the ConverterFactory. Supported 
     *   types are 'number' and 'datetime'</li>
     *   <li><i>options</i>: an optional Object literal of options that the converter expects.</li>
     * </ul>
     * 
     * If the converter option changes after the component has been initialized then <br/>
     * - if the component is valid, the value option is formatted using the new converter instance and the 
     *   display updated with the new value.<br/>
     * - otoh, if the component is invalid when the converter option changed, it is the 
     * responsibility of the page author to clear messages on the component and reset the value if 
     * needed.<br/>
     * 
     * @example <caption>Initialize the component with converter object literal:</caption>
     * $(".selector").ojInputText({
     *   value: 25000,
     *   converter: {
     *     type: 'number', 
     *     options : {
     *       style: 'currency', 
     *       currency: 'USD', 
     *       maximumFractionDigits: 0
     *     }
     *   }
     * });
     * 
     * @example <caption>Initialize the component with a number converter instance:</caption>
     * // Initialize converter instance using currency options
     * var options = {style: 'currency', 'currency': 'USD', maximumFractionDigits: 0};
     * var numberConverterFactory = oj.Validation.converterFactory("number");
     * var salaryConverter = numberConverterFactory.createConverter(options);<br/>
     * // set converter instance using converter option
     * $(".selector").ojInputText({
     *   value: 25000, 
     *   converter: salaryConverter
     * });
     * 
     * @expose 
     * @access public
     * @instance
     * @memberof! oj.editableValue
     * @type {string|Object|undefined}
     */    
    converter: undefined,

    /** 
     * whether the component is disabled. 
     *  
     * <p>The 2-way <code class="prettyprint">disabled</code> binding offered by 
     * the <code class="prettyprint">ojComponent</code> binding 
     * should be used instead of Knockout's built-in <code class="prettyprint">disable</code> 
     * and <code class="prettyprint">enable</code> bindings, 
     * as the former sets the API, while the latter sets the underlying DOM attribute.
     * 
     * @example <caption>Initialize component with <code class="prettyprint">disabled</code> option:</caption>
     * $(".selector").ojInputText({"disabled": true});
     * 
     * @expose 
     * @type {?boolean|undefined}
     * @default <code class="prettyprint">false</code>. The element's disabled property is used as 
     * its initial value if it exists, when the option is not explicitly set. When neither is set, 
     * disabled defaults to false.
     * @public
     * @instance
     * @memberof! oj.editableValue
     */
    disabled: undefined,
    
    /**
     * The help information that goes on the label. When help is set on the input component, then 
     * help information is added to the input's label. The help options are:
     * <ul>
     * <li>definition - this is the help definition text. It is what shows up
     * when the user hovers over the label or the help icon.</li>
     * <li>source - this is the help source url. If present, a help icon will
     * render next to the label and the anchor's target is this source.
     * </ul>
     * 
     * @expose 
     * @memberof! oj.editableValue
     * @instance
     * @type {Object.<string, string>}
     * @default <code class="prettyprint">{ "definition":"some help definition, "source":"some external url" }</code>
     * 
     * @example <caption>Initialize the input with the help definition and external url information:</caption>
     * $( ".selector" ).ojRadioset({ "help": {"definition":"some help definition, "source":"some external url" } });
     * 
     * @example <caption>Set the <code class="prettyprint">help</code> option, after initialization:</caption>
     *
     * // setter
     * $( ".selector" ).ojRadioset( "option", "help", {"definition":"fill out the name", "source":"http:\\www.oracle.com" } );
     */
    help: {definition: null, source: null},
    
    /** 
     * an array of messages for this component, each instance of type oj.Message or an object that 
     * duck types it. 
     * 
     * @example <caption>Get the current set of <code class="prettyprint">messages</code> for the component:</caption>
     * var messages = $(".selector").ojInputText("option", "messages");
     * 
     * @example <caption>Clear all messages set on the component:</caption>
     * $(".selector").ojInputText("option", "messages", []);
     * 
     * @example <caption>Add a message (of default error severity) to the component using the <code class="prettyprint">messages</code> option:</caption>
     * var msgs = [];
     * msgs.push({'summary': 'Error Summary', 'detail': 'Error Detail'}); 
     * $(".selector").ojInputText("option", "messages", msgs);
     * 
     * @example <caption>Set a <code class="prettyprint">oj.Message</code> instance to the component:</caption>
     * var message = new oj.Message("summary text", "detail text");
     * var messagesArr = [message];
     * $(".selector").ojInputText("option", "messages", messagesArr);
     * 
     * @expose 
     * @access public
     * @instance
     * @memberof! oj.editableValue
     * @default initializes to an empty array when no option is set.
     * @type {Array|undefined}
     */    
    messages : undefined,

    /**
     * an Object literal containing the following property-value pairs, that allows a widget to specify 
     * how it wants various 'messaging artifacts' to be displayed in relation to itself. <br/>
     * Accepted values for the key is a string type of the messaging artifact and they include 
     * 'messages', 'converterHint', 'validatorHint', 'title'. <br/>
     * The value is either an array of display options or a string display option. When an array of 
     * display options is specified the first display option is used first and then the second as 
     * fallback and so on. NOTE: In the future we plan to support additional display options like 
     * 'inline'. 
     * <br/>
     * 
     * 
     * @property {string=} converterHint - supported values are 'placeholder', 'notewindow', 'none'. 
     * E.g. {'converterHint': ['placeholder', 'notewindow']}
     * @property {string=} validatorHint - supported values are 'notewindow', 'none'. 
     * E.g. {'validatorHint': ['notewindow']}
     * @property {string=} messages - supported values are 'notewindow', 'none'. 
     * E.g. {'messages': 'notewindow'}
     * @property {string=} title - supported values are 'notewindow', 'none'. 
     * E.g. {'title': 'notewindow'}
     * 
     * @example <caption>Initialize component and override default for converterHint using <code class="prettyprint">messagingDisplayOptions</code>:</caption>
     * // Only messages will get shown in the notewindow associated to this component
     * $(".selector").ojInputText("option", "messagingDisplayOptions", {
     *   'converterHint': ['notewindow'] // the default is ['placeholder', 'notewindow']
     * });
     * 
     * @expose 
     * @access public
     * @instance
     * @default <code class="prettyprint">
     * {
     *   'messages': ['notewindow'], 
     *   'converterHint': ['placeholder', 'notewindow'], 
     *   'validatorHint': ['notewindow'], 
     *   'title': ['notewindow']
     * }</code>
     * @memberof! oj.editableValue
     * @type {Object|undefined}
     */
    messagingDisplayOptions : undefined,
    
    /** 
     * whether the component is required. Allowed values for required are 
     * 'required' and 'optional', 'optional' being the default.<br/>
     * 
     * When required option is set, the input's label will render a required icon. <br/>
     * When required option is set, a required validator - (@link oj.RequiredValidator) - is 
     * implicitly used. If an explicit required validator is set using the validators option then 
     * that gets used instead.
     * 
     * @example <caption>Initialize the component with the <code class="prettyprint">required</code> option:</caption>
     * $(".selector").ojInputNumber({required: 'required'});<br/>
     * @example <caption>Initialize <code class="prettyprint">required</code> otpion from html attribute 'required':</caption>
     * &lt;input type="text" value= "foobar" required/><br/>
     * // reading the required option will return "required"
     * $(".selector").ojInputNumber("option", "required");<br/>
     * 
     * @example <caption>Using <code class="prettyprint">required</code> option and setting an explicit required validator:</caption>
     * &lt;input type="text" value="foobar" required data-bind="ojComponent: {
     *   component: 'ojInputText', 
     *   value: password, 
     *   validators: [{type: 'required', options : {
                               messageSummary: '\'{label}\' Required', 
                               messageDetail: 'A value is required for this field'}}]}"/>
     * @expose 
     * @access public
     * @instance
     * @default when the option is not set, the element's required property is used as its initial 
     * value if it exists.
     * @memberof! oj.editableValue
     * @type {string|undefined}
     */
    required: undefined,
    
    /** 
     * represents advisory information for the component, such as would be appropriate for a tooltip. 
     * 
     * 
     * @example <caption>Initialize the component with the <code class="prettyprint">title</code> option:</caption>
     * &lt;input id="username" type="text" data-bind="
     *    ojComponent: {component: 'ojInputText', title : 'enter at least 3 alphanumeric characters', 
     *                  pattern: '[a-zA-Z0-9]{3,}', value: ''}"/><br/>
     * 
     * @example <caption>Initialize <code class="prettyprint">title</code> option from html attribute 'title':</caption>
     * &lt;input id="username" type="text" value= "foobar" title="enter at least 3 alphanumeric characters" 
     *           pattern="[a-zA-Z0-9]{3,}"/><br/>
     * $("#username").ojInputText({});
     * 
     * // reading the title option will return "enter at least 3 alphanumeric characters"
     * $("#username").ojInputText("option", "title");<br/>
     * 
     * @expose 
     * @access public
     * @instance
     * @default when the option is not set, the element's title attribute is used as its initial 
     * value if it exists. 
     * @memberof! oj.editableValue
     * @type {string|undefined}
     */    
    title: undefined,
    
    /**
     * This option allows setting HTML5's placeholder attribute. Though it is possible to set 
     * placeholder attribute on the element itself, the component will only read the value during 
     * creation time; meaning any subsequent changes to the element's placeholder attribute will 
     * not be picked up.
     * 
     * @example <caption>Initialize the component with the <code class="prettyprint">placeholder</code> option:</caption>
     * &lt;input id="userId" data-bind="ojComponent: {component: 'ojInputText', placeholder: 'User Name'}" /&gt;
     * 
     * @example <caption>Initialize <code class="prettyprint">placeholder</code> option from html attribute:</caption>
     * &lt;input id="userId" data-bind="ojComponent: {component: 'ojInputText'}" placeholder="User Name" /&gt;
     * 
     * // reading the placeholder option will return "User Name"
     * $(".selector").ojInputText("option", "placeholder");<br/>
     * 
     * @expose 
     * @access public
     * @instance
     * @default when the option is not set, the element's placeholder attribute is used if it exists. 
     * If the attribute is not set then the default can be a converter hint. See 
     * messagingDisplayOptions for details.
     * @memberof! oj.editableValue
     * @type {string|undefined}
     */    
    placeholder: undefined,
    
    /** 
     * an array of validator instances, where each instance duck types oj.Validator, or an array of 
     * validator object literals where each object contains the following name value pairs. 
     * <ul>
     *   <li><i>type</i>: a string validator type that is registered with the oj.ValidatorFactory. 
     *   An instance is created using the factory method on @link oj.ValidatorFactory. </li>
     *   <li><i>options</i>: an optional Object literal of options that the validator expects.</li>
     * </ul>
     * After the component has been initialized with validators, changing the validators on the 
     * component can present issues that need to addressed appropriately <br/>
     * - if the component is valid, the current value that passed validations before may now start 
     * failing. E.g, if value was below a certain max value but a new validator lowered the max 
     * value, invalidating the current value. In such cases the page author has the option of 
     * calling the validate() method to re-run validators against the current value. In some cases 
     * it may be necessary to re-initialize the component.<br/>
     * - if the component was invalid when the validators changed, again it may be necessary to 
     * for the page author to clear messages on the component, or in some cases re-initialize the 
     * component might be necessary.<br/>
     * 
     * @example <caption>Initialize the component with validator object literal:</caption>
     * $(".selector").ojInputNumber({
     *   validators: [{
     *     type: 'numberRange', 
     *     options : {
     *       hint: {hintMinimum: 'Enter a value greater than '{min}'}, 
     *       min: 100
     *     }
     *   }],
     * });
     * NOTE: oj.Validation.validatorFactory('numberRange') returns the validator factory that is used 
     * to instantiate a numberRange validator.
     * 
     * @example <caption>Initialize the component with multiple validator instances:</caption>
     * var validator1 = new MyCustomValidator({'foo': 'A'}); 
     * var validator2 = new MyCustomValidator({'foo': 'B'});
     * $(".selector").ojInputNumber({
     *   value: 10, 
     *   validators: [validator1, validator2]
     * });
     * 
     * @expose 
     * @access public
     * @instance
     * @memberof! oj.editableValue
     * @type {Array|undefined}
     */    
    validators: undefined,
    
    /** 
     * The value of the editable component. 
     * 
     * @example <caption>Initialize the component with the <code class="prettyprint">value</code> option specified:</caption>
     * $(".selector").ojInputNumber({'value': 10});<br/>
     * @example <caption>Get or set the <code class="prettyprint">value</code> option, after initialization:</caption>
     * // Getter: returns 10
     * $(".selector").ojInputNumber("option", "value");
     * // Setter: sets 20
     * $(".selector").ojInputNumber("option", "value", 20);
     * 
     * @expose 
     * @access public
     * @instance
     * @default When the option is not set, the element's value property is used as its initial value 
     * if it exists. The type of value is as defined by the component that extends this class. Refer 
     * to specific components for defaults.
     * @memberof! oj.editableValue
     * @type {Object|undefined}
     */
    value: undefined,
    
    // Events
    /**
     * Triggered when the following component options change. 
     * <ul>
     * <li><strong>messages</strong>: a component's validity changes when its messages changes. For example - <br/>
     *   <ul>
     *     <li>when it goes from valid with no messages, to invalid with messages (of severity fatal 
     *      or error), or to valid with messages (of severity warning, info or confirmation). </li>
     *      <li>when it goes from valid with messages, to valid with a new set of messages, or to 
     *        valid with no messages, or to invalid with messages</li>
     *      <li>when it goes from invalid with messages, to invalid with new set of messages, or to 
     *      valid with no messages, or to valid with messages (of severity warning or lower). </li>
     *   </ul>
     * </li>
     * <li><strong>value</strong>: when the component's value changes. </li>
     * </ul>
     * <p>The event payload has the following properties - </p>
     * @property {Event} event <code class="prettyprint">jQuery</code> event object
     * @property {Object} data event payload
     * @property {string} data.option the name of the option that changed, i.e. "messages" or "value"
     * @property {Object} data.previousValue - an Object holding the previous value of the option
     * @property {Object} data.value - an Object holding the current value of the option
     * @property {Object} data.optionMetadata - an Object literal that provides metadata for the option. 
     * 
     * @example <caption>Initialize the ojInputText component with the <code class="prettyprint">optionChange</code> callback to be notified of changes to the component's validity</caption>
     * $(".selector").ojInputText({
     *   'optionChange': function (event, data) {} 
     * });
     * @example <caption>Bind an event listener to the ojoptionchange event</caption>
     * $(".selector").on({
     *   'ojoptionchange': function (event, data) {
     *       window.console.log("option changing is: " + data['option']);
     *   };
     * });
     * 
     * @memberof! oj.editableValue
     * @expose
     * @event 
     * @access public
     * @instance
     *
     */
    optionChange: undefined

	},
  
  // P U B L I C    M E T H O D S
  // value() as a public method is not required to be supported. Customers will use the 'option' 
  // method to set the value instead
  
  /**
   * Reacts to changes to the 'value' or 'messages' option by triggering a 'optionChange' event if 
   * the value changes from its previous value. Refer to the optionChange event for details.
   * 
   * @param {String|Object|string=} key a single string representing a key or an object representing a group 
   * of options
   * @param {Object=} value of the key
   * @fires oj.editableValue#optionChange
   */
  option : function (key, value)
  {
    var retVal, previousValue, previousMsgs, previousMsgDisplay, valueOptionSet = false, newValue, 
        originalEvent, messagesOptionSet = false, deleteSpecialEventKey = false, 
        refreshMessagingOptions = true, placeholderOptionSet = false;
    
    // an explicit key or key/value is passed in.
    if (typeof key === "string" && value !== undefined)
    {
      switch (key)
      {
        case "value":
          valueOptionSet = true;
          previousValue = this.options['value'];
          break;
          
        case "messages":
          messagesOptionSet = true;
          previousMsgs = this.options['messages'] || [];
          break;
          
        case "messagingDisplayOptions":
          previousMsgDisplay = $.extend({}, this.options['messagingDisplayOptions']);
          break;
          
        case "placeholder" :
          placeholderOptionSet = true;
          break;           
      }
    }
    // an object literal of key...values is passed in - ('option', {key: value, key2: value2})
    else if (typeof key === "object")
    {
      if (key)
      {
        if (key['value'] !== undefined)
        {
          valueOptionSet = true;
          previousValue = this.options['value'];
          deleteSpecialEventKey = true;
        }
      
        if (key["messages"] !== undefined)
        {
          messagesOptionSet = true;
          previousMsgs = this.options['messages'];
          deleteSpecialEventKey = true;
        }
        
        // messagingDisplayOptions - 
        if (key['messagingDisplayOptions'])
        {
          previousMsgDisplay = $.extend({}, this.options['messagingDisplayOptions']);
          // key['messagingDisplayOptions'] = $.extend(previousMsgDisplay, key['messagingDisplayOptions']);
        }
        
        if (key['placeholder'])
        {
          placeholderOptionSet = true;
          refreshMessagingOptions = key['_oj_messaging_update'] ? false : true;
          delete key['_oj_messaging_update']; // remove before call to _super
          
        }
        
        if (deleteSpecialEventKey)
        {
          // _SetValue passes a special key for the event, which needs to be removed.
          originalEvent = key['_oj_originalEvent'];
          delete key['_oj_originalEvent']; // remove before call to _super
        }
      }
    }
    
    // Step 2: call the super to set the option 
    retVal = this._superApply(arguments);
    
    // Step 3: trigger events if needed
    if (valueOptionSet)
    {
      newValue = this.options['value'];
      // trigger a optionChange event only when the newValue is different from the previousValue to 
      // avoid recursion. E.g., setOption() triggers optionChange, which calls ko binding callback, 
      // which then writes to observable. Which then causes binding update to call set option again
      if (!this._ValueEquals(previousValue, newValue))
      {
        this._TriggerOptionChange('value', previousValue, originalEvent || null);
      }
    }
    
    if (messagesOptionSet)
    {
      if (!this._messagesEquals(previousMsgs, this.options['messages']))
      {
        this._TriggerOptionChange('messages', previousMsgs, originalEvent || null);
      }
    }
    
    if (placeholderOptionSet)
    {
      if (refreshMessagingOptions)
      {
        // if placeholder was set and it's not from messaging code, then the messaging preferences 
        // will need to re-evaluated. E.g., the default display for 
        // converterHint: ['placeholder', 'notewindow'] is 'placeholder', and if user were to set a 
        // custom placeholder, this overrides the default display for convererHint from 'placeholder'
        // to 'notewindow'. 
        this.__customPlaceholderSet = true;
        this._initComponentMessaging();
      }
      else
      {
        this.__customPlaceholderSet = false;
      }
    }
    
    return retVal;
  },

          
  /**
   * whether the component is currently valid. 
   * @example <caption>Check whether the component is valid:</caption>
   * var value = $(".selector").ojInputText("isValid");
   * @returns {boolean}
   * @access public
   * @instance
   * @expose
   * @memberof! oj.editableValue
   */
  isValid : function ()
  {
    return this.__valid;
  },
  
  /**
   * Called typically when the DOM underneath the component has changed requiring a re-render 
   * of the component, but also when some external condition impacts the rendering of the component,
   * e.g., when the locale for the page change, a component using a converter or translations will 
   * need to be refreshed. <br/>
   * This method override refreshes the component display value to the option value. When the 
   * component was previously invalid it is important to clear the messages explicitly., before 
   * calling refresh.
   * 
   * @example <caption>Clear messages and refresh component.</caption>
   * $(selector).ojInputText("option", "messages", []); <br/>
   * $(selector).ojInputText("refresh");
   * component 
   * @access public
   * @instance
   * @expose
   * @memberof! oj.editableValue
   */
  refresh : function ()
  {
    this._super();
    this._doRefresh(true);
  },
  
  /**
   * A convenience method to validate the option value after it is set programmatically using the 
   * option setter. <br/>
   * 
   * When the value property is set, it's expected to be of the correct type as defined by 
   * the component. To run the value through the validators, this method can be called. When there 
   * are no validators setup for the component this method is a no-op and returns true.
   * When there is at least one validator the first one that fails, updates the component validity, 
   * adds messages and triggers the optionChange event. <br/>
   * Callers should explicitly clear messages when calling this method.
   * 
   * @example <caption>Validate the <code class="prettyprint">value</code> option.</caption>
   * // set value
   * $(.selector).ojInputDate('option', 'value', new Date());
   * // clear current messages on component
   * $(.selector).ojInputText('option', 'messages', []);
   * // validate value. validation errors are displayed if any based on the messagingDisplayOptions.
   * $(.selector).ojInputText('validate');
   * 
   * @param {boolean} requiredOnly If true only runs the required-ness check.
   * 
   * @access public
   * @expose
   * @instance
   * @memberof! oj.editableValue
   */
  validate : function (requiredOnly)
  {
    var newValue, mode = requiredOnly ? this._VALIDATION_MODE.REQUIRED_VALIDATOR_ONLY : 
            this._VALIDATION_MODE.VALIDATORS_ONLY;
    
    // Callers would use the messages option to clear existing messages, before calling validate(). 
    // component("option", "messages", []);
    newValue = this._doRunValidation(this.options['value'], undefined, mode);
    if (!this.isValid())
    {
      return false;
    }
    
    return true;
  },   
    
  // P R O T E C T E D    C O N S T A N T S   A N D   M E T H O D S

  // *********** START WIDGET FACTORY METHODS (they retain _camelcase naming convention) **********
  
  /**
   * Validation mode specifying the kind of validation that gets run.
   * @protected
   * @memberof! oj.editableValue
   * @const
   */       
  _VALIDATION_MODE : {FULL : 1, VALIDATORS_ONLY : 2, REQUIRED_VALIDATOR_ONLY : 3, NONE : 4},

  /**
   * Initializes options defined by this base class.
   * 
   * @memberof! oj.editableValue
   * @instance
   * @protected
   */
  _ComponentCreate : function ()
  {
    var node = this.element, 
        attrsToRemove = ["required", "title"], //remove attributes that trigger html5 validation + 
                                               // inline bubble
        savedAttributes = this._GetSavedAttributes(node); 
    
    this._super();
    
    // update element DOM for disabled
    if (typeof this.options['disabled'] === "boolean")
    {
      node.prop("disabled", this.options['disabled']);
    }
    
    // we do this here instead of in _InitOptions because here we have the final value.
    if (this.options['placeholder'])
    {
      // a custom placeholder has been set; remember it because if none is set messaging sets a 
      // default placeholder
      this.__customPlaceholderSet = true;
    }
    
    // remove html5 validation attributes 
    $.each(attrsToRemove, function (index, value)
    {
      if (value in savedAttributes)
      {
        node.removeAttr(value);
      }
    });
  },
  
  /**
   * The value option alone is initialized here since it requires the component to be fully
   * created. Calling this.options.value before this method does not guarantee the correct 
   * value to be returned.
   *
   * @memberof! oj.editableValue
   * @instance
   * @protected
   */
  _AfterCreate : function ()
  {
    this._super();
    
    // decorate the label
    this._createOjLabel();
    
    // refresh value, theming and aria attributes
    this._doRefresh(false);

    // initialize component messaging
    this._initComponentMessaging();
   
    this._TriggerOptionChange('messages', this.options['messages'], null);
    this.widget().addClass("oj-form-control");
  },
          
  
  /**
   * Detaches the widget from the element and restores element exactly like it was before the widget 
   * was attached.
   * @protected
   * @expose
   * @memberof! oj.editableValue
   * @instance
   * 
   */
  _destroy : function ()
  {
    var widget = this.widget();
    
    this._clearMessages(undefined, true);
    this._getComponentMessaging().deactivate(this._getMessagingContent());
    // remove all selectors added to the widget
    $.each(this._OPTION_TO_CSS_MAPPING, function() { 
        widget.removeClass(this.toString());
      });
    widget.removeClass("oj-form-control");
    // remove all aria attributes added to the element  
    this.element.removeAttr("aria-required");
    if (this.$label)
    {
      this.$label._ojLabel( "destroy" );
    }
    return this._super();
  },
          
  /**
   * Called (by the widget factory) when the option changes, this method responds to the change 
   * by refreshing the component if needed. This method is not called for the options passed in 
   * during the creation of the widget.
   * 
   * @param {string} name of the option
   * @param {Object|string} value 
   * 
   * @expose
   * @memberof! oj.editableValue
   * @instance
   * @protected
   */
  _setOption : function (name, value) 
  {
    var retVal = this._superApply(arguments), shouldRefresh = true, hasMessages, maxLevel = 0;
    switch(name)
    {
      case "converter":
        // When the converter changes clear the cached converter instance.
        this.__converter = null;
        
        // also update messagingstrategy as hint associated with converter could have changed
        this._getComponentMessaging().update(this._getMessagingContent(this.__MESSAGING_CONTENT_UPDATE_TYPE.CONVERTER_HINT));
        // shouldRefresh = true; we want component to refresh its display value using new converter
        break;
      
      case "validators":
        // Clear the cached normalized list of all validator instances
        this._ResetAllValidators();
        shouldRefresh = false;
        break;
        
      case "messages":
        
        // When new messages are written determine component validity and severity and update 
        // component messaging
        hasMessages = value && value.length !== 0;
        // When messages are cleared reset component validity
        if (!hasMessages)
        {
          // options.messages is empty; 
          this.__maxSeverityLevel = 0;
          this.__valid = true;
        }
        else 
        {
          // clear current max severity 
          this.__maxSeverityLevel = 0;
          maxLevel = this._getMaxSeverity();
          
          // determine new valid state
          if (maxLevel >= oj.Message.SEVERITY_LEVEL['ERROR'])
          {
            this.__valid = false;
          }
          else
          {
            this.__valid = true;
          }
        }
        
        this._getComponentMessaging().update(this._getMessagingContent());
        break;
        
      case "messagingDisplayOptions" :
        // clear the cached merged options; the getter setup for this.options['messagingDisplayOptions']
        // will merge the new value with the defaults
        this.__messagingDisplayOptions = null;
        this._initComponentMessaging();
        
        break;
      
      case "placeholder":
        this._SetPlaceholder(value);
        shouldRefresh = false; //  no reason to refresh component.
        break;
      
      case "required":
        // shouldRefresh=true because hints and label should refresh to show new state
        break;
        
      case "title":
        // update messagingstrategy
        this._getComponentMessaging().update(this._getMessagingContent(this.__MESSAGING_CONTENT_UPDATE_TYPE.TITLE));
        break;
    }
      
    if (shouldRefresh)
    {
      // TODO: _setOption is calling _Refresh for every option change. 
      // Allowing this only for value and some specific options (see above) breaks inputnumber tests
      this._Refresh(name, value);
      // refresh aria attributes if needed
      this._refreshAria(name, value);

      // some options have special CSS selectors that need to be added or removed on the widget 
      this._refreshTheming(name, value);
    }      

    return retVal;
  },
  
  // *********** END WIDGET FACTORY METHODS **********
  
  /**
   * Returns a jquery object of the element representing the content node. This could be a jQuery 
   * object of the element the widget was invoked on - typically this is an input or select or 
   * textarea element for which a value can be set.
   * 
   * @memberof! oj.editableValue
   * @instance
   * @protected
   * @return {Object} the jquery element that represents the editable content. E.g., an input
   */
  _GetContentElement : function ()
  {
    return this.element;
  },

  /**
   * Returns a jquery object of the element representing the primary label node for the input 
   * component. 
   * First we look for the aria-labelledby attribute on the input.
   * If that's not found, we look for the label with 'for' attribute 
   * pointing to input.
   * If that's not found, we walk up the dom looking for aria-labelledby.
   * 
   * @memberof! oj.editableValue
   * @instance
   * @protected
   * @return {Object} the jquery element that represents the input component's label.
   *  return null if it can't find anything.
   */
  _GetLabelElement : function ()
  {
    // If input has aria-labelledby set, then look for label it is referring to.
    var queryResult = this._getAriaLabelledByElement(this.element);
    if (queryResult !== null && queryResult.length !== 0)
    {
      return queryResult;
    }
    
    // if no aria-labelledby is on the input, then look for a label with 'for'
    // set.
    var id = this.element.prop("id");
    if (id !== undefined)
    {
      var labelQuery = "label[for='" + id + "']";
      queryResult = $(labelQuery);
      if (queryResult.length !== 0)
      {
        return queryResult;
      }
    }
 
    // if no aria-labelledby on input and no label with 'for' pointing to input,
    // then as a final step we walk up the dom to see if aria-labelledby is set.
    // If so, then we find the label it is referring to.
    // This would be the case when you have multiple inputs grouped in a div 
    // <label id="grouplabel">Address</label>
    // <div aria-labelledby="grouplabel"><input/><input/><input/></div>
    var ariaElement = this.element.closest("[aria-labelledby]");
    if (ariaElement.length !== 0)
    {
      // Element has aria-labelledby set, so look for label it is referring to.
      queryResult = this._getAriaLabelledByElement(ariaElement);
      if (queryResult !== null && queryResult.length !== 0)
      {
        return queryResult;
      }
    }
    return null;

  },
  
  
  /**
   * Returns the element's value. Normally, this is a call to this.element.val(), but for some 
   * components, it could be something else. E.g., for ojRadioset the element's value is really the 
   * value of the selected radio in the set. 
   * 
   * @override
   * @memberof! oj.editableValue
   * @instance
   * @protected
   */
  _GetElementValue : function () 
  {
    return this.element.val();
  },
  

/**
   * Returns a jquery object of the element that triggers messaging behavior. The trigger element 
   * is usually an input or select or textarea element for which a value can be set/retrieved and 
   * validated. 
   * 
   * @return {Object} jquery object 
   * 
   * @memberof! oj.editableValue
   * @instance
   * @protected
   */
  _GetMessagingLauncherElement : function ()
  {
    return this._GetContentElement();
  },
  
  /**
   * Returns the normalized converter instance.
   * 
   * @return {Object} a converter instance or null
   * 
   * @memberof! oj.editableValue
   * @instance
   * @protected
   */
  _GetConverter : function () 
  {
    // this.__converter holds the instance
    if (!this.__converter)
    {
      var converterOption = this.options['converter'];
      this.__converter = oj.IntlConverterUtils.getConverterInstance(converterOption);
    }
    
    return this.__converter || null;
  },

  /**
   * Returns an array of default validators used by component. The list of default validators are 
   * for the internal use of the component and are not a part of this.options.validators. E.g., if 
   * the pattern attribute or option is set, a RegExpValidator instance is automatically created and 
   * added to this list. RequiredValidtor is tracked separately from the default validators.
   * 
   * @return {Object} a map of string name to the validator instance. 
   * 
   * @memberof! oj.editableValue
   * @instance
   * @protected
   */
  _GetDefaultValidators : function ()
  {
    if (!this.__defaultValidators)
    {
      this.__defaultValidators = {};
    }
    
    return this.__defaultValidators;
  },
          
  /**
   * Returns the display value that is ready to be passed to the converter.
   * 
   * @param {Object} value the stored value if available that needs to be formatted for display
   * @return {string} usually a string display value
   * 
   * @memberof! oj.editableValue
   * @instance
   * @protected
   */
  _GetDisplayValue : function (value) 
  {
    return this._GetContentElement().val();
  },

  /**
   * Returns an array of all validators built by merging the validators option set on the component 
   * and the default validators setup by the component. <br/>
   * This does not include the default required validator. Components can override to add to this 
   * array of validators.
   * 
   * @return {Array} of validators
   * 
   * @memberof! oj.editableValue
   * @instance
   * @protected
   */
  _GetAllValidators : function ()
  {
    if (!this.__allValidators)
    {
      var allValidators = [], validatorsOption = this.options['validators'], validator, 
          isValidatorInstance = true, defaultValidatorMap = this._GetDefaultValidators(), 
          defaultValidators = [], vType, vOptions, vTypeStr, normalizedValidators, i;

      // combine public and internal validators to get the combined list
      for (var val in defaultValidatorMap) 
      {
        if (defaultValidatorMap.hasOwnProperty(val)) 
        {
          defaultValidators.push(defaultValidatorMap[val]);
        }          
      }
      allValidators = allValidators.concat(defaultValidators);
        
      if (validatorsOption)
      {
        normalizedValidators = [];
        // Normalize validators 
        for (i = 0; i < validatorsOption.length; i++)
        {
          validator = validatorsOption[i];
          if (typeof validator === "object") 
          {
            // check if we have an actual validator instance that implements the validate() method
            // oj.Validation.__doImplementsCheck(validator, oj.Validator);
            if (!(validator['validate'] && typeof validator['validate'] === "function"))
            {
              isValidatorInstance = false;
            }
            
            if (!isValidatorInstance)
            {
              // we maybe dealing with an object literal
              // {'type': 'numberRange', 'options': { 'min': 100, 'max': 1000,
              //                                    'hint': {'hintMinimum': 'some hint'}}}
              vTypeStr = validator['type'];
              if (vTypeStr && typeof vTypeStr === "string")
              {
                vType = oj.Validation.validatorFactory(vTypeStr);
                if (vType)
                {
                  vOptions = $.extend({}, validator['options']) || {};
                  // we push converter into the options if not provided explicitly. This is to allow
                  // validators to format values shown in the hint and messages
                  vOptions['converter'] = vOptions['converter'] || this._GetConverter();
                  vOptions['label'] = vOptions['label'] || this._getLabelText();
                  validator = vType.createValidator(vOptions);
                }
                else
                {
                  oj.Logger.error("Unable to locate a validatorFactory for the requested type: " + vTypeStr);
                }
              }
            }
            
            normalizedValidators.push(validator);
          }
          else
          {
            oj.Logger.error("Unable to parse the validator provided:" + validator);
          }
        }

        allValidators = allValidators.concat(normalizedValidators);
      }
      
      this.__allValidators = allValidators;
    }
    
    return this.__allValidators || [];
  },
  
  /**
   * EditableValue caches the validators to be run within this.__allValidators variable.
   * This is great; however when the default validators need to be reset [i.e. min + max changing] 
   * then the cached this.__allValidators needs to be cleared out. 
   * This method also updates the messaging strategies as hints associated with validators could 
   * have changed.
   * 
   * 
   * @memberof! oj.editableValue
   * @instance
   * @protected
   */
  _ResetAllValidators : function () 
  {
    if (this.__allValidators)
    {
      this.__allValidators.length = 0;
    }
    this.__allValidators = null;
    
    // update messagingstrategy as hints associated with validators could have changed
    this._getComponentMessaging().update(this._getMessagingContent(this.__MESSAGING_CONTENT_UPDATE_TYPE.VALIDATOR_HINTS));

  },

  /**
   * Whether the component is required.
   * 
   * @return {boolean} true if required; false
   * 
   * @memberof! oj.editableValue
   * @instance
   * @protected
   */
  _IsRequired : function () 
  {
    // by default we check if required attribute is set on the element.
    return this.options.required === "required";
  },
            
  
  /**
   * Convenience handler for the DOM 'change' event. Subclasses are expected to wire up event 
   * handlers for DOM events that they wish to handle.<br/>
   * 
   * The implementation retrieves the display value for the component by calling _GetDisplayValue() 
   * and calls _SetValue(), with full validation.
   * 
   * @param {Event} event DOM event 
   * 
   * @memberof! oj.editableValue
   * @instance
   * @protected
   */
  _HandleChangeEvent : function (event) 
  {
    var submittedValue = this._GetDisplayValue();
    // run full validation
    this._SetValue(submittedValue, event);
  }, 

  /**
   * Called in response to a change in the options set for this component, this method refreshes the 
   * component display value. Subclasses can override to provide custom refresh behavior.
   * 
   * @param {String=} name the name of the option that was changed
   * @param {Object=} value the current value of the option
   * @param {boolean=} fullRefresh false is the default; true means always refresh component 
   * display value
   * 
   * @memberof! oj.editableValue
   * @instance
   * @protected
   */
  _Refresh : function (name, value, fullRefresh)
  {
    switch (name)
    {
      case "converter":
        value = this.options['value'];
        // when converter changes format of value could change
        this._refreshComponentDisplayValue(value, true);
        break;
         
      case "value":
        this._refreshComponentDisplayValue(value, fullRefresh);
        break;

      case "required":
        // need to keep the label in sync with the input
        if (this.$label)
        {
          this.$label._ojLabel("option", "required", value);
        }
        break;
        
      case "help":
        // refresh the help - need to keep the label in sync with the input.
        var helpDef = this.options.help["definition"];
        var helpSource = this.options.help["source"];
        var labelHelpIconWrapper = this._ariaDescribedByHelpIconWrapper(helpSource);

        if (this.$label)
        {
          // Calling option this way calls _setOption in _ojLabel.
          // order matters here. When _ojLabel's help is changed, it removes
          // the help dom, then re-adds it. We need to make sure _ojLabel's  
          // describedById option is there so we can find the dom to remove
          // and recreate if needed.
          this.$label._ojLabel("option", "describedById", labelHelpIconWrapper);
          this.$label._ojLabel("option", "help", 
                          {"definition":helpDef, 
                          "source":helpSource});
        }
        break;        
    }
  },
  /**
   * Called when a aria-required attribute needs to be set or removed. 
   * Most inputs/selects need aria-required on the input element (aka 'content')
   * But it is not legal to have aria-required on radio/checkboxes.
   * Subclasses can override to put aria-required where they want.
   * 
   * @param {Object=} value the current value of the required option
   * 
   * @memberof! oj.editableValue
   * @instance
   * @protected
   */
  _RefreshAriaRequired : function (value)
  {
    var ariaValue, contentNode = this._GetContentElement();

    ariaValue = (value == "required") ? true : false;
    if (ariaValue && contentNode) 
    {
      contentNode.attr("aria-required", ariaValue);
    }
    else
    {
      contentNode.removeAttr("aria-required");
    }
  },

  /**
   * Called when the display value on the element needs to be updated. This method updates the 
   * (content) element value. Widgets can override this method to update the element appropriately. 
   * 
   * @param {String} displayValue of the new string to be displayed
   * 
   * @memberof! oj.editableValue
   * @instance
   * @protected
  */  
  _SetDisplayValue : function (displayValue) 
  {
    var contentElem = this._GetContentElement();
    contentElem.val(displayValue);
  },
  
  /**
   * Sets the value on the component after clearing existing messages on the component. This method 
   * is typically called when a component needs to write a user value into the component. <br/>
   * 
   * @param {Object} newValue the value to be set.
   * @param {Object=} event an optional event if this was a result of ui interaction. For user 
   * initiated actions that trigger a DOM event, passing this event is required. E.g., if user action 
   * causes a 'blur' event. <br/>
   * When _SetValue is called as a result of a programmatic update, such as calling a method on a 
   * component, then the event can be undefined. E.g., ojInputNumber.stepUp()
   * @param {{validationMode:number}=} options an Object literal that callers pass in to determine 
   * how validation gets run. Keys and values to pass in options are as follows:
   * 'validationMode': {number} Accepted values (defined in _VALIDATION_MODE) are - 
   * <ul>
   *   <li>FULL - the default and runs both the converter and all validators. </li>
   *   <li>VALIDATORS_ONLY - runs all validators including the required validator is run.</li>
   *   <li>REQUIRED_VALIDATOR_ONLY - runs just the required validator. </li>
   *   <li>NONE - runs no validation and write the value to the options.</li>
   * </ul>  
   * NOTE: All options expect NONE will clear current messages. <br/>
   * 
   * <ul>
   * <li>
   * If validation is to be run, then the newValue is compared with the last element value. If it's 
   * the same then validation is skipped. If not the same validation continues.
   * </li>
   * <li>When there is a validation error, value option not set and the method returns false.</li>
   * <li>If all validations pass, and the new parsed value is the same as the options.value then the 
   * value option is not written, the component display is refreshed and the method returns true. But
   * if the new value is different then it's written to the options and the component refreshed</li>
   * </ul>
   *   
   * @return {boolean} false if value was not set due to validation error. 
   * @example: Widget subclasses can use this convention to run full validation
   * this._SetValue(value, event);
   * 
   * 
   * @memberof! oj.editableValue
   * @instance
   * @protected
   * 
   */
  _SetValue : function (newValue, event, options)
  {
    var previousValue = this.options['value'], mode, runningValidations = true;
    
    // disallow setting a value of undefined by widgets
    if (newValue === undefined)
    {
      oj.Logger.warn("Attempt to set a value of undefined");
      return false;
    }
    
    if (this._CanSetValue())
    {
      mode = options && options.validationMode ? options.validationMode : this._VALIDATION_MODE.FULL;
      runningValidations = (mode !== this._VALIDATION_MODE.NONE);
      
      if (runningValidations)
      {
        // reset validity and clear messages stored on the component if we are validating and 
        // the new (display) value is not the same as the previous display value.
        if (!(newValue === this._getLastElementValue())) 
        {
          // save off the newValue into the last element value
          this._setLastElementValue(newValue);          
          this._clearMessages(event);

          newValue = this._doRunValidation(newValue, event, mode);
          if (!this.isValid())
          {
            return false;
          }
        }
        else
        {
          if (oj.Logger.level > oj.Logger.LEVEL_WARN)
          {
            oj.Logger.info("Validation was skipped because the display value " + 
                    (newValue.toString) ? newValue.toString() : newValue + " as the previous.");
          }
          return false;
        }
      }

      // before writing the new value to the option, we check if it's same as the current option 
      // value to avoid unnecessary writes to option, observable etc. This alos means no triggering 
      // a optionChange event. it may be necessary to refresh the displayValue.
      if (this._ValueEquals(previousValue, newValue))
      {
        this._updateElementDisplayValue(newValue, event);
        if (oj.Logger.level > oj.Logger.LEVEL_WARN)
        {
          oj.Logger.info("The value was not set on the component as it's the same as the current value - " + 
                  (newValue.toString) ? newValue.toString() : newValue);
        }
      }
      else
      {
        // writing to option value.
        this._updateValueOption(newValue, event);
      }
    }
    
    return true;
  },
    
  /**
   * Whether the a value can be set on the component. If the component is 
   * disabled then setting value on component is a no-op. 
   * 
   * @see #_SetValue
   * 
   * @memberof! oj.editableValue
   * @instance
   * @protected
   */
  _CanSetValue: function ()
  {
    var disabled = this.options['disabled'] || false;
    
    if (disabled)
    {
      return false;
    }
    
    return true;
  },

  /**
   * Sets the placeholder text on the content element by default. It sets the placeholder attribute
   * on the element. Component subclasses can override this method to control where placeholder text
   * gets set.
   * @param {string} value
   * 
   * @memberof! oj.editableValue
   * @instance
   * @protected
   */
  _SetPlaceholder : function(value)
  {
    this._GetContentElement().attr("placeholder", value);
  },
          
  /**
   * Triggers a 'optionChange' event on the component. The payload is the previous and current 
   * values for the option that changed. Currently supported options that trigger this event are 
   * value and messages.
   * 
   * @param {string} option name of the option that changed
   * @param {string|number|Object} previousValue an array of the previous 
   * @param {Event=} originalEvent the original dom event that triggered the validation. If this is 
   * set then writeback happens.
   * 
   * @memberof! oj.editableValue
   * @instance
   * @protected
   */
   _TriggerOptionChange : function (option, previousValue, originalEvent)
   {
     oj.Assert.assertNonEmptyString(option, "");
     
     // TODO: Several components call _SetValue without the originalEvent, of which ojSelect, 
     // ojCombobox are never setting originalEvent. So the writeback never happens. SO temporarily 
     // setting {writeback : 'shouldWrite'}
     var //writebackVal = originalEvent ? "{'writeback': 'shouldWrite'}" : 
         //    "{'writeback': 'shouldNotWrite'}",
      dataHash = {
       'option': option,
       'previousValue': previousValue, 
       'value' : this.options[option],
       'optionMetadata': {'writeback': 'shouldWrite'}};

     switch(option)
     {
       case 'messages':
         
        this._trigger('optionChange', originalEvent || null, dataHash);
        // not preventing default behavior. So show messages
        this._getComponentMessaging().update(this._getMessagingContent());
        break;
        
      case 'value':
        // users can't cancel the value change event as the event is triggered after the value changes
        this._trigger('optionChange', originalEvent || null, dataHash);
        break;
        
      default:
        break;
     }
     
   },

  /**
   * Compares 2 values for equality and returns true if they are equal; false otherwise. Calls 
   * oj.Object.innerEquals() which works for most Javascript data types.
   * 
   * @param {Object|string|undefined} value1 first value
   * @param {Object|string|undefined} value2 another value
   * @return {boolean}
   * 
   * @memberof! oj.editableValue
   * @instance
   * @protected
   */
  _ValueEquals : function (value1, value2)
  {
    return oj.Object.compareValues(value1, value2);
  },
  
  /**
   * Returns the default styleclass for the component. Currently this is 
   * used to pass to the _ojLabel component, which will append -label and 
   * add the style class onto the label. This way we can style the label
   * specific to the input component. For example, for inline labels, the
   * radioset/checkboxset components need to have margin-top:0, whereas all the
   * other inputs need it to be .5em. So we'll have a special margin-top style 
   * for .oj-label-inline.oj-radioset-label
   * All input components must override
   * 
   * @return {string}
   * 
   * @memberof! oj.editableValue
   * @instance
   * @protected
   */
  _GetDefaultStyleClass : function ()
  {
    return "oj-editablevalue";
  },
    
  
  // I N T E R N A L   P R I V A T E   C O N S T A N T S    A N D   M E T H O D S 
  // Subclasses should not override or call these methods
  
  
  /**
   * when below listed options are passed to the component, corresponding CSS will be toggled
   * @private
   * @const
   * @type {Object}
   */
  _OPTION_TO_CSS_MAPPING: {
    "disabled": "oj-disabled",
    "required": "oj-required"
  },
  
  /**
   * Types of messaging content to update.
   * <ul>
   * <li>'ALL' - builds all messaging content</li>
   * <li>'VALIDITY_STATE' - updates only validityState every time validation runs and there are 
   * new messages or when the messages option changes.</li>
   * <li>'CONVERTER_HINT' - updates only converter hints, this is used when converter option 
   * changes</li>
   * <li>'VALIDATOR_HINTS' - updates only validator hints, this is used when validators option 
   * changes</li>
   * <li>'TITLE' - updates only title, when the title property changes</li>
   * </ul>
   * @private
   */
  __MESSAGING_CONTENT_UPDATE_TYPE : {ALL : 1, 
                                     VALIDITY_STATE : 2, 
                                     CONVERTER_HINT : 3, 
                                     VALIDATOR_HINTS : 4, 
                                     TITLE : 5},
                                   
  
  /**
   * Clears messages for this component.  
   * @param {Event=} event
   * @param {boolean=} silentUpdate default value is false; a true value clears the member variable 
   * directly without using the public option method, causing no events to be fired. 
   * @private
  */
  _clearMessages : function (event, silentUpdate) 
  {
    silentUpdate = silentUpdate ? true : false;
    if (!silentUpdate)
    {
      var msgsHash = {};
      msgsHash['messages'] = [];
      if (event)
      {  
        msgsHash['_oj_originalEvent'] = event;
      }
      this.option(msgsHash);
    }
    else
    {
      // if we are destroying widget don't bother setting option
      this.options['messages'] = [];
    }
  },
  
  /**
   * Called at component create time primarily to initialize options, often using DOM values. This 
   * method is called before _ComponentCreate is called, so components that override this method 
   * should be aware that the component has not been rendered yet. The element DOM is available and 
   * can be relied on to retrieve any default values. <p>
   * 
   * This method sets defaults for its options that have a DOM namesake. E.g., value, required, 
   * disabled etc. Subclasses can override this method to set their own defaults for these options.
   * Example, the value option is often not set on this.element for components like radioset, which
   * walk the sub-tree to determine the value.
   * 
   * 
   * @memberof! oj.editableValue
   * @instance
   * @protected
   */
  _InitOptions : function()
  {
    var node = this.element, savedAttributes = this._GetSavedAttributes(node), 
            attrsToRemove = ["required", "title"], domValue, attrVal, propVal; 
    this._super();
    
    // TODO: Blake says no options should be initialized by base. Code needs to be removed when the 
    // create/init changes are in

    // DISABLED:
    // if options.disabled is not set (undefined), read from DOM not saved attributes
    // if options.disabled is set to a valid value (boolean), set it on the 
    // element to keep the two in sync. 
    if (this.options['disabled'] === undefined)
    {
      // In the absence of attribute set default value to null
      this.options['disabled'] = this.element.attr("disabled") !== undefined ? 
        !!this.element.prop("disabled") : null;
    }
    this._validateOption("disabled");
    
    // PLACEHOLDER: (expects a non-empty string)
    // if options.placeholder is not set (undefined), use placeholder attribute on element
    if (this.options['placeholder'] === undefined)
    {
      this.options['placeholder'] = this.element.prop("placeholder");
    }
    
    if (this.options['placeholder'])
    {
      // if we have a non-empty value for placeholder option remember it, so we don't set default 
      // placeholder. 
      // TODO: Should default placeholder be pushed to this.optiopns?
      this.__customPlaceholderSet = true;
    }
    
    // REQUIRED: (expects a boolean)
    // if options.required is not set (undefined), use required attribute on the element.
    if (this.options['required'] === undefined)
    {
      attrVal = this.element.attr("required");
      propVal = this.element.prop("required");
      
      // In the absence of attribute set default value to null. 
      // If attribute is present and not undefined
      //   - In IE9, required attribute is not supported at all, so prop() returns undefined. In 
      //     such cases set default to !!attrVal
      //   - Otherwise set to !!propVal
      // TODO: review needed 
      domValue = (attrVal !== undefined) ? 
        ((propVal !== undefined) ? !!propVal : !!attrVal) : null;
      this.options['required'] = domValue ? "required" : "optional";
    }
    
    this._validateOption("required");
    
    // TITLE: (expects a string)
    // if options.title set to undefined, use title attribute on element.
    if (this.options['title'] === undefined)
    {
      this.options['title'] = this.element.prop("title");
    }

    // VALUE: (can be one of many types)
    // if value option is undefined check element value. 
    if (this.options['value'] === undefined) 
    {
      // element attribute may not be set, in which case default to null
      this.options['value'] = (this.element.attr('value') !== undefined) ? this.element.val() : null;
    }
    
    // initialize messages to an empty array, so later when we trigger an optionChange event 
    // in _AfterCreate(), invalidComponentTracker is populated. 
    // TODO: This is kludg-ey since ComponentBinding.setupManagedAttributes() does not yet support a 
    // AfterCreate callback 
    if (!this.options['messages'])
    {
      this.options['messages'] = [];
    }
        
    // remove html5 validation attributes to not trigger html5 validation + inline bubble
    $.each(attrsToRemove, function (index, value)
    {
      if (value in savedAttributes)
      {
        node.removeAttr(value);
      }
    });
  },

  /**
   * Refreshes the component to respond to DOM changes, in which case fullRefresh=true. This 
   * internal method is also called when the component's theme or accessibility attributes need to 
   * be refreshed.
   * @param {boolean} fullRefresh true if a full refresh of the component is desired.
   * @private
   */
  _doRefresh : function (fullRefresh)
  {
    // we decided not to clear messages on refresh because the user intends to refresh the component 
    // using the latest DOM and latest option values. Page Authors will need to clear messages and 
    // generally ensure component state is accurate and as expected before calling refresh().
    
    fullRefresh = fullRefresh || false;
    if (fullRefresh)
    {
      // the DOM for the label and its text could have changed. 
      if (this.$label)
      {
        this.$label._ojLabel("refresh");
      }
      
      // also clear out anything that relies on the label 
      this._RefreshLabelDependents();
      
      // also re-initialize component messaging, since refresh() can be called when the locale 
      // changes, requiring component to show messaging artifacts for current locale. 
      // E.g., hints, placeholder, messages are all retrieved for the current locale. Typically when 
      // switching locales user should have cleared messages.
      this._initComponentMessaging();
    }
        
    this._Refresh("value", this.options['value'], fullRefresh);
    this._refreshAria("required", this.options.required);
    this._refreshTheming("required", this.options.required);
    this._refreshTheming("disabled", this.options.disabled);
  },

  /**
   * Gets the last stored model value
   * 
   * @private
   */
  _getLastModelValue : function ()
  {
    return this.__oj_lastModelValue;
  },
          
  _getLastElementValue : function () 
  {
    return this.__oj_lastElementValue;
  },
  /**
   * Get the element whose id matches the elem's aria-labelledby value, if any.
   * @private
   * @param {Object} elem the dom element from which you want to get the 
   * aria-labelledby property value
   * @return {Object} if element does not have aria-labelledby defined, then
   *    returns null. If it  does, then return a new jQuery object with the 
   *    label with an id equal to the aria-labelledby value. If no match, then
   *    the jQuery object will be empty.
   */
  _getAriaLabelledByElement: function (elem)
  {
    // look for a label with an id equal to the value of aria-labelledby. 
    // .prop does not work for aria-labelledby. Need to use .attr to find
    // aria-labelledby.
    var ariaId = elem.attr("aria-labelledby");

    if (ariaId !== undefined )
    {
      var labelQuery = "label[id='" + ariaId + "']"; 
      return $(labelQuery);
    }    
    else
      return null;
  },

  /**        
   * Create the _ojLabel component
   * @private
   */
  _createOjLabel : function ()
  {
    this.$label = this._GetLabelElement();
    if (this.$label)
    {
      var helpDef = this.options['help']['definition'];
      var helpSource = this.options['help']['source'];

      var labelHelpIconWrapper = this._ariaDescribedByHelpIconWrapper(helpSource);
      // create the ojLabel component 
      this.$label._ojLabel(
    //   {inputLabelStyleClass: this._GetDefaultStyleClass()+"-label",
        {rootAttributes:{'class': this._GetDefaultStyleClass()+"-label"},
        describedById: labelHelpIconWrapper, 
        required:this.options['required'], 
        help:{'definition': helpDef, 'source': helpSource}});

    }    
  },
  /**  
   * If there is help source (an external URL), then construct an
   * id from the element's id, render aria-describedby with this id, and then
   * return the id to be used by the ojLabel.
   * 
   * For accessibility, we need to wrap help icons with a div. 
   * Then, on the input component we use aria-describedby to point to this div.
   * &lt;div id="fooIcons"&gt;
   *   &lt;span class="oj-label-help-icon oj-component-icon oj-clickable-icon"&gt;
   *   /&lt;span/&gt;
   * /&lt;div/&gt;
   * &lt;input aria-describedby="fooIcons" id="foo" type="text"/&gt;
   *    
   * This function constructs an id to put on the help icon div and returns it.
   * It also adds the aria-describedby on the input.
   * 
   * We render the help icon only if there is help source.
   * 
   * @return {string} an id we constructed
   * @param {string} helpSource helpSource must be present
   * for the aria-describedby to be rendered.
   * @private
   */
  _ariaDescribedByHelpIconWrapper : function (helpSource)
  {
    var labelHelpIconWrapperId = this.element.prop("id") + "Icons";
    if (helpSource)
    {  
      var contentElements = this._GetContentElement();        

      // aria-describedby can be a list of ids, so make sure to append
      //contentElements.attr("aria-describedby", labelHelpIconWrapperId);
      contentElements.each(function() {
        var ariaDescBy = $(this).attr("aria-describedby");
        if (ariaDescBy)
          $(this).attr("aria-describedby", ariaDescBy + ' ' + labelHelpIconWrapperId);
        else
          $(this).attr("aria-describedby", labelHelpIconWrapperId);
     });
    }
    return labelHelpIconWrapperId;  
  },
          
  // helper method to retrieve the label text.          
  _getLabelText : function ()
  {
    if (this.$label)
    {
      return this.$label.text();
    }
  },
  /**        
   * For the current list of messages this method returns the current severity.
   * @return {number} See oj.Message.SEVERITY_LEVEL or -1 if 
   * @private
   */
  _getMaxSeverity : function ()
  {
    if (!this.__maxSeverityLevel)
    {
      this.__maxSeverityLevel = oj.Message.getMaxSeverity(this.options['messages']);
    }
    return this.__maxSeverityLevel;
  },
  
  _getValidityState : function ()
  {
    if (this.__validityState)
    {
      var messages = $.extend([], this.options['messages']); //clone array
      this.__validityState.update(this.__valid, messages, this.__maxSeverityLevel);
    }
    else
    {
      if (typeof this.__valid === "undefined")
      {  
        this.__valid = true;
      }
      this.__validityState = new oj.ComponentValidity(this.__valid, 
                                                      this.options['messages'], 
                                                      this.__maxSeverityLevel);
    }
    return this.__validityState;
  },

  /**
   * Initializes component messaging both when component is initialized or when 
   * messagingDisplayOptions is set/changed. 
   * 
   * @private
   */
  _initComponentMessaging : function()
  {
    var compMessaging = this._getComponentMessaging(), 
            messagingLauncher = this._GetMessagingLauncherElement(), 
            messagingContent = this._getMessagingContent(this.__MESSAGING_CONTENT_UPDATE_TYPE.ALL);
    
    // if default placeholder is currently set then it needs to be cleared here. This is needed for 
    // the following reasons
    // i. a component is reinitialized when the locale changed, requiring the converter hint for 
    // new locale to be set as placeholder.
    // ii. or a component's placeholder option or messagingDisplayOptions option, could have changed 
    // requiring the placeholder to be reset if it's currently set to the default.
    // 
    if (!this.__customPlaceholderSet)
    {
      this.options['placeholder'] = "";
    }
    
    compMessaging.activate(messagingLauncher, messagingContent);
  },
  
  _setLastModelValue : function (value)
  {
    this.__oj_lastModelValue = value;
  },

  _setLastElementValue : function (value) 
  {
    this.__oj_lastElementValue = value;
  },

  
  /**
 * Adds a message to this element
 * @param {Object} message a Message object. TODO: contract needs to exposed
 * @param {Event=} event
 * @private
 */
  _updateMessages: function(message, event) 
  {
    var msgs = this.options['messages'].slice(), messagesHash = {};
    oj.Assert.assertPrototype(message, oj.Message);
    
    // this.options['messages'].push(message);
    msgs.push(message);
    messagesHash['messages'] = msgs;
    if (event)
    {  
      messagesHash['_oj_originalEvent'] = event;
    }
    this.option(messagesHash);
  },
          
          
  _updateValueOption : function (newValue, event)
  {
    var values = {};
    values['value'] = newValue;
    if (event)
    {  
      values['_oj_originalEvent'] = event;
    }

    this.option(values);
  },
  
  /**
   * If the value set can be coerced to an accepted value do it, otherwise throw error.
   * 
   * @param {string} optionName
   * @throws {Error} if option value is invalid
   * @private
   */
  _validateOption : function (optionName)
  {
    var optionValue = this.options[optionName], error = false;
    
    switch (optionName)
    {
      case 'required' :
        if (!optionValue) // 0, false, null, "", default to optional
        {
          this.options[optionName] = "optional";
        }
        else
        {
          // coerce value
          optionValue = "" + optionValue;
          if (optionValue !== "required" && optionValue !== "optional")
          {
            error = true; 
          }
        }
        break;
        
      case "disabled" :
        if (optionValue !== null &&  typeof optionValue !== "boolean")
        {
          error = true;
        }
        
        break;
    }
    
    if (error)
    {
      throw "Option '" + optionName + " 'has an invalid value set: " + optionValue;
    }
  },
  
  /**
   * Runs validation based on the mode settings. 
   * @param {Object} value to parse and/or validate
   * @param {Event=} event the original event or undefined
   * @param {number=} mode determines how validation is run. see _VALIDATION_MODE
   * @return {Object|string} parsed value 
   * @private
   */
  _doRunValidation : function (value, event, mode) 
  {
    var newValue = value;

    // callers of this function should clear messages 
    try
    {
      // Step 1: only when "full" validation is requested converters get run
      if (mode === this._VALIDATION_MODE.FULL)
      {
        // Step1: Parse value using converter
        newValue = this._parseValue(value);
      }

      // Step 2: Run validators
      this._validateValue(newValue, mode === this._VALIDATION_MODE.REQUIRED_VALIDATOR_ONLY);
    }
    catch (ve)
    {
      this._processValidationError(ve, event);
    }
    
    return newValue;
  },
          
  
  /**
   * Formats the value for display, based on the converter options. If no converter is set then 
   * returns the value as is.
   * 
   * @param {string} value value to be formatted
   * 
   * @return {string} formatted value
   * @throws {Error} when an error occurs during formatting
   * @private
   */
  _formatValue : function (value)
  {
    var formattedValue = value, converter = this._GetConverter();
    
    // don't clear messages here because we clear messages only when direct user interaction with 
    // component changes value. All other usecases we expect page authors to clear messages.

    if (converter)
    {
      // TODO: We should support chaining converters but for now we use just the first converter 
      // to parse.

      // Check if we have a converter instance
      if (typeof converter === "object") 
      {
        if (converter['format'] && typeof converter['format'] === "function")
        {
          formattedValue = converter['format'](value);
        }
        else
        {
          if (oj.Logger.level > oj.Logger.LEVEL_WARN)
          {
            oj.Logger.info("converter does not support the format method.");
          }
        }
      }
    }
    
    return formattedValue;
  },
  
  /**
   * @private
   */
  _getComponentMessaging : function ()
  {
    if (!this.__componentMessaging)
    {
      this.__componentMessaging = new oj.ComponentMessaging(this);
    }
    
    return this.__componentMessaging;
  },
  
  /**
   * Returns the required validator instance or creates it if needed and caches it.
   * 
   * @private
   */
  _getDefaultRequiredValidator : function ()
  {
    var vf;
    
    // TODO: Should we cache the same instance of required validator for all components?
    this.__defaultReqValOptions = {'label': this._getLabelText()};    
    vf = oj.Validation.validatorFactory(oj.ValidatorFactory.VALIDATOR_TYPE_REQUIRED);
    return vf ? vf.createValidator(this.__defaultReqValOptions) : null;
  },

  /**
   * Returns an array of validator hints.
   * @param {Array} allValidators
   * @private
   */        
  _getHintsForAllValidators : function(allValidators)
  {
    var validator, validatorHints = [], vHint = "", i;
    if (this._IsRequired())
    {
      validator = this._hasRequiredInValidators(allValidators);
      if (!validator)
      {
        // get the hint for the default required validator and push into array if it's not already 
        // present in the validators array
        validator = this._getDefaultRequiredValidator();
        if (validator['getHint'] && typeof validator['getHint'] === "function")
        {
          vHint = validator['getHint']();
          if (vHint)
          {
            validatorHints.push(vHint);
          }
        }
      }
    }

    // loop through all remaining validators
    for (i = 0; i < allValidators.length; i++)
    {
      validator = allValidators[i], vHint = "";
      if (typeof validator === "object") 
      {
        if (validator['getHint'] && typeof validator['getHint'] === "function")
        {
          vHint = validator['getHint']();
          if (vHint)
          {
            validatorHints.push(vHint);
          }
        }
      }
    }

    return validatorHints;
  },
  
  /**
   * Returns content that will be used by messaging strategies.
   * 
   * @param {number} updateType of messaging content to update. Accepted values are defined by 
   * this.__MESSAGING_CONTENT_UPDATE_TYPE.
   * 
   * @private
   */
  _getMessagingContent : function (updateType)
  {
    var messagingContent = {}, converter = this._GetConverter(), converterHint, allValidators, 
            validatorHints = [];
    updateType = updateType || this.__MESSAGING_CONTENT_UPDATE_TYPE.VALIDITY_STATE;
    
    // Add validityState which includes messages, valid and severity
    if (updateType === this.__MESSAGING_CONTENT_UPDATE_TYPE.ALL || 
        updateType === this.__MESSAGING_CONTENT_UPDATE_TYPE.VALIDITY_STATE)
    {
      messagingContent['validityState'] = this._getValidityState();
    }
    
    // Add converter hints
    
    if (updateType === this.__MESSAGING_CONTENT_UPDATE_TYPE.ALL || 
        updateType === this.__MESSAGING_CONTENT_UPDATE_TYPE.CONVERTER_HINT)
    {
      if (converter)
      {
        if (typeof converter === "object") 
        {
          if (converter['getHint'] && typeof converter['getHint'] === "function")
          {
            converterHint = converter['getHint']() || "";
            messagingContent['converterHint'] = converterHint;
          }
        }
      }
    }
    
    if (updateType === this.__MESSAGING_CONTENT_UPDATE_TYPE.ALL || 
        updateType === this.__MESSAGING_CONTENT_UPDATE_TYPE.VALIDATOR_HINTS)
    {
      allValidators = this._GetAllValidators();
      validatorHints = this._getHintsForAllValidators(allValidators) || [];
      messagingContent['validatorHint'] = validatorHints;
    }
    
    if (updateType === this.__MESSAGING_CONTENT_UPDATE_TYPE.ALL || 
        updateType === this.__MESSAGING_CONTENT_UPDATE_TYPE.TITLE)
    {
      messagingContent['title'] = this.options['title'] || "";
    }
    
    return messagingContent;
  },
          
  /**
   * Checks if a required validator is set explicitly on the validators array and return it.
   * @param {Array} allValidators
   * @return {Object|null} required validator instance
   * @private
   */
  _hasRequiredInValidators : function (allValidators)
  {
    var validator = null, i, required = null;
    for (i = 0; i < allValidators.length; i++)
    {
      validator = allValidators[i];
      if (validator instanceof oj.RequiredValidator)
      {
        required = validator;
        break;
      }
    }

    return required;
  },
  
  /**
   * Compares the messages arrays for equality.
   * 
   * @param {Array} pm previous messages
   * @param {Array} m new messages
   * @returns {boolean} true if equal false otherwise
   * @private
   * 
   */
  _messagesEquals : function (pm, m)
  {
    var match = -1, pmo, passed = true, previousMsgs = $.extend([], pm), msgs = $.extend([], m);
    if (previousMsgs === msgs) return true;
    if (previousMsgs == null || msgs == null) 
    {
      return false;
    }
    if (previousMsgs.length !== msgs.length)
    {
      return false;
    }
    
    $.each(previousMsgs, function (i, pMsg) 
    {
      if (!(pMsg instanceof oj.Message))
      {
        // oj.Messge has equals()
        pmo = new oj.Message(pMsg['summary'], pMsg['detail'], pMsg['severity']);
      }
      else
      {
        pmo = pMsg;
      }
      match = -1;
      $.each(msgs, function(j, msg) {
        {
          if (pmo.equals(msg))
          {
            match = j;
            return; // found a match, so break out of loop
          }
        }
      });
      
      // remove entry at 'match' index from msgs
      if (match > -1)
      {
        msgs.splice(match, 1);
      }
      else
      {
        // we found no match so no need to loop
        passed = false;
        return;
      }
    });
    
    return passed;
  },
  
  /**
   * Parses the value using the converter set and returns the parsed value. If parsing fails the 
   * error is written into the element 
   * 
   * @param {string=} submittedValue to parse
   * @return {Object} parsed value 
   * @throws {Error} an Object with message
   * @private
   */
  _parseValue: function(submittedValue) 
  {
    var converter = this._GetConverter(), parsedValue = submittedValue;
    
    if (converter)
    {
      // TODO: We should support chaining converters but for now we use just the first converter 
      // to parse.

      if (typeof converter === "object") 
      {
        if (converter['parse'] && typeof converter['parse'] === "function")
        {
          // we are dealing with a converter instance
          parsedValue = converter['parse'](submittedValue);
        }
        else
        {
          if (oj.Logger.level > oj.Logger.LEVEL_WARN)
          {
            oj.Logger.info("converter does not support the parse method.");
          }
        }
      }
    }
    
    return parsedValue;
  },

 /**
  * Processes the validation exception and updates the element.
  * 
  * @param {Error} e instance of Error
  * @param {Event=} event the original event that triggered the validation. 
  * @private
  */
  _processValidationError : function (e, event)
  {
    var ojmessage, summary, detail, severity, newMsg = {};
    if (e instanceof oj.ConverterError || e instanceof oj.ValidatorError)
    {
      ojmessage = e.getMessage();
      oj.Assert.assertPrototype(ojmessage, oj.Message);

      severity = ojmessage['severity'];
      summary = ojmessage['summary'];
      detail = ojmessage['detail'];
    }
    else
    {
      // TODO: is this error message generic enough to use for both converter and validator errors?
      severity = oj.Message.SEVERITY_LEVEL['ERROR'];
      summary = oj.Translations.getTranslatedString("oj-message.error");
      detail = e['message'] || oj.Translations.getTranslatedString("oj-converter.detail");
      // ojmessage = new oj.Message(summary, detail, severity);
    }
    
    newMsg['summary'] = summary;
    newMsg['severity'] = severity;
    newMsg['detail'] = detail;
    this._updateMessages(newMsg, event);
  },

  /**
   * Called when a aria attribute needs to be set or removed. 
   * @param {string} option name of the option
   * @param {Object|string} value
   * @private
   */
  _refreshAria : function (option, value)
  {

    var ariaValue, contentNode = this._GetContentElement();
    switch (option)
    {
      case "required":
        this._RefreshAriaRequired(value);
        break;
    }
  },
          
  /**
   * Refreshes the component when a property changes, that affects the display of the component. 
   * E.g., displayValue changes when value, converter or validator changes. Likewise the 
   * invalidElementTracker.
   * 
   * @param {Object|undefined} value the changed value that needs to be updated on UI
   * @param {boolean=} fullRefresh false is the default; true means always refresh component 
   * display value
   * @private
   */        
  _refreshComponentDisplayValue : function (value, fullRefresh)
  {
    var modelValue = value || this.options['value'], lastModelValue, elementValueUpdated;
    
    lastModelValue = this._getLastModelValue();
    elementValueUpdated = fullRefresh || (modelValue !== lastModelValue);

    // If instance (value) changes, we clear the element value and reset errors. 
    // But if the modelValue is the same as the element's _lastModelValue, then the element value 
    // need not be updated nor errors cleared. This situation can happen because the ojComponent 
    // binding's update method can be called too often - e.g. when other bindings are called.

    // TODO: If converter changes we want to format the value using the new converter. This means we 
    // clear the element value and reset any errors on it

    // TODO: If validator changes we don't do anything to update the element. The new validator will 
    // get picked up the next time the value is validated. If we support runnning contextual 
    // validators then the element might need to react appropriately. E.g., if a required validator 
    // was added and the field was empty we would need to run the validator

    if (elementValueUpdated)
    {
      this._updateElementDisplayValue(modelValue);
    }
  },
  
  /**
   * Called anytime the label DOM changes requiring a reset of any dependent feature that caches the 
   * label, including all validators.
   * @private
   */        
  _RefreshLabelDependents : function ()
  {
    // for now reset all validators
    this.__defaultReqValOptions = {};
    this._ResetAllValidators();
  },

  /**
   * Toggles css selector on the widget. E.g., when required option changes, the oj-required 
   * selector needs to be toggled.
   * @param {string} option
   * @param {Object|string} value 
   * @private
   */        
  _refreshTheming : function (option, value)
  {
    if (this._OPTION_TO_CSS_MAPPING.hasOwnProperty(option)) 
    {
      // required is 'required' or 'optional'. Treat anything but 'required' as false.
      if (option !== "required") {
        this.widget().toggleClass(this._OPTION_TO_CSS_MAPPING[option], !!value);
      }
      else {
        this.widget().toggleClass(this._OPTION_TO_CSS_MAPPING[option], (value === "required"));
      }
    }
  },

  _updateElementDisplayValue : function (modelValue, event)
  {
    var displayValue;
    // cache the new model value on the element 
    this._setLastModelValue(modelValue);

    // Update element with the displayValue
    displayValue = modelValue;

    try
    {
      displayValue = this._formatValue(modelValue);
    }
    catch (e)
    {
      this._processValidationError(e, event);
    }
    
    // Ugly: we need a special check for input [type=file] as a value cannot be set programmatically 
    // as it's considered a security violation.
    // if (element.type !== "file")
    this._SetDisplayValue(displayValue); 
    this._setLastElementValue(this._GetDisplayValue());
  },
  
  _updateInvalidElementTracker : function (invalidElementTracker)
  {
    // TBD
  },
          
          
  /**
   * Validates the value by running through the list of regsitered validators. The algorithm is as 
   * follows -
   * 1. check to see if we are currently valid, if not return
   * 2. run required check. 
   * 3. if value is not empty get all the validators and validate in sequence. 
   * 4. if all validators pass return.
   * 
   * Callers can rely on the 'valid' options property to determine the validity state of the 
   * component after calling this method
   * 
   * @param {Object|undefined} value to be validated
   * @param {boolean} requiredOnly true only runs required validation
   * @throws {Error} when validation fails.
   * @private
   */
  _validateValue : function (value, requiredOnly)
  {
    if (!this.__valid)
    {
      return;
    }
    
    var allValidators = this._GetAllValidators(), validator, i, reqValRun = false;

    // run required validation before anything else; 
    if (this._IsRequired())
    {
      validator = this._hasRequiredInValidators(allValidators);
      if (!validator)
      {
        validator = this._getDefaultRequiredValidator();
      }
      validator.validate(value);
      reqValRun = true;
    }

    // Only run other validators when required validation passes and only if all validators are 
    // requested to be run
    if (!requiredOnly)
    {
      for (i = 0; i < allValidators.length; i++)
      {
        validator = allValidators[i];
        if (typeof validator === "object") 
        {
          // validators : [required, numberRange]
          if (validator['validate'] && typeof validator['validate'] === "function")
          {
            if (validator instanceof oj.RequiredValidator && reqValRun)
            {
              // skip running required validation again
              continue;
            }
            validator['validate'](value);
          }
          else
          {
            if (oj.Logger.level > oj.Logger.LEVEL_WARN)
            {
              oj.Logger.info("validator does not support the validate method.");
            }
          }
        
        }
      }
    }
  }     
});

oj.Components.setDefaultOptions(
  {
    'editableValue': // properties for all editableValue components 
    {
      'messagingDisplayOptions': oj.Components.createDynamicPropertyGetter(
        function(context) 
        {
          // var inTable = context['containers'].indexOf('ojTable') >= 0;
          return  {
                    'messages': ['notewindow'], 
                    'converterHint': ['placeholder', 'notewindow'], 
                    'validatorHint': ['notewindow'], 
                    'title': ['notewindow']
                  };
        }
      )
    }
  }
);

/*!
 * JET Label This component is private. @VERSION
 * http://jqueryui.com
 *
 * Copyright 2013 jQuery Foundertion and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * Depends:
 *  jquery.ui.widget.js
 */
/**
 * The _ojLabel component is a private component. It is not meant to be used
 * on a label element directly. Instead EditableValue components 
 * use the _ojLabel component in the internal implementation. 
 * <p>
 * The _ojLabel component decorates the input component's label with
 * extra dom for the required icon and help information (help
 * icon, help description, and help external url). If oj-label* styles are on
 * the label element, then the _ojLabel element will move them onto its root
 * dom element.
 * </p>
 * <h3 id="keyboard-section">
 *   Keyboard interaction and Focus management
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
 * </h3>
 * <p>You can hover over the help and the required icons for additional information. 
 * You can also hover over the label to see the help definition text if there is some. 
 * </p>
 * @class
 * @private
 * @constructor
 * @name oj._ojLabel
 * @augments oj.baseComponent
 */
oj.__registerWidget("oj._ojLabel", $['oj']['baseComponent'],
{
  version : "1.0.0",  
  defaultElement : "<label>", 
  widgetEventPrefix : "oj", 
  options : 
  {
    /** 
     * The id of the input component that is associated with this label.
     * It is used to create an id for label's help icon dom (if any)
     * and that in turn is referred to with aria-describedby on the 
     * input component. This is needed for accessibility so that the screen
     * reader knows that the help icon is related to the input.
     * @expose 
     * @public
     * @instance
     * @memberof! oj._ojLabel
     */
    describedById: null,
    /**
     * The help information that goes on the label.  The help options are:
     * <ul>
     * <li>definition - this is the help definition text. It is what shows up
     * when the user hovers over the label or the help icon.</li>
     * <li>source - this is the help source url. If present, a help icon will
     * render next to the label and the anchor's target is this source.
     * </ul>
     * 
     * @expose 
     * @memberof! oj._ojLabel
     * @instance
     * @type {Object.<string, string>}
     * @default <code class="prettyprint">TODO: what goes here?</code>
     * 
     * @example <caption>Initialize the label with the help definition and external url information:</caption>
     * $( ".selector" )._ojLabel({ help: {definition:"some help definition", source:"some external url" } });
     * 
     * @example <caption>Set the <code class="prettyprint">help</code> option, after initialization:</caption>
     *
     * // setter
     * $( ".selector" )._ojLabel( "option", "help", {definition:"fill out the name", source:"http:\\www.oracle.com" } );
     */
    help: {definition: null, source: null},
    /** 
     * Whether this label should have a required icon.  Allowed values for 
     * required are 'required' and 'optional', 'optional' being the default.
     * @expose 
     * @public
     * @instance
     * @memberof! oj._ojLabel
     */
    required: null,
    /**
     * Allows you to set certain attributes on the root dom element.
     * For _ojLabel, we use 'class' only. The input components (via
     * EditableValue) set a styleclass on the _ojLabel's root in case
     * component-specific label styling is needed. For example, ojradioset
     * would pass class: 'oj-radioset-label'. ojinputtext would pass class:
     * 'oj-inputtext-label'. 
     *
     * @example <caption>Initialize root dom element with the set of 
     * <code class="prettyprint">rootAttributes</code>:</caption>
     * $(".selector")._ojLabel("option", "rootAttributes", {
     *   'class': 'oj-inputtext-label'
     * });
     * 
     * @expose
     * @access public
     * @memberof! oj._ojLabel
     * @instance
     * @type {Object|undefined}
     * @default <code class="prettyprint">{ id: null, class: null, style:null }</code>
     */
     rootAttributes: undefined
  },
 /**
  * @private
  * @const
  */
  _BUNDLE_KEY:
  {
    _TOOLTIP_HELP:      'tooltipHelp',
    _TOOLTIP_REQUIRED:  'tooltipRequired'    
  },
  /**** start Public APIs ****/
   
  /**
   * Returns a jQuery object containing the root dom element of the label 
   * 
   * <p>This method does not accept any arguments.
   * 
   * @expose
   * @memberof! oj._ojLabel
   * @instance
   * @return {jQuery} the label
  */
  widget : function ()
  {
    return this.uiLabel;
  },
  /**
   * Refreshes the required and help dom.
   * @example <caption>Clear messages and refresh component.</caption>
   * $(selector).ojInputText("option", "messages", []); <br/>
   * $(selector).ojInputText("refresh");
   * component 
   * @access public
   * @instance
   * @expose
   * @memberof! oj._ojLabel
   */
  refresh : function ()
  {
    this._super();
    this._refreshRequired();
    this._refreshHelp();
  },
          
   /**** end Public APIs ****/         
          
  /**** start internal widget functions ****/   
       
  /**
   * After _create, the widget should be 100% set up.
   * @override
   * @private
   */
  _create : function ()
  {
    this._super();

    this._drawOnCreate();

  },
  /**
   * set up styles on create
   * @private
   */
  _drawOnCreate : function ()
  {
    // wrap the label with a root dom element (oj-label) and its child 
    // (oj-label-group). Then point this.uiLabel to the root dom element.

    this.uiLabel = this.element.wrap(this._uiLabelWrapperHtml())
                               .closest(".oj-component");
                       
    // move an oj-label styles off of this.element, and put on the 
    // root dom element. Save these so we can put these back on 
    // this.element on destroy.
    this._moveClassesToRoot();
    if (this.options.help['definition'] || this.options.help['source'])
    { 
      this._insertHelpHtml();
      this._addHelpDefToLabel();
    }
    
    if (this.options.required === "required")
    {
      // Add or remove 'required' dom.
      // required. should go right before the label.
      this.element.before(this._requiredHtml());
    }
   },
   /**
   * move oj-label* classes from label element onto the root dom element
   * @private
   */
  _moveClassesToRoot : function ()
  {
    var classes = this.element.attr("class");
    this.movedClassArray  = [];
    if (classes)
    {
      var arrayOfClasses = classes.split(/\s+/);
      var numClasses = arrayOfClasses.length;
      for (var i=0; i < numClasses; i++)
      {
        var className = arrayOfClasses[i];
        // if class name has -label- in it, then move it
        // (e.g., oj-label, oj-label-inline, oj-md-label-nowrap, 
        // oj-md-labels-inline)
        if (className.indexOf("-label") > 0)
        {
          this.uiLabel.addClass(className); 
          this.element.removeClass(className);
          this.movedClassArray.push(className);
        }
      }
    }
  },
  /**
   * return the html string for the root dom element
   * @private
   */
  _uiLabelWrapperHtml : function ()
  {
    var rootAttributes = this.options.rootAttributes;
    var inputLabelClass;
    
    if (rootAttributes)
    {
      inputLabelClass = this.options.rootAttributes['class'];
    }
    
    if (inputLabelClass !== null)
    {
      return "<div class='oj-label oj-component " + inputLabelClass + 
              "'><div class='oj-label-group'></div></div>";
    }
    else
    {
      return "<div class='oj-label oj-component'><div class='oj-label-group'></div></div>";
    }

    
    
  },
  /** 
   * return the html string for the span with oj-label-required-icon
   * @private
   */
  _requiredHtml : function ()
  {
    var required = this.getTranslatedString(this._BUNDLE_KEY._TOOLTIP_REQUIRED);
    // TODO: Do we need oj-component-icon? I'm not seeing it in the label demos
    return "<span class='oj-label-required-icon oj-component-icon' title='" 
            + required + "'></span>";
  },
  /** 
   * return the html string of the span and its help information.
   * if (source), show help icon
   * if (helpDef), add 'title'=helpDef on help icon.
   * @private
   */
  _helpHtml : function (helpDef, source, describedById)
  {
    // construct the help html
    // if source (external url), then render a clickable help icon
    // if helpDef, then render oj-label-help-def style class on the label
    if (source)
    {
      var helpHtml = "<span id='" + describedById + "'>";
      helpHtml += "<a href='" + source + "' target='_blank'><span class=";
      helpHtml += "'oj-label-help-icon oj-component-icon oj-clickable-icon' title='";
      if (helpDef)
        helpHtml += helpDef;
      else
      {
        var tooltipHelp = this.getTranslatedString(this._BUNDLE_KEY._TOOLTIP_HELP);
        helpHtml += tooltipHelp;
      }
      helpHtml += "' role='img'></span>";
      helpHtml += "</a></span>"
    }
    return helpHtml;
  },
   /** 
   * Add help definition information to the label element.
   * @private
   */
  _addHelpDefToLabel : function ()
  {
    var helpDef = this.options.help['definition'];
    if (helpDef)
    {
      // add oj-label-help-def styleclass to the label.
      // add title to the label.
      // TODO APPEND title to the label if there is already a title
      this.element.addClass("oj-label-help-def");
      // append helpDef to title. We concatenate in case label already has
      // title set. Usually the app dev will use title OR helpDef, not both.
      var title = this.element.attr("title");
      if (title)
        this.element.attr("title", title + ' ' + helpDef);
      else
        this.element.attr("title", helpDef);
      
    }
  },
     /** 
   * Add help definition information to the label element.
   * @private
   */
  _removeHelpDefToLabel : function ()
  {
      this.element.removeClass("oj-label-help-def");
      this.element.attr("title", "");
  },
  /** 
   * finds the oj-label-group dom node and prepends the help html to it.
   * @private
   */
  _insertHelpHtml : function ()
  {
    var helpSource = this.options.help['source'];
    if (helpSource)
    {
      var helpDef = this.options.help['definition'];
      this.uiLabel.find(".oj-label-group").prepend(
        this._helpHtml(helpDef, 
                       helpSource,
                       this.options.describedById));
    }                     
  },
  /** 
   * refresh the help dom --
   * find the help root dom node and remove it if it is there 
   * and add back the help html. Helpful if a help option changed.
   * @private
   */  
  _refreshHelp : function ()
  {
    if (this.options.describedById !== null)
    {
      var describedById = "#" + this.options.describedById;
      this.uiLabel.find(describedById).remove();
    }
    // remove the style off of label dom as well.
    this._removeHelpDefToLabel();
    
    // now insert back if needed
    this._insertHelpHtml();
    this._addHelpDefToLabel();
  },
  /** 
   * refresh the required dom --
   * if required is required, then add the required dom if it isn't already there
   * if required is optional, remove the required dom if it is there.
   * Helpful if the required option changed.
   * @private
   */   
  _refreshRequired : function ()
  {
    // Add or remove 'required' dom.
    if (this.options.required === "required")
    {
      // required. should go right before the label if it isn't already there.
      if (this.uiLabel.find(".oj-label-required-icon").length === 0)
        this.element.before(this._requiredHtml());
    }
    else 
    {
      // not required, so find dom node with oj-label-required-icon on it.
      // Remove it.
      this.uiLabel.find(".oj-label-required-icon").remove();
    }
  },
  /**
   * Note that _setOption does not get called during create. it only gets called
   * when the component has already been created.
   * @override
   * @protected
   */
  _setOption : function (key, value)
  {
    this._super(key, value);

    if (key === "required")
    {
      this._refreshRequired();
    }

    // if user changed the help definition or source, then update the UI.
    // Find the help dom first. If it exists, replace it with new dom.
    // if it doesn't exist, add it.
     if (key === "help")
    {
      this._refreshHelp();
    }
  }, 
  /**
   * Return the subcomponent node represented by the documented locator attribute values.
   * Test authors should target spinner sub elements using the following names:
   * <ul>
   * <li><b>oj-label-help-icon</b>: the label's help icon</li>
   * <li><b>oj-label-help-icon-anchor</b>: the anchor tag of the help icon</li>
   * <li><b>oj-label-required-icon</b>: the label's required icon</li>
   * </ul>
   * 
   * @expose
   * @override
   * @memberof! oj._ojLabel
   * @instance
   * @param {Object} locator An Object containing at minimum a subId property 
   * whose value is a string, documented by the component, that allows the component to 
   * look up the subcomponent associated with that string.  It contains:
   * <ul>
   * <li>
   * component: optional - in the future there may be more than one component 
   *   contained within a page element
   * </li>
   * <li>
   * subId: the string, documented by the component, that the component expects 
   * in getNodeBySubId to locate a particular subcomponent 
   * </li>
   * </ul>  
   * @returns {Element|null} the subcomponent located by the subId string 
   * passed in locator, if found.
   */
  getNodeBySubId: function(locator)
  {
    if (locator == null)
    {
      return this.element ? this.element[0] : null;
    }
    
    var subId = locator['subId'];
    if (subId === "oj-label-help-icon") {
      return this.widget().find(".oj-label-help-icon")[0];
    }
    if (subId === "oj-label-help-icon-anchor") {
      return this.widget().find(".oj-label-help-icon").parent()[0];
    }
    if (subId === "oj-label-required-icon") {
        return this.widget().find(".oj-label-required-icon")[0];
    }
    
    // Non-null locators have to be handled by the component subclasses
    return null;
  },  
  /**
   * 
   * @override
   * @protected
   */
  _destroy : function ()
  { 
    // replace the dom we added back with the element dom.
    this._super();
    // replace the oj-label* style classes we moved  to the root dom node 
    // on create
    for (var i=0; i < this.movedClassArray.length; i++)
    {
      this.element.addClass(this.movedClassArray[i]);
    }  
    this._removeHelpDefToLabel();
    
    this.uiLabel.replaceWith(this.element);
  }
  
  /**** end internal widget functions ****/ 
 
});
/**
 * @class
 * @name oj.inputBase
 * @augments oj.editableValue
 * @classdesc
 * <h3 id="inputBaseOverview-section">
 *   Abstract inputBase component
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#inputBaseOverview-section"></a>
 * </h3>
 * 
 * <p>Description: The inputBase component takes care of general needs of other input components [i.e. text + password]
 * 
 * @param {Object=} options a map of option-value pairs to set on the component
 */
oj.__registerWidget("oj.inputBase", $['oj']['editableValue'], 
{
  version : "1.0.0", 
  widgetEventPrefix : "oj",
  
  /**
   * Convenience Array which one can extend to set the attribute to a mandatory value if it doesn't exist or is set to something else 
   * [
   * {
   *    "attr"              : string - attribute associated to the task
   *    "setMandatory"      : value it must be set to [i.e. type="text"]
   * }
   * ]
   * 
   * Examples:
   * 1) [{"attr": "type", "setMandatory": "text"}]
   * 
   * @expose
   * @private
   */
  _ATTR_CHECK : [],
  
  /** 
   * Class names to be applied to this.element()
   * 
   * @expose
   * @private
   */
  _CLASS_NAMES : "",
  
  /** 
   * Class names to be applied to this.widget()
   * 
   * Note that if this value is defined then the this.element will be wrapped
   * 
   * @expose
   * @private
   */
  _WIDGET_CLASS_NAMES : "",
  
  /*
   * If defined will append a div element containing text to be read out by Jaws when focus is placed on the input element 
   * and the value will be used to locate the translated text to be read out by Jaws.
   * 
   * Note the component must also be wrapped
   * Used in conjunction with the above variable. Used to locate the translated text to be read out by Jaws
   * 
   * @expose
   * @private
   */
  _INPUT_HELPER_KEY: "",
  
  options : 
  {
    /** 
     * Regular expression pattern which will be used to validate the component's value. Note that option value 
     * always supercedes element's attribute value and it is best practice to pass the value as an option than to 
     * set it as an element's attribute.
     * 
     * @example <caption>Initialize the component with the <code class="prettyprint">pattern</code> option:</caption>
     * $(".selector").ojInputText({pattern: "[a-zA-Z0-9]{3-9}"});<br/>
     * @example <caption>Initialize <code class="prettyprint">pattern</code> option from the html attribute 'pattern':</caption>
     * &lt;input type="text" id="username" value= "" pattern="[a-zA-Z0-9]{3,}" 
     *           title="Enter at least 3 alphanumeric characters"/><br/>
     * // reading the pattern option will return "[a-zA-Z0-9]{3-9}"
     * $(".selector").ojInputText("option", "pattern");<br/>
     * 
     * @expose 
     * @instance
     * @memberof! oj.inputBase
     * @type {string|undefined}
     */    
    pattern: undefined,
    
    /**
     * This option allows setting HTML5's placeholder attribute. Though it is possible to set 
     * placeholder attribute on the element itself, the component will only read the value during 
     * creation time; meaning any subsequent changes to the element's placeholder attribute will 
     * not be picked up.
     * 
     * @example <caption>Initialize the component with the <code class="prettyprint">placeholder</code> option:</caption>
     * &lt;input id="userId" data-bind="ojComponent: {component: 'ojInputText', placeholder: 'User Name'}" /&gt;
     * @example <caption>Initialize <code class="prettyprint">placeholder</code> option from html attribute:</caption>
     * &lt;input id="userId" data-bind="ojComponent: {component: 'ojInputText'}" placeholder="User Name" /&gt;
     * 
     * // reading the placeholder option will return "User Name"
     * $(".selector").ojInputText("option", "placeholder");<br/>
     * 
     * 
     * @expose 
     * @instance
     * @memberof! oj.inputBase
     * @type {string|undefined}
     */    
    placeholder: undefined,
    
    /** 
     * Dictates component's readOnly state. Note that option value 
     * always supercedes element's attribute value and it is best practice to pass the value as an option than to 
     * set it as an element's attribute.
     * 
     * @example <caption>Initialize component with <code class="prettyprint">readOnly</code> option:</caption>
     * $(".selector").ojInputNumber({"readOnly": true});
     * 
     * @expose 
     * @type {boolean|undefined}
     * @default <code class="prettyprint">false</code>
     * @instance
     * @memberof! oj.inputBase
     */
    readOnly: undefined
  },
  
  /**
   * The base method needs to be overriden so that one can perform attribute check/set [i.e. ojInputText can only have type="text"] 
   * 
   * @protected
   * @override
   * @param {Object} element - jQuery selection to save attributes for
   * @instance
   * @memberof! oj.inputBase
   */
  _SaveAttributes : function (element)
  {
    var ret = this._superApply(arguments);
    
    this._processAttrCheck();
    
    return ret;
  },
  
  /**
   * Overridden to return defaults for pattern and readonly options by using the attr values set on
   * element.
   *  
   * @protected
   * @override
   * @instance
   * @memberOf !oj.inputBase
   */
  _InitOptions: function()
  {
    this._super();
    
    // READONLY: (boolean)
    // if options.readonly is not set (undefined), read from DOM not saved attributes
    // if options.readonly is not set to a valid value (boolean), throw error
    if (this.options['readOnly'] === undefined)
    {
      // TODO: In the absence of attribute set default value to false. Should default be null??
      this.options['readOnly'] = this.element.attr("readonly") !== undefined ? 
        !!this.element.prop("readonly") : false; 
    }
    if (typeof this.options['readOnly'] !== "boolean")
    {
      throw "Option 'readOnly' has an invalid value set: " + this.options['readOnly'];
    }
    
    // PATTERN: (string)
    // if options.pattern is not set, use pattern attribute on element.
    if (this.options['pattern'] === undefined)
    {
      this.options['pattern'] = this.element.prop("pattern"); // if not set this returns ""
    }
  },

  /**
   * 1) Initializes the options
   * 2) If needed wraps the input element, 
   * 
   * @protected
   * @override
   * @instance
   * @memberof! oj.inputBase
   */
  _ComponentCreate : function()
  {
    var node = this.element, 
        ret = this._superApply(arguments),
        savedAttributes = this._GetSavedAttributes(node);
    
    // update element state using options
    if (typeof this.options['readOnly'] === "boolean") 
    {
      this.element.prop("readonly", this.options['readOnly']);
    }
    
    if (this._DoWrapElement())
    {
      this._wrapElement();
    }
    
    // remove pattern attribute to not trigger html5 validation + inline bubble
    if ('pattern' in savedAttributes)
    {
      node.removeAttr('pattern');
    }
  
    return ret;
  },
  
  /**
   * 1) Updates component state based on the option values
   * 2) Adds the classname to the element [intentionally postponing till this process since the component might need to 
   *    reset this.element for some reason]
   * 3) Hooks up the blur handler
   * 4) If necessary appends an input helper to be read out by Jaws accessibility reader
   * 
   * @protected
   * @override
   * @instance
   * @memberof! oj.inputBase
   */        
  _AfterCreate : function () 
  {
    var ret = this._superApply(arguments),
        setOptions = ["disabled", "readOnly"],
        self = this;
    
    if(this._CLASS_NAMES) 
    {
      this.element.addClass(this._CLASS_NAMES);
    }
    
    this.element.on("blur", $.proxy(this._onBlurHandler, this));
    
    this._AppendInputHelper();
    this._refreshStateTheming("readOnly", this.options.readOnly);
    
    //reason it should go through _setOption are for cases where the components are composite and just 
    //placing it on the root node is not sufficient enough
    $.each(setOptions, function(index, ele)
    {
      self._setOption(ele, self.options[ele]);
    });
    
    return ret;
  },
  
  /**
   * @ignore
   * @protected
   * @override
   */
  _setOption : function __setOption(key, value)
  {
    var retVal = this._super(key, value);
    
    if (key === "disabled")
    {
      this.element.attr("disabled", value);
    }
    
    if (key === "readOnly")
    {
      value = !!value;
      this.element.prop("readonly", value);
      this.widget().toggleClass( "oj-read-only", value );
      this._refreshStateTheming("readOnly", this.options.readOnly);
    }

    if (key === "pattern")
    {
      this.__defaultRegExpOptions['pattern'] = value;
    }
    
    return retVal;
  },
  
  /**
   * @ignore
   * @protected
   * @override
   */
  _destroy : function __destroy()
  {
    var ret = this._superApply(arguments);

    this.element.off("blur");
    
    if(this._inputHelper) 
    {
      this._inputHelper.remove();
    }
    
    if(this._DoWrapElement())
    {
      this.element.unwrap();
    }

    this._RestoreAttributes(); //remove when _RestoreAttributes is uncommented from jqueryui-base
    
    return ret;
  },
   /**
   * when below listed options are passed to the component, corresponding CSS will be toggled
   * @private
   * @const
   * @type {Object}
   */
  _OPTION_TO_CSS_MAPPING: {
    "readOnly": "oj-read-only"
  }, 
  /**
   * Performs the attribute check/set by using _ATTR_CHECK variable [i.e. ojInputText must have type be set to "text"].
   * 
   * @private
   */
  _processAttrCheck : function __processAttrCheck()
  {
    
    var attrCheck = this._ATTR_CHECK;
    
    for(var i=0, j=attrCheck.length; i < j; i++) 
    {
      var attr = attrCheck[i]["attr"],
          setMandatoryExists = "setMandatory" in attrCheck[i];
      
      //if it doesn't exist just have to check whether one should set it to a mandatory value
      if(setMandatoryExists)
      {
        this.element.attr(attr, attrCheck[i]["setMandatory"]);
      }
    }
  },
  
  /**
   * Invoked when blur is triggered of the this.element
   * 
   * @ignore
   * @protected
   * @param {Event} event
   */
  _onBlurHandler : function __onBlurHandler(event) 
  {
    this._SetValue(this._GetDisplayValue(), event);
  },
  
  /**
   * Whether the this.element should be wrapped. Method so that additional conditions can be placed
   * 
   * @ignore
   * @protected
   * @return {boolean}
   */
  _DoWrapElement : function ()
  {
    return this._WIDGET_CLASS_NAMES;
  },
  
  /**
   * Wraps the this.element and adds _WIDGET_CLASS_NAMES classes to the wrapped element
   * 
   * @private
   */
  _wrapElement : function __wrapElement() 
  {
    $(this.element).wrap( $("<div>").addClass(this._WIDGET_CLASS_NAMES) );
    this._wrapper = this.element.parent();
  },
  
  /**
   * In some complex components [i.e. datepicker], when the input element receives focus we wish to have Jaws read 
   * out some content.
   * 
   * For those case does this method exist.
   *  
   * @protected
   * @instance
   * @memberOf !oj.inputBase
   */
  _AppendInputHelper : function __AppendInputHelper()
  {
    if(this._INPUT_HELPER_KEY && this._DoWrapElement()) 
    {
      var describedBy = this.element.attr("aria-describedby") || "",
          helperDescribedById = this._GetSubId(this._INPUT_HELPER_KEY);
      
      describedBy += " " + helperDescribedById;
      this.element.attr("aria-describedby", describedBy);
      this._inputHelper = $("<div class='oj-helper-hidden-accessible' id='" + helperDescribedById + "'>" + 
                              this.getTranslatedString(this._INPUT_HELPER_KEY) + "</div>");
      this.widget().append(this._inputHelper);
    }
  },
  
  /**
   * Called when the label DOM changes. This method resets any validators that rely on the label.
   * 
   * @protected
   * @override
   * @instance
   * @memberof! oj.inputBase
   */
  _RefreshLabelDependents : function ()
  {
    // for now reset all validators
    this.__defaultRegExpOptions = {};
    this._super();
  },
  
  /**
   * Sets up the default regExp validator.
   * 
   * @ignore
   * @protected
   * @override
   * @instance
   * @memberof! oj.inputBase
   */
  _GetDefaultValidators : function ()
  {
    var ret = this._superApply(arguments), validatorMap = {};

    // register a default RegExp validator if we have a valid pattern
    if (this.options['pattern'])
    {
      // add validator to the special internalValidators list. These are validators created by 
      // the framework. We don't want these cleared using the option - 'validators'
      validatorMap[oj.ValidatorFactory.VALIDATOR_TYPE_REGEXP] = this._getDefaultRegExpValidator();
    }
    
    return $.extend(validatorMap, ret);
  },
    /**
   * Toggles css selector on the widget. E.g., when readOnly option changes, 
   * the oj-read-only selector needs to be toggled.
   * @param {string} option
   * @param {Object|string} value 
   * @private
   */        
  _refreshStateTheming : function (option, value)
  {
    if (this._OPTION_TO_CSS_MAPPING.hasOwnProperty(option)) 
    {
      // value is a boolean
      this.widget().toggleClass(this._OPTION_TO_CSS_MAPPING[option], !!value);
    }
  },
  
  /**
   * Returns the regexp validator instance or creates it if needed and caches it.
   * @private
   */
  _getDefaultRegExpValidator : function ()
  {
    var vf;
    this.__defaultRegExpOptions = {'pattern': this.options['pattern'], 
                                   'label': this._getLabelText()};

    vf = oj.Validation.validatorFactory(oj.ValidatorFactory.VALIDATOR_TYPE_REGEXP);
    return vf ? vf.createValidator(this.__defaultRegExpOptions) : null;
  },  
  
  /**
   * This helper function will generate ids using widget's uuid as unique identifier for 
   * wai-aria and other necessary ids
   * 
   * @ignore
   * @protected
   * @param {string} sub
   * @return {string}
   */
  _GetSubId : function __getSubId(sub)
  {
    return this["uuid"] + "_" + sub;
  },
  
  /**
   * Returns a jquery object of the element that triggers messaging behavior. The trigger element 
   * is usually an input or select or textarea element for which a value can be set/retrieved and 
   * validated. 
   * 
   * @return {Object} jquery object 
   * 
   * @memberof! oj.editableValue
   * @instance
   * @protected
   */
  _GetMessagingLauncherElement : function ()
  {
    return this.widget();
  },
  
  /**
   * @ignore
   * @protected
   * @return {boolean}
   */
  _IsRTL : function ()
  {
    return this._GetReadingDirection() === "rtl";
  },
  
  /**
   * Return the subcomponent node represented by the documented locator attribute values.
   * @expose
   * @override
   * @param {Object} locator An Object containing at minimum a subId property whose value is a string, documented by the component, that allows the component to 
   *                        look up the subcomponent associated with that string.  It contains:<p>
   *                        component: optional - in the future there may be more than one component contained within a page element<p>
   *                        subId: the string, documented by the component, that the component expects in getNodeBySubId to locate a particular subcomponent
   * @returns {Object|null} the subcomponent located by the subId string passed in locator, if found.<p>
   */
  getNodeBySubId: function(locator)
  {
    if (locator == null)
    {
      return this.element ? this.element[0] : null;
    }
    return null;
  },
  
  widget : function _widget() 
  {
    return this._DoWrapElement() ? this._wrapper : this.element;
  }

});
/*!
 * JET Input  Text @VERSION
 * http://jqueryui.com
 *
 * Copyright 2013 jQuery Foundertion and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * Depends:
 *  jquery.ui.widget.js
 */
/**
 * @class
 * @name oj.ojInputText
 * @augments oj.inputBase
 * 
 * @classdesc
 * <h3 id="inputTextOverview-section">
 *   JET ojInputText Component
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#inputTextOverview-section"></a>
 * </h3>
 * 
 * <p>Description: The ojInputText component enhances a browser input type="text" element.
 * 
 * <h3 id="pseudos-section">
 *   Pseudo-selectors
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#pseudos-section"></a>
 * </h3>
 * 
 * <pre class="prettyprint">
 * <code>$( ":oj-inputText" )            // selects all JET input on the page
 * </code>
 * </pre>
 * 
 * <h3 id="binding-section">
 *   Declarative Binding
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#binding-section"></a>
 * </h3>
 * 
 * <pre class="prettyprint">
 * <code>
 *    &lt;input id="textId" data-bind="ojComponent: {component: 'ojInputText'}" /&gt;
 * </code>
 * </pre>
 * 
 * @desc Creates or re-initializes a JET ojInputText
 * 
 * @param {Object=} options a map of option-value pairs to set on the component
 * 
 * @example <caption>Initialize the input element with no options specified:</caption>
 * $( ".selector" ).ojInputText();
 * 
 * * @example <caption>Initialize the input element with some options:</caption>
 * $( ".selector" ).ojInputText( { "disabled": true } );
 * 
 * @example <caption>Initialize the input element via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;input id="textId" data-bind="ojComponent: {component: 'ojInputText'}" /&gt;
 */
oj.__registerWidget("oj.ojInputText", $['oj']['inputBase'],
{
  version : "1.0.0",  
  defaultElement : "<input>", 
  widgetEventPrefix : "oj", 
  
  /** 
   * @expose
   * @private
   */
  _ATTR_CHECK : [{"attr": "type", "setMandatory": "text"}],
  
  /** 
   * @expose
   * @private
   */
  _CLASS_NAMES : "oj-inputtext-input",
  
  /** 
   * @expose
   * @private
   */
  _WIDGET_CLASS_NAMES : "oj-inputtext oj-form-control oj-component",
  
  /**
   * @override
   * @protected
   * @return {string}
   */
  _GetDefaultStyleClass : function ()
  {
    return "oj-inputtext";
  }
  
});
/*!
 * JET TextArea @VERSION
 * http://jqueryui.com
 *
 * Copyright 2013 jQuery Foundertion and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * Depends:
 *  jquery.ui.widget.js
 */
/**
 * @class
 * @name oj.ojTextArea
 * @augments oj.inputBase
 * 
 * @classdesc
 * <h3 id="textAreaOverview-section">
 *   JET ojTextArea Component
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#textAreaOverview-section"></a>
 * </h3>
 * 
 * <p>Description: The ojTextArea component enhances a browser textarea element.
 * 
 * <h3 id="pseudos-section">
 *   Pseudo-selectors
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#pseudos-section"></a>
 * </h3>
 * 
 * <pre class="prettyprint">
 * <code>$( ":oj-textarea" )            // selects all JET textarea on the page
 * </code>
 * </pre>
 * 
 * <h3 id="binding-section">
 *   Declarative Binding
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#binding-section"></a>
 * </h3>
 * 
 * <pre class="prettyprint">
 * <code>
 *    &lt;textarea id="textAreaId" data-bind="ojComponent: {component: 'ojTextArea'}" &gt;&lt;/textarea&gt;
 * </code>
 * </pre>
 * 
 * @desc Creates or re-initializes a JET ojTextArea.
 * 
 * @param {Object=} options a map of option-value pairs to set on the component
 * 
 * @example <caption>Initialize the textarea with no options specified:</caption>
 * $( ".selector" ).ojTextArea();
 * 
 * * @example <caption>Initialize the textarea with some options:</caption>
 * $( ".selector" ).ojTextArea( { "disabled": true } );
 * 
 * @example <caption>Initialize the textarea via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;textarea id="textAreaId" data-bind="ojComponent: {component: 'ojTextArea'}" &gt;&lt;/textarea&gt;
 */
oj.__registerWidget("oj.ojTextArea", $['oj']['inputBase'],
{
  version : "1.0.0",  
  defaultElement : "<textarea>", 
  widgetEventPrefix : "oj", 
  
  /** 
   * @expose
   * @private
   */
  _ATTR_CHECK : [],
  
  /** 
   * @expose
   * @private
   */
  _CLASS_NAMES : "oj-textarea-input",
  
  /** 
   * @expose
   * @private
   */
  _WIDGET_CLASS_NAMES : "oj-textarea oj-form-control oj-component",
  
  /**
   * @override
   * @protected
   * @return {string}
   */
  _GetDefaultStyleClass : function ()
  {
    return "oj-textarea";
  }
  
});
/*!
 * JET Input Password @VERSION
 * http://jqueryui.com
 *
 * Copyright 2013 jQuery Foundertion and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * Depends:
 *  jquery.ui.widget.js
 */
/**
 * @class
 * @name oj.ojInputPassword
 * @augments oj.inputBase
 * 
 * @classdesc
 * <h3 id="inputPasswordOverview-section">
 *   JET ojInputPassword Component
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#inputPasswordOverview-section"></a>
 * </h3>
 * 
 * <p>Description: The ojInputPassword component enhances a browser input type="password" element.
 * 
 * <h3 id="pseudos-section">
 *   Pseudo-selectors
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#pseudos-section"></a>
 * </h3>
 * 
 * <pre class="prettyprint">
 * <code>$( ":oj-inputPassword" )            // selects all JET input on the page
 * </code>
 * </pre>
 * 
 * <h3 id="binding-section">
 *   Declarative Binding
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#binding-section"></a>
 * </h3>
 * 
 * <pre class="prettyprint">
 * <code>
 *    &lt;input id="passwordId" data-bind="ojComponent: {component: 'ojInputPassword'}" /&gt;
 * </code>
 * </pre>
 * 
 * @desc Creates or re-initializes a JET ojInputPassword
 * 
 * @param {Object=} options a map of option-value pairs to set on the component
 * 
 * @example <caption>Initialize the input element with no options specified:</caption>
 * $( ".selector" ).ojInputPassword();
 * 
 * * @example <caption>Initialize the input element with some options:</caption>
 * $( ".selector" ).ojInputPassword( { "disabled": true } );
 * 
 * @example <caption>Initialize the input element via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;input id="passwordId" data-bind="ojComponent: {component: 'ojInputPassword'}" /&gt;
 */
oj.__registerWidget("oj.ojInputPassword", $['oj']['inputBase'],
{
  version : "1.0.0",  
  defaultElement : "<input>", 
  widgetEventPrefix : "oj", 
  
  /** 
   * @expose
   * @private
   */
  _ATTR_CHECK : [{"attr": "type", "setMandatory": "password"}],
  
  /** 
   * @expose
   * @private
   */
  _CLASS_NAMES : "oj-inputpassword-input",
  
  /** 
   * @expose
   * @private
   */
  _WIDGET_CLASS_NAMES : "oj-inputpassword oj-form-control oj-component",
  
  /**
   * @override
   * @protected
   * @return {string}
   */
  _GetDefaultStyleClass : function ()
  {
    return "oj-inputpassword";
  }
   
});
/*
** Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.
**
**34567890123456789012345678901234567890123456789012345678901234567890123456789
*/

/*global ojld:true*/

/**
 * @class Locale Data Services
 * @export
 */
oj.LocaleData = {};

/**
 * Sets the Locale Elements bundle used by JET
 * If an AMD loader (such as Require.js) is not present, this method should be called by the application to provide
 * a Locale Elements for JET.
 * This method may also be used by an application that wants to completely replace the Locale Elements bundle that is automatically
 * fetched by an AMD loader.
 * @param {Object} bundle resource bundle that should be used by the framework
 * @export
 */
oj.LocaleData.setBundle = function(bundle)
{
  oj.LocaleData._bundle = bundle;
};

/**
 * Retrieves the first day of week for the current locale's region
 * @return {number} a numeric representation of the first week day of the week: 
 * 0 for Sunday, 1 for Monday, etc.
 * @export
 */
oj.LocaleData.getFirstDayOfWeek = function()
{
  return oj.LocaleData._getWeekData("firstDay");
};

/**
 * Retrieves the first weekend day for the current locale's region
 * @return {number} a numeric representation of the first weekend day: 
 * 0 for Sunday, 1 for Monday, etc.
 * @export
 */
oj.LocaleData.getWeekendStart = function()
{
  return oj.LocaleData._getWeekData("weekendStart");
};

/**
 * Retrieves the last weekend day for the current locale's region
 * @return {number} a numeric representation of the last weekend day: 
 * 0 for Sunday, 1 for Monday, etc.
 * @export
 */
oj.LocaleData.getWeekendEnd = function()
{
  return oj.LocaleData._getWeekData("weekendEnd");
};

/**
 * Retrieves locale-specific names of the days of the week
 * @return {Array.<string>} names of the days from Sunday through Sturday
 * @param {string} type - the type of the name. Currently, "abbreviated", "narrow" and "wide" are supported
 * @export
 */
oj.LocaleData.getDayNames = function(type)
{
  if (type== null || (type !== "abbreviated" && type !== "narrow"))
  {
    type = "wide";
  }
  var days = oj.LocaleData._getCalendarData()["days"]["stand-alone"][type];
  
  return [days["sun"], days["mon"], days["tue"], days["wed"], days["thu"],  days["fri"],  days["sat"]];
};

/**
 * Retrieves locale-specific names of months
 * @return {Array.<string>} names of months from January through December
 * @param {string} type - the type of the name. Currently, "abbreviated", "narrow" and "wide" are supported
 * @export
 */
oj.LocaleData.getMonthNames = function(type)
{
  if (type== null || (type !== "abbreviated" && type !== "narrow"))
  {
    type = "wide";
  }
  var months = oj.LocaleData._getCalendarData()["months"]["stand-alone"][type];
  
  return [months["1"], months["2"], months["3"], months["4"], months["5"], months["6"],
           months["7"], months["8"], months["9"], months["10"], months["11"], months["12"]];
};

/**
 * Retrieves whether month is displayed prior to year
 * @return {boolean} whether month is prior to year
 * @export
 */
oj.LocaleData.isMonthPriorToYear = function() 
{
  var longDateFormat = oj.LocaleData._getCalendarData()["dateFormats"]["long"].toUpperCase(),
      monthIndex = longDateFormat.indexOf("M"),
	  yearIndex = longDateFormat.indexOf("Y");
  
  return monthIndex < yearIndex;
}

/**
 * @hidden
 */
oj.LocaleData._getWeekData = function(key)
{
  var b = oj.LocaleData.__getBundle();
  var defRegion = "001";
  var region = oj.LocaleData._getRegion() || defRegion;
  
  var data = b["supplemental"]["weekData"][key];
  
  var val = data[region];
  
  if (val === undefined)
  {
    val = data[defRegion];
  }
  
  return val;
};

/**
 * @hidden
 */
oj.LocaleData._getCalendarData = function()
{
   var b = oj.LocaleData.__getBundle();
   var main  = b['main'];
   
   // skip one level (the name of the locale)
   var data, p;
   for (p in main)
   {
     if (main.hasOwnProperty(p)) {
        data = main[p];
        break;
     }
   }
   return data['dates']['calendars']['gregorian'];
};

/**
 * @hidden
 */
oj.LocaleData._getRegion = function()
{
  var locale = oj.Config.getLocale();
  if (locale)
  {
    var tokens = locale.toUpperCase().split(/-|_/);
    if (tokens.length >= 2)
    {
      var tag = tokens[1];
      if (tag.length == 4) // this is a script tag
      {
        if (tokens.length >= 3)
        {
          return tokens[2];
        }
      }
      else
      {
        return tag;
      }
    }
  }
  return null;
};

/**
 * @hidden
 */
oj.LocaleData.__getBundle = function()
{
  var b = oj.LocaleData._bundle;
  if (b)
  {
    return b;
  }
  
  if (oj.__isAmdLoaderPresent()) {
    oj.Assert.assert(ojld !== undefined, "LocaleElements module must be loaded");
    return ojld;
  }
  return {};
};

/**
 * @hidden
 * Called from oj.Config after AMD loader fetches LocaleElements for the new locale
 */
oj.LocaleData.__updateBundle = function(bundle)
{
  ojld = bundle;
};
/**
 * This is a forked version of globalize.js
 */
/*
 * Copyright Software Freedom Conservancy, Inc.
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 */

/*
   DESCRIPTION
   oji18nImpl.js provides implementation for number and date-time converters
   based on ECMA-402 specification. It also supports user defined patterns and
   lenient parsing. The locale data is based on CLDR.

   PRIVATE CLASSES
    <list of private classes defined - with one-line descriptions>

   NOTES
    <other useful comments, qualifications, etc.>

   MODIFIED    (MM/DD/YY)
    gmurr       01/08/13 - Creation
 */



 
/**  
 * <p>
 * oji18nImpl.js module provides APIs for DateTime and number formatting and 
 * parsing. The locale data
 * definitions will be based on CLDR locale data. It is the user responsibility 
 * to pass the locale data
 * to the format/parse functions. 
 * <p>The format and parse functions can throw the following exceptions:
 * <li> RangeError can be thrown during the validation of the options:
 * Example: The value 'longs' is out of range for 'OraDateTimeConverter.parse'
 * options property 'year'. Expected: ['2-digit', 'numeric']<br>
 * var errorInfo = {<br>
 *   'errorCode' : "optionOutOfRange",<br>
 *   'parameterMap' : {<br>
 *   'propertyName': $property$,<br>
 *   'propertyValue': $options.property$,<br>
 *   'propertyValueValid': $expectedValues$,<br>
 *   'caller': $_getOptionCaller$<br>
 * }<br>
 * };<br>
 * <br>
 * <br>
 * <li> TypeError can be thrown when currency is missing for currency style. It 
 * can be generic when an options requires a corresponding  option value.<br>
 * Example: A value for the property currency is required when the property
 * style is set to the value currency. An accepted value is a three-letter
 * ISO 4217 currency code.<br>
 * var errorInfo = {<br>
 * 'errorCode' : "optionTypesMismatch",<br>  
 * 'parameterMap' : {<br>
 * 'propertyName': 'style', // the driving property<br>
 * 'propertyValue': 'currency', // the driving property's value<br>
 * 'requiredPropertyName': 'currency', // the required property name<br>
 * 'requiredPropertyValueValid': 'a three-letter ISO 4217 currency code'<br>
 * }<br>
 * };<br>
 * 
 * <br>
 * <br>
 * <li>SyntaxError can be thrown when the date format is invalid. it can happen
 * during the calls to parse and format date.<br>
 * Example: Unexpected character(s) encountered in the pattern "MM/dd/cc".<br>
 * An example of a valid pattern is "MM/dd/y".<br>
 * var errorInfo = {<br>
 * 'errorCode' : "optionValueInvalid",<br> 
 * parameterMap : {'propertyName' : 'pattern',<br>
 *                 'propertyValue': $options.pattern$,<br>
 *                 'propertyValueHint': $format$}<br>
 * };<br>
 * <br>
 * <br>
 * <li>Error can be thrown when there is mismatch between date format and
 * date string. it can happen during the calls to parse date.<br>
 * Example: The value "03,05,12" does not match the expected date format
 * "MM/dd/yy"<br>
 * errorInfo = {'errorCode' : "datetimeFormatMismatch", 'parameterMap' : 
 * { 'value': $value$,  'format': $format$}};<br>
 * errorInfo = {'errorCode' : "timeFormatMismatch", 'parameterMap' : 
 * { 'value': $value$,  'format': $format$}};<br>
 * verrorInfo = {'errorCode' : "dateFormatMismatch", 'parameterMap' : 
 * { 'value': $value$,  'format': $format$}};<br>
 * <br>
 *
 * <br>
 * <li>RangeError can be thrown if one of the date fields is out of range.
 * It can happen during the calls to parse date.<br>
 * Example: 64  is out of range.  Enter a value between 0 and 59 for minute 
 * ({'value'} is out of range. Enter a value between {'minValue'} and 
 * {'maxValue'} for {'propertyName'})<br>
 * errorInfo = {<br>
 * 'errorCode' : "datetimeOutOfRange",<br>
 * 'parameterMap' : {'value': $value$, 'minValue': $mainValue$,
 * 'maxVlaue': $maxValue$, 'propertyName': $name$}<br>
 * };<br>
 * <br>
 * <br>
 * <li>SyntaxError  can be thrown during the parsing of the number pattern.
 * It can happen during the calls to parse and format number when the user
 * provides pattern in the options.
 * Or if for some reason the pattern is invalid inside the locale data.<br>
 * <br>
 * Example: Unexpected character(s) encountered in the pattern "#,0##0.0.0". 
 * An example of a valid pattern is "#,##0.0.0".<br>
 * errorInfo = {<br>
 * 'errorCode' : "optionValueInvalid",p<br>
 * 'parameterMap : {'propertyName' : 'pattern',
 * 'propertyValue': $options.pattern$, 'propertyValueHint': $format$}<br>
 * };<br>
 * <br>
 * <li>Error can be thrown when there is mismatch between number pattern and
 * number string. it can happen during the calls to parse number.<br>
 * Example: The value "-$125" does not match the expected currency 
 * pattern "&#xa4;#,##0.00;(&#xa4;#,##0.00)"<br>
 * errorInfo = {'errorCode' : "decimalFormatMismatch", 
 * 'parameterMap' : { 'value': $value$,  'format': $format$}};<br>
 * errorInfo = {'errorCode' : "currencyFormatMismatch", 
 * 'parameterMap' : { 'value': $value$,   'format': $format$}};<br>
 * errorInfo = {'errorCode' : "percentFormatMismatch", 
 * 'parameterMap' : { 'value': $value$,   'format': $format$}};<br>
 *
 * <br>
 * <br>
 * <li>Error  can be thrown during the parsing of a date. it can happen during
 * the calls to parse and format number when the user provides pattern in the 
 * options.
 * Or if for some reason the pattern is invalid inside the locale data.<br>
 * <br>
 * Example: Unexpected character(s) encountered in the pattern "#,0##0.0.0". 
 * An example of a valid pattern is "#,##0.0.0".<br>
 * errorInfo = {<br>
 * 'errorCode' : "optionValueInvalid",p<br>
 * 'parameterMap : {'propertyName' : 'pattern',
 * 'propertyValue': $options.pattern$, 'propertyValueHint': $format$}<br>
 * };<br>
 * <br>
 * <li>Error can be thrown when there is mismatch between weekday and date.
 * It can happen during the calls to parse date.<br>
 * Example: If the user provides "Monday November 26 2013" as input to parse
 * method. The error will be:<br>
 * The weekday Monday does not match the date 26.
 * errorInfo = {'errorCode' : "dateToWeekdayMismatch", 
 * 'parameterMap' : { 'weekday': $weekday$,  'date': $day$}};<br>
 * errorInfo = {'errorCode' : "currencyFormatMismatch", 
 * 'parameterMap' : { 'value': $value$,   'format': $format$}};<br>
 * errorInfo = {'errorCode' : "percentFormatMismatch", 
 * 'parameterMap' : { 'value': $value$,   'format': $format$}};<br>
 *
 */
 
/**
 * @class
 * @name OraNumberConverter
 */
var OraNumberConverter;
/**
 * @class
 * @name OraDateTimeConverter
 */
var OraDateTimeConverter;
 
(function () {
   
  var _parseBCP47, _getLanguageExtension, _parseExtension, _toUpper,
  _trim, _startsWith,
  _getLocaleElementsMainNode, _getLocaleElementsMainNodeKey, _getGetOption,
  _getNumberingSystemKey,
  _localeDataCache = {};
  
  var numeringSystems = {
    'latn' : "\u0030\u0031\u0032\u0033\u0034\u0035\u0036\u0037\u0038\u0039",
    'arab' : "\u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669",
    'thai' : "\u0e50\u0e51\u0e52\u0e53\u0e54\u0e55\u0e56\u0e57\u0e58\u0e59"
  };
  
  _trim = function(value) {
    var regexTrim = /^\s+|\s+$|\u200f|\u200e/g;
    return (value + "").replace(regexTrim, "");
  };
    
  _startsWith = function(value, pattern) {
    return value.indexOf(pattern) === 0;
  };
    
  _toUpper = function(value) {
    // "he-IL" has non-breaking space in weekday names.
    return value.split("\u00A0").join(" ").toUpperCase();
  };

  _getNumberingSystemKey = function(localeElements, locale){
    if(locale === undefined)
      return 'latn';
    var numberingSystemKey = _getLanguageExtension(locale, "nu") || "";
    var symbols = "symbols-numberSystem-" + numberingSystemKey;
    if(localeElements['numbers'][symbols] === undefined)
      numberingSystemKey =  'latn';
    return numberingSystemKey;
  };
  
  _parseBCP47 = function (tag){
    var re = /^(?:(en-GB-oed|i-(?:ami|bnn|default|enochian|hak|klingon|lux|mingo|navajo|pwn|tao|tay|tsu)|sgn-(?:BE-FR|BE-NL|CH-DE))|(art-lojban|cel-gaulish|no-(?:bok|nyn)|zh-(?:guoyu|hakka|min|min-nan|xiang)))$|^(x(?:-[0-9a-z]{1,8})+)$|^(?:((?:[a-z]{2,3}(?:(?:-[a-z]{3}){1,3})?)|[a-z]{4}|[a-z]{5,8})(?:-([a-z]{4}))?(?:-([a-z]{2}|[0-9]{3}))?((?:-(?:[a-z0-9]{5,8}|[0-9][a-z0-9]{3}))*)?((?:-[0-9a-wy-z](?:-[a-z0-9]{2,8}){1,})*)?(-x(?:-[0-9a-z]{1,8})+)?)$/i;
    var match = re.exec (tag);
    if (!match) return null;
	
    var match4 = match[4];
    match4 = match4 ? match4.split ("-") : null;
    var language = null;
    if (match4) language = match4.shift ();
	
    var match7 = match[7];
    match7 = match7 ? match7.split ("-") : null;
    if (match7) match7.shift ();
	
    var match9 = match[9];
    match9 = match9 ? match9.split ("-") : null;
    if (match9){
      match9.shift ();
      match9.shift ();
    }
	
    var match3 = match[3];
    match3 = match3 ? match3.split ("-") : null;
    if (match3) match3.shift ();
    return {
      language: {
        language: language,
        extlang: match4 || []
      },
      script: match[5] || null,
      region: match[6] || null,
      variant: match7 || null,
      extension: _parseExtension (match[8]),
      privateuse: match9 || match3 || [],
      grandfathered: {
        irregular: match[1] || null,
        regular: match[2] || null
      }
    };
  };

  _parseExtension = function (tag){
      
    if (!tag) return [];

    var extensions = [];
    var e;
    var c;
    var newExtension = false;
    var singleton = false;
    var extension = "";
    var parsingExtension = false;
	
    for (var i=0, len=tag.length; i<len; i++){
      c = tag[i];
		
      if (c === "-" && !newExtension){
        newExtension = true;
        e = {
          'singleton': null,
          'extension': []
        };
        continue;
      }
		
      if (newExtension && !singleton){
        singleton = true;
        e['singleton'] = c;
        continue;
      }
		
      if (c === "-"){
        if (!parsingExtension){
          extension = "";
          parsingExtension = true;
        }else{
          if (extension.length === 1){
            parsingExtension = false;
            singleton = false;
            extensions.push (e);
            e = {
              'singleton': null,
              'extension': []
            };
          }
          else{
            e['extension'].push (extension);
            extension = "";
          }
        }
        continue;
      }
		
      extension += c;
    }
	
    e['extension'].push (extension);
    extensions.push (e);
	
    return extensions;
  }; 
    
  _getLanguageExtension = function(locale, token){
    locale = locale || "en-US";
    var parsedLang = _parseBCP47(locale);
    if(parsedLang === null || parsedLang === undefined)
      return null;
    var ext = parsedLang['extension'];
    var localeExtension;
    for(var i in ext) {
      if(ext[i]['singleton'] === 'u') {
        for(var j in ext[i]['extension']) {
          if(ext[i]['extension'][j] === token) {
            j++;
            localeExtension = ext[i]['extension'][j];
            break;
          }
        }
        break;
      }
    }
    return localeExtension;    
  };
    
  _getLocaleElementsMainNode= function(bundle) {
    var mainNode = bundle['main'];
    var subnode;
    for (var n in mainNode)
    {
      subnode = n;
      break;
    }
    return mainNode[subnode];
  }
  
  _getLocaleElementsMainNodeKey= function(bundle) {
    var mainNode = bundle['main'];
    var subnode;
    for (var n in mainNode)
    {
      subnode = n;
      break;
    }
    return subnode;
  }
  
  _getGetOption = function(options, getOptionCaller) {
    if (options === undefined) {
      throw new Error('Internal ' + getOptionCaller +
        ' error. Default options missing.');
    }

    var getOption = function getOption(property, type, values, defaultValue) {
      if (options[property] !== undefined) {
        var value = options[property];
        switch (type) {
          case 'boolean':
            value = Boolean(value);
            break;
          case 'string':
            value = String(value);
            break;
          case 'number':
            value = Number(value);
            break;
          default:
            throw new Error('Internal error. Wrong value type.');
        }
        if (values !== undefined && values.indexOf(value) === -1) {
          var expectedValues = [];
          for(var i=0; i < values.length; i++) {
            expectedValues.push(values[i]);
          }
          var msg = "The value '" + options[property] +
          "' is out of range for '" + getOptionCaller +
          "' options property '" + property + "'. Valid values: " + 
          expectedValues; 
          var rangeError = new RangeError(msg);
          var errorInfo = {
            'errorCode' : 'optionOutOfRange',
            'parameterMap' : {
              'propertyName': property,
              'propertyValue': options[property],
              'propertyValueValid': expectedValues,
              'caller': getOptionCaller
            }
          };
          rangeError['errorInfo'] = errorInfo;
          throw rangeError;
        }

        return value;
      }
      return defaultValue;
    }

    return getOption;
  }

  OraNumberConverter = (function () {
    var regexInfinity,
    regexParseFloat,
    _startsWith,
    _zeroPad,
    _formatNumberImpl,
    _applyPatternImpl,
    _parseNegativePattern,
    _parseNegativeExponent,
    _getNumberSettings,
    _validateNumberOptions,
    _throwMissingCurrency;

    var instance;
 
    regexInfinity = /^[+\-]?infinity$/i;
    regexParseFloat = /^[+\-]?\d*\.?\d*(e[+\-]?\d+)?$/;
    
    _startsWith = function(value, pattern) {
      return value.indexOf(pattern) === 0;
    };

    _zeroPad = function(str, count, left) {
      var l;
      for (l = str.length; l < count; l += 1) {
        str = (left ? ("0" + str) : (str + "0"));
      }
      return str;
    };

    _getNumberSettings = function(localeElements, numberSettings,
      options, locale) {
      var pat;
      var numberingSystemKey = _getNumberingSystemKey(localeElements, locale);
      numberSettings['numberingSystemKey'] = numberingSystemKey;
      numberSettings['numberingSystem'] = "symbols-numberSystem-" +
      numberingSystemKey;        

      //pattern passed in options
      if(options['pattern'] !== undefined && options['pattern'].length > 0) {
        pat = options['pattern'];
      }
      else
      {  
        var key;
        switch(options['style'])
        {
          case "decimal" :
            key = "decimalFormats-numberSystem-" +
            numberSettings['numberingSystemKey'];
            pat = localeElements['numbers'][key]['standard'];
            break;
          case "currency" :
            key = "currencyFormats-numberSystem-" +
            numberSettings['numberingSystemKey'];
            pat = localeElements['numbers'][key]['standard'];
            break;
          case "percent" :
            key = "percentFormats-numberSystem-" +
            numberSettings['numberingSystemKey'];
            pat = localeElements['numbers'][key]['standard'];
            break;
          default:
            key = "decimalFormats-numberSystem-" +
            numberSettings['numberingSystemKey'];
            pat = localeElements['numbers'][key]['standard'];
            break;
        }
      }
      numberSettings['pat'] = pat;
      numberSettings['decimalSeparator'] = localeElements['numbers']
      [numberSettings['numberingSystem']]['decimal'];
      numberSettings['groupingSeparator'] = localeElements['numbers']
      [numberSettings['numberingSystem']]['group'];
      numberSettings['currencyDisplay'] = options['currencyDisplay'];
      if(options['currency'] !== undefined)
        numberSettings['currencyCode'] = options['currency'].toUpperCase();
      numberSettings['style'] = options['style'];
      _applyPatternImpl(options, pat, localeElements, numberSettings);
      if(options['pattern'] === undefined) {
        var nb;
        if(options['maximumFractionDigits'] !== undefined) {
          nb = parseInt(options['maximumFractionDigits'], 10);
          numberSettings['maximumFractionDigits'] = nb;
          if(numberSettings['maximumFractionDigits'] < numberSettings['minimumFractionDigits']) {
            numberSettings['minimumFractionDigits'] = numberSettings['maximumFractionDigits'];
          }
        }
        if(options['minimumFractionDigits'] !== undefined) {
          nb = parseInt(options['minimumFractionDigits'], 10);
          numberSettings['minimumFractionDigits'] = nb;
        }
        if(numberSettings['maximumFractionDigits'] < numberSettings['minimumFractionDigits']) {
          numberSettings['maximumFractionDigits'] = numberSettings['minimumFractionDigits'];
        }
        if(options['minimumIntegerDigits'] !== undefined) {
          nb = parseInt(options['minimumIntegerDigits'], 10);
          numberSettings['minimumIntegerDigits'] = nb;
        }
      }
    };
    
    _throwMissingCurrency = function(prop) {
      var typeError = new TypeError('The property "currency" is required when' +
        'the property "' + prop + '" is "currency". An accepted value is a ' +
        'three-letter ISO 4217 currency code.');
      var errorInfo = {
        'errorCode' : 'optionTypesMismatch',
        'parameterMap' : {
          'propertyName': prop, // the driving property
          'propertyValue': 'currency', // the driving property's value
          'requiredPropertyName': 'currency', // the required property name
          'requiredPropertyValueValid':  'a three-letter ISO 4217 currency code'  
        }
      };
      typeError['errorInfo'] = errorInfo;
      throw typeError;
    };
    
    _validateNumberOptions = function(options, caller) {
      var getOption = _getGetOption(options, caller);
      var s = getOption('style', 'string', ['currency', 'decimal', 'percent', 'perMill'],
        'decimal');
      var c =getOption('currency', 'string');
      if(s === 'currency' && c === undefined) {
        _throwMissingCurrency("style");
      }
    };
    
    // formatNumber
    (function() {
      var _expandNumber;

      _expandNumber = function(number, options, numberSettings) {
        var curSize = numberSettings['groupingSize'];
        if(numberSettings['isPercent'] === true ||
          options['style'] === 'percent')
          number *= 100;
        else if(numberSettings['isPerMill'] === true)
          number *= 1000;
        var numberString = number + "";     
        var split = numberString.split( /e/i );
        var exponent = split.length > 1 ? parseInt( split[1], 10 ) : 0;
        numberString = split[ 0 ];
        split = numberString.split('.');
        var right = split.length > 1 ? split[ 1 ] : "";

        //round the number only if it has decimal points
        if(split.length > 1 && right.length > exponent)      
        {
          var precision = Math.min(numberSettings['maximumFractionDigits'],
            right.length-exponent);
          var factor = Math.pow( 10, precision ),
          rounded = Math.round( number * factor )  / factor;
          if ( !isFinite(rounded) ) {
            rounded = number;
          }
          number = rounded;
        }
      
        numberString = number + "";
        split = numberString.split( /e/i );
        exponent = split.length > 1 ? parseInt( split[1], 10 ) : 0;
        numberString = split[ 0 ];
        split = numberString.split('.');
        numberString = split[ 0 ];
        right = split.length > 1 ? split[ 1 ] : "";

        if (exponent > 0) {
          right = _zeroPad(right, exponent, false);
          numberString += right.slice(0, exponent);
          right = right.substr(exponent);
        }
        else if (exponent < 0) {
          exponent = -exponent;
          numberString = _zeroPad(numberString, exponent + 1, true);
          right = numberString.slice(-exponent, numberString.length) + right;
          numberString = numberString.slice(0, -exponent);
        }
        if (precision > 0) {       
          right = numberSettings['decimalSeparator'] +
          ((right.length > precision) ? right.slice(0, precision) : 
            _zeroPad(right, precision, false));
        }
        else {
          if (numberSettings['minimumFractionDigits'] > 0){
            right = numberSettings['decimalSeparator'];
          }
          else {
            right = "";
          }
        }
        var padLen = numberSettings['decimalSeparator'].length +
        numberSettings['minimumFractionDigits'];
        right = _zeroPad(right, padLen, false);
        var sep = numberSettings['groupingSeparator'],
        ret = "";
        if(options['useGrouping'] === false && options['pattern'] === undefined)
          sep = '';      
        numberString = _zeroPad(numberString,
          numberSettings['minimumIntegerDigits'], true);
        var stringIndex = numberString.length - 1;
        right = right.length > 1 ? right : "";
        var rets;
        while (stringIndex >= 0) {
          if (curSize === 0 || curSize > stringIndex) {
            rets = numberString.slice(0, stringIndex + 1) +
            (ret.length ? (sep + ret + right) : right);
            return rets;
          }
          ret = numberString.slice(stringIndex - curSize + 1, stringIndex + 1) +
          (ret.length ? (sep + ret) : "");
          stringIndex -= curSize;
        }
        rets = numberString.slice(0, stringIndex + 1) + sep + ret + right;
        return rets;
      };

      _formatNumberImpl = function(value, options, localeElements,
        numberSettings, locale) {
        if (!isFinite(value)) {
          if (value === Infinity) {
            return localeElements['numbers'][numberSettings['numberingSystem']]['infinity'];
          }
          if (value === -Infinity) {
            return localeElements['numbers'][numberSettings['numberingSystem']]['infinity'];
          }
          return localeElements['numbers'][numberSettings['numberingSystem']]['nan'];
        }
		
        var number = Math.abs(value);
        number = _expandNumber(number, options, numberSettings);
        var ret = "";
        if(value < 0) {
          ret += numberSettings['negativePrefix'] + number +
          numberSettings['negativeSuffix'];
        }
        else {
          ret += numberSettings['positivePrefix'] + number +
          numberSettings['positiveSuffix'];
        }
        var numberingSystemKey =  _getLanguageExtension(locale, "nu");
        if(numeringSystems[numberingSystemKey] === undefined)
          numberingSystemKey = 'latn';
        if(numberingSystemKey !== 'latn') {
          var idx;
          var nativeRet = [];
          for(idx = 0; idx < ret.length; idx++)
          {
            if(ret[idx] >= '0' && ret[idx] <= '9')
              nativeRet.push(numeringSystems[numberingSystemKey][ret[idx]]);
            else nativeRet.push(ret[idx]);
        
          }
          return nativeRet.join("");
        }
        return ret;
      };

    }());
    
    //remove prefix and suffix, return a sign and value
    _parseNegativePattern = function(value, options, numberSettings,
      localeElements) {
      
      var ret, num = _trim(value), sign = "";
      var exactMatch = false;
      //try exact match of negative prefix and suffix
      var posPrefRegexp = new RegExp("^" + (numberSettings['positivePrefix'] ||
        "+").replace(/([\^\$\.\*\+\?\|\[\]\(\)\{\}])/g, "\\$1"));
      var posSuffRegexp = new RegExp((numberSettings['positiveSuffix'] || "").
        replace(/([\^\$\.\*\+\?\|\[\]\(\)\{\}])/g, "\\$1") + "$");
      var negPrefRegexp = new RegExp("^" + (numberSettings['negativePrefix'] ||
        "-").replace(/([\^\$\.\*\+\?\|\[\]\(\)\{\}])/g, "\\$1"));
      var negSuffRegexp = new RegExp((numberSettings['negativeSuffix'] ||
        "").replace(/([\^\$\.\*\+\?\|\[\]\(\)\{\}])/g, "\\$1") + "$");

      if(num.search(negPrefRegexp) >= 0 && num.search(negSuffRegexp) >= 0) {   
        num = num.replace(negPrefRegexp, "");
        num = num.replace(negSuffRegexp, "");
        sign = "-";
        exactMatch = true;
      }
      //try exact match of positive prefix and suffix
      else if(num.search(posPrefRegexp) >= 0 && num.search(posSuffRegexp) >= 0){
        num = num.replace(posPrefRegexp, "");
        num = num.replace(posSuffRegexp, "");
        sign = "+";
        exactMatch = true;
      }
      //if style is currency, remove currency symbol from prefix and suffix 
      //and try a match
      else if (options['style'] === 'currency') {
        var code = numberSettings['currencyCode'], symbol = code;
        var posPrefix, posSuffix, negPrefix, negSuffix, repStr;
        if(localeElements['numbers']['currencies'][code] !== undefined) {
          symbol = localeElements['numbers']['currencies'][code]['symbol'];
        }
        if(numberSettings['currencyDisplay'] === undefined ||
          numberSettings['currencyDisplay'] === "symbol"){
          repStr = symbol;
        }
        else if (numberSettings['currencyDisplay'] === "code") {
          repStr = code;
        }
        if(repStr !== undefined) {
          posPrefix = (numberSettings['positivePrefix'] || "").replace(
            repStr, "");
          posSuffix = (numberSettings['positiveSuffix'] || "").replace(
            repStr, "");
          negPrefix = (numberSettings['negativePrefix'] || "").replace(
            repStr, "");
          negSuffix = (numberSettings['negativeSuffix'] || "").replace(
            repStr, "");
          posPrefRegexp = new RegExp(("^" + posPrefix).replace(
            /([\^\$\.\*\+\?\|\[\]\(\)\{\}])/g, "\\$1"));
          posSuffRegexp = new RegExp(posSuffix.replace(
            /([\^\$\.\*\+\?\|\[\]\(\)\{\}])/g, "\\$1") + "$");
          negPrefRegexp = new RegExp(("^" + negPrefix).replace(
            /([\^\$\.\*\+\?\|\[\]\(\)\{\}])/g, "\\$1"));
          negSuffRegexp = new RegExp(negSuffix.replace(
            /([\^\$\.\*\+\?\|\[\]\(\)\{\}])/g, "\\$1") + "$");

          //try  match of positive prefix and suffix
          if(num.search(negPrefRegexp) >= 0 && num.search(negSuffRegexp) >= 0) {        
            num = num.replace(negPrefRegexp, "");
            num = num.replace(negSuffRegexp, "");
            sign = "-";
            exactMatch = true;
          }
          //try exact match of positive prefix and suffix
          else if(num.search(posPrefRegexp) >= 0 &&
            num.search(posSuffRegexp) >= 0) {
            num = num.replace(posPrefRegexp, "");
            num = num.replace(posSuffRegexp, "");
            sign = "+";
            exactMatch = true;
          }
        }
      }

      // Try to extract the number accoring to the following pattern:
      // optional +- followed by one or many digits followed by optional
      // fraction part followed by optional exponential.
      // use localized +, -, decimal separator, exponential
      // [+-]?\d+(?:\.\d+)?(?:E[+-]?\d+)?/;
      if(!exactMatch) {
        //remove grouping deparator from string
        var groupingSeparator = 
        localeElements['numbers'][numberSettings['numberingSystem']]['group'];
        var decimalSeparator = 
        localeElements['numbers'][numberSettings['numberingSystem']]['decimal'];
        var plusSign = "+";
        var minusSign = "-";
        var exponential = 
        _toUpper(localeElements['numbers'][numberSettings['numberingSystem']]['exponential']);
        //remove grouping separator from string
        var groupSep = groupingSeparator;
        num = num.split(groupSep).join("");
        var altGroupSep = groupSep.replace(/\u00A0/g, " ");
        if (groupSep !== altGroupSep) {
          num = num.split(altGroupSep).join("");
        }       
        var regExpStr = "[" + plusSign + minusSign + "]" + "?\\d*(?:"  +
        decimalSeparator + "\\d+)?(?:" + exponential +
        "[" + "+" + "-" + "]?\\d+)?";
        regExpStr = regExpStr.replace(".", "\\.");
        var regExp =new RegExp(regExpStr);
        var match = regExp.exec(_toUpper(num));
        num = match[0];
        if (_startsWith(num, minusSign)) {
          num =  num.substr(minusSign.length);
          sign = "-";
        }
        else if (_startsWith(num, plusSign)) {
          num = num.substr(plusSign.length);
          sign = "+";
        }
      }
      ret = [sign, num];
      return ret;
    };

    _parseNegativeExponent = function(value, localeElements, numberSettings) {
      var neg = localeElements['numbers'][numberSettings['numberingSystem']]['minusSign'],
      pos =  localeElements['numbers'][numberSettings['numberingSystem']]['plusSign'],
      ret;
      if (_startsWith(value, neg)) {
        ret = [ "-", value.substr(neg.length) ];
      }
      else if (_startsWith(value, pos)) {
        ret = [ "+", value.substr(pos.length) ];
      }
      return ret || [ "", value ];
    };

    // _applyPatternImpl
    (function() {

      var _regionMatches, _expandAffix, _expandAffixes, _throwSyntaxError,
      zeroDigit         = '0',
      groupingSeparator = ',',
      decimalSeparator  = '.',
      percent           = '%',
      perMill           = '\u2030',
      digit             = '#',
      separator         = ';',
      exponent          =  "E|e",
      minus             = '-',
      quot              = '\'',
      currency     = '\u00A4';
  
      var posPrefixPattern,
      posSuffixPattern,
      negPrefixPattern,
      negSuffixPattern;

      var MAXIMUM_INTEGER_DIGITS = 0x7fffffff;
      var MAXIMUM_FRACTION_DIGITS = 0x7fffffff;
      
      _throwSyntaxError = function(pattern) {
        var msg, syntaxError, errorInfo, samplePattern = "#,##0.###";
        msg =  "Unexpected character(s) encountered in the pattern \"" + 
        pattern + " An example of a valid pattern is \"" + samplePattern +
        '".';
        syntaxError = new SyntaxError(msg);
        errorInfo = {
          'errorCode' : 'optionValueInvalid',
          'parameterMap' : {
            'propertyName' : 'pattern',
            'propertyValue': pattern,
            'propertyValueHint': samplePattern
          }
        };
        syntaxError['errorInfo'] = errorInfo;
        throw syntaxError;
      }
      _regionMatches = function(str1, offset1, str2, offset2, len) {
        var sub1 = str1.substr(offset1, len);
        var sub2 = str2.substr(offset2, len);
        if(sub1.localeCompare(sub2) == 0){
          return true;
        }
        return false;
      };

      _expandAffixes = function(localeElements, numberSettings) {
        var curDisplay = {};
        if (posPrefixPattern != null) {
          numberSettings['positivePrefix'] = _trim(_expandAffix(posPrefixPattern,
            localeElements, numberSettings, curDisplay));
        }
        if (posSuffixPattern != null) {
          numberSettings['positiveSuffix'] = _trim(_expandAffix(posSuffixPattern,
            localeElements, numberSettings, curDisplay));
        }
        if (negPrefixPattern != null) {
          numberSettings['negativePrefix'] = _trim(_expandAffix(negPrefixPattern,
            localeElements, numberSettings, curDisplay));
        }
        if (negSuffixPattern != null) {
          numberSettings['negativeSuffix'] = _trim(_expandAffix(negSuffixPattern,
            localeElements, numberSettings, curDisplay));
        }
        if(curDisplay['name'] !== undefined) {
          numberSettings['positiveSuffix'] = "\u00a0" + curDisplay['name'];
          numberSettings['positivePrefix'] = "";
          numberSettings['negativeSuffix'] = "\u00a0" + curDisplay['name'];
          numberSettings['negativePrefix'] =  _trim(localeElements['numbers'][numberSettings['numberingSystem']]['minusSign']);
        }
      }

      _expandAffix = function(pattern, localeElements, numberSettings,
        currencyDisplay) {
        var buffer = "";
        for (var i=0; i<pattern.length;) {
          var c = pattern.charAt(i++);
          if (c == quot)// {
            continue;
          //c = pattern.charAt(i++);
          switch (c) {
            case currency:
              var code = numberSettings['currencyCode'];
              var name = code, symbol = code;
              if(localeElements['numbers']['currencies'][code] !== undefined) {
                name = localeElements['numbers']['currencies'][code]['displayName']; 
                symbol = localeElements['numbers']['currencies'][code]['symbol'];
              }
              if(numberSettings['currencyDisplay'] === undefined ||
                numberSettings['currencyDisplay'] === "symbol")
                c = symbol;
              else if (numberSettings['currencyDisplay'] === "code") {
                c = code;
              }
              else {
                c = name;
                currencyDisplay['name'] = c;
              }
              break;
            case percent:
              c = localeElements['numbers'][numberSettings['numberingSystem']]['percentSign'];
              break;
            case perMill:
              c = localeElements['numbers'][numberSettings['numberingSystem']]['perMille'];
              break;
            case minus:
              c = localeElements['numbers'][numberSettings['numberingSystem']]['minusSign'];
              break;
          }
          //}
          buffer = buffer.concat(c);
        }
        return buffer;
      }

      _applyPatternImpl = function(options, pattern, localeElements,
        numberSettings) {
      
        var gotNegative = false,
        useExponentialNotation = false;
        var phaseOneLength = 0;         
        var start = 0;
        var isPrefix = true;
        
        for (var j = 1; j >= 0 && start < pattern.length; --j) {
          var inQuote = false;
          var prefix = "";
          var suffix = "";
          var decimalPos = -1;
          var multiplier = 1;
          var digitLeftCount = 0, zeroDigitCount = 0, digitRightCount = 0,
          groupingCount = -1;
          var minExponentDigits;
          var phase = 0;

          isPrefix = true;
          for (var pos = start; pos < pattern.length; ++pos) {
            var ch = pattern.charAt(pos);
            switch (phase) {
              case 0:
              case 2:
                // Process the prefix / suffix characters
                if (inQuote) {
                  if (ch === quot) {
                    if ((pos+1) < pattern.length && pattern.charAt(pos+1) === 
                      quot) {
                      ++pos;
                      if(isPrefix)
                        prefix = prefix.concat("''");
                      else
                        suffix = suffix.concat("''");
                    } else {
                      inQuote = false; // 'do'
                    }
                    continue;
                  }
                }
                else {
                  // Process unquoted characters seen in prefix or suffix phase.
                  if (ch === digit ||
                    ch === zeroDigit ||
                    ch === groupingSeparator ||
                    ch === decimalSeparator) {
                    phase = 1;
                    --pos; // Reprocess this character
                    continue;
                  } else if (ch === currency) {
                    if(options['currency'] === undefined)
                      _throwMissingCurrency("pattern");
                    // Use lookahead to determine if the currency sign
                    // is doubled or not.
                    options['style'] = 'currency';
                    var doubled = (pos + 1) < pattern.length &&
                    pattern.charAt(pos + 1) === currency;
                    if (doubled) { // Skip over the doubled character
                      ++pos;
                    }
                    if(isPrefix)
                      prefix = prefix.concat(doubled ? "'\u00A4\u00A4" : 
                        "'\u00A4");
                    else
                      suffix = suffix.concat(doubled ? "'\u00A4\u00A4" : 
                        "'\u00A4");
                    continue;
                  } else if (ch === quot) {
                    if (ch == quot) {
                      if ((pos+1) < pattern.length &&
                        pattern.charAt(pos+1) == quot) {
                        ++pos;
                        if(isPrefix)
                          prefix = prefix.concat("''");// o''clock
                        else
                          suffix = suffix.concat("''");
                      } else {
                        inQuote = true; // 'do'
                      }
                      continue;
                    }
                  } else if (ch === separator) {
                    if (phase === 0 || j === 0) {                    
                      _throwSyntaxError(pattern);
                    }
                    start = pos + 1;
                    pos = pattern.length;
                    continue;
                  }

                  // Next handle characters which are appended directly.
                  else if (ch === percent) {
                    options['style'] = 'percent';
                    if (multiplier != 1) {                      
                      _throwSyntaxError(pattern);
                    }
                    numberSettings['isPercent'] = true;
                    multiplier = 100;
                    if(isPrefix)
                      prefix = prefix.concat("'%");
                    else
                      suffix = suffix.concat("'%");
                    continue;
                  } else if (ch === perMill) {
                    if (multiplier != 1) {                      
                      _throwSyntaxError(pattern);
                    }
                    options['style'] = 'perMill';
                    numberSettings['isPerMill'] = true;
                    multiplier = 1000;
                    if(isPrefix)
                      prefix = prefix.concat("'\u2030");
                    else
                      suffix = suffix.concat("'\u2030");
                    continue;
                  }
                  else if (ch === minus) {
                    if(isPrefix)
                      prefix = prefix.concat("'-");
                    else
                      suffix = suffix.concat("'-");
                    continue;
                  }
                }
                if(isPrefix)
                  prefix = prefix.concat(ch);
                else
                  suffix = suffix.concat(ch);
                break;

              case 1:
                if (j === 1) {
                  ++phaseOneLength;
                } else {
                  if (--phaseOneLength === 0) {
                    phase = 2;
                    isPrefix = false;
                  }
                  continue;
                }

                if (ch === digit) {
                  if (zeroDigitCount > 0) {
                    ++digitRightCount;
                  } else {
                    ++digitLeftCount;
                  }
                  if (groupingCount >= 0 && decimalPos < 0) {
                    ++groupingCount;
                  }
                } else if (ch === zeroDigit) {
                  if (digitRightCount > 0) {
                    _throwSyntaxError(pattern);
                  }
                  ++zeroDigitCount;
                  if (groupingCount >= 0 && decimalPos < 0) {
                    ++groupingCount;
                  }
                } else if (ch === groupingSeparator) {
                  groupingCount = 0;
                } else if (ch === decimalSeparator) {
                  if (decimalPos >= 0) {                    
                    _throwSyntaxError(pattern);
                  }
                  decimalPos = digitLeftCount + zeroDigitCount + 
                  digitRightCount;
                } else if (_regionMatches(pattern, pos, exponent, 0, 
                  exponent.length)){
                  if (useExponentialNotation) {
                    _throwSyntaxError(pattern);
                  }
                  useExponentialNotation = true;
                  minExponentDigits = 0;

                  pos = pos + exponent.length;
                  while (pos < pattern.length && pattern.charAt(pos) === 
                    zeroDigit) {
                    ++minExponentDigits;
                    ++phaseOneLength;
                    ++pos;
                  }
              
                  if ((digitLeftCount + zeroDigitCount) < 1 || 
                    minExponentDigits < 1) {
                    _throwSyntaxError(pattern);
                  }
                  phase = 2;
                  isPrefix = false;
                  --pos;
                  continue;
                } else {
                  phase = 2;
                  isPrefix = false;
                  --pos;
                  --phaseOneLength;
                  continue;
                }
                break;
            }
          }

      
          if (zeroDigitCount === 0 && digitLeftCount > 0 && decimalPos >= 0) {
            // Handle "###.###" and "###." and ".###"
            var n = decimalPos;
            if (n === 0) { // Handle ".###"
              ++n;
            }
            digitRightCount = digitLeftCount - n;
            digitLeftCount = n - 1;
            zeroDigitCount = 1;
          }

          // Do syntax checking on the digits.
          if ((decimalPos < 0 && digitRightCount > 0) ||
            (decimalPos >= 0 && (decimalPos < digitLeftCount ||
              decimalPos > (digitLeftCount + zeroDigitCount))) ||
            groupingCount == 0 || inQuote) {
            _throwSyntaxError(pattern);
          }

          if (j === 1) {
            posPrefixPattern = prefix;
            posSuffixPattern = suffix;
            negPrefixPattern = posPrefixPattern;
            negSuffixPattern = posSuffixPattern;
            var digitTotalCount = digitLeftCount + zeroDigitCount + 
            digitRightCount;
            // The effectiveDecimalPos is the position the decimal is at or
            //would be at if there is no decimal. Note that if decimalPos<0,
            // then digitTotalCount == digitLeftCount + zeroDigitCount.
            var effectiveDecimalPos = decimalPos >= 0 ?
            decimalPos : digitTotalCount;
            numberSettings['minimumIntegerDigits'] = (effectiveDecimalPos - 
              digitLeftCount);
            numberSettings['maximumIntegerDigits'] = (useExponentialNotation ?
              digitLeftCount + numberSettings['minimumIntegerDigits'] :
              MAXIMUM_INTEGER_DIGITS);
            numberSettings['maximumFractionDigits'] = (decimalPos >= 0 ?
              (digitTotalCount - decimalPos) : 0);
            numberSettings['minimumFractionDigits'] = (decimalPos >= 0 ?
              (digitLeftCount + zeroDigitCount - decimalPos) : 0);
            numberSettings['groupingSize'] = (groupingCount > 0) ? 
            groupingCount : 0;
            
          } else {
            negPrefixPattern = prefix;
            negSuffixPattern = suffix;
            gotNegative = true;
          }
        }

        if (pattern.length == 0) {
          posPrefixPattern = posSuffixPattern = "";
          numberSettings['minimumIntegerDigits'] = 0;
          numberSettings['maximumIntegerDigits'] = MAXIMUM_INTEGER_DIGITS;
          numberSettings['minimumFractionDigits'] = 0;
          numberSettings['maximumFractionDigits'] = MAXIMUM_FRACTION_DIGITS;
        }

        // If there was no negative pattern, or if the negative pattern is
        // identical to the positive pattern, then prepend the minus sign to
        // the positive pattern to form the negative pattern.
        if (!gotNegative ||
          ((negPrefixPattern.localeCompare(posPrefixPattern) == 0)
            && (negSuffixPattern.localeCompare(posSuffixPattern) == 0))) {
          negSuffixPattern = posSuffixPattern;
          negPrefixPattern = "'-" + posPrefixPattern;
        }
        _expandAffixes(localeElements, numberSettings);
      }

    }());
  
    function _init()
    {
    
      return {
        /**
         * Format a number.
         * @memberOf OraNumberConverter
         * @param {number} value - Number object to be formatted.
         * @param {Object} localeElements - the instance of LocaleElements  
         * bundle
         * @param {Object=} options - Containing the following properties:<br>
         * - <b>style.</b>  is one of the String values "decimal", "currency"  
         * or "percent". The default is "decimal".<br>
         * - <b>currency.</b> An ISO 4217 alphabetic currency code. Mandatory 
         *  when style is "currency".<br>
         * - <b>currencyDisplay.</b> is one of the String values "code", 
         * "symbol", or "name", specifying whether to display the currency as  
         * an ISO 4217 alphabetic currency code, 
         * a localized currency symbol, or a localized currency name if 
         * formatting with the "currency" style. It is only present when style 
         * has the value "currency". The default is "symbol".<br>
         * - <b>minimumIntegerDigits.</b> is a non-negative integer Number value 
         * indicating the minimum integer digits to be used. Numbers will be 
         * padded with leading zeroes if necessary.<br>
         * - <b>minimumFractionDigits.</b> a non-negative integer Number value 
         * indicating the minimum fraction digits to be used. Numbers will be 
         * padded with trailing zeroes if necessary.<br>
         * - <b>maximumFractionDigits.</b> a non-negative integer Number value 
         * indicating the maximum fraction digits to be used. Numbers will be 
         * rounded if necessary.<br>
         * - <b>useGrouping.</b> is a Boolean value indicating whether a 
         * grouping separator should be used. The default is true.<br>
         * - <b>pattern.</b> custom pattern. Will override above options 
         * when present.
         * @param {string=} locale - A BCP47 compliant language tag. it is only 
         * used to extract the unicode extension keys. 
         * @return {string} formatted number.
         * @throws {RangeError} If a property value of the options parameter is 
         * out of range.
         * @throws {TypeError} If the style is currency and currency code is 
         * missing.
         * @throws {SyntaxError} If an unexpected character is encountered in 
         * the pattern.
         */ 
        format : function(value, localeElements, options, locale) {
          if(arguments.length <=2 || options === undefined) {
            options = {
              'useGrouping': true,
              'style': 'decimal'
            }; 
          }
          _validateNumberOptions(options, "OraNumberConverter.format");
          localeElements = _getLocaleElementsMainNode(localeElements);
          var numberSettings = {};
          _getNumberSettings(localeElements, numberSettings, options, locale);
          return _formatNumberImpl(value, options, localeElements,
            numberSettings, locale);
        },
    
        /**
         * Parse a number.
         * @memberOf OraNumberConverter
         * @param {string|number} str - string to be parsed.
         * @param {Object} localeElements - the instance of LocaleElements 
         * bundle
         * @param {Object=} options - Containing the following properties:<br>
         * - <b>style.</b>  is one of the String values "decimal", "currency" or 
         * "percent". The default is "decimal".<br>
         * - <b>currency.</b> An ISO 4217 alphabetic currency code. Mandatory 
         * when style is "currency".<br>
         * - <b>currencyDisplay.</b> is one of the String values "code", 
         * "symbol", or "name", specifying whether to display the currency as 
         * an ISO 4217 alphabetic currency code,
         *  a localized currency symbol, or a localized currency name if 
         *  formatting with the "currency" style. It is only considered when 
         *  style has the value "currency". The default is "symbol".<br>
         * - <b>minimumIntegerDigits.</b> is a non-negative integer Number value 
         * indicating the minimum integer digits to be used. Numbers will be 
         * padded with leading zeroes if necessary.<br>
         * - <b>minimumFractionDigits.</b> a non-negative integer Number value 
         * indicating the minimum fraction digits to be used. Numbers will be 
         * padded with trailing zeroes if necessary.<br>
         * - <b>maximumFractionDigits.</b> a non-negative integer Number value 
         * indicating the maximum fraction digits to be used. Numbers will be 
         * rounded if necessary.<br>
         * - <b>useGrouping.</b> is a Boolean value indicating whether a 
         * grouping separator should be used. The default is true.<br>
         * - <b>pattern.</b> custom pattern. Will override above options when 
         * present.<br>
         * @param {string=} locale - A BCP47 compliant language tag. it is only 
         * used to extract the unicode extension keys. 
         * @return {number} a number object parsed from the string. In case of 
         * error, returns null.
         * @throws {RangeError} If a property value of the options parameter is 
         * out of range.
         * @throws {TypeError} If the style is currency and currency code is 
         * missing.
         * @throws {SyntaxError} If an unexpected character is encountered in 
         * the pattern.
         * @throws {Error} If the <i>str</i> parameter does not match the number 
         * pattern.
         */ 
        parse : function(str, localeElements, options, locale) {
          if(typeof str === "number")
            return str;
          if(Object.prototype.toString.call(str) === '[object Number]')
            return  Number(str);
          if(arguments.length <= 2 || options === undefined) {
            options = {
              'useGrouping': true,
              'style': 'decimal'
            }; 
          }
          var errStr = str;
          _validateNumberOptions(options, "OraNumberConverter.parse");
          localeElements = _getLocaleElementsMainNode(localeElements);
          var numberSettings = {};
          var numberingSystemKey =  _getLanguageExtension(locale, "nu");
          if(numeringSystems[numberingSystemKey] === undefined)
            numberingSystemKey = 'latn';
          if(numberingSystemKey !== 'latn') {
            var idx;
            var latnStr = [];
            for(idx = 0; idx < str.length; idx++)
            {
              var pos = numeringSystems[numberingSystemKey].indexOf(str[idx]);
              if(pos != -1)
                latnStr.push(pos);
              else
                latnStr.push(str[idx]);       
            }
            str =  latnStr.join("");
          }
          _getNumberSettings(localeElements, numberSettings, options, locale); 
          var decimalSeparator = localeElements['numbers']
          [numberSettings['numberingSystem']]['decimal'],
          groupingSeparator = localeElements['numbers']
          [numberSettings['numberingSystem']]['group'],      
          ret = NaN,        
          value1 = str.replace(/ /g, "");      
          // allow infinity or hexidecimal
          if (regexInfinity.test(value1)) {
            ret = parseFloat(str);
          }
          else {

            var signInfo = _parseNegativePattern(str, options, numberSettings,
              localeElements),
            sign = signInfo[ 0 ],
            num = signInfo[ 1 ];
            sign = sign || "+";

            // remove spaces: leading, trailing and between - and number. 
            // Used for negative currency pt-BR
            num = num.replace(/ /g, "");

            // determine exponent and number
            var exponent,
            intAndFraction,
            exponentPos = num.indexOf("e");
            if (exponentPos < 0) exponentPos = num.indexOf("E");
            if (exponentPos < 0) {
              intAndFraction = num;
              exponent = null;
            }
            else {
              intAndFraction = num.substr(0, exponentPos);
              exponent = num.substr(exponentPos + 1);
            }
            // determine decimal position
            var integer,
            fraction,
            decSep = decimalSeparator,
            decimalPos = intAndFraction.indexOf(decSep);
            if (decimalPos < 0) {
              integer = intAndFraction;
              fraction = null;
            }
            else {
              integer = intAndFraction.substr(0, decimalPos);
              fraction = intAndFraction.substr(decimalPos + decSep.length);
            }
            // handle groups (e.g. 1,000,000)
            var groupSep = groupingSeparator;
            integer = integer.split(groupSep).join("");
            var altGroupSep = groupSep.replace(/\u00A0/g, " ");
            if (groupSep !== altGroupSep) {
              integer = integer.split(altGroupSep).join("");
            }
            // build a natively parsable number string
            var p = sign + integer;
            if (fraction !== null) {
              p += "." + fraction;
            }
            if (exponent !== null) {
              // exponent itself may have a number patternd
              var expSignInfo = _parseNegativeExponent(exponent, localeElements,
                numberSettings);
              p += "e" + (expSignInfo[0] || "+") + expSignInfo[ 1 ];
            }
            if (regexParseFloat.test(p)) {
              ret = parseFloat(p);
            }
          }
          if(numberSettings['isPercent'] === true || options['style'] ===
            'percent')
            ret /= 100;
          else if(numberSettings['isPerMill'] === true)
            ret /= 1000;
          if(isNaN(ret)) {
            var msg, error, errorInfo, code;
            msg = "Unparsable number " + errStr + " The expected number " + 
            "pattern is " + numberSettings['pat'];
            switch(options['style'])
            {
              case "decimal" :
                code = "decimalFormatMismatch";
                break;
              case "currency" :
                code = "currencyFormatMismatch";
                break;
              case "percent" :
                code = "percentFormatMismatch";
                break;
            }
            error = new Error(msg);
            errorInfo = {
              'errorCode' : code,
              'parameterMap' : {
                'value' : errStr,
                'format': numberSettings['pat']
              }
            };
            error['errorInfo'] = errorInfo;
            throw error;
          }
          return ret;
        },
      
        /**
         * Resolve options.
         * Returns a new object with properties reflecting the number formatting 
         * options computed based on the options parameter.
         * If options is not provided, the properties will be derived from the 
         * locale defaults.
         * @memberOf OraNumberConverter
         * @param {Object} localeElements - the instance of LocaleElements 
         * bundle
         * @param {Object=} options containing the following properties:<br>
         * - <b>style.</b> "decimal", "currency" or "percent". The default is 
         * "decimal".<br>
         * - <b>currency.</b> An ISO 4217 alphabetic currency code. Mandatory 
         * when when style is "currency".<br>
         * - <b>currencyDisplay.</b> is one of the String values "code", 
         * "symbol", or "name", specifying whether to display the currency as 
         * an ISO 4217 alphabetic currency code,
         *   a localized currency symbol, or a localized currency name if 
         *   formatting with the "currency" style. It is only present 
         *   when style has the value "currency". The default is "symbol".<br>
         * - <b>minimumIntegerDigits.</b> is a non-negative integer Number value 
         * indicating the minimum integer digits to be used. Numbers will be 
         * padded with leading zeroes if necessary.<br>
         * - <b>minimumFractionDigits.</b> a non-negative integer Number value 
         * indicating the minimum fraction digits to be used. Numbers will be 
         * padded with trailing zeroes if necessary.<br>
         * - <b>maximumFractionDigits.</b> a non-negative integer Number value 
         * indicating the maximum fraction digits to be used. Numbers will be 
         * rounded if necessary.<br>
         * - <b>numberingSystem</b>. The numbering system.
         * - <b>useGrouping.</b> is a Boolean value indicating whether a 
         * grouping separator should be used. The default is true.<br>
         * - <b>pattern.</b> custom pattern. Will override above options when 
         * present.<br>
         * @param {string=} locale - A BCP47 compliant language tag. it is only 
         * used to extract the unicode extension keys. 
         * @return {Object} Resolved options object.
         * @throws {RangeError} If a property value of the options parameter is 
         * out of range.
         * @throws {TypeError} If the style is currency and currency code is 
         * missing. 
         */
        resolvedOptions : function(localeElements, options, locale){
          if(arguments.length < 3 || locale === undefined) {
            locale = _getLocaleElementsMainNodeKey(localeElements);
          }
          if(arguments.length < 2 || options === undefined) {
            options = {
              'useGrouping': true,
              'style': 'decimal'
            }; 
          }
          localeElements = _getLocaleElementsMainNode(localeElements);
          var numberSettings = {};
          _validateNumberOptions(options, "OraNumberConverter.resolvedOptions");
          _getNumberSettings(localeElements, numberSettings, options, locale);
          numberSettings['numberingSystemKey'] =  _getLanguageExtension(locale,
            "nu");
          if(numeringSystems[numberSettings['numberingSystemKey']] === 
            undefined)
            numberSettings['numberingSystemKey'] = 'latn';
          var resOptions = {
            'locale': locale,
            'style': (options['style'] === undefined) ? 'decimal' : 
            options['style'],
            'useGrouping' : (options['useGrouping'] === undefined) ? true : 
            options['useGrouping'],
            'minimumIntegerDigits' : numberSettings['minimumIntegerDigits'],
            'minimumFractionDigits' : numberSettings['minimumFractionDigits'],
            'maximumFractionDigits' : numberSettings['maximumFractionDigits'],
            'numberingSystem': numberSettings['numberingSystemKey']
          }
          if(options['style'] === 'currency') {
            resOptions['currency'] = options['currency'];
            resOptions['currencyDisplay'] = (options['currencyDisplay'] === 
              undefined) ?  'symbol' : options['currencyDisplay'];
          }
          if(options['pattern'] !== undefined)
            resOptions['pattern'] = options['pattern'];
          return resOptions;
        }
      };
    }
  
    return {
      /**
       * getInstance.
       * Returns the singleton instance of OraNumberConverter class.  
       * @memberOf OraNumberConverter
       * @return {Object} The singleton OraNumberConverter instance.
       */
      getInstance: function () {	 
        if ( !instance ) {
          instance = _init();
        }	 
        return instance;
      }	 
    };
  
  }());
  ///////////////////////////////--DateTimeConverter--/////////////////////////
  OraDateTimeConverter =  (function() {

    var
    _appendPreOrPostMatch,
    _expandFormat,
    _getTokenRegExp,
    _parseExact,
    _formatImpl,
    _parseImpl,
    _formatRelativeImpl,
    _throwInvalidDateFormat,
    _getResolvedOptionsFromPattern,
    _dateTimeStyle,
    _get2DigitYearStart,
    _isHour12,
    _dateTimeStyleFromPattern,
    _expandPredefinedStylesFormat,
    _isLeapYear, _getDaysInMonth, instance;
  
    
    _get2DigitYearStart = function(options) {
      var option = options['two-digit-year-start'];
      if(option === undefined || isNaN(option))
        option = 1950;
      option = parseInt(option, 10);
      return option;
    };
    
    _isHour12 = function(localeElements) {
      var mainNode = _getLocaleElementsMainNode(localeElements);
      var territory = mainNode['identity']['territory'] || '001';
      var prefferedHours = localeElements['supplemental']['prefferedHours'];
      var hour12 = prefferedHours[territory];
      return hour12 === 'h';      
    };
    
    _isLeapYear = function(y) {
      if (y % 400 == 0)
        return true;
      else if (y % 100 == 0)
        return false;
      else if (y % 4 == 0)
        return true;
      else
        return false;
    };
    
    _getDaysInMonth = function(y, m) {
      switch (m) {
        case 0 :
        case 2 :
        case 4 :
        case 6 :
        case 7 :
        case 9 :
        case 11 :
          return 31;
        case 1:
          if(_isLeapYear(y))
            return 29;
          else
            return 28;
        default:
          return 30;
      }
    };

    _getTokenRegExp = function() {
      return (/ccccc|cccc|ccc|cc|c|EEEEE|EEEE|EEE|EE|E|dd|d|MMMMM|MMMM|MMM|MM|M|LLLLL|LLLL|LLL|LL|L|yyyy|yy|y|hh|h|HH|H|KK|K|kk|k|mm|m|ss|s|aa|a|SS|S|zzzz|zzz|zz|z|GGGGG|GGGG|GGG|GG|G/g);
    };

    _expandPredefinedStylesFormat = function(options, localeElements, caller) {
      var mainNode = _getLocaleElementsMainNode(localeElements);
      var getOption = _getGetOption(options, caller);
      var fmtType = getOption('formatType', 'string', ['date', 'time', 
        'datetime'], 'date');
      var dStyle = getOption('dateFormat', 'string', 
        ['short', 'medium', 'long', 'full'], 'short');
      var tStyle = getOption('timeFormat', 'string', 
        ['short', 'medium', 'long', 'full'], 'short');
      var cal = mainNode['dates']['calendars']['gregorian'];
      var dateFormats = cal['dateFormats'];
      var timeFormats = cal['timeFormats'];
      var dStyleFmt, tStyleFmt, format;
      switch (dStyle)
      {
        case "full" :
          dStyleFmt = dateFormats['full'];
          break;
        case "long" :
          dStyleFmt = dateFormats['long'];
          break;
        case "medium" :
          dStyleFmt = dateFormats['medium'];
          break;
        case "short" :
          dStyleFmt = dateFormats['short'];
          break;
        default:
          break;
      }
      switch (tStyle)
      {
        case "full" :
          tStyleFmt = timeFormats['full'];
          break;
        case "long" :
          tStyleFmt = timeFormats['long'];
          break;
        case "medium" :
          tStyleFmt = timeFormats['medium'];
          break;
        case "short" :
          tStyleFmt = timeFormats['short'];
          break;
        default:
          break;
      }
      if(dStyleFmt !== undefined && (fmtType === "datetime" || 
        fmtType === "date"))
        format = dStyleFmt;
      if(tStyleFmt !== undefined && (fmtType === "datetime" || 
        fmtType === "time"))
        { 
        if(format)
          format = format + " " + tStyleFmt;
        else
          format = tStyleFmt;
      }
      return format;
    };

    _appendPreOrPostMatch = function(preMatch, strings) {
      // appends pre- and post- token match strings while removing escaped 
      // characters.
      // Returns a single quote count which is used to determine if the 
      // token occurs
      // in a string literal.
      var quoteCount = 0,
      escaped = false;
      for (var i = 0, il = preMatch.length; i < il; i++) {
        var c = preMatch.charAt(i);
        switch (c) {
          case "\'":
            if (escaped) {
              strings.push("\'");
            }
            else {
              quoteCount++;
            }
            escaped = false;
            break;
          case "\\":
            if (escaped) {
              strings.push("\\");
            }
            escaped = !escaped;
            break;
          default:
            strings.push(c);
            escaped = false;
            break;
        }
      }
      return quoteCount;
    };
    
    _throwInvalidDateFormat = function(format, options, m) {
      var msg, error, errorInfo, samplePattern;
      var isDate = options['year'] !== undefined || options['month'] !== 
      undefined ||
      options['weekday'] !== undefined || options['day'] !== undefined;
      var isTime = options['hour'] !== undefined || options['minute'] !==
      undefined ||
      options['second'] !== undefined;
      if(isDate && isTime) {
        samplePattern = "MM/dd/yy hh:mm:ss a";
      }
      else if(isDate) {
        samplePattern = "MM/dd/yy";           
      }
      else {
        samplePattern = "hh:mm:ss a";          
      }
      msg = "Unexpected character(s) " + m + " encountered in the pattern \"" +
      format  + " An example of a valid pattern is \"" + samplePattern + '".';
      error = new SyntaxError(msg);
      errorInfo = {
        'errorCode' : 'optionValueInvalid',
        'parameterMap' : {
          'propertyName' : 'pattern',
          'propertyValue' : format,
          'propertyValueHint ': samplePattern
        }
      };
      error['errorInfo'] = errorInfo;
      throw error;
    };
    
    //expand formats
    (function() {   
      var _toAvailableFormatsKeys,
      _expandAvailableDateFormatsPattern,
      _expandAvailableTimeFormatsPattern,
      _basicFormatMatcher,
      _appendToKey;
      
      _basicFormatMatcher = function(dateTimeKeys, localeElements, isDate,
        hour12)
        {          
        var mainNode = _getLocaleElementsMainNode(localeElements);
        var availableFormats = mainNode['dates']['calendars']['gregorian']
        ['dateTimeFormats']['availableFormats'];
        var dateTimeFormats;
        if(isDate)
          dateTimeFormats = ['era', 'year', 'month', 'weekday', 'day'];
        else
          dateTimeFormats = ['weekday', 'hour', 'minute', 'second'];
        //,'timeZoneName'];

        var removalPenalty = 120;
        var additionPenalty = 20;
        var longLessPenalty = 8;
        var longMorePenalty = 6;
        var shortLessPenalty = 6;
        var shortMorePenalty = 3;
        var bestScore = -Infinity;
        var bestFormat = undefined; 
        var match;
        var regExp = _getTokenRegExp();
        for(var f in availableFormats) {
          var format = {};
          format['pattern'] = availableFormats[f];
          var score = 0;
          while ((match = regExp.exec(f)) !== null) {
            var m = match[0];
            switch(m) {
              case "y" :
                format['year'] = 'numeric';
                break;
              case "yy" :
                format['year'] = '2-digit';
                break;
              case "M" :
              case "L" :
                format['month'] = 'numeric';
                break;
              case "MM" :
              case "LL" :
                format['month'] = '2-digit';
                break;
              case "MMM":
              case "LLL":
                format['month'] = 'short';
                break;
              case "MMMM":
              case "LLLL":
                format['month'] = 'long';
                break;
              case "MMMMM" :
              case "LLLLL" :
                format['month'] = 'narrow';
                break;
              case "E":
              case "EE":
              case "EEE":
              case "c":
              case "cc":
              case "ccc":
                format['weekday'] = 'short';
                break;
              case "EEEE":
              case "cccc":
                format['weekday'] = 'long';
                break;
              case "EEEEE" :
              case "ccccc" :
                format['weekday'] = 'narrow';
                break;               
              case "d" :
                format['day'] = 'numeric';
                break;
              case "dd" :
                format['day'] = '2-digit';
                break;               
              case "h" :
                if (hour12) {
                  format['hour'] = 'numeric';
                }
                break;
              case "H" :
                if (!hour12) {
                  format['hour'] = 'numeric';
                }
                break;
              case "hh" :
                if (hour12) {
                  format['hour'] = '2-digit';
                }
              case "HH" :
                if (!hour12) {
                  format['hour'] = '2-digit';
                }              
                break;
              case "m" :
                format['minute'] = 'numeric';
                break;
              case "mm" :
                format['minute'] = '2-digit';
                break;               
              case "s" :
                format['second'] = 'numeric';
                break;
              case "ss" :
                format['second'] = '2-digit';
                break;               
              case "G" :
              case "GG" :
              case "GGG" :
                format['era'] = 'short';
                break;              
              case "GGGG" :
                format['era'] = 'long';
                break;               
              case "GGGGG" :
                format['era'] = 'narrow';
                break;
              case "z" :
              case "zz" :
              case "zzz" :
                format['timeZoneName'] = 'short';
                break;              
              case "zzzz" :
                format['timeZoneName'] = 'long';
                break;               
              default:
                break;
            }
          }
          for(var property in dateTimeFormats) {
            var optionsProp = dateTimeKeys[dateTimeFormats[property]];
            var formatProp = format[dateTimeFormats[property]];
            if(optionsProp === undefined && formatProp !== undefined) {
              score -= additionPenalty;
            }
            else if(optionsProp !== undefined && formatProp === undefined) {
              score -= removalPenalty;
            }
            else if(optionsProp !== undefined && formatProp !== undefined){
 
              var values = {
                '2-digit':0, 
                'numeric':1, 
                'narrow':2, 
                'short':3, 
                'long':4
              };
              var optionsPropIndex = values[optionsProp];
              var formatPropIndex = values[formatProp];
              var delta = Math.max(Math.min(formatPropIndex - 
                optionsPropIndex, 2), -2);
              if(delta === 2) {
                score -= longMorePenalty;
              }
              else if(delta ===1 ) {
                score -= shortMorePenalty;
              }
              else if(delta === -1) {
                score -= shortLessPenalty;
              }
              else if(delta === -2) {
                score -= longLessPenalty;
              }
            }
          }
          if(score > bestScore) {
            bestScore = score;
            bestFormat = format;
          }         
        }
        if(bestFormat !== undefined) {
          return bestFormat['pattern'];
        }
        return null;
      };
      
      
      _toAvailableFormatsKeys = function (options, localeElements, caller) {
        var dateKey = '', timeKey = '';
        var dateOptions = {}, timeOptions = {};
  
        var getOption = _getGetOption(options, caller);
          
        //date key
        var option = getOption('era', 'string', ['narrow', 'short', 'long']);
        dateKey += _appendToKey(dateOptions, 'era',
          option, {
            'narrow': 'GGGGG', 
            'short': 'GGG', 
            'long': 'GGGG'
          });            
  
        option = getOption('year',  'string', ['2-digit', 'numeric']); 
        dateKey += _appendToKey(dateOptions, 'year',
          option, {
            '2-digit': 'yy', 
            'numeric': 'y'
          });

        option = getOption('month', 'string', ['2-digit', 'numeric', 'narrow',
          'short', 'long']);
        dateKey += _appendToKey(dateOptions, 'month',
          option, {
            '2-digit': 'MM', 
            'numeric': 'M',
            'narrow': 'MMMMM', 
            'short': 'MMM', 
            'long': 'MMMM'
          });

        option = getOption('weekday', 'string', ['narrow', 'short', 'long']);
        dateKey += _appendToKey(dateOptions, 'weekday',
          option, {
            'narrow': 'EEEEE', 
            'short': 'E', 
            'long': 'EEEE'
          });

        option = getOption('day', 'string', ['2-digit', 'numeric']);
        dateKey += _appendToKey(dateOptions, 'day',
          option, {
            '2-digit': 'dd', 
            'numeric': 'd'
          });
   
        //time key
        var hr12 = getOption('hour12', 'boolean', [true, false]);
        if(hr12 === undefined)
          hr12 = _isHour12(localeElements);
        option = getOption('hour', 'string', ['2-digit', 'numeric']);
        if (hr12 === true) {
          timeKey += _appendToKey(timeOptions, 'hour',
            option, {
              '2-digit': 'hh', 
              'numeric': 'h'
            });
        } 
        else {
          timeKey += _appendToKey(timeOptions, 'hour',
            option, {
              '2-digit': 'HH', 
              'numeric': 'H'
            });
        }

        option = getOption('minute', 'string', ['2-digit', 'numeric']);
        timeKey += _appendToKey(timeOptions, 'minute',
          option, {
            '2-digit': 'mm', 
            'numeric': 'm'
          });

        option = getOption('second', 'string', ['2-digit', 'numeric']);
        timeKey += _appendToKey(timeOptions, 'second',
          option, {
            '2-digit': 'ss', 
            'numeric': 's'
          });
            
        return [dateKey, timeKey, dateOptions, timeOptions];
      };
        
      _appendToKey = function (obj, prop, option, pairs) {
        if (option !== undefined) {
          obj[prop] = option;
          return pairs[option];
        } else {
          return '';
        }
      };

      _expandAvailableDateFormatsPattern = function (formatTemplate, options,
        caller)
        {
        var datePat = formatTemplate, regExPat, match;
        var getOption = _getGetOption(options, caller);
        //year
        var option = getOption('year', 'string', ['2-digit', 'numeric']);
        var pairs =  {
          '2-digit': 'yy', 
          'numeric': 'yyyy'
        };
        if(option !== undefined)
          datePat = datePat.replace(/y{1,4}/, pairs[option]);

        //month
        option = getOption('month', 'string', ['2-digit', 'numeric', 'narrow',
          'short', 'long']);
        if(option !== undefined) {
          pairs = {
            '2-digit': 'MM', 
            'numeric': 'M', 
            'narrow': 'MMMMM', 
            'short': 'MMM', 
            'long': 'MMMM'
          };
          if(pairs[option] !== undefined && pairs[option].length > 2)
            datePat = datePat.replace(/M{3,5}/, pairs[option]);
          else if(option === '2-digit') {
            regExPat=/^[M][^M]|[^M]M[^M]/g;
            match= regExPat.exec(formatTemplate);
            if(match !== null) {
              datePat = datePat.replace('M', 'MM');
            }
          }
        }
            
        //weekday
        option = getOption('weekday', 'string', ['narrow', 'short', 'long']);
        if(option !== undefined) { 
          pairs = {
            'narrow': 'EEEEE', 
            'short': 'EEE', 
            'long': 'EEEE'
          };
          datePat = datePat.replace(/E{1,5}/, pairs[option]);
        }
        //day

        option = getOption('day', 'string', ['2-digit', 'numeric']);
        if(option !== undefined) { 
          if(option === '2-digit') {
            regExPat=/^[d][^d]|[^d]d[^d]/g;
            match = regExPat.exec(formatTemplate);
            if(match !== null) {
              datePat = datePat.replace('d', 'dd');
            }
          }
        }
          
        return datePat;
      };
      
      _expandAvailableTimeFormatsPattern = function (formatTemplate, options,
        caller) {
        var timePat = formatTemplate;
        var getOption = _getGetOption(options, caller);
        var option = getOption('hour', 'string', ['2-digit', 'numeric']);
        if(option === '2-digit') {
          var regExPat=/(?:^|[^h])h[^h]|[^H]H[^H]|[^k]k[^k]|[^K]K[^K]/;
          var match= regExPat.exec(formatTemplate);
          if(match !== null) {
            var len = match[0].length-2;
            var ext = match[0][len] + match[0][len];
            timePat = formatTemplate.replace(match[0][len], ext);
          }
        }
        return timePat;
      };
        
      _expandFormat = function(options, localeElements, caller) {
        var mainNode = _getLocaleElementsMainNode(localeElements);
        var locale = _getLocaleElementsMainNodeKey(localeElements);
        var getOption = _getGetOption(options, caller);
        var pattern;
        var matcher = getOption('formatMatcher',  'string', 
          ['basic', 'munger'], 'munger');
        var count = 0;
        for(count in options){
          count++;
        }
        if(count == 0) {
          options = {
            'year': 'numeric', 
            'month': 'numeric', 
            'day': 'numeric'
          };
        }

        var dateTimeKeys = _toAvailableFormatsKeys(options, localeElements, 
          caller);
        //First try to get the pattern from cache
        if(_localeDataCache[locale] !== undefined) {
          if(_localeDataCache[locale]['dates']['calendars']['gregorian']
            ['dateTimeFormats'][dateTimeKeys[0] + dateTimeKeys[1]] !==
            undefined){
            return _localeDataCache[locale]['dates']['calendars']['gregorian']['dateTimeFormats'][dateTimeKeys[0] + dateTimeKeys[1]];
          }
        }          
        if(dateTimeKeys[0] === '' && dateTimeKeys[1] === '') {
          return _expandPredefinedStylesFormat(options, localeElements, 
            caller);
        }
        var availableFormats = mainNode['dates']['calendars']['gregorian']
        ['dateTimeFormats']['availableFormats'];
        var datePattern = availableFormats[dateTimeKeys[0]];
        var hour12 = getOption('hour12', 'boolean', [true, false]);
        if(hour12 === undefined)
          hour12 = _isHour12(localeElements);
        if(datePattern === undefined && dateTimeKeys[0] !== '') {
          var dateTemplatePattern = _basicFormatMatcher(dateTimeKeys[2], 
            localeElements, true, hour12);
          if(dateTemplatePattern !== null) {
            if(matcher === 'basic') {
              datePattern = dateTemplatePattern;
            }
            else {
              datePattern = _expandAvailableDateFormatsPattern(
                dateTemplatePattern, options, caller);
            }
          }
          else
            datePattern = dateTimeKeys[0];
        }
        var timePattern = availableFormats[dateTimeKeys[1]];
        if(timePattern === undefined && dateTimeKeys[1] !== '') {
          var timeTemplatePattern = _basicFormatMatcher(dateTimeKeys[3],
            localeElements, false, hour12);
          if(timeTemplatePattern !== null) {
            if(matcher === 'basic')
              timePattern = timeTemplatePattern;
            else
              timePattern = _expandAvailableTimeFormatsPattern(
                timeTemplatePattern, options, caller);
          }
          else
            timePattern = dateTimeKeys[1];
        }
        pattern = datePattern || '';
        if(timePattern !== undefined)
        {
          if(pattern !== '')
            pattern += ' ' + timePattern;
          else
            pattern = timePattern;
        }
        //cache the pattern
        if(_localeDataCache[locale] === undefined) {
          _localeDataCache[locale] = {};
          _localeDataCache[locale]['dates'] = {};
          _localeDataCache[locale]['dates']['calendars'] = {};
          _localeDataCache[locale]['dates']['calendars']['gregorian'] = {};
          _localeDataCache[locale]['dates']['calendars']['gregorian']
          ['dateTimeFormats'] = {};
        }
        _localeDataCache[locale]['dates']['calendars']['gregorian']
        ['dateTimeFormats'][dateTimeKeys[0] + dateTimeKeys[1]] = pattern;
        return pattern;
      };      
    }());
            
      
    _formatImpl = function(value, localeElements, options) {
      var ret;
      var mainNode = _getLocaleElementsMainNode(localeElements);
      var format = options['pattern'] || _expandFormat(options, localeElements,
        "OraDateTimeConverter.format");
      // Start with an empty string
      ret = [];
      var part,
      zeros = [ "0", "00", "000" ],
      quoteCount = 0,
      tokenRegExp = _getTokenRegExp(),
      cal = mainNode['dates']['calendars']['gregorian'];
      var calDaysFormt = cal['days']['format'],
      calDaysStandAlone = cal['days']['stand-alone'],
      calMonthdFormt = cal['months']['format'],
      calMonthdStandAlone = cal['months']['stand-alone'];

      function _padZeros(num, c) {
        var r, s = num + "";
        if (c > 1 && s.length < c) {
          r = (zeros[c - 2] + s);
          return r.substr(r.length - c, c);
        }
        else {
          r = s;
        }
        return r;
      }

      function _getPart(date, part) {
        switch (part) {
          case 0:
            return date.getFullYear();
          case 1:
            return date.getMonth();
          case 2:
            return date.getDate();
          case 3:
            var days = {
              0: "sun", 
              1: "mon", 
              2: "tue", 
              3: "wed", 
              4: "thu", 
              5: "fri", 
              6: "sat"
            };
            return days[date.getDay()];
        }
      }
      
      for (; ;) {
        // Save the current index
        var index = tokenRegExp.lastIndex,
        // Look for the next pattern
        ar = tokenRegExp.exec(format);

        // Append the text before the pattern (or the end of the string if 
        // not found)
        var preMatch = format.slice(index, ar ? ar.index : format.length);
        quoteCount += _appendPreOrPostMatch(preMatch, ret);

        if (!ar) {
          break;
        }

        // do not replace any matches that occur inside a string literal.
        if (quoteCount % 2) {
          ret.push(ar[0]);
          continue;
        }

        var current = ar[ 0 ],
        clength = current.length;

        switch (current) {
          case "E":
          case "EE":
          case "EEE":
          case "EEEE":
          case "EEEEE":
            switch(clength) {
              case 5:
                part = calDaysFormt['narrow'];
                break;
              case 4:
                part = calDaysFormt['wide'];
                break;
              case 3:
              case 2:
              case 1:
                part = calDaysFormt['abbreviated'];
                break;
            }
            ret.push(part[_getPart(value, 3)]);
            break;
          case "c":
          case "cc":
          case "ccc":
          case "cccc":
          case "ccccc":
            switch(clength) {
              case 5:
                part = calDaysStandAlone['narrow'];
                break;
              case 4:
                part = calDaysStandAlone['wide'];
                break;
              case 3:
              case 2:
              case 1:
                part = calDaysStandAlone['abbreviated'];
                break;
            }
            ret.push(part[_getPart(value, 3)]);
            break;
          case "d":
            ret.push(_getPart(value, 2));
            break;
          case "dd":
            // Day of month, with leading zero for single-digit days
            ret.push(
              _padZeros(_getPart(value, 2), clength)
              );
            break;
          case "MMM":
          case "MMMM":
          case "MMMMM":
            switch(clength) {
              case 5:
                part = calMonthdFormt['narrow'];
                break;
              case 4:
                part = calMonthdFormt['wide'];
                break;
              case 3:
                part = calMonthdFormt['abbreviated'];
                break;
            }          
            ret.push(part[_getPart(value, 1)+1]);
            break;
          case "LLL":
          case "LLLL":
          case "LLLLL":
            switch(clength) {
              case 5:
                part = calMonthdStandAlone['narrow'];
                break;
              case 4:
                part = calMonthdStandAlone['wide'];
                break;
              case 3:
                part = calMonthdStandAlone['abbreviated'];
                break;
            }          
            ret.push(part[_getPart(value, 1)+1]);
            break;
          case "M":
          case "L":
            // Month, as digits, with no leading zero for single-digit months
            ret.push(_getPart(value, 1) + 1);
            break;
          case "MM":
          case "LL":
            // Month, as digits, with leading zero for single-digit months
            ret.push(
              _padZeros(_getPart(value, 1) + 1, clength));
            break;
          case "y":
          case "yy":
          case "yyyy":
            // Year represented by four full digits
            part =  value.getFullYear();
            if (clength == 2) {
              part = part % 100;
            }
            ret.push(_padZeros(part, clength));
            break;
          case "h":
            // Hours with no leading zero for single-digit hours, 
            // using 12-hour clock
            part = value.getHours() % 12;
            if (part === 0) part = 12;
            ret.push(part);
            break;
          case "hh":
            // Hours with leading zero for single-digit hours, 
            // using 12-hour clock
            part = value.getHours() % 12;
            if (part === 0) part = 12;
            ret.push(_padZeros(part, clength));
            break;
          case "K":
            // Hours with leading zero for single-digit hours, 
            // using 12-hour clock
            part = value.getHours() % 12;
            ret.push(part);
            break;
          case "KK":
            // Hours with leading zero for single-digit hours, 
            // using 12-hour clock
            part = value.getHours() % 12;
            ret.push(_padZeros(part, clength));
            break;
          case "H":
            // Hours with no leading zero for single-digit hours, 
            // using 24-hour clock
            ret.push(value.getHours());
            break;
          case "HH":
            // Hours with leading zero for single-digit hours, 
            // using 24-hour clock
            ret.push(_padZeros(value.getHours(), clength));
            break;
          case "k":
            // Hours with no leading zero for single-digit hours, 
            // using 24-hour clock
            part = value.getHours();
            if (part === 0) part = 24;
            ret.push(part);
            break;
          case "kk":
            // Hours with leading zero for single-digit hours, 
            // using 24-hour clock
            part = value.getHours();
            if (part === 0) part = 24;
            ret.push(_padZeros(part, clength));
            break;
          case "m":
            // Minutes with no leading zero for single-digit minutes
            ret.push(value.getMinutes());
            break;
          case "mm":
            // Minutes with leading zero for single-digit minutes
            ret.push(_padZeros(value.getMinutes(), clength));
            break;
          case "s":
            // Seconds with no leading zero for single-digit seconds
            ret.push(value.getSeconds());
            break;
          case "ss":
            // Seconds with leading zero for single-digit seconds
            ret.push(_padZeros(value.getSeconds(), clength));
            break;
          case "a":
            // Multicharacter am/pm indicator
            part = value.getHours() < 12 ? 
            cal['dayPeriods']['format']['wide']['am'] : 
            cal['dayPeriods']['format']['wide']['pm'];
            ret.push(part);
            break;
          case "SS":
          case "S":
            // Milliseconds
            ret.push(value.getMilliseconds());
            break;
          case "z":
          case "zz":
          case "zzz":
          case "zzzz":
            // Time zone offset with leading zero
            part = value.getTimezoneOffset();
            ret.push(
              (part <= 0 ? "+" : "-") + 
              _padZeros(Math.floor(Math.abs(part/60)), 2) + 
              _padZeros(Math.floor(Math.abs(part%60)), 2)
              );
            break;
          case "G":
          case "GG":
          case "GGG":
          case "GGGG":
          case "GGGGG":
            switch(clength) {
              case 5:
                part = cal['eras']['eraAbbr'];
                break;
              case 4:
                part = cal['eras']['eraAbbr'];
                break;
              case 3:
              case 2:
              case 1:
                part = cal['eras']['eraAbbr'];
                break;
            }          
            ret.push(part['1']);
            break;
          case "/":
            ret.push("/");
            break;
          default:
            _throwInvalidDateFormat(format, options, current);
        }
      }
      return ret.join("");
      
    };
  

    //_formatRelativeImpl
    (function() {
      var _getDaysDif, _getDayIndex,
      _isSameYear, _isNextYear, _isPrevYear,
      _isSameMonth, _isNextMonth, _isPrevMonth,
      _isSameWeek, _isNextWeek, _isPrevWeek,
      _isSameDay, _isNextDay, _isPrevDay;

      //d1 and d2 same year
      _isSameYear = function(d1, d2) {
        return d1.getFullYear() == d2.getFullYear();
      };

      //d2 is next year
      _isNextYear = function(d1, d2) {
        return d2.getFullYear() - d1.getFullYear() == 1;
      };

      //d2 is previous year
      _isPrevYear = function(d1, d2) {
        return _isNextYear(d2, d1);
      };

      //d2 and d1 same month 
      _isSameMonth = function(d1, d2) {
        return _isSameYear(d1, d2) && (d1.getMonth() === d2.getMonth());
      };

      //d2 is next month
      _isNextMonth = function(d1, d2) {
        if(_isSameYear(d1, d2))
          return (d2.getMonth() - d1.getMonth()) == 1;
        else if(_isNextYear(d1, d2)) {
          return d1.getMonth() == 11 && (d2.getMonth() == 0);   
        }
        return false;
      };

      //d2 is previous month
      _isPrevMonth = function(d1, d2) {
        return _isNextMonth(d2, d1);
      };

      //difference in days between d2 and d1. Only valid if d2 is same or 
      //next month of d1
      _getDaysDif = function(d1, d2) {
        var day1 = d1.getDate();
        var day2 = d2.getDate();  
        if(_isNextMonth(d1, d2)) {
          day2 += _getDaysInMonth(d1.getFullYear, d1.getMonth());
        }
        return day2 - day1;
      };

      _getDayIndex = function(localeElements, idx) {
        var mainNode = _getLocaleElementsMainNode(localeElements);
        var territory = mainNode['identity']['territory'] || '001';
        var firstDayNode = 
        localeElements['supplemental']['weekData']['firstDay'];
        var firstDayOfweek = firstDayNode[territory];
        var ret = idx - firstDayOfweek;
        if(ret < 0)
          ret += 7;
        return ret;
      };

      //d1 and d2 same week
      _isSameWeek = function(localeElements, d1, d2) {
        if(d1 > d2) {
          //swap dates to make sure we work with positive numbers
          var tmp = d1;
          d1 = d2;
          d2 = tmp;  
        }
        if((!_isSameMonth(d1, d2)) && (!_isNextMonth(d1, d2)))
          return false;
        var dif = _getDaysDif(d1, d2) + 
        _getDayIndex(localeElements, d1.getDay());
        return dif >= 0 && dif <= 6; 
      };

      //d2 is next week
      _isNextWeek = function(localeElements, d1, d2) {
        if((!_isSameMonth(d1, d2)) && (!_isNextMonth(d1, d2)))
          return false;
        var dif = _getDaysDif(d1, d2) + 
        _getDayIndex(localeElements, d1.getDay());
        return dif >= 7 && dif <= 13; 
      };

      //d2 is previous week
      _isPrevWeek = function(localeElements, d1, d2) {
        return _isNextWeek(localeElements, d2, d1);
      };

      //d1 and d2 same day
      _isSameDay = function(d1, d2) {
        return _isSameYear(d1, d2) && _isSameMonth(d1, d2) &&
        (d1.getDate() === d2.getDate());
      };

      //d2 is next day
      _isNextDay = function(d1, d2) {
        if((!_isSameMonth(d1, d2)) && (!_isNextMonth(d1, d2))) {
          return false;
        }
        return (_getDaysDif(d1, d2) === 1);
      };

      //d2 is previous day
      _isPrevDay = function(d1, d2) {
        return _isNextDay(d2, d1);
      };
      
      /**
       * Format a relative date/time
       * @param {Date} value - Date object to be formatted.
       * @param {Object} localeElements - the instance of 
       * LocaleElements bundle.
       * @param {Object} options - Containing the following properties:
       * formatUsing. Allowed values: "displayName"
       * dateField. Allowed values: "day", "week", "month", "year"
       * @return {string|null} relative date. null if the value falls 
       * out side the supported relative range.
       */
      _formatRelativeImpl = function(value, localeElements, options) {
        var mainNode = _getLocaleElementsMainNode(localeElements);
        var fields = mainNode['dates']['fields'];
        var getOption = _getGetOption(options, 
          "OraDateTimeConverter.formatRelative");
        var formatUsing = getOption('formatUsing', 'string', 
          ['displayName']);
        var option = getOption('dateField', 'string',
          ['day', 'week', 'month', 'year']);
        var now = new Date();
        switch(option) {
          case "day" :
            if(_isSameDay(now, value))
              return fields['day']['relative-type-0'];
            if(_isNextDay(now, value))
              return fields['day']['relative-type-1'];
            if(_isPrevDay(now, value))
              return fields['day']['relative-type--1'];
            break;
          case "week" :
            if(_isSameWeek(localeElements, now, value))
              return fields['week']['relative-type-0'];
            if(_isNextWeek(localeElements, now, value))
              return fields['week']['relative-type-1'];
            if(_isPrevWeek(localeElements, now, value))
              return fields['week']['relative-type--1'];
            break;
          case "month" :
            if(_isSameMonth(now, value))
              return fields['month']['relative-type-0'];
            if(_isNextMonth(now, value))
              return fields['month']['relative-type-1'];
            if(_isPrevMonth(now, value))
              return fields['month']['relative-type--1'];
            break;
          case "year" :
            if(_isSameYear(now, value))
              return fields['year']['relative-type-0'];
            if(_isNextYear(now, value))
              return fields['year']['relative-type-1'];
            if(_isPrevYear(now, value))
              return fields['year']['relative-type--1'];
            break;
          default :
            break;
        }
        return null;
      };
    }());
    
    
    // parse functions
    (function() {
      var _expandYear,
      _getTokenIndex,
      _parseLenient,
      _parseLenientyMEd,
      _parseLenientyMMMEd,
      _parseLenienthms,
      _getDayIndex,
      _getMonthIndex,
      _getParseRegExp,
      _validateRange,
      _arrayIndexOfDay,
      _arrayIndexOfMonth,
      _throwDateFormatMismatch,
      _throwWeekdayMismatch;
      
      _throwWeekdayMismatch = function(weekday, day) {
        var msg, error, errorInfo;
        msg =  "The weekday " + weekday + " does not match the date " + day; 
        error = new Error(msg);
        errorInfo = {
          'errorCode' : 'dateToWeekdayMismatch',
          'parameterMap' : {
            'weekday' : weekday,
            'date':day
          }
        };
        error['errorInfo'] = errorInfo;
        throw error;
      };
      
      _throwDateFormatMismatch = function(value, format, style) {
        var msg, error, errorInfo, errorCodeType;
        if(style === 2) {
          msg =  "The value \"" + value + 
          "\" does not match the expected date-time format \"" + format + '"';
          errorCodeType = "datetimeFormatMismatch";
        }
        else if(style === 0) {
          msg =  "The value \"" + value + 
          "\" does not match the expected date format \"" + format + '"';
          errorCodeType = "dateFormatMismatch";
         
        }
        else {
          msg = "The value \"" + value + 
          "\" does not match the expected time format \"" + format + '"';
          errorCodeType = "timeFormatMismatch";
        
        }
        error = new Error(msg);
        errorInfo = {
          'errorCode' : errorCodeType,
          'parameterMap' : {
            'value': value,
            'format': format
          }
        };
        error['errorInfo'] = errorInfo;
        throw error;
      };
        
      _expandYear = function(start2DigitYear, year) {
        // expands 2-digit year into 4 digits.
        if (year < 100) {
          var ambiguousTwoDigitYear = start2DigitYear % 100;
          year += Math.floor((start2DigitYear/100))*100 + 
          (year < ambiguousTwoDigitYear ? 100 : 0);
        }
        return year;
      };
  
      _arrayIndexOfDay = function(daysObj, item) {
        var days = {
          "sun": 0, 
          "mon": 1, 
          "tue": 2, 
          "wed": 3, 
          "thu": 4, 
          "fri": 5, 
          "sat": 6
        };
        for (var d in daysObj) {
          if (_toUpper(daysObj[d]) === item) {
            return days[d];
          }
        }
        return -1;
      };
  
      _arrayIndexOfMonth = function(monthsObj, item) {    
        for (var m in monthsObj) {
          if (_toUpper(monthsObj[m]) === item) {
            return (m - 1);
          }
        }
        return -1;
      };
      
      _getDayIndex = function(localeElements, value, fmt) {
        var mainNode = _getLocaleElementsMainNode(localeElements);
        var ret, days;
        var calDaysFmt = 
        mainNode['dates']['calendars']['gregorian']['days']['format'];
        var calDaysStdAlone = 
        mainNode['dates']['calendars']['gregorian']['days']['stand-alone'];
        switch(fmt) {
          case 0:
            days =  [
            calDaysFmt['abbreviated'],
            calDaysFmt['wide']
            ];
            break;
          case 1:
            days =  [
            calDaysStdAlone['abbreviated'],
            calDaysStdAlone['wide']
            ];
            break;
          default:
            break;
        }
        value = _toUpper(value);
        ret = _arrayIndexOfDay(days[0], value);
        if (ret === -1) {
          ret = _arrayIndexOfDay(days[1], value);
        }
        return ret;
      };

      //fmt:0 for format, 1 for stand-alone, 2 for lenient parse
      _getMonthIndex = function(localeElements, value, fmt) {
        var ret = -1, months;
        var mainNode = _getLocaleElementsMainNode(localeElements);
        var calMonthsFmt = 
        mainNode['dates']['calendars']['gregorian']['months']['format'];
        var calMonthsStdAlone = 
        mainNode['dates']['calendars']['gregorian']['months']['stand-alone'];
        switch(fmt) {
          case 0:
            months =  [
            calMonthsFmt['wide'],
            calMonthsFmt['abbreviated']
            ];
            break;
          case 1:
            months =  [
            calMonthsStdAlone['wide'],
            calMonthsStdAlone['abbreviated']
            ];
            break;
          case 2:
            months =  [
            calMonthsFmt['wide'],
            calMonthsFmt['abbreviated'],
            calMonthsStdAlone['wide'],
            calMonthsStdAlone['abbreviated']
            ];
            break; 
          default:
            return -1;
        }
        value = _toUpper(value);
        for(var m in months) {
          ret = _arrayIndexOfMonth(months[m], value);
          if (ret !== -1) {
            return ret;
          }
        }
        return ret;
      };

      _getParseRegExp = function(format, options) {
        // converts a format string into a regular expression with groups that
        // can be used to extract date fields from a date string.
        // check for a cached parse regex.
        var re = {};
		

        // expand single digit formats, then escape regular expression
        //  characters.
        var expFormat = format.replace(/([\^\$\.\*\+\?\|\[\]\(\)\{\}])/g,
          "\\\\$1"),
        regexp = [ "^" ],
        groups = [],
        index = 0,
        quoteCount = 0,
        tokenRegExp = _getTokenRegExp(),
        match;

        // iterate through each date token found.
        while ((match = tokenRegExp.exec(expFormat)) !== null) {
          var preMatch = expFormat.slice(index, match.index);
          index = tokenRegExp.lastIndex;

          // don't replace any matches that occur inside a string literal.
          quoteCount += _appendPreOrPostMatch(preMatch, regexp);
          if (quoteCount % 2) {
            regexp.push(match[0]);
            continue;
          }

          // add a regex group for the token.
          var m = match[ 0 ],
          add;
          switch (m) { 
            //Some locales have month names as alpha-numeric
            case "MMMMM":
            case "MMMM":
            case "MMM":
              add = "(\\D+|\\d\\d?\\D|\\d\\d?)";
              break;
            case "LLLLL":
            case "LLLL":
            case "LLL":
              add = "(\\D+|\\d\\d?\\D|\\d\\d?)";
              break;
            case "EEEEE":
            case "EEEE":
            case "EEE":
            case "EE":
            case "E":
            case "ccccc":
            case "cccc":
            case "ccc":
            case "cc":
            case "c":
            case "GGGGG":
            case "GGGG":
            case "GGG":
            case "GG":
            case "G":
              add = "(\\D+)";
              break;
            case "a":
              add = "(\\D*)";
              break;
            case "yy":
            case "dd":
            case "MM":
            case "LL":
            case "hh":
            case "HH":
            case "KK":
            case "kk":
            case "mm":
            case "ss":
              add = "(\\d\\d?)";
              break;
            case "SS":
            case "S":
              add = "(\\d{1,3})";
              break;
            case "y":
            case "yyyy":
              add = "(\\d{1,4})";
              break;
            case "d":
            case "M":
            case "L":
            case "H":
            case "h":
            case "K":
            case "k":
            case "m":
            case "s":
              add = "(\\d\\d?)";
              break;
            case "zzzz":
            case "zzz":
            case "zz":
            case "z":
              add = "([+-]?\\d{1,4})";
              break;
            case "/":
              add = "(\\/)";
              break;
            default:
              _throwInvalidDateFormat(format, options, m);
          }
          if (add) {
            regexp.push(add);
          }
          groups.push(match[0]);
        }
        _appendPreOrPostMatch(expFormat.slice(index), regexp);
        regexp.push("$");

        // allow whitespace to differ when matching formats.
        var regexpStr = regexp.join("").replace(/\s+/g, "\\s+"),
        parseRegExp = {
          'regExp': regexpStr, 
          'groups': groups
        };

        // cache the regex for this format.
        return re[ format ] = parseRegExp;
      };

      _validateRange = function(name, value, low, high, displayValue,
        displayLow, displayHigh) {
        if(value < low || value > high) { 
          var msg =  displayValue + 
          " is out of range.  Enter a value between " + displayLow +
          " and " + displayHigh + " for " + name; 
          var rangeError = new RangeError(msg);
          var errorInfo = {
            'errorCode' : "datetimeOutOfRange",
            'parameterMap' : {
              'value': displayValue, 
              'minValue': displayLow,
              'maxValue': displayHigh,
              'propertyName': name
            }
          };
          rangeError['errorInfo'] = errorInfo;
          throw rangeError;              
        }
      };
        
      _getTokenIndex = function(arr, token)
      {
        for(var i in arr){
          for (var n in arr[i])
          {
            if(n === token)
              return parseInt(i, 10);
          }         
        }
        return 0;
      };
        
      //time lenient parse
      _parseLenienthms = function(result, timepart, format, localeElements) {
        var mainNode = _getLocaleElementsMainNode(localeElements);
        var calPM = mainNode['dates']['calendars']['gregorian']['dayPeriods']['format']['wide']['pm'];
        //hour, optional minutes and optional seconds
        var timeRegExp = 
        /(\d{1,2})(?:\D+?(\d{1,2}))?(?:\D+?(\d{1,2}))?(?:\D+?(\d{1,3}))?/g;
        var timeFormatRegExp= /h|H|K|k/g;
        var hour = 0, minute = 0, second = 0, msec=0, idx;
        var match = timeRegExp.exec(timepart);
        if(match[1] !== undefined)
          hour = parseInt(match[1], 10);
        if(match[2] !== undefined)
          minute = parseInt(match[2], 10);
        if(match[3] !== undefined)
          second = parseInt(match[3], 10);
        if(match[4] !== undefined)
          msec = parseInt(match[4], 10);
 
        match =  timeFormatRegExp.exec(format);
        switch(match[0]) {
          case "h":
            // Hour in am/pm (1-12)
            if (hour === 12) hour = 0;
            _validateRange("hour", hour, 0, 11, hour, 1, 12);
            idx = (_toUpper(timepart)).indexOf(_toUpper(calPM));
            if( idx !== -1 && hour < 12)
              hour += 12;
            break;
          case "K":
            // Hour in am/pm (0-11)
            _validateRange("hour", hour, 0, 11, hour, 0, 11);
            idx = (_toUpper(timepart)).indexOf(_toUpper(calPM));
            if( idx !== -1 && hour < 12)
              hour += 12;
            break;
          case "H":
            _validateRange("hour", hour, 0, 23, hour, 0, 23);
            break;
          case "k":
            if (hour === 24) hour = 0;
            _validateRange("hour", hour, 0, 23, hour, 1, 24);
            break;
          default:
            break;
        }
        // Minutes.
        _validateRange("minute", minute, 0, 59, minute, 0, 59);
        // Seconds.
        _validateRange("second", second, 0, 59, second, 0, 59);
        //millisec
        _validateRange("millisec", msec, 0, 999, msec, 0, 999);

        result.setHours(hour, minute, second, msec);
      };
        
      //lenient parse yMd and yMEd patterm. Must have year, moth, 
      //date all numbers. Ex: 5/3/2013
      //weekday is optional. If present it must match date. 
      //Ex:  Tuesday 11/19/2013
      //if year > 2-digits it can be anywhere in the string. 
      //Otherwise assume its position based on pattern
      //if date > 12 it can be anywhere in the string. 
      //Otherwise assume its position based on pattern 
      //separators can be any non digit characters
      _parseLenientyMEd = function(value, format, options, localeElements,
        isDateTime)
        {
        var regExp = /(\d{1,4})\D+?(\d{1,4})\D+?(\d{1,4})/g;
        var match = regExp.exec(value);
        if(match === null) {
          _throwDateFormatMismatch(value, format, 0);
        }
        var tokenIndexes = [{
          'y':format.indexOf("y")
        },{
          'M':format.indexOf("M")
        },{
          'd':format.indexOf("d")
        }];
        tokenIndexes.sort(function(a,b){
          for (var n1 in a)
          {
            break;
          }
          for (var n2 in b)
          {
            break;
          }
          return a[n1]-b[n2];
        });
        var year, month, day, yearIndex, dayIndex, i;
        var foundYear = false, foundDay = false;
        for(i =1; i <= 3; i++)
        {
          var tokenMatch =  match[i];
          //find year if year is yyy|yyyy
          if(tokenMatch.length > 2 || tokenMatch > 31)
          {
            year = tokenMatch;
            foundYear = true;
            yearIndex = i-1;
          }
        }

        if(!foundYear) {
          yearIndex = _getTokenIndex(tokenIndexes, 'y');
          year = match[_getTokenIndex(tokenIndexes, 'y')+1];
        }
        //find day if day value > 12
        for(i = 0; i < 3; i++){ 
          if(i!== yearIndex && match[i+1] > 12) {
            day = match[i+1];
            foundDay = true;
            dayIndex = i;
            break;
          }
        }
        if(!foundDay) {
          if(yearIndex === _getTokenIndex(tokenIndexes, 'd'))
          {
            day = match[_getTokenIndex(tokenIndexes, 'y')+1];
            month = match[_getTokenIndex(tokenIndexes, 'M')+1];
          }
          else if (yearIndex === _getTokenIndex(tokenIndexes, 'M'))
          {
            day = match[_getTokenIndex(tokenIndexes, 'd')+1];
            month = match[_getTokenIndex(tokenIndexes, 'y')+1];   
          }
          else {
            day = match[_getTokenIndex(tokenIndexes, 'd')+1];
            month = match[_getTokenIndex(tokenIndexes, 'M')+1];   
 
          }
        }
        else {
          for(i = 0; i < 3; i++){ 
            if(i!== dayIndex && i !== yearIndex) {
              month = match[i+1];
              break;
            }
          }
          if(month === undefined) {
            month = match[_getTokenIndex(tokenIndexes, 'M')+1];
          }
        }
        month -= 1;
        var daysInMonth = _getDaysInMonth(year, month);
        _validateRange("month", month, 0, 11, month+1, 1, 12);
        _validateRange("day", day, 1, daysInMonth, day, 1, daysInMonth);
        var start2DigitYear = _get2DigitYearStart(options);
        year = _expandYear(start2DigitYear, parseInt(year, 10));
        _validateRange("year", year, 0, 9999, year, 0, 9999);
        var result = 
        {
          'value': new Date(year, month, day),
          'warning' : 'lenient parsing was used'
        };
        if(isDateTime) {
          var timepart = value.substr(regExp.lastIndex +1);
          _parseLenienthms(result['value'], timepart, format, localeElements);
        }
        return result;
      };

      //lenient parse yMMMd and yMMMEd patterns. Must have year, date as numbers 
      //and month name.
      //weekday is optional. If present it must match date.
      // Ex:  Monday Nov, 11 2013
      //weekday and month name can be anywhere in the string.
      //if year > 2-digits it can be anywhere in the string. 
      //Otherwise assume its position based on pattern
      //separators can be any non digit characters
      _parseLenientyMMMEd = function(value, format, options, localeElements,
        isDateTime) {
        value =  _toUpper(value); 
        var mainNode = _getLocaleElementsMainNode(localeElements);
        //locate month name
        var calMonthsFmt = 
        mainNode['dates']['calendars']['gregorian']['months']['format'];
        var calMonthsStandAlone = 
        mainNode['dates']['calendars']['gregorian']['months']['stand-alone'];
        var months =  [
        calMonthsFmt['wide'],
        calMonthsFmt['abbreviated'],
        calMonthsStandAlone['wide'],         
        calMonthsStandAlone['abbreviated']
        ];
        var foundMatch = false;
        var reverseMonth;
        var i, j, mName;
        for (i in months) {
          reverseMonth = [];
          for(j in months[i]) {
            mName = _toUpper( months[i][j]);
            reverseMonth.push({
              'idx':j, 
              'name':mName
            });
          }
          reverseMonth.sort(function(a,b){
            return b['idx'] - a['idx'];
          });
          
          for(j in reverseMonth) {
            mName =  reverseMonth[j]['name'];
            if (value.indexOf(mName) != -1) {
              foundMatch = true;
              value = value.replace(mName, "");
              break;
            }
          }
          if(foundMatch)
            break;
        }
        //There is no month name. Try yMEd lenient parse.
        if(!foundMatch) {
          return _parseLenientyMEd(value, format, options, localeElements,
            isDateTime);
        }
          
        var month = _getMonthIndex(localeElements, mName, 2);          
        _validateRange("month", month, 0, 11, month, 1, 12);

        //locate weekday
        var calDaysFmt = 
        mainNode['dates']['calendars']['gregorian']['days']['format'];
        var calDaysStandAlone = 
        mainNode['dates']['calendars']['gregorian']['days']['stand-alone'];
        var days =  [
        calDaysFmt['wide'],
        calDaysFmt['abbreviated'],
        calDaysStandAlone['wide'],         
        calDaysStandAlone['abbreviated']
        ];
          
        foundMatch = false;
        var dName;
        for (i in days) {
          for(j in days[i]) {
            dName = _toUpper(days[i][j]);
            if (value.indexOf(dName) != -1) {
              foundMatch = true;
              value = value.replace(dName, "");
              break;
            }
          }
          if(foundMatch)
            break;
          dName = null;
        }
   
        //find year and date
        var regExp = /(\d{1,4})\D+?(\d{1,4})/g;
        var match = regExp.exec(value);
        if(match === null) {
          _throwDateFormatMismatch(value, format, 0);
        }
        var tokenIndexes = [{
          'y':format.indexOf("y")
        },{
          'd':format.indexOf("d")
        }];
      
        tokenIndexes.sort(function(a,b){
          for (var n1 in a)
          {
            break;
          }
          for (var n2 in b)
          {
            break;
          }
          return a[n1]-b[n2];
        });
        
        var year, day, yearIndex;
        var foundYear = false;
        for(i =1; i <= 2; i++)
        {
          var tokenMatch =  match[i];
          //find year if year is yyy|yyyy
          if(tokenMatch.length > 2 || tokenMatch > 31)
          {
            year = tokenMatch;
            foundYear = true;
            yearIndex = i-1;
          }
        }
        if(!foundYear) {
          yearIndex = _getTokenIndex(tokenIndexes, 'y');
          year = match[_getTokenIndex(tokenIndexes, 'y')+1];
        } 
        if(yearIndex === _getTokenIndex(tokenIndexes, 'd'))
        {
          day = match[_getTokenIndex(tokenIndexes, 'y')+1];
        }
        else {
          day = match[_getTokenIndex(tokenIndexes, 'd')+1];
        }
          
        var start2DigitYear = _get2DigitYearStart(options);
        year = _expandYear(start2DigitYear, parseInt(year, 10));
        _validateRange("year", year, 0, 9999, year, 0, 9999);
        var parsedDate = new Date(year, month, day);
        if(dName != null) {
          var weekDay = _getDayIndex(localeElements, dName, 0);  
          // day of week does not match date
          if (parsedDate.getDay() !== weekDay) {
            _throwWeekdayMismatch(dName, parsedDate.getDate());
          }
        }
        var daysInMonth = _getDaysInMonth(year, month);
        _validateRange("day", day, 1, daysInMonth, day, 1, daysInMonth);
        var result = 
        {
          'value': parsedDate,
          'warning' : 'lenient parsing was used'
        };
        if(isDateTime) {
          var timepart = value.substr(regExp.lastIndex +1);
          _parseLenienthms(result['value'], timepart, format, localeElements);
        }
        return result;
      };
      
      _parseLenient = function(value, format, options, localeElements) {
        var dtStyle = _dateTimeStyle(options, "OraDateTimeConverter.parse");
        switch (dtStyle) {
          //date style
          case 0 :
            return _parseLenientyMMMEd(value, format, options, localeElements,
              false);
            break
          //time style
          case 1 :
            var d = new Date();
            _parseLenienthms(d, value, format, localeElements);
            var result = 
            {
              'value': d,
              'warning' : 'lenient parsing was used'
            };
            return result;
            break;
          //date-time style
          case 2 :
            return _parseLenientyMMMEd(value, format, options, localeElements,
              true);
            break;
          default:
            break;
        }
        return null;
      };
         
      _parseExact = function(value, format, options, localeElements) {
        var mainNode = _getLocaleElementsMainNode(localeElements);
        // try to parse the date string by matching against the format string
        // while using the specified culture for date field names.
        value = _trim(value);
        // convert date formats into regular expressions with groupings.
        // use the regexp to determine the input format and extract the date
        //  fields.
        var parseInfo = _getParseRegExp(format, options),
        match = new RegExp(parseInfo['regExp']).exec(value);
        var monthsFormat = 
        mainNode['dates']['calendars']['gregorian']['months']['format'];
        var monthsStandalone = 
        mainNode['dates']['calendars']['gregorian']['months']['stand-alone'];
        var daysFormat = 
        mainNode['dates']['calendars']['gregorian']['days']['format'];
        var daysStandAlone = 
        mainNode['dates']['calendars']['gregorian']['days']['stand-alone'];
        var startName, endName;
        if (match === null) {
          return _parseLenient(value, format, options, localeElements);
        }

        // found a date format that matches the input.
        var groups = parseInfo['groups'],
        year = null, month = null, date = null, weekDay = null,
        hour = 0, hourOffset, min = 0, sec = 0, msec = 0, tzMinOffset = null,
        pmHour = false, weekDayName,
        calPM = mainNode['dates']['calendars']['gregorian']['dayPeriods']['format']['wide']['pm'];
        var start2DigitYear = _get2DigitYearStart(options);
        // iterate the format groups to extract and set the date fields.
        for (var j = 0, jl = groups.length; j < jl; j++) {
          var matchGroup = match[ j + 1 ];
          if (matchGroup) {
            var current = groups[ j ],
            clength = current.length,
            matchInt = parseInt(matchGroup, 10);
            switch (current) {
              case "dd":
              case "d":
                // Day of month.
                date = matchInt;
                //try leneient parse for date style only
                if(date > 31)                    
                  return _parseLenient(value, format, options, localeElements)
                break;
              case "MMM":
                month = _getMonthIndex(localeElements, matchGroup, 0);
                startName = monthsFormat['abbreviated']['1'];
                endName = monthsFormat['abbreviated']['12'];
                _validateRange("month name", month, 0, 11, matchGroup, 
                  startName, endName);
                break;
              case "MMMM":
                month = _getMonthIndex(localeElements, matchGroup, 0);
                startName = monthsFormat['wide']['1'];
                endName = monthsFormat['wide']['12'];
                _validateRange("month name", month, 0, 11, matchGroup, 
                  startName, endName);
                break;
              case "MMMMM":
                month = _getMonthIndex(localeElements, matchGroup, 0);
                startName = monthsFormat['abbreviated']['1'];
                endName = monthsFormat['abbreviated']['12'];
                _validateRange("month name", month, 0, 11, matchGroup, 
                  startName, endName);
                break;
              case "LLL":
                month = _getMonthIndex(localeElements, matchGroup, 1);
                startName = monthsStandalone['abbreviated']['1'];
                endName = monthsStandalone['abbreviated']['12'];
                _validateRange("month name", month, 0, 11, matchGroup, 
                  startName, endName);
                break;
              case "LLLL":
                month = _getMonthIndex(localeElements, matchGroup, 1);
                startName = monthsStandalone['wide']['1'];
                endName = monthsStandalone['wide']['12'];
                _validateRange("month name", month, 0, 11, matchGroup, 
                  startName, endName);
                break;
              case "LLLLL":
                month = _getMonthIndex(localeElements, matchGroup, 1);
                startName = monthsStandalone['abbreviated']['1'];
                endName = monthsStandalone['abbreviated']['12'];
                _validateRange("month name", month, 0, 11, matchGroup, 
                  startName, endName);
                break;
              case "M":
              case "MM":
              case "L":
              case "LL":
                // Month.
                month = matchInt - 1;
                //try leneient parse for date style only
                if(month > 11)
                  return _parseLenient(value, format, options, localeElements)
                break;
              case "y":
              case "yy":
              case "yyyy":
                year = _expandYear(start2DigitYear, matchInt);
                _validateRange("year", year, 0, 9999, year, 0, 9999);
                break;
              case "h":
              case "hh":
                // Hour in am/pm (1-12)
                hour = matchInt;
                if (hour === 12) hour = 0;
                _validateRange("hour", hour, 0, 11, matchInt, 1, 12);
                break;
              case "K":
              case "KK":
                // Hour in am/pm (0-11)
                hour = matchInt;
                _validateRange("hour", hour, 0, 11, matchInt, 0, 11);
                break;
              case "H":
              case "HH":
                hour = matchInt;
                _validateRange("hour", hour, 0, 23, matchInt, 0, 23);
                break;
              case "k":
              case "kk":
                hour = matchInt;
                if (hour === 24) hour = 0;
                _validateRange("hour", hour, 0, 23, matchInt, 1, 24);
                break;
              case "m":
              case "mm":
                // Minutes.
                min = matchInt;
                _validateRange("minute", min, 0, 59, matchInt, 0, 59);
                break;
              case "s":
              case "ss":
                // Seconds.
                sec = matchInt;
                _validateRange("second", sec, 0, 59, matchInt, 0, 59);
                break;
              case "a":
                pmHour = (_toUpper(matchGroup) === _toUpper(calPM)) ;
                break;
              case "S":
                // Milliseconds.
                msec = matchInt * Math.pow(10, 3 - clength);
                _validateRange("millisec", msec, 0, 999, matchInt, 0, 999);
                break;
              case "E":
              case "EE":
              case "EEE":
                // Day of week.
                weekDayName = matchGroup;
                weekDay = _getDayIndex(localeElements, matchGroup, 0);
                startName = daysFormat['abbreviated']['sun'];
                endName = daysFormat['abbreviated']['sat'];
                _validateRange("weekday", weekDay, 0, 6, matchGroup, 
                  startName, endName);
                break;  
              case "c":
              case "cc":
              case "ccc":
                // Day of week.
                weekDayName = matchGroup;
                weekDay = _getDayIndex(localeElements, matchGroup, 1);
                startName = daysStandAlone['abbreviated']['sun'];
                endName = daysStandAlone['abbreviated']['sat'];
                _validateRange("weekday", weekDay, 0, 6, matchGroup, 
                  startName, endName);
                break;  
              case "EEEE":
                // Day of week.
                weekDayName = matchGroup;
                weekDay = _getDayIndex(localeElements, matchGroup, 0);
                startName = daysFormat['wide']['sun'];
                endName = daysFormat['wide']['sat'];
                _validateRange("weekday", weekDay, 0, 6, matchGroup, 
                  startName, endName);
                break;
              case "EEEEE":
                // Day of week.
                weekDayName = matchGroup;
                weekDay = _getDayIndex(localeElements, matchGroup, 0);
                startName = daysFormat['abbreviated']['sun'];
                endName = daysFormat['abbreviated']['sat'];
                _validateRange("weekday", weekDay, 0, 6, matchGroup, 
                  startName, endName);
                break; 
              case "cccc":
                // Day of week.
                weekDayName = matchGroup;
                weekDay = _getDayIndex(localeElements, matchGroup, 1);
                startName = daysStandAlone['wide']['sun'];
                endName = daysStandAlone['wide']['sat'];
                _validateRange("weekday", weekDay, 0, 6, matchGroup, 
                  startName, endName);
                break;
              case "ccccc":
                // Day of week.
                weekDayName = matchGroup;
                weekDay = _getDayIndex(localeElements, matchGroup, 1);
                startName = daysStandAlone['abbreviated']['sun'];
                endName = daysStandAlone['abbreviated']['sat'];
                _validateRange("weekday", weekDay, 0, 6, matchGroup, 
                  startName, endName);
                break;
              case "z":
              case "zz":
              case "zzz":
              case "zzzz":
                // Time zone offset in +/-hhmm | +/-hmm.
                hourOffset = (matchInt/100) << 0;
                _validateRange("TZ Offset", hourOffset, -12, 13, 
                  matchInt, -12, 13);
                var minOffset = Math.abs(matchInt % 100);
                _validateRange("TZ Offset", minOffset, 0, 59, minOffset, 0, 
                  59);
                tzMinOffset  = (hourOffset * 60)  + 
                (_startsWith(matchGroup, "-") ? -minOffset : minOffset);
                break;
            }
          }
        }
        var parsedDate = new Date(), defaultYear;
        defaultYear =  parsedDate.getFullYear();
        if (year === null) {
          year = defaultYear;
        }
        // if day and month are unspecified,the defaults are current 
        // day and month.
        if (month === null && date === null) {
          month = parsedDate.getMonth();
          date = parsedDate.getDate();
        }
        // if day is unspecified, default 1st day of month.
        else if (date === null) {
          date = 1;
        }
        
        //validate day range, depending on the month and year
        var daysInMonth = _getDaysInMonth(year, month);
        _validateRange("day", date, 1, daysInMonth, date, 1, daysInMonth);
        // have to set year, month and date together to avoid overflow based 
        // on current date.
        parsedDate.setFullYear(year, month, date);

        // day of week does not match date
        if (weekDay !== null && parsedDate.getDay() !== weekDay) {
          _throwWeekdayMismatch(weekDayName, parsedDate.getDate());
        }
        // if pm designator token was found make sure the hours fit the 
        // 24-hour clock.
        if (pmHour && hour < 12) {
          hour += 12;
        }
        parsedDate.setHours(hour, min, sec, msec);
        if (tzMinOffset !== null) {
          // adjust timezone to utc before applying local offset.
          var adjustedMin = parsedDate.getMinutes() - (tzMinOffset + 
            parsedDate.getTimezoneOffset());
          parsedDate.setHours(parsedDate.getHours() + 
            ((adjustedMin / 60) << 0), adjustedMin % 60);
        }
        var result =
        {
          'value': parsedDate
        };
        return result;
      };
    }()); 
    
    _getResolvedOptionsFromPattern = function(locale, numberingSystemKey, 
      pattern) {
      // expand single digit formats, then escape regular expression 
      // characters.
      var expFormat = pattern.replace(/([\^\$\.\*\+\?\|\[\]\(\)\{\}])/g, 
        "\\\\$1"),
      regexp = [ "^" ],
      quoteCount = 0,
      index=0,
      tokenRegExp = _getTokenRegExp(),
      match;
      var result = {
        'locale': locale,
        'numberingSystem': numberingSystemKey,
        'calendar': 'gregorian'
      };
      // iterate through each date token found.
      while ((match = tokenRegExp.exec(expFormat)) !== null) {
        var preMatch = expFormat.slice(index, match.index);
        index = tokenRegExp.lastIndex;

        // skip matches that occur inside a string literal.
        quoteCount += _appendPreOrPostMatch(preMatch, regexp);
        if (quoteCount % 2) {
          continue;
        }

        // add a regex group for the token.
        var m = match[ 0 ];
        switch (m) {
          case "EEEEE":
          case "ccccc":
            result['weekday'] = 'narrow';
            break
          case "EEEE":
          case "cccc":
            result['weekday'] = 'long';
            break;
          case "EEE":
          case "EE":
          case "E":
          case "ccc":
          case "cc":
          case "c":
            result['weekday'] = 'short';
            break;
          case "MMMMM":
          case "LLLLL":
            result['month'] = 'narrow';
            break;
          case "MMMM":
          case "LLLL":
            result['month'] = 'long';
            break;
          case "MMM":
          case "LLL":
            result['month'] = 'short';
            break;
          case "MM":
          case "LL":
            result['month'] = '2-digit';
            break;
          case "M":
          case "L":
            result['month'] = 'numeric';
            break;
          case "a":
            result['hour12'] = true;
            break;
          case "SS":
          case "S":
            result['millisecond'] = 'numeric';
            break;
          case "dd":
            result['day'] = '2-digit';
            break;
          case "d":
            result['day'] = 'numeric';
            break;
          case "yyyy":
          case "y":
            result['year'] = 'numeric';
            break;
          case "yy":
            result['year'] = '2-digit';
            break;
          case "HH":
          case "kk":
            result['hour'] = '2-digit';
            result['hour12'] = false;
            break;
          case "H":
          case "k":
            result['hour'] = 'numeric';
            result['hour12'] = false;
            break;
          case "hh":
          case "KK":
            result['hour'] = '2-digit';
            result['hour12'] = true;
            break;        
          case "h":
          case "K":
            result['hour'] = 'numeric';
            result['hour12'] = true;
            break;
          case "mm":
            result['minute'] = '2-digit';
            break;
          case "m":
            result['minute'] = 'numeric';
            break;
          case "ss":
            result['second'] = '2-digit';
            break;
          case "s":
            result['second'] = 'numeric';
            break;
          case "/":
          case "zzzz":
          case "zzzz":
          case "zz":
          case "z":
            break;
          default:
            _throwInvalidDateFormat(pattern, result, m);
            break;
        }
      }
      return result;
    };
  
    //test if the pattern is date, time or date-time
    //0: date, 1:time, 2:date-time
    _dateTimeStyleFromPattern = function(pattern) {
      var result = _getResolvedOptionsFromPattern('', '', pattern);
      var isDate = (result['year'] !== undefined || result['month'] !== 
        undefined ||
        result['weekday'] !== undefined || result['day'] !== undefined);
      var isTime = (result['hour'] !== undefined || result['minute'] !== 
        undefined ||
        result['second'] !== undefined);
      if(isDate && isTime)
        return 2;
      else if (isTime)
        return 1;
      else
        return 0;    
    };
      
    //test if the pattern/options is date, time or date-time
    //0: date, 1:time, 2:date-time
    _dateTimeStyle = function(options, caller) {
      //try pattern
      if(options['pattern'] !== undefined ) {
        return _dateTimeStyleFromPattern(options['pattern']);     
      }
        
      //try ecma options
      var getOption = _getGetOption(options, caller);
      var isTime = (getOption('hour', 'string', ['2-digit', 'numeric']) !== 
        undefined ||
        getOption('minute', 'string', ['2-digit', 'numeric']) !== undefined ||
        getOption('second', 'string', ['2-digit', 'numeric']) !== undefined);
      var isDate = (getOption('year', 'string', ['2-digit', 'numeric']) !== 
        undefined ||
        getOption('month', 'string', 
          ['2-digit', 'numeric', 'narrow', 'short', 'long']) !== undefined ||
        getOption('day', 'string', ['2-digit', 'numeric']) !== undefined ||
        getOption('weekday', 'string', ['narrow', 'short', 'long']) !== 
        undefined);
      if(isDate && isTime)
        return 2;
      else if (isTime)
        return 1;
      else if (isDate)
        return 0;                
        
      //try predefined style
      var option = getOption('formatType', 'string', 
        ['date', 'time', 'datetime'], 'date');
      if(option === 'datetime')
        return 2;
      else if (option === 'time')
        return 1;
      return 0;
    };
  
    _parseImpl = function(str, localeElements, options, locale) {
      var numberingSystemKey =  _getLanguageExtension(locale, "nu");
      if(numeringSystems[numberingSystemKey] === undefined)
        numberingSystemKey = 'latn';         
      if(numberingSystemKey !== 'latn') {
        var idx;
        var latnStr = [];
        for(idx = 0; idx < str.length; idx++)
        {
          var pos = numeringSystems[numberingSystemKey].indexOf(str[idx]);
          if(pos != -1)
            latnStr.push(pos);
          else
            latnStr.push(str[idx]);       
        }
        str =  latnStr.join("");
      }
      if(arguments.length <= 2 || options === undefined)
      {
        //default is yMd
        options = {
          'year': 'numeric', 
          'month': 'numeric', 
          'day': 'numeric'
        };
      }
      var formats = options['pattern'] || _expandFormat(options, localeElements, 
        "OraDateTimeConverter.parse");
      var date = _parseExact(str, formats, options, localeElements);
      return date;
    };
      
    function _init() {    
      return {
        /**
       * Format a date.
       * @memberOf OraDateTimeConverter
       * @param {Date} value - Date object to be formatted.
       * @param {Object} localeElements - the instance of LocaleElements bundle.
       * @param {Object=} options - Containing the following properties:<br>
       * - <b>weekday.</b> Allowed values: "narrow", "short", "long".<br>
       * - <b>era.</b> Allowed values: "narrow", "short", "long".<br>
       * - <b>year.</b> Allowed values:"2-digit", "numeric".<br>
       * - <b>month.</b> Allowed values: "2-digit", "numeric", "narrow", 
       * "short", "long".<br>
       * - <b>day.</b> Allowed values: "2-digit", "numeric".<br>
       * - <b>hour.</b> Allowed values: "2-digit", "numeric".<br>
       * - <b>minute.</b> Allowed values: "2-digit", "numeric".<br>
       * - <b>second.</b> Allowed values: "2-digit", "numeric".<br>
       * - <b>timeZoneName.</b> Will be ignored in phase1. We do not support it 
       * yet.<br>
       * - <b>hour12.</b> is a Boolean value indicating whether 12-hour format 
       * (true) or 24-hour format (false) should be used. It is only relevant 
       * when hour is also present.<br>
       * - <b>formatMatcher.</b> optional, specifies the algorithm to be used 
       * for looking up the date format based on the options. Allowed values: 
       * "basic", "munger". The default is munger.
       * - <b>pattern.</b> custom String pattern as defined by Unicode CLDR.<br>
       * - <b>formatType.</b> a predefined formatting type. Allowed values: 
       * "date", "time", "datetime".
       * - <b>dateFormat.</b> optional, specifies the date format field. 
       * Allowed values: "short", "medium", "long", "full". It is only 
       * considered when formatType is present. The default value 
       * is "short".<br>
       * - <b>timeFormat.</b> optional, specifies the time format field. 
       * Allowed values: "short", "medium", "long", "full". It is only 
       * considered when formatType is present. The default value 
       * is "short".<br><br>
       * The order of precedence is the following:<br>
       * 1. pattern.<br>
       * 2. ECMA options.<br>
       * 3. formatType.<br>
       * If options is ommitted, the default will be the following object:<br>
       * {<br>
       * year:"numeric",<br> 
       * month:"numeric",<br> 
       * day:"numeric"<br>
       * };
       * @param {string=} locale - A BCP47 compliant language tag. it is only 
       * used to extract the unicode extension keys. 
       * @return {string|null} formatted date.
       * @throws {RangeError} If a propery value of the options parameter is 
       * out of range.
       * @throws {SyntaxError} If an Unexpected token is encountered in the 
       * pattern. 
       */ 
        format : function(value, localeElements, options, locale) {
          if(typeof value === "number") {
            value = new Date(value);            
          }
          else if(typeof value === "string") {
            if(_trim(value) === '')
              return null;
            value = _parseImpl(value, localeElements, options, locale);
            value = value['value'];
          }
          if(value.toString() === 'Invalid Date')
            return 'Invalid Date';
          if(arguments.length <=2 || options === undefined)
          {
            //default is yMd
            options = {
              'year': 'numeric', 
              'month': 'numeric', 
              'day': 'numeric'
            };
          }
          var ret = _formatImpl(value, localeElements, options);
          var numberingSystemKey =  _getLanguageExtension(locale, "nu");
          if(numeringSystems[numberingSystemKey] === undefined)
            numberingSystemKey = 'latn';           
          if(numberingSystemKey !== 'latn') {
            var idx;
            var nativeRet = [];
            for(idx = 0; idx < ret.length; idx++)
            {
              if(ret[idx] >= '0' && ret[idx] <= '9')
                nativeRet.push(numeringSystems[numberingSystemKey][ret[idx]]);
              else nativeRet.push(ret[idx]);
        
            }
            return nativeRet.join("");
          }
          return ret;
        },
      
        /**
       * Format a relative date/time
       * @memberOf OraDateTimeConverter
       * @param {Date} value - Date object to be formatted.
       * @param {Object} localeElements - the instance of LocaleElements bundle.
       * @param {Object} options - Containing the following properties:
       * formatUsing. Allowed values: "displayName"
       * dateField. Allowed values: "day", "week", "month", "year"
       * @return {string|null} relative date. null if the value falls out side 
       * the supported relative range.
       */
        formatRelative : function(value, localeElements, options) {
          return _formatRelativeImpl(value, localeElements, options);
        },


        /**
       * Parse a date.
       * @memberOf OraDateTimeConverter
       * @param {string} str - String to be parsed.
       * @param {Object} localeElements - The instance of LocaleElements bundle
       * @param {Object=} options - Containing the following properties:<br>
       * - <b>weekday.</b> Allowed values: "narrow", "short", "long".<br>
       * - <b>era.</b> Allowed values: "narrow", "short", "long".<br>
       * - <b>year.</b> Allowed values:"2-digit", "numeric".<br>
       * - <b>month.</b> Allowed values: "2-digit", "numeric", "narrow", 
       * "short", "long".<br>
       * - <b>day.</b> Allowed values: "2-digit", "numeric".<br>
       * - <b>hour.</b> Allowed values: "2-digit", "numeric".<br>
       * - <b>minute.</b> Allowed values: "2-digit", "numeric".<br>
       * - <b>second.</b> Allowed values: "2-digit", "numeric".<br>
       * - <b>timeZoneNmae.</b> Will be ignored in phase1. We do not support it
       *  yet.<br>
       * - <b>hour12.</b> is a Boolean value indicating whether 12-hour format 
       * (true) or 24-hour format (false) should be used. It is only relevant 
       * when hour is also present.<br>
       * - <b>formatMatcher.</b> optional, specifies the algorithm to be used 
       * for looking up the date format based on the options. Allowed values: 
       * "basic", "munger". The default is munger.
       * - <b>pattern.</b> custom String pattern as defined by Unicode CLDR.<br>
       * - <b>two-digit-year-start.</b> the 100-year period 2-digit year. 
       * During parsing, two digit years will be placed in the range 
       * two-digit-year-start to two-digit-year-start + 100 years. 
       * The default is 1950.<br>
       * - <b>formatType.</b> a predefined formatting type. Allowed values: 
       * "date", "time", "datetime".
       * - <b>dateFormat.</b> optional, specifies the date format. Allowed 
       * values: "short", "medium", "long", "full". It is only considered when 
       * formatType is present. The default value is "short".<br>
       * - <b>timeFormat.</b> optional, specifies the time format. Allowed 
       * values: "short", "medium", "long", "full". It is only considered when 
       * formatType is present. The default value is "short".<br><br>
       * The order of precedence is the following:<br>
       * 1. pattern.<br>
       * 2. ECMA options.<br>
       * 3. formatType.<br>          
       * If options is ommitted, the default will be the following object:<br>
       * {<br>
       * year:"numeric",<br> 
       * month:"numeric",<br> 
       * day:"numeric"<br>
       * };
       * @param {string=} locale - A BCP47 compliant language tag. it is only 
       * used to extract the unicode extension keys. 
       * @return {Date} a date object parsed from the string. In case of error, 
       * returns null.
       * @throws {RangeError} If a property value of the options parameter is 
       * out of range.
       * @throws {SyntaxError} If an Unexpected token is encountered in the 
       * pattern.
       * @throws {Error} If the <i>str</i> parameter does not match the format 
       * pattern.
       * @throws {RangeError} if one of the date fields is out of range.
       */ 
        parse : function(str, localeElements, options, locale) {
          return _parseImpl(str, localeElements, options, locale);
        },
      
        /**
       * Resolve options.
       * Returns a new object with properties reflecting the date and time 
       * formatting options computed based on the options parameter. 
       * If the options parameter is ommitted, the following object will be 
       * returned:<br>
       * {<br>
       * calendar: "gregorian"<br>
       * numberingSystem: "latn"<br>
       * locale: &lt;locale parameter&gt;,<br>
       * day: "numeric",<br>
       * month: "numeric",<br>
       * year: "numeric"<br>
       * };
       * @memberOf OraDateTimeConverter
       * @param {Object} localeElements - The instance of LocaleElements bundle                           
       * @param {Object=} options - Containing the following properties:<br>
       * - <b>calendar.</b> The calendar system.<br>
       * - <b>weekday.</b> Allowed values: "narrow", "short", "long".<br>
       * - <b>era.</b> Allowed values: "narrow", "short", "long".<br>
       * - <b>year.</b> Allowed values:"2-digit", "numeric".<br>
       * - <b>month.</b> Allowed values: "2-digit", "numeric", "narrow", 
       * "short", "long".<br>
       * - <b>day.</b> Allowed values: "2-digit", "numeric".<br>
       * - <b>hour.</b> Allowed values: "2-digit", "numeric".<br>
       * - <b>minute.</b> Allowed values: "2-digit", "numeric".<br>
       * - <b>second.</b> Allowed values: "2-digit", "numeric".<br>
       * - <b>timeZoneName.</b> Will be ignored in phase1. We do not support 
       * it yet.<br>
       * - <b>hour12.</b> is a Boolean value indicating whether 12-hour format 
       * (true) or 24-hour format (false) should be used. It is only relevant 
       * when hour is also present.<br>
       * - <b>formatMatcher.</b> optional, specifies the algorithm to be used 
       * for looking up the date format based on the options. Allowed values: 
       * "basic", "munger". The default is munger.
       * - <b>pattern.</b> custom String pattern as defined by Unicode CLDR. 
       * Will override above options when present.<br>
       * - <b>two-digit-year-start.</b> the 100-year period 2-digit year. 
       * During parsing, two digit years will be placed in the range 
       * two-digit-year-start to two-digit-year-start + 100 years. 
       * The default is 1950.<br>
       * - <b>formatType.</b> predefined format type.  Allowed values: 
       * "datetime", "date", "time"<br>
       * - <b>dateFormat.</b> format of date field.  Allowed values: "short", 
       * "medium", "long", "full". It is only relevant when formatType is also 
       * present<br>
       * - <b>timeFormat.</b> format of time field.  Allowed values: "short", 
       * "medium", "long", "full". It is only relevant when formatType is also 
       * present<br>
       * @param {string=} locale - A BCP47 compliant language tag. it is only 
       * used to extract the unicode extension keys.
       * @return {Object} Resolved options object.
       * @throws {RangeError} If a property value of the options parameter is 
       * out of range.
       */
           
        resolvedOptions : function(localeElements, options, locale){
          if(arguments.length < 3 || locale === undefined) {
            locale = _getLocaleElementsMainNodeKey(localeElements);
          }
          if(arguments.length < 2 || options === undefined)
          {
            //default is yMd
            options = {
              'year': 'numeric', 
              'month': 'numeric', 
              'day': 'numeric'
            };
          }
          var ecma = false;
          var result;
          var numberingSystemKey =  _getLanguageExtension(locale, "nu");
          if(numeringSystems[numberingSystemKey] === undefined)
            numberingSystemKey = 'latn';
          if(options !== undefined && options['pattern'] !== undefined ) {
            result = _getResolvedOptionsFromPattern(locale, numberingSystemKey, 
              options['pattern']);
            result['pattern'] = options['pattern'];
            return result;
          }
          if(options !== undefined) {
            result = {
              'locale': locale,
              'numberingSystem': numberingSystemKey,
              'calendar': 'gregorian'
            };
            var count = 0;
            for(count in options){
              count++;
            }
            if(count == 0) {            
              result['year']= 'numeric'; 
              result['month'] = 'numeric'; 
              result['day']=  'numeric';
              return result;
            }
            var getOption = _getGetOption(options, 
              "OraDateTimeConverter.resolvedOptions");
            var option = getOption('year',  'string', ['2-digit', 'numeric']);
            if(option !== undefined) {
              result['year'] = option;
              ecma = true;
            }
            option = getOption('era', 'string', ['narrow', 'short', 'long']);
            if(option !== undefined) {
              result['era'] = option;
              ecma = true;
            }
            option = getOption('month', 'string', ['2-digit', 'numeric', 
              'narrow', 'short', 'long']);
            if(option !== undefined) {
              result['month'] = option;
              ecma = true;
            }
            option = getOption('day', 'string', ['2-digit', 'numeric']);
            if(option !== undefined) {
              result['day'] = option;
              ecma = true;
            }
            option = getOption('weekday', 'string', ['narrow', 'short', 
              'long']);
            if(option !== undefined) {
              result['weekday'] = option;
              ecma = true;
            }           
            option = getOption('hour', 'string', ['2-digit', 'numeric']);
            if(option !== undefined) {
              result['hour'] = option;
              ecma = true;
              option = getOption('hour12', 'boolean', [true, false]);
              if(option === undefined)
                option = _isHour12(localeElements);
              result['hour12'] = option;
            }
            option = getOption('minute', 'string', ['2-digit', 'numeric']);
            if(option !== undefined) {
              result['minute'] = option;
              ecma = true;
            }
            option = getOption('second', 'string', ['2-digit', 'numeric']);
            if(option !== undefined) {
              result['second'] = option;
              ecma = true;
            }
            result['two-digit-year-start'] = _get2DigitYearStart(options);
            if(!ecma) {
              //var format = _expandPredefinedStylesFormat(options, 
                //localeElements, OraDateTimeConverter.resolvedOptions);
              //result = _getResolvedOptionsFromPattern(locale, 
                //numberingSystemKey, format);
              var fmtType = getOption('formatType', 'string', 
                ['date', 'time', 'datetime'], 'date');
              var dStyle = getOption('dateFormat', 'string', 
                ['short', 'medium', 'long', 'full'], 'short');
              var tStyle = getOption('timeFormat', 'string', 
                ['short', 'medium', 'long', 'full'], 'short');
              result['formatType'] = fmtType;
              result['dateFormat'] = dStyle;
              result['timeFormat'] = tStyle;
              return result;
            }
            result['patternFromOptions'] = _expandFormat(options, 
              localeElements, "OraDateTimeConverter.resolvedOptions");
            return result;
          }
          var defaultOptions = {
            'year': 'numeric', 
            'month': 'numeric', 
            'day': 'numeric'
          };
          var patternFromOptions = _expandFormat(defaultOptions,
            localeElements, "OraDateTimeConverter.resolvedOptions");
          return {
            'calendar': 'gregorian',
            'locale': locale,
            'numberingSystem': numberingSystemKey,
            'year': 'numeric', 
            'month': 'numeric', 
            'day': 'numeric',
            'patternFromOptions': patternFromOptions
          };
        }
      };
    }
   
    return {
      /**
     * getInstance.
     * Returns the singleton instance of OraDateTimeConverter class.  
     * @memberOf OraDateTimeConverter
     * @return {Object} The singleton OraDateTimeConverter instance.
     */
      getInstance: function () {	 
        if ( !instance ) {
          instance = _init();
        }	 
        return instance;
      }	 
    };
  }());
}());
/**
 * @export
 * Placeholder here as closure compiler objects to export annotation outside of top level
 */

/**
 * The ojvalidation module.
 * @name oj.Validation
 * @class 
 * @export
 */
oj.Validation = {};

/**
 * Internal properties to hold all factory provider callbacks or instances by name
 * @private
 */
oj.Validation._converterFactories = {}; oj.Validation._validatorFactories = {};

/**
 * Internal properties to hold the default factory instances.
 * @private
 */
oj.Validation._defaultConverterFactories = {}; oj.Validation._defaultValidatorFactories = {};

/**
 * Internal property that identifies the type that is the contract for conveters and validators.
 * @private
 */
oj.Validation._CONTRACTS = {'converter' : {name: "oj.ConverterFactory",  type: oj.ConverterFactory},
                            'validator': {name: "oj.ValidatorFactory", type: oj.ValidatorFactory}};

/**
 * Module method to register and retrieve converter factory instances by name. 
 * When passed only the name, an existing factory (registered for the name) is returned. Callers can 
 * expect to get back the default 'number' and 'datetime' converters. 
 * When passed two arguments, a new factory for the name is registered. If the name already exists 
 * the new instance replaces the old one. 
 * 
 * @param {string} type a case insensitive name of the converter factory. 
 * @param {Object=} instance the instance of the factory that implements the contract for 
 * oj.ConverterFactory.
 * 
 * @export
 */
oj.Validation.converterFactory = function (type, instance)
{
  var retValue;
  if (type && !instance)
  {
    // getter
    retValue = oj.Validation._getFactory(type, oj.Validation._converterFactories);
  }
  else if (type && instance)
  {
    // setter
    retValue = oj.Validation._registerFactory(type, 
                                              instance, 
                                              oj.Validation._converterFactories,
                                              oj.Validation._CONTRACTS['converter']);
  }
  
  return retValue;
};

/**
 * Module method to register and retrieve validator factory instances by name. 
 * When passed only the name, an existing factory (registered for the name) is returned. 
 * When passed two arguments, a new factory for the name is registered. If the name already exists 
 * the new instance replaces the old one. 
 * 
 * @param {string} type a case insensitive name of the validator factory. 
 * @param {Object=} instance the instance of the factory that implements the contract for 
 * oj.ValidatorFactory.
 * 
 * @export
 */
oj.Validation.validatorFactory = function (type, instance)
{
  var retValue;
  if (type && !instance)
  {
    // getter
    retValue = oj.Validation._getFactory(type, oj.Validation._validatorFactories);
  }
  else if (type && instance)
  {
    // setter
    retValue = oj.Validation._registerFactory(type, 
                                              instance, 
                                              oj.Validation._validatorFactories, 
                                              oj.Validation._CONTRACTS['validator']);
  }
  
  return retValue;
};

/**
 * Returns the default converter factory instances for the supported types as defined by the 
 * oj.ConverterFactory.
 * 
 * @param {string} type The default converter factory for the type. Supported types are 'number' and 
 * 'datetime'
 * @return {Object} an instance of oj.ConverterFactory or null if an unknown type is requested.
 * @export
 */
oj.Validation.getDefaultConverterFactory = function (type)
{
  return oj.Validation._getFactory(type, oj.Validation._defaultConverterFactories);
};

/**
 * Returns the default validator factory instance for the requested types as defined by the 
 * oj.ValidatorFactory.
 * 
 * @param {string} type The default converter factory for the type. Supported types are 'number' and 
 * 'datetime'
 * @return {Object} an instance of oj.ConverterFactory or null if an unknown type is requested.
 * @export
 */
oj.Validation.getDefaultValidatorFactory = function (type)
{
  return oj.Validation._getFactory(type, oj.Validation._defaultValidatorFactories);
};

// PACKAGE PRIVATE METHODS
/**
 * Called only by internal jet converter factory implementations.
 * 
 * @param {string} name
 * @param {Object} instance
 * @private
 */
oj.Validation.__registerDefaultConverterFactory = function (name, instance)
{
  // save to both factories
  var contractDef = oj.Validation._CONTRACTS['converter'];
  oj.Validation._registerFactory (name, instance, oj.Validation._defaultConverterFactories, contractDef);
  oj.Validation._registerFactory(name, instance, oj.Validation._converterFactories, contractDef);
};

/**
 * Called only by internal jet validator factory implementations.
 * 
 * @param {string} name of the validator factory
 * @param {Object} instance of the validator factory that creates instances of the validator
 * @private
 */
oj.Validation.__registerDefaultValidatorFactory = function (name, instance)
{
  // save to both factories
  var contractDef = oj.Validation._CONTRACTS['validator'];
  oj.Validation._registerFactory (name, instance, oj.Validation._defaultValidatorFactories, contractDef);
  oj.Validation._registerFactory(name, instance, oj.Validation._validatorFactories, contractDef);
};


/**
 * Checks that the instance implements the interface type. If it doesn't it throws an error.
 * @param {Object} instance
 * @param {Object} type
 * @param {string} typeName 
 * @throws {Error} if instance does not implement the methods defined on type.  
 * @private
 */
oj.Validation._doImplementsCheck = function (instance, type, typeName)
{
  if (type)
  {
    // Check that instance duck types providerType
    if (!oj.Validation._quacksLike(instance, type))
    {
      throw new Error("Factory instance does not implement the methods expected by the factory of type " + typeName);
    }
  }
};

/**
 * Retrieves the converter factory by name from the provided factories.
 * @private
 */
oj.Validation._getFactory = function(name, factories)
{
  oj.Assert.assertString(name);
  var cachedInstance = null;
  
  if (name)
  {
    name = name.toLowerCase();

    // getter called to retrieve the factory instance 
    var providerProps = factories[name] || {}; 
    cachedInstance = providerProps['instance'] || null;
  }
  // TODO: log a warning that name is null
  return cachedInstance;
};

/**
 * Tests whether an object 'quacks like a duck'. Returns `true` if the thingie has all of the 
 * methods of the second, parameter 'duck'. Returns `false` otherwise. 
 *
 * @param {Object} thingie the object to test.
 * @param {Object} duck The archetypal object, or 'duck', that the test is against.
 * @private
*/
oj.Validation._quacksLike = function(thingie, duck) 
{
  var valid = true, property;

  oj.Assert.assertObject(thingie);
  oj.Assert.assertObject(duck);

  for (property in duck) 
  {
    // Ensure that thingie defines the same functions as duck. We don't care about other properties
    if (duck.hasOwnProperty(property)) 
    {
      if (typeof duck[property] === "function" && 
              !thingie[property] && typeof thingie[property] !== "function") 
      {
        valid = false;
        break;
      }
    }
  }
  
  return valid;
};

/**
 * Registers the factory instance by the name, storing it into the factories object, after ensruing 
 * that the instance duck types the specified contract.
 * 
 * @private
 */
oj.Validation._registerFactory = function(name, instance, factories, contractDef)
{
  oj.Assert.assertString(name);
  oj.Assert.assertObject(instance);

  if (name)
  {
    // set new provider factory function clearing out the previously stored instance
    var props = {};
    props['instance'] = instance;
    oj.Validation._doImplementsCheck(instance, contractDef.type, contractDef.name);

    // Save to default and public factories
    factories[name.toLowerCase()] = props;
  }
};

/**
 * The contract for a ConverterFactory that provides a factory method to create a converter by its 
 * type.
 * 
 * @name oj.ConverterFactory
 * @abstract
 * @class
 * @export
 */
oj.ConverterFactory = 
{
  /**
   * Default converter type for number
   * @expose
   * @member
   */
  "CONVERTER_TYPE_NUMBER" : 'number',
  /**
   * Default converter type for datetime 
   * @expose
   * @member
   */
  "CONVERTER_TYPE_DATETIME" : 'datetime',

  /**
   * Creates an immutable converter instance of the requested type. Implementations can register 
   * custom converter factories for the supported or new types.
   * 
   * @param {(Object|null)} options an object containing the options required by the converter for its 
   * initialization. The key value pairs used in the options is implementation specific.
   * 
   * @return {Object} a converter instance.
   * @throws {TypeError} if an unrecognized type was provided 
   * @expose
   */
  createConverter : function(options) {}  
};

/**
 * The contract for a ValidatorFactory that provides a factory method to create a validator by its 
 * type.
 * 
 * @name oj.ValidatorFactory
 * @abstract
 * @class
 * @export
 */
oj.ValidatorFactory = 
{
  /**
   * Default validator type for required validation, used to create an instance of type 
   * {@link oj.RequiredValidator}.
   * @expose
   * @member
   */
  "VALIDATOR_TYPE_REQUIRED" : 'required',
          
  /**
   * Default validator type for regular expression based validation, used to create an instance of 
   * type {@link oj.RegExpValidator}.
   * @expose
   * @member
   */
  "VALIDATOR_TYPE_REGEXP" : 'regexp',

  /**
   * Default validator type for range validation involving numbers, used to create an instance of type 
   * {@link oj.NumberRangeValidator}.
   * @expose
   * @member
   */
  "VALIDATOR_TYPE_NUMBERRANGE" : 'numberRange',

  /**
   * Default validator type for length validation, used to create an instance of type 
   * {@link oj.LengthValidator}.
   * @expose
   * @member
   */
  "VALIDATOR_TYPE_LENGTH" : 'length',

  /**
   * Default validator type for range validation involving datetimes, used to create an instance of type 
   * {@link oj.DateTimeRangeValidator}.
   * @expose
   * @member
   */
  "VALIDATOR_TYPE_DATETIMERANGE" : 'dateTimeRange',
  
  /**
   * Default validator type for date restriction validation, used to create an instance of type 
   * {@link oj.DateRestrictionValidator}.
   * @expose
   * @member
   */
  "VALIDATOR_TYPE_DATERESTRICTION" : 'dateRestriction',
          
  /**
   * Creates an immutable validator instance of the requested type. Implementations can register 
   * custom validator factories for the supported or new types.
   * 
   * @param {(Object|null)} options an object containing the options required by the validator for its 
   * initialization. The key value pairs used in the options is implementation specific.
   * 
   * @return {Object} a validator instance.
   * @throws {TypeError} if an unrecognized type was provided 
   * @expose
   */
  createValidator : function(options) {}  
};

/**
 * @export
 * Placeholder here as closure compiler objects to export annotation outside of top level
 */

/**
 * Converter Contract
 */

/**
 * Constructs an immutable instance of Converter.
 * 
 * @param {Object=} options an object literal used to provide an optional information to 
 * initialize the converter.<p>
 * @export
 * @constructor
 */
oj.Converter = function(options)
{
  this.Init(options);
};

// Subclass from oj.Object 
oj.Object.createSubclass(oj.Converter, oj.Object, "oj.Converter");


/**
 * Initializes converter instance with the set options
 * @param {Object=} options an object literal used to provide an optional information to 
 * initialize the converter.<p>
 * @export
 */
oj.Converter.prototype.Init = function(options) 
{
  oj.Converter.superclass.Init.call(this);
  // should we make options truly immutable? non-configurable, non-enumerable, non-writable
  // Object.defineProperty(oj.Converter.prototype, "_options", {value: options});
  this._options = options;
};

/**
 * Returns a hint that describes the converter format expected.
 * @return {String|null} a hint describing the format the value is expected to be in.
 * @export
 */
oj.Converter.prototype.getHint = function () 
{
  oj.Assert.failedInAbstractFunction();
  return null;
};

/**
 * Returns the options called with converter initialization.
 * @return {Object} an object of options.
 * @export
 */
oj.Converter.prototype.getOptions = function () 
{
  return (this._options || {});
};

/**
 * Parses a String value using the options provided. 
 * 
 * @param {String} value to parse
 * @return {(Number|Date)} the parsed value. 
 * @throws {Error} if parsing fails
 * @export
 */
oj.Converter.prototype.parse = function (value) 
{
  oj.Assert.failedInAbstractFunction();
  return null;
};

/**
 * Formats the value using the options provided. 
 * 
 * @param {(Number|Date)} value the value to be formatted for display
 * @return {(String|null)} the localized and formatted value suitable for display
 * @throws {Error} if formatting fails.
 * @export
 */
oj.Converter.prototype.format = function (value) 
{
  oj.Assert.failedInAbstractFunction();
  return null;
};

/**
 * Returns an object literal with locale and formatting options computed during initialization of 
 * the object. If options was not provided at the time of initialization, the properties will be 
 * derived from the locale defaults.
 * @return {Object} an object of resolved options.
 * @export
 */
oj.Converter.prototype.resolvedOptions = function ()
{
  var resolved = {};
  // returns a clone of this._options
  $.extend(resolved, this._options);
  
  return resolved;
};


// oj.ConverterError

/**
 * Constructs a ConverterError instance from a summary and detail 
 * 
 * @param {string} summary a localized String that provides a summary of the error
 * @param {string} detail a localized String that provides a detail of the error
 * @constructor
 * @export
 */
oj.ConverterError = function (summary, detail)
{
  var message = new oj.Message(summary, detail, oj.Message.SEVERITY_LEVEL['ERROR']);
  this.Init(message); 
};

oj.ConverterError.prototype = new Error();

/**
 * Initializes the instance. 
 * @param {Object} message instance of oj.Message
 * @export
 */
oj.ConverterError.prototype.Init = function (message)
{
  var detail = message['detail'], summary = message['summary'];
  this._message = message;

  // so browser can get to e.name and e.message 
  this.name = 'Converter Error';
  this.message = detail || summary;
};

/**
 * Returns an instance of oj.Message.
 * 
 * @return {Object} instance of oj.Message
 * @export
 */
oj.ConverterError.prototype.getMessage = function ()
{
  return this._message;
};
/**
 * @export
 * Placeholder here as closure compiler objects to export annotation outside of top level
 */

/**
 * oj.NumberConverter Contract. 
 */

/**
 * @export
 * @constructor
 * @augments oj.Converter 
 * @name oj.NumberConverter
 */
oj.NumberConverter = function()
{
  this.Init();
};

// Subclass from oj.Object 
oj.Object.createSubclass(oj.NumberConverter, oj.Converter, "oj.NumberConverter");

/**
 * Initializes the number converter instance with the set options.
 * @param {Object=} options an object literal used to provide an optional information to 
 * initialize the converter.<p>
 * @export
 */
oj.NumberConverter.prototype.Init = function(options) 
{
  oj.NumberConverter.superclass.Init.call(this, options);
};

/**
 * Formats the Number value using the options provided and returs a String value.
 * 
 * @param {Number} value the value to be formatted for display
 * @return {(String|null)} the localized and formatted value suitable for display
 * @throws {Error} a ConverterError if formatting fails.
 * @export
 */
oj.NumberConverter.prototype.format = function (value) 
{
  return oj.NumberConverter.superclass.format.call(this, value);
};

/**
 * Parses the value using the options provided and returns a Number object.
 * 
 * @param {String} value to parse
 * @return {Number} the parsed value as a Number object.
 * @throws {Error} a ConverterError if parsing fails
 * @export
 */
oj.NumberConverter.prototype.parse = function (value) 
{
  return oj.NumberConverter.superclass.parse.call(this, value);
};

/**
 * @export
 * Placeholder here as closure compiler objects to export annotation outside of top level
 */

/**
 * oj.DateTimeConverter Contract. 
 */

/**
 * @constructor
 * @param {Object=} options an object literal used to provide an optional information to 
 * @augments oj.Converter 
 * @name oj.DateTimeConverter
 * @export
 */
oj.DateTimeConverter = function(options)
{
  this.Init(options);
};

// Subclass from oj.Object 
oj.Object.createSubclass(oj.DateTimeConverter, oj.Converter, "oj.DateTimeConverter");

/**
 * Initializes the date time converter instance with the set options.
 * @param {Object=} options an object literal used to provide an optional information to 
 * initialize the converter.<p>
 * @export
 */
oj.DateTimeConverter.prototype.Init = function(options) 
{
  oj.DateTimeConverter.superclass.Init.call(this, options);
};

/**
 * Formats the Date value using the options provided and returns a String value.
 * 
 * @param {Date} value to be formatted for display
 * @return {(String|null)} the localized and formatted value suitable for display
 * @throws {Error} a ConverterError if formatting fails.
 * @export
 */
oj.DateTimeConverter.prototype.format = function (value) 
{
  return oj.DateTimeConverter.superclass.format.call(this, value);
};


/**
 * Returns true if a 24-hour format is set; false otherwise.
 * @export
 */
oj.DateTimeConverter.prototype.isHourInDaySet = function()
{
  oj.Assert.failedInAbstractFunction();
};

/**
 * Returns true if 12-hour is set; false otherwise.
 * @export
 */
oj.DateTimeConverter.prototype.isHourInAMPMSet = function()
{
  oj.Assert.failedInAbstractFunction();
};

/**
 * Returns true if minutes are shown in the time portion; false otherwise.
 * @export
 */
oj.DateTimeConverter.prototype.isMinuteSet = function()
{
  oj.Assert.failedInAbstractFunction();
};

/**
 * Returns true if seconds are shown in the time portion; false otherwise.
 * @export
 */
oj.DateTimeConverter.prototype.isSecondSet = function()
{
  oj.Assert.failedInAbstractFunction();
};

/**
 * Returns true if milliseconds are shown in the time portion; false otherwise.
 * @export
 */
oj.DateTimeConverter.prototype.isMilliSecondSet = function()
{
  oj.Assert.failedInAbstractFunction();
};

/**
 * Returns true if year is shown in the date portion; false otherwise.
 * @export
 */
oj.DateTimeConverter.prototype.isYearSet = function()
{
  oj.Assert.failedInAbstractFunction();
};

/**
 * Returns true if month is shown in the date portion; false otherwise.
 * @export
 */
oj.DateTimeConverter.prototype.isMonthSet = function()
{
  oj.Assert.failedInAbstractFunction();
};

/**
 * Returns true if day is shown in the date portion; false otherwise.
 * @export
 */
oj.DateTimeConverter.prototype.isDaySet = function()
{
  oj.Assert.failedInAbstractFunction();
};

/**
 * Returns true if the day name is shown in the date portion; false otherwise.
 * @export
 */
oj.DateTimeConverter.prototype.isDayNameSet = function()
{
  oj.Assert.failedInAbstractFunction();
};

/**
 * Parses the value using the options provided and returns a Date value.
 * 
 * @param {String} value to parse
 * @return {Date} the parsed value as a Date object.
 * @throws {Error} a ConverterError if parsing fails
 * @export
 */
oj.DateTimeConverter.prototype.parse = function (value) 
{
  return oj.DateTimeConverter.superclass.parse.call(this, value);
};
/**
 * @export
 * Placeholder here as closure compiler objects to export annotation outside of top level
 */

/**
 * Validator Contract
 */

/**
 * @constructor
 * @export
 */
oj.Validator = function()
{
  this.Init();
};

// Subclass from oj.Object 
oj.Object.createSubclass(oj.Validator, oj.Object, "oj.Validator");

/**
 * Initializes validator instance with the set options
 * @export
 */
oj.Validator.prototype.Init = function() 
{
  oj.Validator.superclass.Init.call(this);
};

/**
 * Vaidates the value.
 * 
 * @param {Object} value to be validated
 * @return {*} a boolean true if validation passes.
 * @throws Error if validation fails
 * @export
 */
oj.Validator.prototype.validate = function (value) {
  oj.Assert.failedInAbstractFunction();
};

/**
 * Returns a hint that describes the validator rule.
 * @returns {*} a hint string or null
 * @export
 */
oj.Validator.prototype.getHint = function () 
{
  oj.Assert.failedInAbstractFunction();
};

// ValidatorError

/**
 * Constructs a ValidatorError instance from a summary and detail 
 * 
 * @param {string} summary a localized String that provides a summary of the error
 * @param {string} detail a localized String that provides a detail of the error
 * @constructor
 * @export
 */
oj.ValidatorError = function (summary, detail)
{
  var message = new oj.Message(summary, 
                               detail, 
                               oj.Message.SEVERITY_LEVEL['ERROR']);
  this.Init(message); 
};

oj.ValidatorError.prototype = new Error();

/**
 * Initializes the instance. 
 * @param {Object} message an instance of oj.Message
 * @export
 */
oj.ValidatorError.prototype.Init = function (message)
{
  var detail = message['detail'], summary = message['summary'];
  this._message = message;

  // so browser can get to e.name and e.message 
  this.name = 'Validator Error';
  this.message = detail || summary;
};

/**
 * Returns an instance of oj.Message.
 * 
 * @returns {Object} instance of oj.Message
 * @export
 */
oj.ValidatorError.prototype.getMessage = function ()
{
  return this._message;
};
/**
 * @export
 * Placeholder here as closure compiler objects to export annotation outside of top level
 */

/**
 * Constructs a message object 
 * .
 * @param {string} summary - Localized summary message text
 * @param {string} detail - Localized detail message text 
 * @param {number|string} severity - An optional severity for this message. Use constants 
 * oj.Message.SEVERITY_LEVEL for number types and oj.Message.SEVERITY_TYPE for string types. Default 
 * is SEVERITY_ERROR if no severity is specified
 * @constructor
 * @export
 */
oj.Message = function(summary, detail, severity)
{
  this.Init(summary, detail, severity);
};

/**
 * Message Severity Type. 
 * @const
 * @export 
 */
oj.Message.SEVERITY_TYPE = {
  /**
   * Message Severity Level Confirmation. This is the lowest severity level outside of none.
   */
  'CONFIRMATION': 'confirmation',

  /**
   * Message Severity Level Info. This has a higher severity level than confirmation.
   */
  'INFO':'info',

  /**
   * Message Severity Level Warning. This has a higher severity level than confirmation and is used 
   * when displaying a warning message.
   */
  'WARNING': 'warning',

  /**
   * Message Severity Level Error. This has a higher severity level than warning but lower than fatal 
   * and used when displaying an error message. 
   */
  'ERROR': 'error',

  /**
   * Message Severity Level Fatal. This is highest severity level used when displaying a critical 
   * error message, often fatal or unrecoverable.
   * @const
   * @export 
   */
  'FATAL': 'fatal'
};


/**
 * Message severity level
 * @export
 */
oj.Message.SEVERITY_LEVEL = {
  'FATAL' : 5,
  'ERROR' : 4,        
  'WARNING' : 3,
  'INFO' : 2,
  'CONFIRMATION' : 1
};

// Subclass from oj.Object 
oj.Object.createSubclass(oj.Message, oj.Object, "oj.Message");

/**
 * Initializes Message instance with the set options
 * @param {string} summary a lcalized summary message text
 * @param {string} detail a localized detail message text 
 * @param {number|string} severity - An optional severity for this message.  Use constants 
 * oj.Message.SEVERITY_LEVEL for number types and oj.Message.SEVERITY_TYPE for string types.
 *                   
 * @export
 */
oj.Message.prototype.Init = function(summary, detail, severity) 
{
  this['summary'] = summary;
  this['detail'] = detail;
  this['severity'] = severity || oj.Message.SEVERITY_TYPE.ERROR; // defaults to ERROR
  
  /*
  // once initialized proeperties of the oj.Message instance cannot be altered.
  Object.defineProperty(oj.Message.prototype, "summary", {value: summary,  
                                                          writable : false,
                                                          enumerable : true,
                                                          configurable : true});
  Object.defineProperty(oj.Message.prototype, "detail", {value: detail,  
                                                          writable : false,
                                                          enumerable : true,
                                                          configurable : true});
  Object.defineProperty(oj.Message.prototype, "severity", {value: severity,  
                                                          writable : false,
                                                          enumerable : true,
                                                          configurable : true});
  */
  oj.Message.superclass.Init.call(this);
};

/**
 * Indicates whether some other oj.Message instance - msg,  is "equal to" this one.
 * Method is equivalent to java ".equals()" method.
 * 
 * @param {Object} msg 
 * @export
 */
oj.Message.prototype.equals = function (msg)
{
  if (msg)
  {
    if ((oj.Message.getSeverityLevel(this['severity']) === 
            oj.Message.getSeverityLevel(msg['severity'])) && 
        this['summary'] === msg['summary'] && 
        this['detail'] === msg['detail'])
    {
      return true;
    }
  }
  
  return false;
};

/**
 * A convenience method that returns the severity level when given either a severity level of type 
 * number or a severity type of string. 
 * If severity level is not provided or is not valid this returns a severity error.
 * @param {string|number|undefined} severity 
 * @return {number}
 * @export
 */
oj.Message.getSeverityLevel = function (severity)
{
  var index;
  if (severity)
  {
    if (typeof severity === "string")
    {
      index = oj.Message._LEVEL_TO_TYPE.indexOf(severity, 1);
      if (index === -1)
      {
        severity = oj.Message.SEVERITY_LEVEL['ERROR'];
      }
      else
      {
        severity = index;
      }
    }
    else if (typeof severity === "number" && (severity < oj.Message.SEVERITY_LEVEL['CONFIRMATION'] && 
          severity > oj.Message.SEVERITY_LEVEL['FATAL']))
    {
      severity = oj.Message.SEVERITY_LEVEL['ERROR'];
    }
  }
  
  return !severity ? oj.Message.SEVERITY_LEVEL['ERROR'] : severity;
};

/**
 * A convenience method that returns the severity type when given either a severity level of type 
 * number or a severity type of string. 
 * If severity level is not provided or is not valid this return a severity error.
 * @param {string|number|undefined} level 
 * @return {string}
 * @export
 */
oj.Message.getSeverityType = function (level) 
{
  var index;
  if (level)
  {
    if (typeof level === "string")
    {
      index = oj.Message._LEVEL_TO_TYPE.indexOf(level, 1);
      if (index === -1)
      {
        // when given an unrecognized type return "error"
        level = oj.Message.SEVERITY_TYPE['ERROR'];
      }
    }
    else if (typeof level === "number")
    {
      if (level < oj.Message.SEVERITY_LEVEL['CONFIRMATION'] && 
          level > oj.Message.SEVERITY_LEVEL['FATAL'])
      {
        level = oj.Message.SEVERITY_TYPE['ERROR'];
      }
      else
      {
        level = oj.Message._LEVEL_TO_TYPE[level];
      }
    }
  }
  return level || oj.Message.SEVERITY_TYPE['ERROR'];
};

/**
 * A convenience method that returns the max severity level in a array of message objects.  
 * @param {Array} messages an array of message instances
 * @returns {number} -1 if none can be determined; otherwise a severity level as defined by 
 * oj.Message.SEVERITY_LEVEL.
 * @export
 */
oj.Message.getMaxSeverity = function (messages)
{
  var maxLevel = -1, currLevel, message, i;
  if (messages && messages.length > 0)
  {
    $.each(messages, function (i, message)
      {
        if (message)
        {
          currLevel = oj.Message.getSeverityLevel(message['severity']);
        }
        maxLevel = maxLevel < currLevel ? currLevel : maxLevel;
      });
    
  }
  
  return maxLevel;
};

/**
 * A convenience method to determine the validity of the messages.
 * @param {Array} messages an array of message instances
 * @returns {boolean} true if none of the messages are of severity error or greater. false otherwise
 * @export
 */
oj.Message.isValid = function (messages)
{
  var maxSeverity = oj.Message.getMaxSeverity(messages);
  if (maxSeverity >= oj.Message.SEVERITY_LEVEL.ERROR)
  {
    return false;
  }
  
  return true;
};

/**
 * @private
 * @type Array
 */
oj.Message._LEVEL_TO_TYPE = ['none', // this can never be set
                             oj.Message.SEVERITY_TYPE['CONFIRMATION'], 
                             oj.Message.SEVERITY_TYPE['INFO'],
                             oj.Message.SEVERITY_TYPE['WARNING'],
                             oj.Message.SEVERITY_TYPE['ERROR'],
                             oj.Message.SEVERITY_TYPE['FATAL']];

/*global OraNumberConverter:true*/
/**
 * @export
 * Placeholder here as closure compiler objects to export annotation outside of top level
 */

/**
 * @constructor
 * @classdesc Constructs an immutable instance and initializes it with the options provided. When initialized 
 * with no options, the default options for the current locale are assumed. The converters by 
 * default use the current page locale (returned by oj.Config.getLocale()). There are several ways 
 * to initialize the converter.
 * <p>
 * <ul>
 * <li>Using options defined by the ECMA 402 Specification, these would be the properties style, 
 * currency, currencyDisplay, minimumIntegerDigits, minimumFractionDigits, maximumFractionDigits, 
 * useGrouping</li>
 * <li>Using a custom decimal, currency or percent format pattern. specified using the 'pattern' property</li>
 * </ul>
 * <p>
 * 
 * The converter provides leniency when parsing user input value to a number in the following ways:<br/>
 * 
 * <ul>
 * <li>Prefix and suffix that do not match the pattern, are removed. E.g., when pattern is 
 * "#,##0.00%" (suffix is the % character), a value of "abc-123.45xyz", will be leniently parsed to 
 * -123.45</li>
 * <li>When a value includes a symbol but the pattern doesn't require it.  E.g., the options are 
 * {pattern: "###", currency: 'USD'}, then values ($123), (123) and -123 will be leniently parsed as 
 * -123.</li>
 * </ul>
 * <p>
 * @property {Object=} options - an object literal used to provide an optional information to 
 * initialize the converter.
 * @property {string=} options.style - sets the style of number formatting. Allowed values are "decimal" 
 * (the default), "currency" or "percent". When a number is formatted as a decimal, the decimal 
 * character is replaced with the most appropriate symbol for the locale. In English this is a 
 * decimal point ("."), while in many locales it is a decimal comma (","). If grouping is enabled the 
 * locale dependent grouping separator is also used. These symbols are also used for numbers 
 * formatted as currency or a percentage, where appropriate.
 * @property {string=} options.currency - specifies the currency that will be used when formatting the 
 * number. The value should be a ISO 4217 alphabetic currency code. If the style is set to currency, 
 * it's required that the currency property also be specified. This is because the currency used is 
 * not dependent on the locale. You may be using a Thai locale, but dealing in US Dollars, e.g.
 * @property {string=} options.currencyDisplay - if the number is using currency formatting, specifies 
 * if the currency will be displayed using its "code" (as an ISO 4217 alphabetic currency code), 
 * "symbol" (a localized currency symbol (e.g. $ for US dollars, £ for Great British pounds, and so 
 * on), or "name" (a localized currency name. So allowed values are "code", "symbol" and "name "
 * @property {number=} options.minimumIntegerDigits - sets the minimum number of digits before the 
 * decimal place (known as integer digits). The number is padded with leading zeros if it would not 
 * otherwise have enough digits. The value must be an integer between 1 and 21.
 * @property {number=} options.minimumFractionDigits - similar to 'minimumIntegerDigits', except it 
 * deals with the digits after the decimal place (fractional digits). It must be an integer between 
 * 0 and 20. The fractional digits will be padded with trailing zeros if they are less than the minimum.
 * @property {number=} options.maximumFractionDigits - follows the same rules as 'minimumFractionDigits', 
 * but sets the maximum number of fractional digits that are allowed. The value will be rounded if 
 * there are more digits than the maximum specified.
 * @property {boolean=} options.useGrouping - when the value is truthy, the locale dependent grouping 
 * separator is used when formatting the number. This is often known as the thousands separator, 
 * although it is up to the locale where it is placed. The ‘useGrouping’ is set to true by default.
 * @property {string=} options.pattern an optional localized pattern, where the characters used in 
 * pattern are as defined in the Unicode CLDR for numbers, percent or currency formats. When present 
 * this will override the other "options". <p>
 * 
 * &nbsp;&nbsp;- When the pattern represents a currency style the 'currency' property is required to 
 * be set, as not setting this will throw an error. The 'currencyDisplay' is optional. <br/>Example: 
 * {pattern: '¤#,##0', currency: 'USD'}. <p>
 * 
 * &nbsp;&nbsp;- It's not mandatory for the pattern to have the special character '¤' (currency sign) 
 * be present. When not present, values are treated as a currency value, but are not formatted to 
 * show the currency symbol. <br/>Example: {pattern: '#,##0', currency: 'USD'} <p>
 * 
 * &nbsp;&nbsp;- When the pattern represents a percent style, the percent special character ('%') needs to be 
 * explicitly specified in the pattern, e.g., {pattern: "#,##0%"}. If the pattern does not contain 
 * the percent character it's treated as a decimal pattern, unless the style is set to percent, 
 * in which case the value is treated as a percent value, but not formatted to show the percent symbol. 
 * <br/>Example: {style: 'percent', pattern: "#,##0"}. <p>
 * 
 * &nbsp;&nbsp;- A decimal pattern or exponent pattern is specified in the pattern using the CLDR 
 * conventions. <br/>Example: {pattern: "#,##0.00"} or {pattern: "0.##E+0"}. <p>
 * 
 * NOTE: 'pattern' is provided for backwards compatibility with existing apps that may want the 
 * convenience of specifying an explicit format mask. Setting a pattern will override the default 
 * locale specific format. <br/>
 * 
 * @example <caption>Create a number converter to parse/format currencies</caption>
 * var converterFactory = oj.Validation.converterFactory("number");
 * var options = {style: "currency", currency: "USD", minimumIntegerDigits: 2};
 * converter = converterFactory.createConverter(options);<br/>
 * 
 * @example <caption>A number converter for percent values using a custom (CLDR) pattern</caption>
 * var converterFactory = oj.Validation.converterFactory("number");
 * var options = {pattern: '#,##0%'};
 * converter = converterFactory.createConverter(options);<br/>
 * 
 * @example <caption>To parse a value as percent but format it without displaying the percent character</caption>
 * var options = {style: 'percent', pattern: '#,##0'};<br/>
 * 
 * @example <caption>To parse a value as currency using a custom (CLDR) pattern</caption>
 * var options = {pattern: '¤#,##0', currency: 'USD'};
 * 
 * @export
 * @augments oj.NumberConverter 
 * @name oj.IntlNumberConverter
 */
oj.IntlNumberConverter = function(options)
{
  this.Init(options);
};

oj.Object.createSubclass(oj.IntlNumberConverter, oj.NumberConverter, "oj.IntlNumberConverter");

/**
 * Initializes the number converter instance with the set options.
 * @param {Object=} options an object literal used to provide an optional information to 
 * initialize the converter.<p>
 * @export
 */
oj.IntlNumberConverter.prototype.Init = function(options) 
{
  oj.IntlNumberConverter.superclass.Init.call(this, options);
};


// Returns the wrapped number converter implementation object.
oj.IntlNumberConverter.prototype._getWrapped = function ()
{
  if (!this._wrapped)
  {
    this._wrapped = OraNumberConverter.getInstance();
  }
  
  return this._wrapped;
};

/**
 * Formats a Number and returns the formatted string, using the options this converter was 
 * initialized with.
 * 
 * @param {Number|number} value to be formatted for display
 * @return {string} the localized and formatted value suitable for display. When the value is 
 * formatted as a percent it's multiplied by 100.
 * 
 * @throws {Error} a ConverterError both when formatting fails, or if the options provided during 
 * initialization cannot be resolved correctly. 
 * 
 * @export
 */
oj.IntlNumberConverter.prototype.format = function (value) 
{
  // undefined, null and empty string values all return null. If value is NaN then return "".
  if (value == null || 
      (typeof value === "string" && (oj.StringUtils.trim("" + value)).length === 0) ||
      (typeof value === "number" && isNaN(value))) 
  {
    return oj.IntlConverterUtils.__getNullFormattedValue();
  }
  
  // TODO: Is this correct?
  var localeElements = oj.LocaleData.__getBundle(), locale = oj.Config.getLocale(), 
          resolvedOptions = this.resolvedOptions(), converterError;
  
  try
  {
    return this._getWrapped().format(value, localeElements, resolvedOptions, locale);
  }
  catch (e)
  {
    converterError = this._processConverterError(e, value);
    throw converterError;
  }
};

/**
 * Retrieves a hint String describing the format the value is expected to be in.
 * 
 * @return {String} a hint describing the format the value is expected to be in.
 * @export
 */
oj.IntlNumberConverter.prototype.getHint = function ()
{
  // UX does not want any hint for numbers. 
  // return oj.Translations.getTranslatedString("oj-converter.hint.summary",
  //        {'exampleValue': this._getHintValue()}); 
  return oj.IntlNumberConverter.superclass.getHint.call(this);
};

/**
 * Returns the options called with converter initialization.
 * @return {Object} an object of options.
 * @export
 */
oj.IntlNumberConverter.prototype.getOptions = function () 
{
  return oj.IntlNumberConverter.superclass.getOptions.call(this);
};

/**
 * Parses a string value to return a Number, using the options this converter was initialized with. 
 * 
 * @param {String|string} value to parse
 * @return {number|null} the parsed number or null if the value was null or an empty string. When 
 * the value is parsed as a percent its 1/100th part is returned.
 * 
 * @throws {Error} a ConverterError both when parsing fails, or if the options provided during 
 * initialization cannot be resolved correctly. 
 *  
 * @export
 */
oj.IntlNumberConverter.prototype.parse = function (value) 
{
  var localeElements = oj.LocaleData.__getBundle(), locale = oj.Config.getLocale(), 
          resolvedOptions = this.resolvedOptions(), converterError;

  // null and empty string values are ignored and not parsed. It
  // undefined.
  if (value == null || value === "") // check for undefined, null and ""
  {
    return null;
  }
  
  try
  {
    // we want to trim the value for leading spaces before and after
    return this._getWrapped().parse(oj.StringUtils.trim(value), 
                                    localeElements, 
                                    resolvedOptions, 
                                    locale);
  }
  catch (e)
  {
    converterError = this._processConverterError(e, value);
    throw converterError;
  }
  
};

/**
 * Returns an object literal with properties reflecting the number formatting options computed based 
 * on the options parameter. If options (or pattern) is not provided, the properties will be derived 
 * from the locale defaults.
 * 
 * @return {Object} An object literal containing the resolved values for the following options. Some 
 * of these properties may not be present, indicating that the corresponding components will not be 
 * represented in the formatted output.
 * <ul>
 * <li><b>locale</b>: a String value with the language tag of the locale whose localization is used 
 * for formatting.</li>
 * <li><b>style</b>: a String value. One of the allowed values - "decimal", "currency" or "percent".</li>
 * <li><b>currency</b>: a String value.  an ISO 4217 alphabetic currency code. May be present only 
 *  when style is currency.</li>
 * <li><b>currencyDisplay</b>: a String value. One of the allowed values - "code", "symbol", or 
 *  "name".</li>
 * <li><b>numberingSystem</b>: a String value of the numbering system used. E.g. latn</li>
 * <li><b>minimumIntegerDigits</b>: a non-negative integer Number value indicating the minimum 
 *  integer digits to be used.</li>
 * <li><b>minimumFractionDigits</b>: a non-negative integer Number value indicating the minimum 
 *  fraction digits to be used.</li>
 * <li><b>maximumFractionDigits</b>: a non-negative integer Number value indicating the maximum 
 *  fraction digits to be used.</li>
 * <li><b>useGrouping</b>: a Boolean value indicating whether a grouping separator is used.</li>
 * 
 * @throws a oj.ConverterError when the options that the converter was initialized with are invalid. 
 * @export
 */
oj.IntlNumberConverter.prototype.resolvedOptions = function()
{
  var localeElements, locale = oj.Config.getLocale(), converterError;
  // options are resolved and cached for the current locale. when locale changes resolvedOptions 
  // is reevaluated as it contains locale specific info.
  if ((locale !== this._locale) || !this._resolvedOptions)
  {
    localeElements = oj.LocaleData.__getBundle();
    try
    {
      // cache if successfully resolved
      this._resolvedOptions = this._getWrapped().resolvedOptions(localeElements, 
                                                                 this.getOptions(), 
                                                                 locale);
      this._locale = locale;
    }
    catch (e)
    {
      converterError = this._processConverterError(e);
      throw converterError;
    }
  }
  
  return this._resolvedOptions;
};

/**
 * Processes the error returned by the converter implementation and throws a oj.ConverterError 
 * instance.
 * 
 * @param {Error} e
 * @param {String|string|Number|number|Object=} value
 * @throws an instance of oj.ConverterError
 * @private
 */
oj.IntlNumberConverter.prototype._processConverterError = function (e, value)
{
  var errorInfo = e['errorInfo'], summary, detail, errorCode, parameterMap, converterError, 
          propName, resourceKey;
  if (errorInfo)
  {
    errorCode = errorInfo['errorCode'];
    parameterMap = errorInfo['parameterMap'];
    oj.Assert.assertObject(parameterMap);
    propName = parameterMap['propertyName'];
    
    if (e instanceof TypeError)
    {
      if (errorCode === "optionTypesMismatch" || errorCode === "optionTypeInvalid")
      {
        converterError = oj.IntlConverterUtils.__getConverterOptionError(errorCode, parameterMap);
      }
    }
    else if (e instanceof RangeError)
    {
      if (errorCode === "optionOutOfRange")
      {
        converterError = oj.IntlConverterUtils.__getConverterOptionError(errorCode, parameterMap);
      }
    }
    else if (e instanceof SyntaxError)
    {
      if (errorCode === "optionValueInvalid")
      {
        converterError = oj.IntlConverterUtils.__getConverterOptionError(errorCode, parameterMap);
      }
    }
    else if (e instanceof Error)
    {
      if (errorCode === "decimalFormatMismatch")
      {
        // The '{value}' does not match the expected decimal format '{format}'.
        resourceKey = "oj-converter.number.decimalFormatMismatch.summary";
      }
      else if (errorCode === "currencyFormatMismatch")
      {
        // The {value} does not match the expected currency format {format}.
        resourceKey = "oj-converter.number.currencyFormatMismatch.summary";
      }
      else if (errorCode === "percentFormatMismatch")
      {
        resourceKey = "oj-converter.number.percentFormatMismatch.summary";
      }
      
      if (resourceKey)
      {
        summary = oj.Translations.getTranslatedString(resourceKey, 
          {'value': value || parameterMap['value'],
           'format': parameterMap['format']});
        
        detail = oj.Translations.getTranslatedString("oj-converter.hint.detail",
          {'exampleValue': this._getHintValue()}); 
          
        converterError = new oj.ConverterError(summary, detail);
      }
    }
  }
  
  if (!converterError)
  {
    // An error we are unfamiliar with. Get the message and set as detail
    summary = e.message; // TODO: What should the summary be when it's missing??
    detail = e.message;
    converterError = new oj.ConverterError(summary, detail);
  }
  
  return converterError;
};

// Returns the hint value.
oj.IntlNumberConverter.prototype._getHintValue = function()
{
  var value = "";
  try
  {
    value =  this.format(12345.98765);
  }
  catch (e)
  {
    if (e instanceof oj.ConverterError)
    {
      // Something went wrong and we don't have a way to retrieve a valid value.
      // TODO: Log an error
      value = "";
    }
  }
  finally
  {
    return value;
  }
};

/*
 * Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.
 */
/**
 * Constructs a DateRestrictionValidator that ensures the value provided is not in a disabled entry of dayMetaData
 * @param {Object=} options an object literal used to provide:<p>
 * <ul>
 *   <li> 'dayMetaData': Additional info to be used when rendering the day 
 *                       This should be in the following JSON format with the year, month, day based on Date.getFullYear(), Date.getMonth(), and Date.getDate():
 *                       {year: {month: {day: {disabled: true|false, className: "additionalCSS", tooltip: 'Stuff to display'}}}<p>
 *   <li> 'message': an optional object literal of custom error message to be used:<p>
 *       <ul>
 *                <li> messageDayMetaData: The detail error message to be used for constructing faces messages, if input value is in disabled entry of dayMetaData.<p>
 *                     Parameters:<p>
 *                     <ul>
 *                       <li> {0} value entered by the user<p>
 *                     </ul>
 *                     Usage: Entered {0} which is a disabled entry of dayMetaData.<p>
 *        </ul>
 * </ul>
 * @export
 * @constructor
 */
oj.DateRestrictionValidator = function _DateRestrictionValidator(options)
{
  this.Init(options);
};

// Subclass from oj.Object 
oj.Object.createSubclass(oj.DateRestrictionValidator, oj.Validator, "oj.DateRestrictionValidator");

/**
 * Initializes validator instance with the set options
 * @param {Object=} options
 * @export
 */
oj.DateRestrictionValidator.prototype.Init = function (options)
{
  oj.DateRestrictionValidator.superclass.Init.call(this);
  this._dayMetaData = options["dayMetaData"];
  if (options)
  {
    this._customMessage = options['message'] || {};
  }
};

/**
 * Validates whether the date provided is part of disabled date within dayMetaData
 *
 * @param {Object} value that is being validated
 * @returns {boolean} boolean of whether it is in disabled meta data
 * 
 * @export
 */
oj.DateRestrictionValidator.prototype._inDisabledMetaData = function(value) 
{
  var dayMetaData = this._dayMetaData,
      disabledInMetaData = function getMetaData(dayMetaData, position, params) {
        if(!dayMetaData || position === params.length) {
          return dayMetaData;
        }
        
        var nextPos = position + 1;
        return getMetaData(dayMetaData[params[position]], nextPos, params) || getMetaData(dayMetaData["*"], nextPos, params);
      };
  
  if(dayMetaData) {
    var fullYear = value.getFullYear(),
        month = value.getMonth() + 1, //request to start from 1 rather than 0
        date = value.getDate(),
        metaData = disabledInMetaData(dayMetaData, 0, [fullYear, month, date]);
    
    return metaData && metaData.disabled;
  }
  
  return false;
};

/**
 * Validates whether the date provided is part of disabled date within dayMetaData
 *
 * @param {Object} value that is being validated
 * @returns {Object} original if validation was successful
 *
 * @throws {Error} when there is no match
 * @export
 */
oj.DateRestrictionValidator.prototype.validate = function (value)
{
  var messageDayMetaData,
      summary = "", 
      detail = "", 
      translations = oj.Translations, 
      customMessage = this._customMessage;
  
  if(this._inDisabledMetaData(value)) {
    
    messageDayMetaData = customMessage["messageDayMetaData"];
    summary = translations.getTranslatedString('oj-validator.restriction.date.dayMetaData.summary');
    detail = messageDayMetaData ? translations.applyParameters(messageDayMetaData, {"value": value}) : 
                translations.getTranslatedString('oj-validator.restriction.date.dayMetaData.detail', {"value": value});
    throw new oj.ValidatorError(summary, detail);
  }
  
  return value;
};

/*
 * Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.
 */

/**
 * Constructs a RegExpValidator that ensures the value matches the provided pattern
 * @param {Object} options an object literal used to provide the pattern, an optional hint and error 
 * message.<p>
 * <ul>
 * <li><b>pattern</b>: a regexp pattern that the validator matches a value against. <p>
 * Example:<p>
 * '\\d{10}'</li>
 * <li><b>hint</b>: an optional hint text. There is no default hint provided by the validator. <p>
 * Parameters: <p>
 * {pattern} - the pattern to enforce<p>
 * Example:<p>
 * "value must meet this pattern {pattern}" </li>
 * <li>
 * <b>messageSummary</b>: a custom error message summarizing the error <p>
 * Parameters: <p>
 * {label} - label of the component for which this message applies. The label may not always be 
 * available depending on the usage of the validator. <p>
 * {pattern} - the pattern the value should match<p>
 * {value} - value entered by user<p>
 * Examples:<p>
 * "'{label}' Format Incorrect" // translating to 'Phone Number' Format Incorrect
 * </li>
 * <li><b>messageDetail</b>: a custom error message to be used for creating detail part of message, when 
 * the users input does not match the specified pattern. <p>
 * Parameters:<p>
 * {label} - label text of the component for which this message applies. 
 * {pattern} the 'pattern' that the value should match <p>
 * {value} value entered by the user<p>
 * Examples:<p>
 * "The value {value} must contain at least 3 alphanumeric characters"<br/>
 * </li>
 * </ul>
 * @export
 * @constructor
 */
oj.RegExpValidator = function(options) 
{
  this.Init(options);
};

// Subclass from oj.Object or oj.Validator. It does not matter
oj.Object.createSubclass(oj.RegExpValidator, oj.Validator, "oj.RegExpValidator");

// key to access required validator specific resources in the bundle 
oj.RegExpValidator._BUNDLE_KEY_DETAIL = "oj-validator.regExp.detail";
oj.RegExpValidator._BUNDLE_KEY_SUMMARY = "oj-validator.regExp.summary";

/**
 * Initializes validator instance with the set options
 * @param {Object} options
 * @export
 */
oj.RegExpValidator.prototype.Init = function(options) 
{
  oj.RegExpValidator.superclass.Init.call(this);
  this._options = options;
};

/**
 * Validates value for matches using the regular expression provided by the pattern. 
 * 
 * @param {string|number} value that is being validated 
 * @returns {boolean} true if validation was successful 
 * 
 * @throws {Error} when there is no match
 * @export
 */

oj.RegExpValidator.prototype.validate = function(value)
{
  var pattern = (this._options && this._options['pattern']) || "", label, summary, detail, params;
  //For some reason when using digits as input values
  // parseString becomes a integer type, so get away with it.
  value = value ? value.toString() : value;
  
  // We intend that the pattern provided is matched exactly
  var exactPattern = "^(" + pattern + ")$", valid = false, 
          localizedDetail, localizedSummary, matchArr;
  
  matchArr = value.match(exactPattern);
  if ((matchArr !== null) && (matchArr[0] === value))
  {
    valid = true;
  }
  else
  {
    if (this._options)
    {
      summary = this._options['messageSummary'] || null;
      detail = this._options['messageDetail'] || null;
      label = this._options && this._options['label'] || "";
    }
    
    params = {'label': label, 'pattern': pattern, 'value': value};
    localizedSummary = summary ? 
      oj.Translations.applyParameters(summary, params) : 
      oj.Translations.getTranslatedString(this._getSummaryKey(), params);
    localizedDetail = (detail) ? 
      oj.Translations.applyParameters(detail, params) : 
      oj.Translations.getTranslatedString(this._getDetailKey(), params);
    
    throw new oj.ValidatorError(localizedSummary, localizedDetail);
  }
  
  return valid;
};

/**
 * A message to be used as hint, when giving a hint on the expected pattern. There is no default 
 * hint for this property.
 * 
 * @returns {String|null} a hint message or null if no hint is available in the options
 * @export
 */
oj.RegExpValidator.prototype.getHint = function()
{
  var hint = null;
  if (this._options && (this._options['hint']))
  {
    hint = oj.Translations.applyParameters(this._options['hint'], this._options['pattern']);
  }
  
  return hint;
};

oj.RegExpValidator.prototype._getSummaryKey = function ()
{
  return oj.RegExpValidator._BUNDLE_KEY_SUMMARY;
};

oj.RegExpValidator.prototype._getDetailKey = function ()
{
  return oj.RegExpValidator._BUNDLE_KEY_DETAIL;
};
/*global OraDateTimeConverter:true*/
/**
 * @export
 * Placeholder here as closure compiler objects to export annotation outside of top level
 */

/**
 * @constructor
 * 
 * @classdesc Constructs an immutable instance and initializes it with the options provided. There are 
 * several ways to initialize the converter. The converters by default uses the locale symbols for 
 * the current page locale (returned by {@link oj.Config#getLocale}.
 * <ul>
 * <li>Using options defined by the ECMA 402 Specification, these would be the properties year, 
 * month, day, hour, minute, second, weekday, era, timeZoneName, hour12</li>
 * <li>Using a custom date and/or time format pattern using the 'pattern' property</li>
 * <li>Using the standard date, datetime and time format lengths defined by Unicode CLDR, these 
 * would include the properties formaType, dateFormat, timeFormat.</li>
 * </ul>
 * 
 * <p>
 * The options when specified take precendence in the following order:<br>
 * 1. pattern.<br>
 * 2. ECMA options.<br>
 * 3. formatType/dateFormat/timeFormat.
 * <p>
 * The converter provides great leniency when parsing a user input value to a date in the following 
 * ways: <br/>
 * <ul>
 * <li>Allows use of any character for separators irrespective of the separator specified in the 
 * associated pattern. E.g., if pattern is set to 'y-M-d', the following values are all valid - 
 * 2013-11-16, 2013/11-16 and 2013aaa11xxx16.</li>
 * <li>Allows specifying 4 digit year in any position in relation to day and month. E.g., 11-2013-16 
 * or 16-11-2013</li>
 * <li>Supports auto-correction of value, when month and day positions are swapped as long as the 
 * date is > 12 when working with the Gregorian calendar. E.g., if the pattern is 'y-M-d', 
 * 2013-16-11 will be auto-corrected to 2013-11-16. However if both date and month are less or equal 
 * to 12, no assumptions are made about the day or month and the value parsed against the exact pattern.</li>
 * <li>Supports auto-correction of value, for the short and long types of weekday and month names. 
 * So they can are used anywhere in the value. E.g., if the expected pattern is E, MMM, d, y, all 
 * these values are acceptable - Tue, Nov 26 2013 or Nov, Tue 2013 26 or 2013 Tue 26 Nov. <br/>
 * NOTE: Lenient parsing of narrow era, weekday or month name is not supported because of ambiguity in 
 * choosing the right value. So we expect for narrow era, weekday or month option that values be 
 * provided either in their short or long forms. E.g., Sat, March 02, 2013.
 * </li>
 * <li>Specifying the weekday is optional. E.g., if the expected pattern is E, MMM, d, y; then 
 * entering Nov 26, 2013, is automatically turned to Tuesday Nov 26, 2013. But entering an invalid 
 * weekday, i.e., if the weekday does not match the date, an exception is thrown.</li>
 * <li>Leniency rules apply equally no matter which option is used - pattern, ECMA options or formatType</li>
 * </ul>
 * 
 * @property {Object=} options - an object literal used to provide an optional information to 
 * initialize the converter.<p>
 * @property {string=} options.year - allowed values are "2-digit", "numeric". When no options are 
 * set the default value of "numeric" is used.
 * @property {string=} options.month - specifies how the month is formatted. Allowed values are 
 * "2-digit", "numeric", "narrow", "short", "long". The last 3 values behave in the same way as for 
 * weekday, indicating the length of the string used. When no options are set the default value of 
 * "numeric" is used.
 * @property {string=} options.day - specifies how the day is formatted. Allowed values are "2-digit",
 *  "numeric". When no options are set the default value of "numeric" is used.
 * @property {string=} options.hour - specifies how the hour is formatted. Allowed values are 
 * "2-digit" or "numeric". The hour is displayed using the 12 or 24 hour clock, depending on the 
 * locale. See 'hour12' for details.
 * @property {string=} options.minute - specifies how the minute is formatted. Allowed values are 
 * "2-digit", "numeric".
 * @property {string=} options.second - specifies whether the second should be displayed as "2-digit" 
 * or "numeric".
 * @property {string=} options.weekday - specifies how the day of the week is formatted. If absent, it 
 * is not included in the date formatting. Allowed values are "narrow", "short", "long" indicating the 
 * length of the string used.
 * @property {string=} options.era - specifies how the era is included in the formatted date. If 
 * absent, it is not included in the date formatting. Allowed values are "narrow", "short", "long".
 * @property {string=} options.timeZoneName - allowed values are "short", "long".
 * @property {boolean=} options.hour12 - specifies what time notation is used for formatting the time. 
 * A true value uses the 12-hour clock and false uses the 24-hour clock (often called military time 
 * in the US). This property is undefined if the hour property is not used when formatting the date.
 * 
 * @property {string=} options.pattern - a localized string pattern, where the the characters used in 
 * pattern conform to Unicode CLDR for date time formats. This will override all other options 
 * when present. <br/>
 * NOTE: 'pattern' is provided for backwards compatibility with existing apps that may want the 
 * convenience of specifying an explicit format mask. Setting a 'pattern' will override the default 
 * locale specific format.
 * 
 * @property {string=} options.formatType - determines the 'standard' date and/or time format lengths 
 * to use. Allowed values: "date", "time", "datetime". See 'dateFormat' and 'timeFormat' options. 
 * When set a value must be specified.
 * @property {string=} options.dateFormat - specifies the standard date format length to use when 
 * formatType is set to "date" or "datetime". Allowed values are : "short" (default), "medium", "long", 
 * "full". 
 * @property {string=} options.timeFormat - specifies the standard time format length to use when 
 * 'formatType' is set to "time" or "datetime". Allowed values: "short" (default), "medium", "long", 
 * "full". 
 * 
 * @example <caption>Create a date time converter using no options. This uses the default value for 
 * year, month, day properties</caption>
 * var converterFactory = oj.Validation.converterFactory("datetime");
 * converter = converterFactory.createConverter();
 * var resolved = converter.resolvedOpions();
 * // logs "day=numeric, month=numeric, year=numeric"
 * window.console.log("day=" + resolved.day + ", month=" + resolved.month + ", year=" + resolved.year);
 * <br/>
 * 
 * @example <caption>Create a date time converter using the ECMA options to represent date</caption>
 * var options = { year:'2-digit', month: '2-digit', day: '2-digit'};
 * var converterFactory = oj.Validation.converterFactory("datetime");
 * converter = converterFactory.createConverter(options);<br/>
 * 
 * @example <caption>Create a date time converter using the 'pattern' option</caption>
 * var options = {pattern: 'MM-dd-yyyy'}; 
 * var converterFactory = oj.Validation.converterFactory("datetime");
 * converter = converterFactory.createConverter(options);<br/>
 * 
 * @example <caption>Create a date time converter using the standard format length</caption>
 * var options = {formatType: 'date', dateFormat: 'medium'}; 
 * var converterFactory = oj.Validation.converterFactory("datetime");
 * converter = converterFactory.createConverter(options);<br/>
 * 
 * @export
 * @augments oj.DateTimeConverter 
 * @name oj.IntlDateTimeConverter
 */
oj.IntlDateTimeConverter = function(options)
{
  this.Init(options);
};

// Subclass from oj.Object 
oj.Object.createSubclass(oj.IntlDateTimeConverter, oj.DateTimeConverter, "oj.IntlDateTimeConverter");
oj.IntlDateTimeConverter._DEFAULT_DATE = new Date(1998, 10, 29, 15, 45, 31);

/**
 * Initializes the date time converter instance with the set options.
 * @param {Object=} options an object literal used to provide an optional information to initialize 
 * the converter.<p>
 * 
 * @export
 */
oj.IntlDateTimeConverter.prototype.Init = function(options) 
{
  oj.IntlDateTimeConverter.superclass.Init.call(this, options);
};


// Returns the wrapped date time converter implementation object.
oj.IntlDateTimeConverter.prototype._getWrapped = function ()
{
  if (!this._wrapped)
  {
    this._wrapped = OraDateTimeConverter.getInstance();
  }
  
  return this._wrapped;
};

/**
 * Formats the Date value using the resolved options and returns a String value.
 * 
 * @param {Date} value to be formatted for display
 * @return {string} the localized and formatted value suitable for display
 * 
 * @throws {Error} a ConverterError both when formatting fails, and if the options provided during 
 * initialization cannot be resolved correctly. 
 * @export
 */
oj.IntlDateTimeConverter.prototype.format = function (value) 
{
  var localeElements = oj.LocaleData.__getBundle(), locale = oj.Config.getLocale(), 
          resolvedOptions = this.resolvedOptions(), converterError;
  
  // undefined, null and empty string values all return null. If value is NaN then return "".
  // TODO: Should we automatically parse() the integer value representing the number of milliseconds 
  // since 1 January 1970 00:00:00 UTC (Unix Epoch)?
  if (value == null || 
      (typeof value === "string" && (oj.StringUtils.trim("" + value)).length === 0)) 
  {
    return oj.IntlConverterUtils.__getNullFormattedValue();
  }
  
  try
  {
    return this._getWrapped().format(value, localeElements, resolvedOptions, locale);
  }
  catch (e)
  {
    converterError = this._processConverterError(e, value);
    throw converterError;
  }
};


/**
 * Formats a Date object as a relative date, using the relativeOptions. 
 * @param {Date} value - Date object to be formatted. This value is compared with the current date 
 * on the client to arrive at the relative formatted value.
 * @param {Object} relativeOptions - an Object literal containing the following properties. The 
 * default options are ignored during relative formatting - <br>
 * <ul>
 * <li><b>formatUsing</b>: Specifies the relative formatting convention to use for (calendar or) 
 * the date field type. allowed values: "displayName". <br>Setting value to 'displayName' uses the 
 * relative display name for the instance of the dateField, and one or two past and future instances.
 * </li>
 * <li><b>dateField</b>: allowed values are: "day", "week", "month", "year"</li>
 * </ul>
 * @return {string|null} relative date. null if the value falls out side the supported relative range.
 * @throws {Object} an instance of {@link oj.ConverterError}
 * @memberOf oj.IntlDateTimeConverter
 * @export
 */
oj.IntlDateTimeConverter.prototype.formatRelative = function(value, relativeOptions) 
{
  var localeElements = oj.LocaleData.__getBundle(), locale = oj.Config.getLocale(), converterError;
  try
  {
    return this._getWrapped().formatRelative(value, localeElements, relativeOptions, locale);
  }
  catch (e)
  {
    converterError = this._processConverterError(e, value);
    throw converterError;
  }
};

/**
 * Retrieves a hint String describing the format the value is expected to be in.
 * 
 * @return {String} a hint describing the format the value is expected to be in.
 * @export
 */
oj.IntlDateTimeConverter.prototype.getHint = function ()
{
  var resolvedOptions = this.resolvedOptions(), patternFromOptions = 
          resolvedOptions["patternFromOptions"];;
  
  // TODO: converter hints are often shown in placeholder and is a user-friendly readable pattern. 
  // Until this feature is implemented use the CLDR pattern
  return patternFromOptions ? patternFromOptions : "";
};

// Returns the hint value.
oj.IntlDateTimeConverter.prototype._getHintValue = function()
{
  var value = "";
  try
  {
    // example date 
    value =  this.format(oj.IntlDateTimeConverter._DEFAULT_DATE);
  }
  catch (e)
  {
    if (e instanceof oj.ConverterError)
    {
      // Something went wrong and we don't have a way to retrieve a valid value.
      // TODO: Log an error
      value = "";
    }
  }
  finally
  {
    return value;
  }
};


/**
 * Returns the options called with converter initialization.
 * @return {Object} an object of options.
 * @export
 */
oj.IntlDateTimeConverter.prototype.getOptions = function () 
{
  return oj.IntlDateTimeConverter.superclass.getOptions.call(this);
};

/**
 * Returns an object literal with locale and formatting options computed during initialization of 
 * the object. If options was not provided at the time of initialization, the properties will be 
 * derived from the locale defaults.
 * @return {Object} an object of resolved options. Properties whose corresponding internal 
 * properties are not present are not assigned. More properties may be included as needed.
 * <ul>
 * <li><b>locale</b> - a String value with the language tag of the locale whose localization is used 
 * for formatting.</li>
 * <li><b>numberingSystem</b>: a String value of the numbering system used. E.g. latn</li>
 * <li><b>era</b>: a String value. One of allowed values - "narrow", "short", "long"</li>
 * <li><b>year</b>: a String value. One of allowed values - "2-digit", "numeric"</li>
 * <li><b>month</b>: a String value. One of allowed values - "2-digit", "numeric", "narrow", "short"
 * , "long"</li>
 * <li><b>weekday</b>: a String value. One of the allowed values - "narrow", "short", "long"</li>
 * <li><b>day</b>: a String value. One of allowed values - "2-digit", "numeric"</li>
 * <li><b>hour</b>: String value. One of allowed values - "2-digit", "numeric"</li>
 * <li><b>minute</b>: a String value. One of allowed values - "2-digit", "numeric"</li>
 * <li><b>second</b>: a String value. One of allowed values - "2-digit", "numeric"</li>
 * <li><b>hour12</b>: a Boolean value indicating whether 12-hour format (true) or 24-hour format 
 * (false) should be used. It is only relevant when hour is also present.</li>
 * <li><b>timeZoneName</b>: String value. One of allowed values - "short", "long".</li>
 * </ul>
 * 
 * @throws a oj.ConverterError when the options that the converter was initialized with are invalid. 
 * @export
 */
oj.IntlDateTimeConverter.prototype.resolvedOptions = function ()
{
  var localeElements, locale = oj.Config.getLocale(), converterError, options = this.getOptions();
  // options are resolved and cached for a locale
  if ((locale !== this._locale) || !this._resolvedOptions)
  {
    localeElements = oj.LocaleData.__getBundle();
    try
    {
      // cache if successfully resolved
      this._resolvedOptions = this._getWrapped().resolvedOptions(localeElements, 
                                                                 options, 
                                                                 locale);
      this._locale = locale;
    }
    catch (e)
    {
      converterError = this._processConverterError(e);
      throw converterError;
    }
  }
  
  return this._resolvedOptions;
};

/**
 * Returns true if a 24-hour format is set; false otherwise.
 * @export
 */
oj.IntlDateTimeConverter.prototype.isHourInDaySet = function()
{
  var ro = this.resolvedOptions(), hour = ro['hour'], hour12 = ro['hour12'];
  if (hour && !hour12)
  {
    // if hour12=false or not set and hour is set to some value
    return true;
  }
  
  return false;
};

/**
 * Returns true if 12-hour is set; false otherwise.
 * @export
 */
oj.IntlDateTimeConverter.prototype.isHourInAMPMSet = function()
{
  var ro = this.resolvedOptions(), hour = ro['hour'], hour12 = ro['hour12'];  
  if (hour && hour12)
  {
    // if hour12==true and hour is set to some value
    return true;
  }
  
  return false;
  
};

/**
 * Returns true if minutes are shown in the time portion; false otherwise.
 * @export
 */
oj.IntlDateTimeConverter.prototype.isMinuteSet = function()
{
  return this._isOptionSet('minute');
};

/**
 * Returns true if seconds are shown in the time portion; false otherwise.
 * @export
 */
oj.IntlDateTimeConverter.prototype.isSecondSet = function()
{
  return this._isOptionSet('second');
};

/**
 * Returns true if milliseconds are shown in the time portion; false otherwise.
 * @export
 */
oj.IntlDateTimeConverter.prototype.isMilliSecondSet = function()
{
  return this._isOptionSet('millisecond');
};

/**
 * Returns true if year is shown in the date portion; false otherwise.
 * @export
 */
oj.IntlDateTimeConverter.prototype.isYearSet = function()
{
  return this._isOptionSet('year');
};

/**
 * Returns true if month is shown in the date portion; false otherwise.
 * @export
 */
oj.IntlDateTimeConverter.prototype.isMonthSet = function()
{
  return this._isOptionSet('month');
};

/**
 * Returns true if day is shown in the date portion; false otherwise.
 * @export
 */
oj.IntlDateTimeConverter.prototype.isDaySet = function()
{
  return this._isOptionSet('day');
};

/**
 * Returns true if the day name is shown in the date portion; false otherwise.
 * @export
 */
oj.IntlDateTimeConverter.prototype.isDayNameSet = function()
{
  return this._isOptionSet('weekday');
};

/**
 * Parses the value using the resolved options provided and returns a Date value.
 * 
 * @param {String|string} value to parse
 * @return {Date} the parsed value as a Date object.
 * 
 * @throws {Error} a ConverterError both when parsing fails, and if the options provided during 
 * initialization cannot be resolved correctly. 
 *  
 * @export
 */
oj.IntlDateTimeConverter.prototype.parse = function (value) 
{
  var result, parsed;
  // undefined, null and empty string values are ignored and not parsed. 
  if (value == null || value === "") 
  {
    return null;
  }
  
  var localeElements = oj.LocaleData.__getBundle(), locale = oj.Config.getLocale(), 
          resolvedOptions = this.resolvedOptions(), converterError;

  try
  {
    // date converter parses the value and returns an Object with 2 fields - 'value' and 'warning'
    result = this._getWrapped().parse(value, localeElements, resolvedOptions, locale); 
    parsed = result['value'];
    if (typeof result === "object" && parsed)
    {
      // TODO: For now log a warning when we leniently parse a value; later we plan to flash the 
      // field.
      if (result['warning'])
      {
        oj.Logger.warn("The value " + value + " was leniently parsed to represent a date " + 
                (parsed.toString) ? parsed.toString() : parsed);
      }
      
    }
    return parsed;
  }
  catch (e)
  {
    converterError = this._processConverterError(e, value);
    throw converterError;
  }
};

/**
 * Processes the error returned by the converter implementation and throws a oj.ConverterError 
 * instance.
 * @param {Error} e
 * @param {String|string|Date|Object=} value 
 * @throws an instance of oj.ConverterError
 * @private
 */
oj.IntlDateTimeConverter.prototype._processConverterError = function (e, value)
{
  var errorInfo = e['errorInfo'], summary, detail, errorCode, parameterMap, converterError, 
          propName, resourceKey;
  if (errorInfo)
  {
    errorCode = errorInfo['errorCode'];
    parameterMap = errorInfo['parameterMap'];
    oj.Assert.assertObject(parameterMap);
    propName = parameterMap['propertyName'];
    
    if (e instanceof TypeError)
    {
      if (errorCode === "optionTypesMismatch" || errorCode === "optionTypeInvalid")
      {
        converterError = oj.IntlConverterUtils.__getConverterOptionError(errorCode, parameterMap);
      }
    }
    else if (e instanceof RangeError)
    {
      if (errorCode === "optionOutOfRange")
      {
        converterError = oj.IntlConverterUtils.__getConverterOptionError(errorCode, parameterMap);
      }
      else if (errorCode === 'datetimeOutOfRange') // TODO: NLS should use lower case time
      {
        // The '{value}' is out of range. Enter a value between '{minValue}' and '{maxValue}' for 
        // '{propertyName}'.
        summary = oj.Translations.getTranslatedString("oj-converter.datetime.datetimeOutOfRange.summary", 
          {'propertyName': propName,
           'value': parameterMap['value']});
        detail = oj.Translations.getTranslatedString("oj-converter.datetime.datetimeOutOfRange.detail",
          {'minValue': parameterMap['minValue'],
           'maxValue': parameterMap['maxValue']});
         
        converterError = new oj.ConverterError(summary, detail);
      }
    }
    else if (e instanceof SyntaxError)
    {
      if (errorCode === "optionValueInvalid")
      {
        converterError = oj.IntlConverterUtils.__getConverterOptionError(errorCode, parameterMap);
      }
    }
    else if (e instanceof Error)
    {
      if (errorCode === "dateFormatMismatch")
      {
        // The '{value}' does not match the expected date format '{format}'.
        resourceKey = "oj-converter.datetime.dateFormatMismatch.summary";
      }
      else if (errorCode === "timeFormatMismatch")
      {
        // The {value} does not match the expected time format {format}.
        resourceKey = "oj-converter.datetime.timeFormatMismatch.summary";
      }
      else if (errorCode === "datetimeFormatMismatch")
      {
        resourceKey = "oj-converter.datetime.datetimeFormatMismatch.summary";
      }
      else if (errorCode === "dateToWeekdayMismatch")
      {
        summary = oj.Translations.getTranslatedString("oj-converter.datetime.dateToWeekdayMismatch.summary", 
          {'date': parameterMap['date'], 'weekday': parameterMap['weekday']});
        detail = oj.Translations.getTranslatedString("oj-converter.datetime.dateToWeekdayMismatch.detail");
        converterError = new oj.ConverterError(summary, detail);
      }
      
      if (resourceKey)
      {
        summary = oj.Translations.getTranslatedString(resourceKey, 
          {'value': value || parameterMap['value'],
           'format': parameterMap['format']});
        
        detail = oj.Translations.getTranslatedString("oj-converter.hint.detail",
          {'exampleValue': this._getHintValue()}); 
          
        converterError = new oj.ConverterError(summary, detail);
      }
    }
  }
  
  if (!converterError)
  {
    // An error we are unfamiliar with. Get the message and set as detail
    summary = e.message; // TODO: What should the summary be when it's missing??
    detail = e.message;
    converterError = new oj.ConverterError(summary, detail);
  }
  
  return converterError;
};

/**
 * Checks to see if an option is present in the resolved options.
 * @param {string} optionName
 * @returns {boolean} true if optionName is present.
 * @private
 */
oj.IntlDateTimeConverter.prototype._isOptionSet = function (optionName)
{
  var ro = this.resolvedOptions(), hasOption = ro[optionName] ? true : false;
  return hasOption;
};

/*
 * Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.
 */
/**
 * Constructs a DateTimeRangeValidator that ensures the value provided is within a given range
 * @param {Object=} options an object literal used to provide:<p>
 * <ul>
 *   <li><b>min</b>: The minimum datetime value of the entered value.<p>
 *   <li><b>max</b>: The maximum datetime value of the entered value.<p>
 *   <li><b>hint</b>: an optional object literal of hint text to be used. There is no default hint 
 *   provided by this validator.<p>
 *    <ul>     
 *      <li>'hintMaximum': Hint message to be used, to give a hint about the allowed maximum.<p>
 *        Parameters:
 *        <ul>
 *          <li>{max} the maximum </li>
 *        </ul>
 *        <p>Usage: Enter a datetime less than or equal to {max}</p>
 *      </li>
 *      <li>'hintMinimum': Hint message to be used, to give a hint about the allowed minimum.<p>
 *        Parameters:
 *        <ul>
 *          <li>{min} the minimum</li>
 *        </ul>
 *        <p>Usage: Enter a datetime greater than or equal to {min}</p>
 *      </li>
 *      <li>'hintInRange': Hint message to be used, to give a hint about the allowed range.<p>
 *        Parameters:<p>
 *        <ul>
 *          <li>{min} the minimum</li>
 *          <li>{max} the maximum</li>
 *        </ul>
 *        <p>Usage: Enter a datetime between {min} and {max}</p>
 *      </li>
 *     </ul>
 *   </li>
 *   <li><b>message</b>: an optional object literal of custom error messages to be used:<p>
 *    <ul>
 *      <li>'messageMaximum': The detail error message to be used when input value exceeds the maximum value set.<p>
 *        Parameters:<p>
 *        <ul>
 *          <li>{value} value entered by the user</li>
 *          <li>{max} the maximum allowed value</li>
 *        </ul>
 *        <p>Usage: Entered {value} with max being {max}</p>
 *      </li>
 *      <li>'messageMinimum': The detail error message to be used when input value is less than the set minimum value.<p>
 *        Parameters:<p>
 *        <ul>
 *          <li>{value} value entered by the user</li>
 *          <li>{max} the minimum allowed value</li>
 *        </ul>
 *        <p>Usage: Entered {value} with min being {min}</p>
 *      </li>
 *      <li>'messageNotInRange': The detail error message to be used if input value is not within the range, when minimum and maximum is set.<p>
 *        Parameters:<p>
 *        <ul>
 *          <li>{value} value entered by the user</li>
 *          <li>{min} the minimum allowed value</li>
 *          <li>{max} the maximum allowed value</li>
 *        </ul>
 *        <p>Usage: Entered {value} with min and max being {min}, {max}</p>
 *      </li>
 *    </ul>
 *  </li>
 * </ul>
 * @export
 * @constructor
 */
oj.DateTimeRangeValidator = function _DateTimeRangeValidator(options)
{
  this.Init(options);
};

// Subclass from oj.Object 
oj.Object.createSubclass(oj.DateTimeRangeValidator, oj.Validator, "oj.DateTimeRangeValidator");

/**
 * Initializes validator instance with the set options
 * @param {Object=} options
 * @export
 */
oj.DateTimeRangeValidator.prototype.Init = function (options)
{
  oj.DateTimeRangeValidator.superclass.Init.call(this);
  this._min = options["min"];
  this._max = options["max"];
  this._converter = oj.IntlConverterUtils.getConverterInstance(options["converter"]);
  if (options)
  {
    this._hint = options['hint'] || {};
    this._customMessage = options['message'] || {};
  }
};

/**
 * Validates the minimum + maximum conditions
 *
 * @param {Object} value that is being validated
 * @returns {Object} original if validation was successful
 *
 * @throws {Error} when there is no match
 * @export
 */
oj.DateTimeRangeValidator.prototype.validate = function (value)
{
  var messageNotInRange, messageMinimum, messageMaximum,
      min = this._min, 
      max = this._max, 
      summary = "", 
      detail = "", 
      translations = oj.Translations, 
      customMessage = this._customMessage,
      minStr = min && this._converter ? this._converter['format'](min) : min,
      maxStr = max && this._converter ? this._converter['format'](max) : max;
  
  if (min !== null && max !== null)
  {
    //range
    if ((value >= min && value <= max) || min > max)
    {
      return value;
    }
	
    messageNotInRange = customMessage["messageNotInRange"];
    summary = translations.getTranslatedString('oj-validator.range.datetime.range.summary');
    detail = messageNotInRange ? 
      translations.applyParameters(messageNotInRange, {"value": value, "min": minStr, "max": maxStr}) : 
      translations.getTranslatedString('oj-validator.range.datetime.range.detail', {"min": minStr, "max": maxStr});
  }
  else 
  {
    //only min
    if (min !== null)
    {
      if (value >= min)
      {
        return value;
      }
	  
      messageMinimum = customMessage["messageMinimum"];
      summary = translations.getTranslatedString('oj-validator.range.datetime.min.summary');
      detail = messageMinimum ? 
        translations.applyParameters(messageMinimum, {"value": value, "min": minStr}) : 
        translations.getTranslatedString('oj-validator.range.datetime.min.detail', {"min": minStr});
    }
    //max only
    else 
    {
      if (max === null || value <= max)
      {
        return value;
      }
	    messageMaximum = customMessage["messageMaximum"];
      summary = translations.getTranslatedString('oj-validator.range.datetime.max.summary');
      detail = messageMaximum ? 
        translations.applyParameters(messageMaximum, {"value": value, "max": maxStr}) : 
        translations.getTranslatedString('oj-validator.range.datetime.max.detail', {"max": maxStr});
    }
  }

  throw new oj.ValidatorError(summary, detail);
};

/**
 * A message to be used as hint. There is no default hint for this property.
 *
 * @returns {String|null} a hint message or null if no hint is available in the options
 * @export
 */
oj.DateTimeRangeValidator.prototype.getHint = function ()
{
  var hint = null, hints = this._hint, 
      hintInRange = hints["hintInRange"], hintMinimum = hints["hintMinimum"], hintMaximum = hints["hintMaximum"],
      min = this._min, 
      max = this._max, 
      minStr = min && this._converter ? this._converter['format'](min) : min,
      maxStr = max && this._converter ? this._converter['format'](max) : max,
      translations = oj.Translations;
	  
  if (min !== null && max !== null) 
  {
    hint = hintInRange ? translations.applyParameters(hintInRange, {"min": minStr, "max": maxStr}) : 
            translations.getTranslatedString('oj-validator.range.datetime.range.hint', {"min": minStr, "max": maxStr});
  }
  else if (min !== null)
  {
    hint = hintMinimum ?  translations.applyParameters(hintMinimum, {"min": min}) :
                          translations.getTranslatedString('oj-validator.range.datetime.min.hint', {"min": minStr});
  }
  else if (max !== null)
  {
    hint = hintMaximum ?  translations.applyParameters(hintMaximum, {"max": max}) :
                          translations.getTranslatedString('oj-validator.range.datetime.max.hint', {"max": maxStr});
  }

  return hint;
};
/*
 * Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.
 */

/**
 * Constructs a RequiredValidator that ensures that the value provided is not empty
 * @param {Object=} options an object literal used to provide an optional hint and error message.<p>
 * <ul>
 * <li><b>hint</b>: an optional hint text. There is no default hint provided by this validator.</li>
 * <li>
 * <b>messageSummary</b>: a custom error message summarizing the error <p>
 * Parameters: <p>
 * {label} - label of the component for which this message applies. The label may not always be 
 * available depending on the usage of the validator. <p>
 * Examples:<p>
 * "'{label}' Required" 
 * </li>
 * <li><b>messageDetail</b>: a custom error message to be used for creating detail part of message, 
 * when the value provided is empty. NOTE: the parameter 'message' has been deprecated.<p>
 * Parameters:<p>
 * {label} - label text of the component for which this message applies. 
 * Examples:<p>
 * "A value is required for the field '{label}'.<br/>
 * </li>
 * </ul>
 * @export
 * @constructor
 */
oj.RequiredValidator = function(options) 
{
  this.Init(options);
};

// Subclass from oj.Object or oj.Validator. It does not matter
oj.Object.createSubclass(oj.RequiredValidator, oj.Validator, "oj.RequiredValidator");

// key to access required validator specific resources in the bundle 
oj.RequiredValidator._BUNDLE_KEY_DETAIL = "oj-validator.required.detail";
oj.RequiredValidator._BUNDLE_KEY_SUMMARY = "oj-validator.required.summary";

/**
 * Initializes validator instance with the set options
 * @param {Object=} options
 * @export
 */
oj.RequiredValidator.prototype.Init = function(options) 
{
  oj.RequiredValidator.superclass.Init.call(this);
  this._options = options;
};

/**
 * Validates value to be non-empty
 * 
 * @param {Object|string|number} value that is being validated 
 * @returns {boolean} true if validation was was successful the value is non-empty
 * 
 * @throws {Error} when fails required-ness check
 * @export
 */
oj.RequiredValidator.prototype.validate = function(value)
{
  var localizedDetail, localizedSummary, detail, summary, params = {}, label = "";
  // checks for empty arrays and String. Objects are considered non-null.
  // Need to specifically test for if value is 0 first if number is passed on.
  if ((typeof value === "number" && value === 0) || (value && value.length !== 0))
  {
    return true;
  }
  else
  {
    if (this._options)
    {
      // we have deprecated support for message param and instead use messageDetail.
      detail = this._options['messageDetail'] || this._options['message'] || null;
      summary = this._options['messageSummary'] || null;
      label = this._options['label'] || "";
    }
    params = {'label': label};
    localizedSummary = (summary) ? oj.Translations.applyParameters(summary, params) :
            oj.Translations.getTranslatedString(this._getSummaryKey(), params);
    localizedDetail = (detail) ? 
    oj.Translations.applyParameters(detail, params) : 
    oj.Translations.getTranslatedString(this._getDetailKey(), params);
    
    throw new oj.ValidatorError(localizedSummary, localizedDetail);
  }

};

/**
 * A message to be used as hint, when giving a hint on the expected pattern. There is no default 
 * hint for this property.
 * 
 * @returns {String|string|null} a hint message or null if no hint is available in the options
 * @export
 */
oj.RequiredValidator.prototype.getHint = function()
{
  var hint = "";
  if (this._options && (this._options['hint']))
  {
    hint = oj.Translations.getTranslatedString(this._options['hint']);
  }
  
  return hint;
};

oj.RequiredValidator.prototype._getSummaryKey = function ()
{
  return oj.RequiredValidator._BUNDLE_KEY_SUMMARY;
};

oj.RequiredValidator.prototype._getDetailKey = function ()
{
  return oj.RequiredValidator._BUNDLE_KEY_DETAIL;
};
/*
 * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
 */

/**
 * Constructs a LengthValidator that ensures the value entered is within a given length. 
 * 
 * @param {Object=} options an object literal used to provide:<p>
 *  <ul>
 *    <li><strong>min</strong>: A number that is the minimum length of the value.</li>
 *    <li><strong>max</strong>: a number that is the maximum length of the value.</li>
 *    <li><strong>hint</strong>: optional object literal of hint text to be used. There is no default 
 *    hint provided by this validator.</li>
 *      <ul>     
 *        <li>'hintMaximum': Hint message to be used, to indicate the allowed maximum.<p>
 *          Parameters:
 *          <ul>
 *            <li>{max} the maximum</li>
 *          </ul>
 *          Usage: Enter {max} or fewer characters
 *        </li>
 *        <li>'hintMinimum': Hint message to be used, to indicate the allowed minimum.<p>
 *        Parameters:
 *          <ul>
 *            <li>{min} the minimum</li>
 *          </ul>
 *          Usage: Enter {min} or more characters</li>
 *        <li>'hintInRange': Hint message to be used, to indicate the allowed range.<p>
 *        Parameters:
 *          <ul>
 *            <li>{min} the minimum</li>
 *            <li>{max} the maximum</li>
 *          </ul>
 *          Usage: Enter between {min} and {max} characters
 *        </li>
 *      </ul>
 *    </li>
 *    <li><strong>message</strong>: optional object literal of custom error message to be used:<p>
 *      <ul>
 *        <li>'messageMaximum': The detail error message to be used as the error message, when 
 *        the length of the input value exceeds the maximum value set.<p>
 *        Parameters:
 *          <ul>
 *            <li>{value} value entered by the user</li>
 *            <li>{max} the maximum allowed value</li>
 *          </ul>
 *          Usage: The {value} has too many characters. Enter {max} or fewer characters, not more.
 *        </li>
 *        <li>'messageMinimum': The detail error message to be used as the error message, when 
 *        input value is less than the set minimum value.<p>
 *        Parameters:
 *          <ul>
 *            <li>{value} value entered by the user</li>
 *            <li>{min} the minimum allowed value</li>
 *          </ul>
 *          Usage: The {value} has too few characters. Enter {min} or more characters, not less.
 *        </li>
 *        <li>'messageNotInRange': The detail error message to be used as the error messages, when 
 *        input value is not with in the range, set by min and max options.<p>
 *        Parameters:<p>
 *          <ul>
 *            <li> {value} value entered by the user</li>
 *            <li> {min} the minimum allowed value</li>
 *            <li> {max} the maximum allowed value</li>
 *          </ul>
 *          Usage: The number of characters in {value} is out of range. Enter {min} or more characters 
 *          up to a maximum of {max}.
 *        </li>
 *      </ul>
 *    </li>
 *  </ul>
 * @export
 * @constructor
 */
oj.LengthValidator = function (options)
{
  this.Init(options);
};

// Subclass from oj.Object 
oj.Object.createSubclass(oj.LengthValidator, oj.Validator, "oj.LengthValidator");

/**
 * Initializes validator instance with the set options
 * @param {Object=} options
 * @export
 */
oj.LengthValidator.prototype.Init = function (options)
{
  oj.LengthValidator.superclass.Init.call(this);
  this._min = options["min"];
  this._max = options["max"];
  
  if (options)
  {
    this._hint = options['hint'] || {};
    this._customMessage = options['message'] || {};
  }
};

oj.LengthValidator.prototype.getHint = function()
{
  var hint = null, hints = this._hint, 
      hintInRange = hints["hintInRange"], hintMinimum = hints["hintMinimum"], 
      hintMaximum = hints["hintMaximum"],
      translations = oj.Translations,
      min = this._min !== undefined ? parseInt(this._min, 10) : null, 
      max = this._max !== undefined ? parseInt(this._max, 10) : null, params;
	  
  if (min !== null && max !== null) 
  {
    if (min !== max)
    {
      params = {"min": min, "max": max};
      hint = hintInRange ? translations.applyParameters(hintInRange, params) : 
	                       translations.getTranslatedString('oj-validator.length.range.hint', params);
    }
    else
    {
      hint = translations.getTranslatedString('oj-validator.length.exact.hint', {'length': min});
    }
  }
  else if (min !== null)
  {
    params = {"min": min};
    hint = hintMinimum ?  translations.applyParameters(hintMinimum, params) :
	                      translations.getTranslatedString('oj-validator.length.min.hint', params);
  }
  else if (max !== null)
  {
    params = {"max": max};
    hint = hintMaximum ?  translations.applyParameters(hintMaximum, params) :
                          translations.getTranslatedString('oj-validator.length.max.hint', params);
  }

  return hint;
};

/**
 * Validates the length of vaue is greater than minimum and/or less than maximum.
 *
 * @param {string} value that is being validated
 * @returns {string} original if validation was successful
 *
 * @throws {Error} when the length is out of range.
 * @export
 */
oj.LengthValidator.prototype.validate  = function(value)
{
  var summary = "", detail = "", string = "" + value, length = string.length,
      customMessage = this._customMessage, 
      messageNotInRange = customMessage["messageNotInRange"], 
      messageMinimum = customMessage["messageMinimum"], 
      messageMaximum = customMessage["messageMaximum"],
      translations = oj.Translations, params,
      min = this._min !== undefined ? parseInt(this._min, 10) : null, 
      max = this._max !== undefined ? parseInt(this._max, 10) : null;
  
  // If only min is set and length is at least min, or 
  // if only max is set and length is at most max, or
  // if length is between min and max or
  // if neither min or max is set return with no error.
  if ((min === null || length >= this._min) &&
     ((max === null) || (length <= this._max)))
  {
    return string;
  }
  else
  {
    if ((this._min > 0) && (max !== null))

    {
      var exact = (this._min === this._max);
      if (exact)
      {
        params = {"value": value, "length": min};
        summary = translations.getTranslatedString('oj-validator.length.exact.summary');
        detail = translations.getTranslatedString('oj-validator.length.exact.detail', params);
      }
      else
      {
        params = {"value": value, "min": min, "max": max};
        summary = translations.getTranslatedString('oj-validator.length.range.summary');
        detail = messageNotInRange ? translations.applyParameters(messageNotInRange, params) : 
                    translations.getTranslatedString('oj-validator.length.range.detail', params);
        
      }
    }
    else if (length < this._min) //too short
    {
      params = {"value": value, "min": min};
      summary = translations.getTranslatedString('oj-validator.length.min.summary');
      detail = messageMinimum ? translations.applyParameters(messageMinimum, params) : 
                  translations.getTranslatedString('oj-validator.length.min.detail', params);
    }
    else // too long
    {
      params = {"value": value, "max": max};
      summary = translations.getTranslatedString('oj-validator.length.max.summary');
      detail = messageMaximum ? translations.applyParameters(messageMaximum, params) : 
                    translations.getTranslatedString('oj-validator.length.max.detail', params);
    }
    
    throw new oj.ValidatorError(summary, detail);
  }
};
/*
 * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
 */
/**
 * Constructs a NumberRangeValidator that ensures the value provided is within a given range
 * @param {Object=} options an object literal used to provide:<p>
 *  <ul>
 *    <li><strong>min</strong>: The minimum number value of the entered value.</li>
 *    <li><strong>max</strong>: The maximum number value of the entered value.</li>
 *    <li><strong>hint</strong>: optional object literal of hint text to be used.</li>
 *      <ul>     
 *        <li>'hintMaximum': Hint message to be used, to indicate the allowed maximum.<p>
 *          Parameters:
 *          <ul>
 *            <li>{max} the maximum</li>
 *          </ul>
 *          Usage: Enter a number less than or equal to {max}
 *        </li>
 *        <li>'hintMinimum': Hint message to be used, to indicate the allowed minimum.<p>
 *        Parameters:
 *          <ul>
 *            <li>{min} the minimum</li>
 *          </ul>
 *          Usage: Enter a number greater than or equal to {min}</li>
 *        <li>'hintInRange': Hint message to be used, to indicate the allowed range.<p>
 *        Parameters:
 *          <ul>
 *            <li>{min} the minimum</li>
 *            <li>{max} the maximum</li>
 *          </ul>
 *          Usage: Enter a number between {min} and {max}
 *        </li>
 *      </ul>
 *    </li>
 *    <li><strong>message</strong>: optional object literal of custom error message to be used:<p>
 *      <ul>
 *        <li>'messageMaximum': The detail error message to be used as the error message, when 
 *        input value exceeds the maximum value set.<p>
 *        Parameters:
 *          <ul>
 *            <li>{value} value entered by the user</li>
 *            <li>{max} the maximum allowed value</li>
 *          </ul>
 *          Usage: The number {value} must be less than or equal to {max}.
 *        </li>
 *        <li>'messageMinimum': The detail error message to be used as the error message, when 
 *        input value is less than the set minimum value.<p>
 *        Parameters:
 *          <ul>
 *            <li>{value} value entered by the user</li>
 *            <li>{min} the minimum allowed value</li>
 *          </ul>
 *          Usage: The number {value} must be greater than or equal to {min}.
 *        </li>
 *        <li>'messageNotInRange': The detail error message to be used as the error messages, when 
 *        input value is not with in the range, set by min and max options.<p>
 *        Parameters:<p>
 *          <ul>
 *            <li> {value} value entered by the user</li>
 *            <li> {min} the minimum allowed value</li>
 *            <li> {max} the maximum allowed value</li>
 *          </ul>
 *          Usage: The number {value} is not between {min} and {max}.
 *        </li>
 *      </ul>
 *    </li>
 *  </ul>
 * @export
 * @constructor
 */
oj.NumberRangeValidator = function _NumberRangeValidator(options)
{
  this.Init(options);
};

// Subclass from oj.Object 
oj.Object.createSubclass(oj.NumberRangeValidator, oj.Validator, "oj.NumberRangeValidator");

/**
 * Initializes validator instance with the set options
 * @param {Object=} options
 * @export
 */
oj.NumberRangeValidator.prototype.Init = function (options)
{
  oj.NumberRangeValidator.superclass.Init.call(this);
  this._min = options["min"];
  this._max = options["max"];
  this._converter = oj.IntlConverterUtils.getConverterInstance(options['converter']);
  
  if (options)
  {
    this._hint = options['hint'] || {};
    this._customMessage = options['message'] || {};
  }
};

/**
 * Validates the minimum + maximum conditions
 *
 * @param {string|number} value that is being validated
 * @returns {string} original if validation was successful
 *
 * @throws {Error} when value is out of range
 * @export
 */
oj.NumberRangeValidator.prototype.validate = function (value)
{
  var string = value ? value.toString() : value, 
      numberValue = parseFloat(string), customMessage = this._customMessage, 
      messageNotInRange = customMessage["messageNotInRange"], 
      messageMinimum = customMessage["messageMinimum"], 
      messageMaximum = customMessage["messageMaximum"],
      min = this._min !== undefined ? parseFloat(this._min) : null, 
      max = this._max !== undefined ? parseFloat(this._max) : null, 
      minStr = min && this._converter ? this._converter['format'](min) : min,
      maxStr = max && this._converter ? this._converter['format'](max) : max,
      summary = "", 
      detail = "", 
	  params = null,
      translations = oj.Translations;
  
  if (min !== null && max !== null)
  {
    //range
    if ((numberValue >= min && numberValue <= max) || min > max)
    {
      return string;
    }
	
	params = {"value": value, "min": minStr, "max": maxStr};
    summary = translations.getTranslatedString('oj-validator.range.number.range.summary');
    detail = messageNotInRange ? translations.applyParameters(messageNotInRange, params) : 
                translations.getTranslatedString('oj-validator.range.number.range.detail', params);
  }
  else 
  {
    //only min
    if (min !== null)
    {
      if (numberValue >= min)
      {
        return string;
      }
	  
	  params = {"value": value, "min": minStr};
      summary = translations.getTranslatedString('oj-validator.range.number.min.summary');
      detail = messageMinimum ? translations.applyParameters(messageMinimum, params) : 
                  translations.getTranslatedString('oj-validator.range.number.min.detail', params);
    }
    //max only
    else 
    {
      if (max === null || numberValue <= max)
      {
        return string;
      }
	  
	  params = {"value": value, "max": maxStr};
      summary = translations.getTranslatedString('oj-validator.range.number.max.summary');
      detail = messageMaximum ? translations.applyParameters(messageMaximum, params) : 
                    translations.getTranslatedString('oj-validator.range.number.max.detail', params);
    }
  }

  throw new oj.ValidatorError(summary, detail);
};

/**
 * @returns {String|null} a hint message or null if no hint is available in the options
 * @export
 */
oj.NumberRangeValidator.prototype.getHint = function ()
{
  var hint = null, hints = this._hint, 
      hintInRange = hints["hintInRange"], hintMinimum = hints["hintMinimum"], hintMaximum = hints["hintMaximum"],
      translations = oj.Translations,
      min = this._min !== undefined ? parseFloat(this._min) : null, 
      max = this._max !== undefined ? parseFloat(this._max) : null,
      minStr = min && this._converter ? this._converter['format'](min) : min,
      maxStr = max && this._converter ? this._converter['format'](max) : max;
	  
  if (min !== null && max !== null) 
  {
  	hint = hintInRange ? translations.applyParameters(hintInRange, {"min": minStr, "max": maxStr}) : 
	                       translations.getTranslatedString('oj-validator.range.number.range.hint', {"min": minStr, "max": maxStr});
  }
  else if (min !== null)
  {
    hint = hintMinimum ?  translations.applyParameters(hintMinimum, {"min": minStr}) :
	                      translations.getTranslatedString('oj-validator.range.number.min.hint', {"min": minStr});
  }
  else if (max !== null)
  {
    hint = hintMaximum ?  translations.applyParameters(hintMaximum, {"max": maxStr}) :
                          translations.getTranslatedString('oj-validator.range.number.max.hint', {"max": maxStr});
  }

  return hint;
};
/*
 * Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.
 */

/**
 * A factory implementation to create the built-in number converter of type 
 * {@link oj.IntlNumberConverter}. 
 * 
 * @name oj.NumberConverterFactory
 * @class
 * 
 * @example <caption>create an instance of the jet datetime converter using the options provided</caption>
 * var ncf = oj.Validation.converterFactory(oj.ConverterFactory.CONVERTER_TYPE_NUMBER); 
 * var salaryOptions = {currency: "EUR" , pattern: "¤#,##0.00;(¤#,##0.00)"};
 * var salaryConverter = ncf.createConverter(salaryOptions);
 * @public
 */
oj.NumberConverterFactory = (function () 
{
  
  function _createNumberConverter(options) 
  {
    return new oj.IntlNumberConverter(options);
  }
  
  return {
    /**
     * Creates an immutable (jet) number converter instance.
     * 
     * @param {Object=} options an object literal used to provide optional information to initialize 
     * the jet number converter with. For details on what to pass for options, refer to 
     * {@link oj.IntlNumberConverter}
     * 
     * @return {oj.IntlNumberConverter}
     * @memberOf oj.NumberConverterFactory
     * @public
     */
    'createConverter': function(options) {
      return _createNumberConverter(options);
    }
  };
}()); // notice immediate invocation of anonymous function

/** Register the default factory provider function */
oj.Validation.__registerDefaultConverterFactory(oj.ConverterFactory.CONVERTER_TYPE_NUMBER, // factory name
                               oj.NumberConverterFactory);


/**
 * A factory implementation to create the built-in datetime converter of type 
 * {@link oj.IntlDateTimeConverter}. 
 * 
 * @name oj.DateTimeConverterFactory
 * @public
 * @class
 * @example <caption>create an instance of the jet datetime converter using the options provided</caption>
 * var dtcf = oj.Validation.converterFactory(oj.ConverterFactory.CONVERTER_TYPE_DATETIME);  
 * var dateOptions = {year: '2-digit', month: 'numeric', day: 'numeric'};
 * var dateConverter = dtcf.createConverter(dateOptions);
 */
oj.DateTimeConverterFactory = (function () 
{
  function _createDateTimeConverter(options) 
  {
    return new oj.IntlDateTimeConverter(options);
  }
  
  /**
   * 
   * @public
   */
  return {
    /**
     * Creates an immutable (jet) datetime converter instance. 
     * 
     * @param {Object=} options an object literal used to provide an optional information to 
     * initialize the jet datetime converter. For details on what to pass for options, refer to 
     * @link oj.IntlDateTimeConverter.
     * 
     * @return {oj.IntlDateTimeConverter} 
     * @memberOf oj.DateTimeConverterFactory
     * @public
     */
    'createConverter' : function(options) {
      return _createDateTimeConverter(options);
    }
  };
}()); // notice immediate invocation of anonymous function

/** Register the default factory provider function */
oj.Validation.__registerDefaultConverterFactory(oj.ConverterFactory.CONVERTER_TYPE_DATETIME, // factory name
                               oj.DateTimeConverterFactory);


// JET VALIDATOR FACTORIES 

/**
 * A factory implementation to create an instance of the built-in required validator of type 
 * {@link oj.RequiredValidator}. 
 * 
 * @example <caption>create an instance of the required validator using the factory</caption>
 * var rvf = oj.Validation.validatorFactory(oj.ValidatorFactory.VALIDATOR_TYPE_REQUIRED); 
 * var options = {'hint' : 'a value is required for this field'};
 * var requiredValidator = rvf.createValidator(options);
 * 
 * @name oj.RequiredValidatorFactory
 * @class
 * @public
 */
oj.RequiredValidatorFactory = (function () 
{
  
  function _createRequiredValidator(options) 
  {
    return new oj.RequiredValidator(options);
  }
  
  return {
    /**
     * Creates an immutable validator instance of type @link oj.RequiredValidator that ensures that 
     * the value provided is not empty.  
     * 
     * @param {Object=} options an object literal used to provide an optional hint and error 
     * message. See {@link oj.RequiredValidator} for details.<p>
     * 
     * @return {oj.RequiredValidator}
     * @memberOf oj.RequiredValidatorFactory
     * @public
     */
    'createValidator': function(options) {
      return _createRequiredValidator(options);
    }
  };
}()); // notice immediate invocation of anonymous function

/** Register the default factory provider function */
oj.Validation.__registerDefaultValidatorFactory(oj.ValidatorFactory.VALIDATOR_TYPE_REQUIRED,
                                                oj.RequiredValidatorFactory);
                               
/**
 * A factory implementation that creates an instance of the built-in regExp validator of type 
 * {@link oj.RegExpValidator}.
 * 
 * @example <caption>create an instance of the regExp validator using the factory</caption>
 * var rvf = oj.Validation.validatorFactory(oj.ValidatorFactory.VALIDATOR_TYPE_REGEXP);  
 * var usernameValidator = rvf.createValidator(
 *  {
 *    'pattern': '[a-zA-Z0-9]{3,}', 
 *    'messageDetail': 'You must enter at least 3 letters or numbers'}
 *  });
 * 
 * @name oj.RegExpValidatorFactory
 * @class
 * @public
 */
oj.RegExpValidatorFactory = (function () 
{
  
  function _createRegExpValidator(options) 
  {
    return new oj.RegExpValidator(options);
  }
  
  return {
    /**
     * Creates an immutable validator instance of type {@link oj.RegExpValidator} that ensures the value 
     * matches the provided pattern. 
     * 
     * @param {Object} options an object literal used to provide the pattern, an optional hint, error 
     * message among others. See {@link oj.RegExpValidator} for details.<p>
     * 
     * 
     * @return {oj.RegExpValidator} 
     * @memberOf oj.RegExpValidatorFactory
     * @public
     */
    'createValidator': function(options) {
      return _createRegExpValidator(options);
    }
  };
}()); // notice immediate invocation of anonymous function

/** Register the default factory provider function */
oj.Validation.__registerDefaultValidatorFactory(oj.ValidatorFactory.VALIDATOR_TYPE_REGEXP,
                                                oj.RegExpValidatorFactory);
                                        
/**
 * a factory implementation to create an instance of the built-in dateTimeRange validator of type 
 * {@link oj.DateTimeRangeValidator}. 
 * 
 * @example <caption>create an instance of the dateTimeRange validator using the factory</caption>
 * var drvf = oj.Validation.validatorFactory(oj.ValidatorFactory.VALIDATOR_TYPE_DATETIMERANGE);  
 * var birthdateOptions = {min: new Date(1930, 00, 01), max: new Date(1995, 11,31)};
 * var birthdateValidator = drvf.createValidator(birthdateOptions);
 *  
 * @name oj.DateTimeRangeValidatorFactory
 * @class
 * @public
 */
oj.DateTimeRangeValidatorFactory = (function () 
{
  
  function _createDateTimeRangeValidator(options) 
  {
    return new oj.DateTimeRangeValidator(options);
  }
  
  return {
    /**
     * Creates an immutable validator instance of type {@link oj.DateTimeRangeValidator} that ensures 
     * that the (datetime) value provided is within a given range.
     * 
     * @param {Object=} options an object literal used to provide the minimum, maximum and other 
     * optional values. See {@link oj.DateTimeRangeValidator} for details.<p>
     * 
     * @return {oj.DateTimeRangeValidator}
     * @memberOf oj.DateTimeRangeValidatorFactory
     * @public
     */
    'createValidator': function(options) {
      return _createDateTimeRangeValidator(options);
    }
  };
}()); // notice immediate invocation of anonymous function

/** Register the default factory provider function */
oj.Validation.__registerDefaultValidatorFactory(oj.ValidatorFactory.VALIDATOR_TYPE_DATETIMERANGE,
                                                oj.DateTimeRangeValidatorFactory);
												
/**
 * a factory method to create an instance of the built-in dateRestriction validator of type 
 * {@link oj.DateRestrictionValidator}. 
 * 
 * @example <caption>create an instance of the dateRestriction validator using the factory </caption>
 * var drvf = oj.Validation.validatorFactory(oj.ValidatorFactory.VALIDATOR_TYPE_DATERESTRICTION);
 * var drValidator = drvf.createValidator();
 *  
 * @name oj.DateRestrictionValidatorFactory
 * @class
 * @public
 */
oj.DateRestrictionValidatorFactory = (function () 
{
  
  function _createDateRestrictionValidator(options) 
  {
    return new oj.DateRestrictionValidator(options);
  }
  
  return {
    /**
     * Creates an immutable validator instance of type oj.DateRestrictionValidator that ensures that the 
     * (date) value provided is not in a disabled entry of dayMetaData.
     * 
     * @param {Object=} options an object literal used to provide the dayMetaData optional value. 
     * See {@link oj.ojInputDate} and {@link oj.DateRestrictionValidator} for details.<p>
     * 
     * @return {oj.DateRestrictionValidator}
     * @memberOf oj.DateRestrictionValidatorFactory
     * @public
     */
    'createValidator': function(options) {
      return _createDateRestrictionValidator(options);
    }
  };
}()); // notice immediate invocation of anonymous function

/** Register the default factory provider function */
oj.Validation.__registerDefaultValidatorFactory(oj.ValidatorFactory.VALIDATOR_TYPE_DATERESTRICTION,
                                                oj.DateRestrictionValidatorFactory);
                                        
/**
 * a factory method to create an instance of a built-in numberRange validator of type 
 * {@link oj.NumberRangeValidator}. 
 * 
 * @example <caption>create an instance of the numberRange validator using the factory</caption>
 * var lrvf = oj.Validation.validatorFactory(oj.ValidatorFactory.VALIDATOR_TYPE_NUMBER_RANGE);
 * var options = {hint: {hintMinimum: 'Enter a value greater than {min}'}, min: 100};
 * var lrValidator = lrvf.createValidator(options);
 * 
 * @name oj.NumberRangeValidatorFactory
 * @class
 * @public
 */
oj.NumberRangeValidatorFactory = (function () 
{
  
  function _createNumberRangeValidator(options) 
  {
    return new oj.NumberRangeValidator(options);
  }
  
  return {
    /**
     * Creates an immutable validator instance of type {@link oj.NumberRangeValidator} that ensures 
     * that the value provided is within a given range.
     * 
     * @param {Object=} options an object literal used to provide the minimum, maximum and other 
     * optional values. See {@link oj.NumberRangeValidator} for details.<p>
     * 
     * @return {oj.NumberRangeValidator}
     * @memberOf oj.NumberRangeValidatorFactory
     * @public
     */
    'createValidator': function(options) {
      return _createNumberRangeValidator(options);
    }
  };
}()); // notice immediate invocation of anonymous function

/** Register the default factory provider function */
oj.Validation.__registerDefaultValidatorFactory(oj.ValidatorFactory.VALIDATOR_TYPE_NUMBERRANGE,
                                                oj.NumberRangeValidatorFactory);
                                        
/**
 * Returns an instance of oj.LengthValidatorFactory that provides a factory method to create an 
 * instance of a length validator. 
 * 
 * @example <caption>create an instance of the length validator using the factory</caption>
 * var lvf = oj.Validation.validatorFactory(oj.ValidatorFactory.VALIDATOR_TYPE_LENGTH);
 * var options = {hint: {hintMaximum: 'Enter {max} or fewer characters'}, max: 10};
 * var lValidator = lvf.createValidator(options);
 * 
 * @name oj.LengthValidatorFactory
 * @class
 * @public
 */
oj.LengthValidatorFactory = (function () 
{
  
  function _createLengthValidator(options) 
  {
    return new oj.LengthValidator(options);
  }
  
  return {
    /**
     * Creates an immutable validator instance of type oj.LengthValidator that ensures that the 
     * value provided is withing a given length.
     * 
     * @param {Object=} options an object literal used to provide the 'minimum', 'maximum' and other 
     * optional values. See {@link oj.LengthValidator} for details.<p>
     * 
     * @return {oj.LengthValidator}
     * @memberOf oj.LengthValidatorFactory
     * @public
     */
    'createValidator': function(options) {
      return _createLengthValidator(options);
    }
  };
}()); // notice immediate invocation of anonymous function

/** Register the default factory provider function */
oj.Validation.__registerDefaultValidatorFactory(oj.ValidatorFactory.VALIDATOR_TYPE_LENGTH,
                                                oj.LengthValidatorFactory);
oj.IntlConverterUtils = {};

/**
 * Given either an Object literal representing a 'converter' option (used in components) or a 
 * converter instance of type oj.Converter, this method returns the converter instance.
 * 
 * @param {Object} converterOption
 * @returns {Object} converterInstance or null if a converter cannot be determined
 * @expose
 */
oj.IntlConverterUtils.getConverterInstance = function (converterOption)
{
  var cTypeStr = "", cOptions = {}, converterInstance = null, cf;
  
  if (converterOption)
  {
    if (typeof converterOption === "object")
    {
      // TODO: Should we check that it duck types oj.Converter?
      if (converterOption instanceof oj.Converter || 
          (converterOption['parse'] && typeof converterOption['parse'] === "function") || 
          (converterOption['format'] && typeof converterOption['format'] === "function"))
      {
        // we are dealing with a converter instance
        converterInstance = converterOption;
      }
      else 
      {
        // check if there is a type set
        cTypeStr = converterOption['type'];
        cOptions = converterOption['options'] || {};
      }
    }

    if (!converterInstance)
    {
      // either we have an object literal or just plain string.
      cTypeStr = cTypeStr || converterOption;
      if (cTypeStr && typeof cTypeStr === "string")
      {
        // if we are passed a string get registered type. 
        cf = oj.Validation.converterFactory(cTypeStr);
        converterInstance = cf.createConverter(cOptions);
      }
    }
  }
  
  return converterInstance;
};

// PACKAGE PRIVATE

/**
 * Processes an converter option error and returns a oj.ConverterERror instance.
 * @param {string} errorCode
 * @param {Object} parameterMap
 * @return {Object} an oj.ConverterError instance
 * @private
 */
oj.IntlConverterUtils.__getConverterOptionError = function(errorCode, parameterMap)
{
  oj.Assert.assertObject(parameterMap);
  var summary = "", detail = "", propName = parameterMap['propertyName'], reqPropName, 
          propValueValid;
  
  if (errorCode === "optionTypesMismatch")
  {
    reqPropName = parameterMap['requiredPropertyName'];
    propValueValid = parameterMap['requiredPropertyValueValid'];
    // Summary: A value for the property '{requiredPropertyName}' is required when the property 
    // '{propertyName}' is set to '{propertyValue}'.
    summary = oj.Translations.getTranslatedString("oj-converter.optionTypesMismatch.summary", 
      {'propertyName': propName,
       'propertyValue': parameterMap['propertyValue'],
       'requiredPropertyName': reqPropName});

    detail = oj.IntlConverterUtils._getOptionValueDetailMessage(reqPropName, propValueValid);
  }
  else if (errorCode === "optionTypeInvalid")
  {
    // Summary: A value of the expected type was not provided for '{propertyName}'.
    propName = parameterMap['propertyName'];
    propValueValid = parameterMap['propertyValueValid'];
    summary = oj.Translations.getTranslatedString("oj-converter.optionTypeInvalid.summary", 
      {'propertyName': propName});

    detail = oj.IntlConverterUtils._getOptionValueDetailMessage(propName, propValueValid);
  }
  else if (errorCode === "optionOutOfRange")
  {
    // The value {propertyValue} is out of range for the option '{propertyName}'.
    summary = oj.Translations.getTranslatedString("oj-converter.optionOutOfRange.summary", 
      {'propertyName': propName,
       'propertyValue': parameterMap['propertyValue']});

    propValueValid = parameterMap['propertyValueValid'];
    detail = oj.IntlConverterUtils._getOptionValueDetailMessage(propName, propValueValid);
  }
  else if (errorCode === "optionValueInvalid")
  {
    // An invalid value '{propertyValue}' was specified for the option '{propertyName}'.. 
    summary = oj.Translations.getTranslatedString("oj-converter.optionValueInvalid.summary", 
      {'propertyName': propName,
       'propertyValue': parameterMap['propertyValue']});
    
    propValueValid = parameterMap['propertyValueHint'];
    detail = oj.IntlConverterUtils._getOptionValueDetailMessage(propName, propValueValid);
  }
  
  return new oj.ConverterError(summary, detail);

};


/**
 * Builds the detail message for possible converter option values. Only applicable when errorInfo is 
 * returned from JET converter implementation.
 * 
 * @param {string} propName name of the property 
 * @param {Array|string} propValueValid valid value or values expected.
 * 
 * @return {string} the localized message
 * @private
 */
oj.IntlConverterUtils._getOptionValueDetailMessage = function (propName, propValueValid)
{
  // Detail: An accepted value for '{propertyName}' is '{propertyValueValid}'. or 
  // Accepted values for '{propertyName}' are '{propertyValueValid}'.
  var resourceKey;
  
  if (propValueValid)
  {
    if (typeof propValueValid === "string")
    {
      resourceKey = "oj-converter.optionHint.detail";
    }
    else
    {
      // we have an array of values
      resourceKey = "oj-converter.optionHint.detail-plural";
      propValueValid = 
         propValueValid.join(oj.Translations.getTranslatedString("oj-converter.plural-separator"));
    }
    return oj.Translations.getTranslatedString(resourceKey, 
      {'propertyName': propName,
       'propertyValueValid': propValueValid});

  }
  
  return "";
};

/**
 * Returns the default value for non-truthy values.
 * 
 * @returns {string} an empty string
 * @private
 */
oj.IntlConverterUtils.__getNullFormattedValue = function ()
{
  return "";
};

/*jslint browser: true, devel: true*/
/*global ComponentChangeTracker:true*/


/**
 * To create a custom binding,
 * use oj.ComponentBinding.create(). Using prototypal inheritance to extend
 * oj.ComponentBinding is not supported.
 * @export
 * @class oj.ComponentBinding 
 * @classdesc JQueryUI component binding for Knockout.js. 
 * @param {string|Array.<string>} name - the name of the binding or an
 * array of strings in case the binding needs to be registered under several names
 * @param {?(Object|string)=} options - property object
 * @see oj.ComponentBinding.create
 * @constructor
 */
oj.ComponentBinding = function(name, options)
{
  this.Init(name, options);
};

oj.Object.createSubclass(oj.ComponentBinding, oj.Object, "oj.ComponentBinding");


/**
 * Creates a binding instance and registers it with Knockout.js
 * @export
 * @param {string|Array.<string>} name - the name of the binding or an
 * array of strings in case the binding needs to be registered under several names
 * @param {?(Object|string)=} options - property object with the following fields:
 * <ul>
 *   <li>{string} 'componentName' - name of the component 
 *       Not specifying this parameter indicates that the binding should use the 'component' attribute 
 *       on itself to determine the constructor name
 *   </li>
 *   <li>{Function} 'afterCreate'- a callback invoked after component instance has been created.
 *        The function will receive the following parameters:
 *        <ul>
 *           <li>{Element} element - DOM element associated with this binding</li>
 *           <li>{Function} widgetConstructor - constructor for the JQueryUI widget created
 *            by this binding. The constructor is already bound to the associated 
 *            JQuery element</li>
 *           <li>{Function} valueAccessor - a JavaScript function that you can call to 
 *           get a map of current binding attributes</li>
 *           <li>{Object} allBindings -  a JavaScript object that you can use to access all the model values bound 
 *           to this DOM element</li>
 *           <li>{Object} bindingContext -  an object that holds the binding context available to this element's bindings. 
 *           This object includes special properties including $parent, $parents, and $root that can be used to access
 *           data that is bound against ancestors of this context</li>
 *        </ul>
 *   </li>
 *   <li>{Function} 'beforeDestroy'- a callback invoked before the component instance is detroyed by this binding
 *        The function will receive the same parameters as the 'afterCreate' callback above.
 *   </li>
 * </ul>
 * When this parameter is specified as a string, it will be interpreted as a single 'componentName' option
 * @return {oj.ComponentBinding} binding instance
 */
oj.ComponentBinding.create = function(name, options)
{
  if (name == null)
  {
    throw "Binding name is required!";
  }
  
  var instance = new oj.ComponentBinding(name, options);
  
  var handlers = ko.bindingHandlers, i;
  var names = Array.isArray(name) ? name : [name];
  for (i=0; i<names.length; i++)
  {
    handlers[names[i]] = instance;
  }
  
  return instance;
};

/**
 * Retrieves the default componnet binding instance registered with Knockout.js
 * @return {oj.ComponentBinding} default binding instance
 * @export
 */
oj.ComponentBinding.getDefaultInstance = function()
{
  return oj.ComponentBinding._INSTANCE;
};

/**
 * Sets up custom handling for attributes that will be managed by this binding 
 * instance
 * @param {Object} opts - property object with the following fields:
 * <ul>
 *   <li>'attributes' - string array of attribue names</li>
 *   <li>'init' - a function called when a managed attribute is initialized.
 *        The function will receive the following parameters:
 *        <ul>
 *           <li>{string} name - attribute name</li>
 *           <li>{Object} value - attribute value</li>
 *           <li>{Element} element - DOM element where this binding is being attached</li>
 *           <li>{Function} widgetConstructor - constructor for the JQueryUI widget created
 *            by this binding. The constructor is already bound to the associated 
 *            JQuery element</li>
 *           <li>{Function} valueAccessor - a JavaScript function that you can call to 
 *           get a map of current binding attributes</li>
 *           <li>{Object} allBindings -  a JavaScript object that you can use to access all the model values bound 
 *           to this DOM element</li>
 *           <li>{Object} bindingContext -  an object that holds the binding context available to this element's bindings. 
 *           This object includes special properties including $parent, $parents, and $root that can be used to access
 *           data that is bound against ancestors of this context</li>
 *        </ul>
 *        The optional return value of the function is a name-to-value map of
 *        properties that should be set on the component
 *   </li>
 *   <li>'update' - a function called when a managed attribute is updated.
 *        The function will receive the same parameters as the 'init' callback above.
 *        The optional return value of the function is a name-to-value map of
 *        properties that should be set on the component at the time when other
 *        accumulated changes are delivered
 *   </li>
 *   <li>'for' (optional) - a string representing component type or constructor 
 *        name restricting the applicability of these managed attributes
 *   </li>
 *   <li>'use' (optional) - an string array of component types whose managed attribute behavior
 *       should be used for the component type specified with the 'for' attribute
 *   </li>
 * </ul>
 * @export
 */
oj.ComponentBinding.prototype.setupManagedAttributes = function(opts)
{

  var forName = opts['for'];
  forName = forName == null ? '@global' : forName;
  
  if (oj.Logger.option('level') >= oj.Logger.LEVEL_ERROR 
        && this._managedAttrOptions[forName])
  {
    oj.Logger.error("Managed Attributes for '%s' are redefined",  forName);
  }
  
  this._managedAttrOptions[forName] = opts;
};



/**
 * Delivers all accumulated component changes across all instances of this binding.
 * Calling this method is optional - the changes will be delivered after a 1ms timeout
 * if this method is never invoked. However, you may call this method to speed up
 * component updates when the aplication code is done updating the view models.
 * @export
 */
oj.ComponentBinding.deliverChanges = function()
{
  oj.ComponentBinding._changeQueue.deliverChanges();
};

/**
 * @private
 */
oj.ComponentBinding.prototype.Init = function(names, options)
{
  oj.ComponentBinding.superclass.Init.call(this);
  
  if (typeof options === "string")
  {
    options = {'componentName': options};
  }
  
  this._bindingOptions = options || {};
  
  
  this._bindingNames = Array.isArray(names) ? names : [names];
  
  this['init'] = oj.Object.createCallback(this, this._init);
  this['update'] = oj.Object.createCallback(this, this._update);
  
  this._managedAttrOptions = {};
};



/**
 * @private
 */
oj.ComponentBinding._NEEDS_JUIB_INIT = "_ojNeedsJUIBInit";


/**
 * @private
 */
oj.ComponentBinding.prototype._init = function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) 
{
  //Invoke child bindings first to allow on-the-fly generation of child content
  ko.applyBindingsToDescendants(bindingContext, element);
  
  // Store the flag on the DOM element indicating that this binding still needs to be initialized
  // We will delay initialiazation (including creation of the JQueryUI component until update()
  // because other bindings such as foreachcdelay their DOM manipulation until update(). 
  // We need the complete dom to support functions like buttonset() and menu() on containers
  
  $(element).data(oj.ComponentBinding._NEEDS_JUIB_INIT, true);
  
    
  return {'controlsDescendantBindings': true};
};


/**
 * @private
 */
oj.ComponentBinding.prototype._update = function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext)
{
  var jelem = $(element);
  
  if (!jelem.data(oj.ComponentBinding._NEEDS_JUIB_INIT))
  {
    return;
  }
  
  jelem.data(oj.ComponentBinding._NEEDS_JUIB_INIT, null);
  
  
  this._initComponent(element, jelem, valueAccessor, allBindingsAccessor, bindingContext);
};


/**
 * @private
 */
oj.ComponentBinding.prototype._initComponent = function(element, jelem, valueAccessor, allBindingsAccessor, bindingContext)
{
  var options = valueAccessor();
  var roleAttrName = null;
  var disposed = false;
  var registeredListers = [];
  var tracker = null;
  var comp = null;
  
  var bindingMap = oj.ComponentBinding._getBindingValueMap(this._bindingNames, element, bindingContext);
  
 
  
  var stage = 0; // init
  
  var attributeEvaluatorCache = {};
  
  var componentName = this._bindingOptions['componentName'];
  
  if (componentName == null)
  {
    roleAttrName = 'component';    
      
    if (!bindingMap[roleAttrName])
    {
      // Try the deprecated 'role' attribute
      roleAttrName = 'role';
      
      if (!bindingMap[roleAttrName])
      {
        oj.Logger.error("component attribute is required for the ojComponent binding");
        return;
      }
    }
  
    var role = options[roleAttrName];
    
    if (role == null)
    {
      oj.Logger.error("non-null component attribute is required for the ojComponent binding");
      return;
    }
    
    
    // Use ko.computed to track changes to the 'component' attribute
    ko.computed(
        function()
        { 
          // evaluate full property expression to ensure that Knockout adds subscriptions to any computed observables that
          // may be in the chain
          oj.ComponentBinding._evaluatePropertyExpression(bindingMap[roleAttrName], roleAttrName, attributeEvaluatorCache, bindingContext);
          if (stage == 0)
          {
            componentName = ko.utils.unwrapObservable(role);
          }
          else
          {
            disposed = true;
            bindingMap = null;
            
            oj.ComponentBinding._unregisterWritebacks(jelem);
            
            if (comp)
            {
              // Clean up after a component type change
              tracker.dispose();
              tracker = null;
              
              var destroyCallback = this._bindingOptions['beforeDestroy'];
              if (destroyCallback)
              {
                destroyCallback(element, comp, valueAccessor, allBindingsAccessor, bindingContext);
              }
              
              comp("destroy");
              comp = null;
              
              var l;
              for (l=0; l<registeredListers.length; l++)
              {
                registeredListers[l].dispose();
              }
              registeredListers = null;
            }
            
            this._initComponent(element, jelem, valueAccessor, allBindingsAccessor, bindingContext);
          }
          return null;
        },
        this/* 'this' object for the 'read' function*/,
        {'disposeWhenNodeIsRemoved' : element});
  }
  
  if (componentName != null)
  {
    comp = jelem[componentName];
      
    if ((typeof comp) === "function")
    {
      comp = comp.bind(jelem);
      
      var managedAttrMap = oj.ComponentBinding._resolveManagedAttributes(this._managedAttrOptions, bindingMap, componentName);
      
      // Always use managed attribute behavior from the default instance
      var defaultInstance = oj.ComponentBinding.getDefaultInstance();
      if (this !== defaultInstance)
      {
        var defaultManagedMap = defaultInstance._getManagedAttributes(bindingMap, componentName);
        // Override default managed attribute map with values from this binding's map.
        // Note that there is no need to clone defaultManagedMap because a new instance gets created
        // every time _getManagedAttributes() is called
        oj.CollectionUtils.copyInto(defaultManagedMap, managedAttrMap);
        managedAttrMap = defaultManagedMap;
      }
      
      var propertyMap = {};
      tracker = new ComponentChangeTracker(comp, element, oj.ComponentBinding._changeQueue);
      
      var writablePropMap = 
      {
        '^slider$' : [{'event': 'slidechange', 'getter': _extractValueFromChangeEvent}],
        '^oj*': [{'event': 'ojoptionchange', 'getter': _extractOptionChange}]
      };    
      
      var binding = this;
      
      var handler = function()
        {
          var prop = this._property;
          
          // evaluate full property expression to ensure that Knockout adds subscriptions to any computed observables that
          // may be in the chain
          var exp = bindingMap[prop];
          if (exp)
          {
            oj.ComponentBinding._evaluatePropertyExpression(exp, prop, attributeEvaluatorCache, bindingContext);
          }
          
          if (stage === 0) // init, no change
          {
            var val = options[prop];
            var value = oj.ComponentBinding._toJS(val);
          
          
            if (managedAttrMap[prop] != null)
            {
              var initFunc = managedAttrMap[prop].init;
              if (initFunc != null)
              {
                var initProps = initFunc(prop, value, element, comp, valueAccessor, 
                                         allBindingsAccessor, bindingContext) || {};
                oj.CollectionUtils.copyInto(propertyMap, initProps);
              }
            }
            else
            {
              propertyMap[prop] = value;
            }
          }
          // this is a real change
          else if (!disposed)
          {
            var v = oj.ComponentBinding._toJS(valueAccessor()[prop]);
            
            if (managedAttrMap[prop] != null)
            {
              var updateFunc = managedAttrMap[prop].update;
              if (updateFunc != null) 
              {
                var updateProps = updateFunc(prop, v, element, comp, valueAccessor, 
                                              allBindingsAccessor, bindingContext) || {}, p;
                for (p in updateProps)            
                {
                  if (updateProps.hasOwnProperty(p)) {
                    tracker.addChange(p, updateProps[p]);
                  }
                }
              }
            }
            else
            {
            
              tracker.addChange(prop, v);
            }
          }
          
          return null;
        };
      
      var p;
      for (p in options)
      {
        if (options.hasOwnProperty(p))
        {
          if (p !== roleAttrName)
          {
            // ko.computed is used to set up dependency tracking for the bindings's attribute
            // Any observable evaulated during the initial invocation of the function is going to be treated as a dependency
            // by Knockout. Once that dependency changes, the fuction below will be called again, in which case we will know
            // to deliver the change
            registeredListers.push(
                ko.computed(handler, {_property: p}/* 'this' object for the 'read' function*/,
                    {'disposeWhenNodeIsRemoved' : element}));
          }
            
        }
      }
      
      oj.ComponentBinding._registerWritebacks(jelem, componentName, writablePropMap, 
                                              valueAccessor, bindingMap, tracker,
                                              bindingContext);
      
      comp(propertyMap);
      
      var createCallback = this._bindingOptions['afterCreate'];
      if (createCallback)
      {
        createCallback(element, comp, valueAccessor, allBindingsAccessor, bindingContext);
      }
      
      propertyMap = null;
    }
    else
    {
      oj.Logger.error("Component %s is not found", componentName);
    }
  }
  
  stage = 1; // after init
};

// Returns a map of the custom binding's properties. Each key is the property name,
// and each value is a string representation of the property expression
/**
 * @private
 */
oj.ComponentBinding._getBindingValueMap = function(names, elem, bindingContext) 
{
  var map = {},
      bindingValue = null,
      provider = ko.bindingProvider.instance,
      keyValueArray, stringTrimRegex, n, e,
      selfVal = null, i, keyValueEntry;

  if (provider.getBindingsString) 
  {
    bindingValue = provider.getBindingsString(elem, bindingContext);  
  }
  else
  {
    bindingValue = elem.getAttribute("data-bind");
  }
  
  if (!bindingValue) {
    return map;
  }
  
  keyValueArray = ko.jsonExpressionRewriting.parseObjectLiteral(bindingValue);
  
  stringTrimRegex = /^(\s|\u00A0)+|(\s|\u00A0)+$/g;
  
  for (i=0; i<keyValueArray.length; i=i+1) 
  {
    keyValueEntry = keyValueArray[i];
    
    var bindingKey = keyValueEntry['key'].replace(stringTrimRegex, '');
    
    if (names.indexOf(bindingKey) >= 0) 
    {
      selfVal = keyValueEntry['value'];
      break;
    }
  }
  
  if (!selfVal) {
    return map;
  }
  
  // now parse this binding's key/value pairs
  keyValueArray = ko.jsonExpressionRewriting.parseObjectLiteral(selfVal);
  
  
  for (n=0; n<keyValueArray.length; n=n+1) 
  {
    e = keyValueArray[n];
    map[e['key'].replace(stringTrimRegex, '')] = e['value'].replace(stringTrimRegex, '');  
  }
  
  return map;
};


// Evaluates an individual custom binding property expression
/**
 * @private
 */
oj.ComponentBinding._evaluatePropertyExpression = function(expOrCallback, key, cache, bindingContext) 
{
  var evaluator = cache[key];
  
  if (evaluator === undefined)
  {
    if (typeof expOrCallback !== "string")
    {
      expOrCallback = expOrCallback();
    }
    
    evaluator = null;
    
    if (expOrCallback !== null)
    {
      /*jslint evil:true */
      evaluator = new Function("$context", "with($context){with($data||{}){return " + expOrCallback + ";}}");
    }
    
    cache[key] = evaluator;
  }
  
  return evaluator ? evaluator(bindingContext) : null;
};

/**
 * @private 
 */
function _extractValueFromChangeEvent(event, eventData) 
{
  var prop = 'value';
  var nameVal = {};
  nameVal[prop] = eventData[prop];
  return nameVal;
};

/**
 * @private 
 */
function _extractOptionChange(event, eventData)
{
  var nameVal = {};
  var metadata = eventData['optionMetadata'];
  var shouldWrite = metadata ? "shouldWrite" === metadata['writeback']: false;
  if (shouldWrite)
  {
    nameVal[eventData['option']] = eventData['value'];  
  }
  return nameVal;
};

/**
 * @private
 */
oj.ComponentBinding.prototype._getManagedAttributes = function(bindingMap, componentName)
{
  return oj.ComponentBinding._resolveManagedAttributes(this._managedAttrOptions, bindingMap, componentName);
}

/**
 * @private
 */
oj.ComponentBinding._resolveManagedAttributes = function(optionMap, bindingMap, componentName)
{
  var managedAttrMap = {};
  
  var applicableOptions = [];
  
  
  var traverseOptions = function(name)
  {
    var opt = optionMap[name];
    if (opt != null)
    {
      applicableOptions.push(opt);
      var parents = opt['use'], i;
      if (parents != null)
      {
        parents = Array.isArray(parents) ? parents : [parents];
        for (i=0; i<parents.length; i++)
        {
          traverseOptions(parents[i]);
        }
      }
    }
  };
  
  traverseOptions(componentName);
  
  var global = optionMap['@global'], attr, n;
  
  if (global)
  {
    applicableOptions.push(global);
  }
  
  if (applicableOptions.length > 0)
  {
    for (attr in bindingMap)
    {
      if (bindingMap.hasOwnProperty(attr)) {
        for (n=0; n<applicableOptions.length; n++)
        {
          var opts  = applicableOptions[n];
          var attributes = opts['attributes'];

          if (attributes != null && attributes.indexOf(attr) >= 0)
          {
            managedAttrMap[attr] = {init: opts['init'], update:opts['update']};
            break;
          }
        }
      }
    }
  }
  
  return managedAttrMap;
};

/**
 * @private
 */
oj.ComponentBinding._HANDLER_NAMESPACE = ".ojWriteback";

/**
 * @private
 */
oj.ComponentBinding._unregisterWritebacks = function(jelem)
{
  if (jelem)
  {
    jelem.off(oj.ComponentBinding._HANDLER_NAMESPACE);
  }
}

/**
 * @private
 */
oj.ComponentBinding._registerWritebacks = function(jelem, componentName, writablePropMap, 
                                                   valueAccessor, bindingMap, tracker,
                                                   bindingContext)
{
  var cachedPropertyExpressionWriters = {};
  
  for (var pattern in writablePropMap)
  {
    if (componentName.match(pattern))
    {
      var eventInfos = writablePropMap[pattern];
      for (var i=0; i<eventInfos.length; i++)
      {
        var info = eventInfos[i];
        
        jelem.on(
          info['event'] + oj.ComponentBinding._HANDLER_NAMESPACE,
          { //JQuery will pass this object as event.data
            getter: info['getter']
          },
          function(evt, data)
          {
            // Prevent bubbling to parent DOM elements. Other event handlers will still be called
            evt.stopPropagation();
            
            var nameValues = evt.data.getter(evt, data);
            
            tracker.suspend();
            
            try
            {
              for (var name in nameValues)
              {
                oj.ComponentBinding._writeValueToProperty(name, 
                                                          valueAccessor()[name], 
                                                          nameValues[name],
                                                          bindingMap[name],
                                                          bindingContext,
                                                          cachedPropertyExpressionWriters);
              }
            }
            finally
            {
              tracker.resume();
            }
          }
        );
      }
      
      break;  
    }
  }
      
};

/**
 * @private
 */
oj.ComponentBinding._getPropertyWriterExpression = function(expression)
{ 
  var reserveddWords = ["true", "false", "null", "undefined"];
  
  if (expression == null || reserveddWords.indexOf(expression) >= 0)
  {
    return null;
  }

  // Matches something that can be assigned to--either an isolated identifier or something ending with a property accessor
  // This is designed to be simple and avoid false negatives, but could produce false positives (e.g., a+b.c).
  // This also will not properly handle nested brackets (e.g., obj1[obj2['prop']]; see #911).
  var assignmentTarget = /^(?:[$_a-z][$\w]*|(.+)(\.\s*[$_a-z][$\w]*|\[.+\]))$/i;

  var match = expression.match(assignmentTarget);
  
  if (match === null)
  {
    return null;
  }
  
  var target = match[1] ? ('Object(' + match[1] + ')' + match[2]) : expression;
  
  return 'function(v){' + target + '=v;}';
};

/**
 * @private
 */
oj.ComponentBinding._writeValueToProperty = function(name, property, value,
                                                     propertyExpression,
                                                     bindingContext, 
                                                     cachedPropertyExpressionWriters)
{  
  if (property == null || !ko.isObservable(property))
  {    
    var func = oj.ComponentBinding._evaluatePropertyExpression(
      function()
      {
        return oj.ComponentBinding._getPropertyWriterExpression(propertyExpression);
      },
      name, 
      cachedPropertyExpressionWriters, 
      bindingContext);
    
    if (func)
    {
      func(value);
    }
  
  }
  else if (ko.isWriteableObservable(property))
  {
    property(value);
  }
};


/**
 * @private
 */
oj.ComponentBinding._toJS = function(prop) 
{
  // ko.toJS creates a cloned object for both plain javascript objects and Object subclasses. We need to avoid it
  // for the latter case to ensure that complex Model objects can be used as binding properties without being cloned
  
  prop = ko.utils.unwrapObservable(prop);
  
  if ((Array.isArray(prop) || oj.CollectionUtils.isPlainObject(prop)) && prop['ojConvertToJS'])
  {
    prop = ko.toJS(prop);
  }

  return prop;
};


/**
 * @private
 * @constructor
 * Global Change Queue Implementation
 * The queue is used to delay component updates until all model changes have been propagated
 * This is a private class that does not need to be xported
 */
function GlobalChangeQueue()
{
  this.Init();
}

// Subclass from oj.Object 
oj.Object.createSubclass(GlobalChangeQueue, oj.Object, "ComponentBinding.GlobalChangeQueue");

GlobalChangeQueue.prototype.Init = function()
{
  GlobalChangeQueue.superclass.Init.call(this);
  this._callbacks = [];
};

GlobalChangeQueue.prototype.registerComponentChanges = function(changesCallback)
{
  if (this._callbacks.indexOf(changesCallback) === -1)
  {
    this._callbacks.push(changesCallback);
    if (!this._delayTimer)
    {
      this._delayTimer = setTimeout(oj.Object.createCallback(this, this._deliverChangesImpl), 1);
    }
  }
};

GlobalChangeQueue.prototype.removeComponentChanges = function(changesCallback)
{
  var index = this._callbacks.indexOf(changesCallback);
  if (index >= 0)
  {
    this._callbacks.splice(index, 1);
  }
};

GlobalChangeQueue.prototype.deliverChanges = function()
{
  if (this._delayTimer)
  {
    clearTimeout(this._delayTimer);
  }
  this._deliverChangesImpl();
};

GlobalChangeQueue.prototype._deliverChangesImpl = function()
{
  var i;
  this._delayTimer = null;
  
  try
  {
    for (i=0; i<this._callbacks.length; i=i+1)
    {
      this._callbacks[i]();
    }
  }
  finally
  {
    this._callbacks = [];
  }
};

/**
 * @private
 * @constructor
 * Keeps track of changes for a single component
 */
function ComponentChangeTracker(component, element, queue)
{
  this.Init(component, element, queue);
}

// Subclass from oj.Object 
oj.Object.createSubclass(ComponentChangeTracker, oj.Object, "ComponentBinding.ComponentChangeTracker");

/**
 * @param {Function} component
 * @param {Element} element
 * @param {Object} queue
 */
ComponentChangeTracker.prototype.Init = function(component, element, queue)
{
  ComponentChangeTracker.superclass.Init.call(this);
  this._component = component;
  this._element = element;
  this._queue = queue;
  this._updateCallback = oj.Object.createCallback(this,this._applyUpdates);
  this._changes = {};
  this._suspendCount = 0;
};


ComponentChangeTracker.prototype.addChange = function(property, value)
{
  if (this._isSuspended() || this._disposed)
  {
    return;
  }
  this._changes[property] = value;
  this._queue.registerComponentChanges(this._updateCallback);
};

ComponentChangeTracker.prototype.dispose = function()
{
  this._queue.removeComponentChanges(this._updateCallback);
  this._disposed = true;
};

ComponentChangeTracker.prototype.resume = function()
{
  oj.Assert.assert(this._suspendCount > 0, "ComponentChangeTracker._suspendCount underflow");
  this._suspendCount = this._suspendCount-1;
};

ComponentChangeTracker.prototype.suspend = function()
{
  this._suspendCount = this._suspendCount-1;
};

ComponentChangeTracker.prototype._isSuspended = function()
{
  return (this._suspendCount >= 1);
};

ComponentChangeTracker.prototype._applyUpdates = function()
{
  try
  {
    // Check if the component is still "alive"
    if (oj.Components.getWidgetConstructor(this._element) != null)
    {
      this._component("option", this._changes); 
    }
  }
  finally
  {
    this._changes = {};
  }
};


/**
 * @private
 */
oj.ComponentBinding._changeQueue = new GlobalChangeQueue();

/**
 * @private
 */
oj.ComponentBinding._INSTANCE = oj.ComponentBinding.create(["ojComponent", "jqueryUI"]);

//
// Define a template source that allows the use of a knockout array (ko[])
// to provide storage for a template string.
//
// This simplifies template assignment and template usage for the user, as shown in the following example:
//
// Template Assignment:
//
//   ko.templates["myKey"] = templateText;
//
// Template Usage:
//
//   <div data-bind="template: {name: myKey}">
//
/*jslint browser: true*/

/**
 * @export
 */
oj.koStringTemplateEngine = {};

/**
 * @export
 */
oj.koStringTemplateEngine.install = function() 
{
    //define a template source that tries to key into an object first to find a template string

    var _templateText = {}; // Stores the text property for the template object.
    var _templateData = {}; // Stores the data property for the template object.

    // data = {},
    var _engine = new ko['nativeTemplateEngine']();

    /**
     *  @constructor
     *  @private
     */

    var StringTemplate = function(template) {

        this._templateName = template;

        this.text = function(value) 
	{
	    // When passed no parameters, return the template object.
            if (!value)
	    {
                return _templateText[this._templateName];
            }

            _templateText[this._templateName] = value;
        };

        this.data = function(key, value)
	{

            if (!_templateData[this._templateName]) {
		_templateData[this._templateName] = {};
            }

            if (arguments.length === 1) {
                return _templateData[this._templateName][key];
            }

            _templateData[this._templateName][key] = value;
        };
    };

    //
    // Override knockout's makeTemplateSource(), returning the new stringTemplate 
    //
    _engine['makeTemplateSource'] = function(template, templateDocument)
    {
	if (typeof template == "string") 
	{
            templateDocument = templateDocument || document;
            var elem = templateDocument.getElementById(template);

            if (elem) 
	    {
		return new ko['templateSources']['domElement'](elem);
	    }
            return new StringTemplate(template);
	}
        if ((template && (template.nodeType == 1)) || (template.nodeType == 8)) 
	{
            return new ko['templateSources']['anonymousTemplate'](template);
        }
    };

    //make the templates accessible
    // ko.templates = _templateText;
    ko.templates = _templateText;

    //make this new template engine our default engine
    ko['setTemplateEngine'](_engine);
};


/**
 * Returns a header renderer function executes the template specified in the binding attribute.
 * (for example, a knockout template).
 * @param {Object} bindingContext the ko binding context
 * @param {string} template the name of the template
 * @return {Function} the renderer function
 * @private
 */
function _getDataGridHeaderRenderer(bindingContext, template)
{
    return function(context)
    {
        var parent, childContext;

        parent = context['parentElement'];
        // runs the template
        // runs the template
        childContext = bindingContext['createChildContext'](context['data'], null, 
                           function(binding)
                           {
                               binding['$key'] = context['key'];
                               binding['$metadata'] = context['metadata'];
                               binding['$headerContext'] = context;
                           }
                       );
        ko['renderTemplate'](template, childContext, null, parent);

        // tell the datagrid not to do anything
        return null;
    };
}

/**
 * Returns a cell renderer function executes the template specified in the binding attribute.
 * (for example, a knockout template).
 * @param {Object} bindingContext the ko binding context
 * @param {string} template the name of the template
 * @return {Function} the renderer function
 * @private
 */
function _getDataGridCellRenderer(bindingContext, template)
{
    return function(context)
    {
        var parent, childContext;

        parent = context['parentElement'];
        // runs the template
        childContext = bindingContext['createChildContext'](context['data'], null, 
                           function(binding)
                           {
                               binding['$keys'] = context['keys'];
                               binding['$metadata'] = context['metadata'];
                               binding['$cellContext'] = context;
                           }
                       );
        ko['renderTemplate'](template, childContext, null, parent);

        // tell the datagrid not to do anything
        return null;
    };
}

oj.ComponentBinding.getDefaultInstance().setupManagedAttributes(
{
  'attributes': ["header", "cell"],
  'init': function(name, value, element, widgetConstructor, valueAccessor, allBindingsAccessor, bindingContext)
  {
    var row, rowTemplate, column, columnTemplate, cellTemplate;
    if (name === "header")
    {
        // find row template and creates a renderer
        row = value['row'];
        if (row != null)
        {
            rowTemplate = row['template'];
            if (rowTemplate != null)
            {
                row['renderer'] = _getDataGridHeaderRenderer(bindingContext, rowTemplate);
            }
        }

        // find column template and creates a renderer
        column = value['column'];
        if (column != null)
        {
            columnTemplate = column['template'];
            if (columnTemplate != null)
            {
                column['renderer'] = _getDataGridHeaderRenderer(bindingContext, columnTemplate);
            }
        }

        widgetConstructor({'header': value});
    }
    else if (name === "cell")
    {
        // find the cell template and creates a renderer
        cellTemplate = value['template'];
        if (cellTemplate != null)
        {
            value['renderer'] = _getDataGridCellRenderer(bindingContext, cellTemplate);
        }
        widgetConstructor({'cell': value});
    }
  },
  'update': function(name, value, element, widgetConstructor, valueAccessor, allBindingsAccessor, bindingContext)
  {
    var row, rowTemplate, column, columnTemplate, cellTemplate;
    if (name === "header")
    {
        // find row template and creates a renderer
        row = value['row'];
        if (row != null)
        {
            rowTemplate = row['template'];
            if (rowTemplate != null)
            {
                row['renderer'] = _getDataGridHeaderRenderer(bindingContext, rowTemplate);
            }
        }

        // find column template and creates a renderer
        column = value['column'];
        if (column != null)
        {
            columnTemplate = column['template'];
            if (columnTemplate != null)
            {
                column['renderer'] = _getDataGridHeaderRenderer(bindingContext, columnTemplate);
            }
        }

        return {'header': value};
    }
    else if (name === "cell")
    {
        // find the cell template and creates a renderer
        cellTemplate = value['template'];
        if (cellTemplate != null)
        {
            value['renderer'] = _getDataGridCellRenderer(bindingContext, cellTemplate);
        }
        return {'cell': value};
    }
    return null;
  },
      
  'for': 'ojDataGrid'
});

/*jslint browser: true, devel: true*/

// TODO: do we have JSDoc / API doc for bindings?  (Latest answer: no for now, just doc it briefly in baseComponent's contextMenu option for now.)
// TODO: split up init and update so get from DOM on init only, and update only sets it on DOM.  That way, 
//       can update observable to null, without having to additionally clear DOM attr to avoid having it restored from DOM attr.
//       Vet with Max first.
// TODO: keep binding and DOM in synch, a la disabled option in JQUI, similar to todo for contextMenu feature on JET base class.
// TODO: share code with baseComponent._setupContextMenu?  Should this have any of the configurability of that method?
//       where would shared code live?
ko.bindingHandlers['ojContextMenu'] = 
{
  'update': function (element, valueAccessor, allBindings, viewModel, bindingContext) 
  {
    var eventNamespace = ".ojContextMenu";
    $(element).off( eventNamespace );

    var menu = ko.utils.unwrapObservable(valueAccessor());
    // menu is selector like "#myMenuId", or null, or some malformed thing.

    if ($.type(menu) !== "string")
    {
      menu = element.getAttribute("contextmenu");
      if (menu)
        menu = "#" + menu;
    }

    if (menu) 
      menu = $(menu).data( "oj-ojMenu" );// if selector finds >1 element, .data() uses the first one.
                                            // if selector finds 0 elements, .data() returns nothing.
    
    if ( menu )
    {
      var $element = $(element);
      $element.on( "keydown" + eventNamespace + " " + "contextmenu" + eventNamespace, function( event ) {
        if (event.type === "contextmenu" || (event.which == 121 && event.shiftKey)) // right-click or Shift-F10
        {
          menu.show(event, {"launcher": $element, "focus": "menu"});
          return false; // Don't show native context menu
        }

        return true;
      });
    }
        
//  if (!menu)
      // TODO: Max suggested logging a warning if menu is null.  Since setting null is the way you would turn off the ContextMenu functionality, 
      // should we really log?  If so, warning or just info?
  }
};



/*jslint browser: true, devel: true*/

/** 
 * @private
 * @const
 */
var _COLUMNS_ATTR = 'columns';

/** 
 * @private
 * @const
 */
var _COLUMNS_DEFAULT_ATTR = 'columnsDefault';

/** 
 * The row template will be used to render the row elements. 
 * The row, status, and component objects will be available 
 * in the template context.
 * @private
 * @const
 */
var _ROW_TEMPLATE_ATTR = 'rowTemplate';

/**
 * Create and return a renderer which the component will call. That renderer
 * will render the template.
 * @param {Object} bindingContext  Binding Context
 * @param {string} type  'cell' or 'header' or 'row'
 * @param {string} template  template name
 * @return {Object} Renderer
 * @private
 */
function _getTableColumnTemplateRenderer(bindingContext, type, template)
{
  var rendererOption = {};
  (function(template, type) {
    rendererOption = function(params) {
      var childContext = null;
      var parentElement = null;
      if (type == 'header')
      {
        // calling bindingContext.extend() creates a context with 
        // new properties without adding extra level to the parent hierarchy
        childContext = bindingContext['extend']({'$column': params['column'],
          '$headerContext': params['headerContext']});
        parentElement = params['headerContext']['parentElement'];
      }
      else if (type == 'cell')
      {
        var childData = params['row'];
        childContext = bindingContext['createChildContext'](childData, null,
          function(binding)
          {
            binding['$column'] = params['column'];
            binding['$cellContext'] = params['cellContext'];
          }
        );
        parentElement = params['cellContext']['parentElement'];
      }
      if (type == 'footer')
      {
        // calling bindingContext.extend() creates a context with 
        // new properties without adding extra level to the parent hierarchy
        childContext = bindingContext['extend']({'$column': params['column'],
          '$footerContext': params['footerContext']});
        parentElement = params['footerContext']['parentElement'];
      }
      ko['renderTemplate'](template, childContext, null, parentElement, 'replaceNode');
    };
  }(template, type));

  return rendererOption;
}

/**
 * Create and return a renderer which the component will call. That renderer
 * will render the template.
 * @param {string} template  template name
 * @return {Object} Renderer
 * @private
 */
function _getTableRowTemplateRenderer(bindingContext, template)
{
  return function(params) {
    var childData = params['row'];
    var childContext = bindingContext['createChildContext'](childData, null,
      function(binding)
      {
        binding['$rowContext'] = params['rowContext'];
      }
    );
    ko['renderTemplate'](template, childContext, null, params['rowContext']['parentElement'], 'replaceNode');
  };
}

oj.ComponentBinding.getDefaultInstance().setupManagedAttributes(
  {
    'attributes': [_COLUMNS_ATTR, _COLUMNS_DEFAULT_ATTR, _ROW_TEMPLATE_ATTR],
    'init': function(name, value, element, widgetConstructor, valueAccessor,
      allBindingsAccessor, bindingContext)
    {
      if (name == _COLUMNS_ATTR || name == _COLUMNS_DEFAULT_ATTR)
      {
        var i, template, footerTemplate, headerTemplate;
        for (i = 0; i < value.length; i++)
        {
          var column = value[i];
          template = column['template'];
          footerTemplate = column['footerTemplate'];
          headerTemplate = column['headerTemplate'];

          if (template != null)
          {
            column['renderer'] = _getTableColumnTemplateRenderer(bindingContext, 'cell', template);
          }
          if (footerTemplate != null)
          {
            column['footerRenderer'] = _getTableColumnTemplateRenderer(bindingContext, 'footer', footerTemplate);
          }
          if (headerTemplate != null)
          {
            column['headerRenderer'] = _getTableColumnTemplateRenderer(bindingContext, 'header', headerTemplate);
          }
        }
        if (name == _COLUMNS_ATTR)
        {
          widgetConstructor({'columns': value});
        }
        else
        {
          widgetConstructor({'columnsDefault': value});
        }
      }
      else if (name == _ROW_TEMPLATE_ATTR)
      {
        widgetConstructor({'rowRenderer': _getTableRowTemplateRenderer(bindingContext, value)});
      }
    },
    'update': function(name, value, element, widgetConstructor, valueAccessor,
      allBindingsAccessor, bindingContext)
    {
      if (name == _COLUMNS_ATTR || name == _COLUMNS_DEFAULT_ATTR)
      {
        var i, template, footerTemplate, headerTemplate;
        for (i = 0; i < value.length; i++)
        {
          var column = value[i];
          template = column['template'];
          footerTemplate = column['footerTemplate'];
          headerTemplate = column['headerTemplate'];

          if (template != null)
          {
            column['renderer'] = _getTableColumnTemplateRenderer(bindingContext, 'cell', template);
          }
          if (footerTemplate != null)
          {
            column['footerRenderer'] = _getTableColumnTemplateRenderer(bindingContext, 'footer', footerTemplate);
          }
          if (headerTemplate != null)
          {
            column['headerRenderer'] = _getTableColumnTemplateRenderer(bindingContext, 'header', headerTemplate);
          }
        }
        if (name == _COLUMNS_ATTR)
        {
          widgetConstructor({'columns': value});
        }
        else
        {
          widgetConstructor({'columnsDefault': value});
        }
      }
      else if (name == _ROW_TEMPLATE_ATTR)
      {
        return {'rowRenderer': _getTableRowTemplateRenderer(bindingContext, value)};
      }
      return null;
    },
    'for': 'ojTable'
  });

/*jslint browser: true*/

/**
 * @export
 * @class oj.DataSource
 * @classdesc Object representing data used by table and grid components
 * @property {Object} data data supported by the components
 * @param {Object} data data supported by the components
 * @constructor
 */
oj.DataSource = function(data)
{
    this.data = data;
    this.Init();
};

// Subclass from oj.Object 
oj.Object.createSubclass(oj.DataSource, oj.Object, "oj.DataSource");

/**
 * Initializes the instance.
 * @export
 */
oj.DataSource.prototype.Init = function()
{
    this._eventHandlers = [];
    oj.DataSource.superclass.Init.call(this);
};

/**
 * Attach an event handler to the datasource
 * @param {string} eventType eventType supported by the datasource
 * @param {function(Object)} eventHandler event handler function
 * @export
 */
oj.DataSource.prototype.on = function(eventType, eventHandler)
{
    var foundEventHandler = false, i;
    for (i = 0; i < this._eventHandlers.length; i++)
    {
        if (this._eventHandlers[i]['eventType'] == eventType && 
            this._eventHandlers[i]['eventHandlerFunc'] == eventHandler)
        {
            foundEventHandler = true;
            break;
        }
    }
    if (!foundEventHandler) {
        this._eventHandlers.push({'eventType': eventType, 'eventHandlerFunc': eventHandler});
    }
};

/**
 * Detach an event handler from the datasource
 * @param {string} eventType eventType supported by the datasource
 * @param {function(Object)} eventHandler event handler function
 * @export
 */
oj.DataSource.prototype.off = function(eventType, eventHandler)
{
    var i;
    for (i = this._eventHandlers.length-1; i >= 0; i--)
    {
        if (this._eventHandlers[i]['eventType'] == eventType && 
            this._eventHandlers[i]['eventHandlerFunc'] == eventHandler)
        {
            this._eventHandlers.splice(i, 1);
            break;
        }
    }
};

/**
 * Handle the event
 * @param {string} eventType  event type
 * @param {Object} event  event
 * @export
 */
oj.DataSource.prototype.handleEvent = function(eventType, event)
{
    var i;
    for (i = 0; i < this._eventHandlers.length; i++)
    {
        var eventHandler = this._eventHandlers[i];
        if (eventHandler['eventType'] == eventType)
        {
            eventHandler['eventHandlerFunc'](event);
        }
    }
};


/**
 * Base class for all tree structure DataSource
 * @param {Object} data data supported by the component
 * @export
 */
oj.TreeDataSource = function(data)
{
    oj.TreeDataSource.superclass.constructor.call(this, data);
};


// Subclass TreeDataSource to DataSource
oj.Object.createSubclass(oj.TreeDataSource, oj.DataSource, "oj.TreeDataSource");

/**
 * Returns the number of children for a specified parent.  If the value returned is not >= 0 then it is automatically assumed
 * that the child count is unknown.
 * @param {Object} parent the parent key.  Specify null if inquiring child count of the root.
 * @return {number} the number of children for the specified parent.
 */
oj.TreeDataSource.prototype.getChildCount = function(parent)
{
    return -1;
};

/**
 * Fetch the children
 * @param {Object} parent the parent key.  Specify null if fetching children from the root.
 * @param {Object} range information about the range, it must contain the following properties: start, count.
 * @param {number} range.start the start index of the range in which the children are fetched.
 * @param {number} range.count the size of the range in which the children are fetched.  
 * @param {Object} callbacks the callbacks to be invoke when fetch children operation is completed.  The valid callback
 *        types are "success" and "error".
 * @param {function(oj.NodeSet)} callbacks.success the callback to invoke when fetch completed successfully.
 * @param {function({status: Object})} callbacks.error the callback to invoke when fetch children failed.
 * @param {Object=} options optional parameters for this operation.
 * @param {boolean=} options.queueOnly true if this fetch request is to be queued and not execute yet.  The implementation must maintain 
 *        the order of the fetch operations.  When queueOnly is false/null/undefined, any queued fetch operations are then
 *        flushed and executed in the order they are queued.  This flag is ignored if the datasource does not support batching.
 * @export
 */
oj.TreeDataSource.prototype.fetchChildren = function(parent, range, callbacks, options)
{
    oj.Assert.failedInAbstractFunction();
};

/**
 * Fetch all children and their children recursively from a specified parent.
 * @param {Object} parent the parent key.  Specify null to fetch everything from the root (i.e. expand all)
 * @param {Object} callbacks the callbacks to be invoke when fetch children operation is completed.  The valid callback
 *        types are "success" and "error".
 * @param {function(oj.NodeSet)} callbacks.success the callback to invoke when fetch completed successfully.
 * @param {function({status: Object})} callbacks.error the callback to invoke when fetch children failed.
 * @param {Object=} options optional parameters for this operation.
 * @param {number=} options.start the index related to parent in which to begin fetching descendents from.  If this is not specified, then 
 * @param {number=} options.maxCount the maximum number of children to fetch.  If a non-positive number is specified, then the value is ignored and
 *        there is no maximum fetch count.
 * @export
 */
oj.TreeDataSource.prototype.fetchDescendents = function(parent, callbacks, options)
{
    oj.Assert.failedInAbstractFunction();
};

/**
 * Performs a sort operation on the tree data.
 * @param {Object} criteria the sort criteria.  It must contain the following properties: key, direction
 * @param {Object} criteria.key the key identifying the attribute (column) to sort on
 *        {string} criteria.direction the sort direction, valid values are "ascending", "descending", "none" (default)
 * @param {function()} callbacks.success the callback to invoke when the sort completed successfully.  
 * @param {function({status: Object})} callbacks.error the callback to invoke when sort failed.
 * @export
 */
oj.TreeDataSource.prototype.sort = function(criteria, callbacks)
{
    oj.Assert.failedInAbstractFunction();
};

/**
 * Returns the current sort criteria of the tree data.
 * @return {Object} the current sort criteria.  It should contain the following properties: key, direction where
 *         criteria.key the key identifying the attribute (column) to sort on.  Value is null if it's not sorted.
 *         criteria.direction the sort direction, valid values are "ascending", "descending", "none" (default)
 * @export
 */
oj.TreeDataSource.prototype.getSortCriteria = function()
{
    return {'key': null, 'direction': 'none'};
};

/**
 * Moves a row from one location to another (different position within the same parent or a completely different parent)
 * @param {Object} rowToMove the key of the row to move
 * @param {Object} referenceRow the key of the reference row which combined with position are used to determine 
 *        the destination of where the row should moved to.
 * @param {number|string} position The position of the moved row relative to the reference row.  
 *        This can be a string: "before", "after", "inside", "first", "last", or the zero based index to position 
 *        the element at a specific point among the reference row's current children.
 * @param {function()} callbacks.success the callback to invoke when the move completed successfully.  
 * @param {function({status: Object})} callbacks.error the callback to invoke when move failed.
 * @export
 */ 
oj.TreeDataSource.prototype.move = function(rowToMove, referenceRow, position, callbacks)
{
    oj.Assert.failedInAbstractFunction();
};

/**
 * Checks whether a move operation is valid.
 * @param {Object} rowToMove the key of the row to move
 * @param {Object} referenceRow the key of the reference row which combined with position are used to determine 
 *        the destination of where the row should moved to.
 * @param {number|string} position The position of the moved row relative to the reference row.  
 *        This can be a string: "before", "after", "inside", "first", "last", or the zero based index to position 
 *        the element at a specific point among the reference row's current children.
 * @return {string} returns "valid" if the move is valid, "invalid" otherwise.
 * @export
 */ 
oj.TreeDataSource.prototype.moveOK = function(rowToMove, referenceRow, position)
{
    return "valid";
};

/**
 * Determines whether this TreeDataSource supports the specified feature.
 * @param {string} feature the feature in which its capabilities is inquired.  Currently the valid features "sort", 
 *        "move", "fetchDescendents", "batchFetch"
 * @return {string|null} the name of the feature.  Returns null if the feature is not recognized.
 *         For "sort", the valid return values are: "default", "none".  
 *         For "fetchDescendents", the valid return values are: "enable", "disable", "suboptimal".  
 *         For "move", the valid return values are: "default", "none".  
 *         For "batchFetch", the valid return values are: "enable", "disable".  
 * @export
 */
oj.TreeDataSource.prototype.getCapability = function(feature)
{
    return null;
};
/**
 * Base class for FlattenedTreeDataGridDataSource and FlattenedTreeTableDataSource
 * @param {Object} treeDataSource the instance of TreeDataSource to flattened
 * @param {Object=} options the options set on the FlattenedDataSource
 * @constructor
 * @export
 */
oj.FlattenedTreeDataSource = function(treeDataSource, options)
{
    this.m_wrapped = treeDataSource;
    this.m_options = options;
    oj.FlattenedTreeDataSource.superclass.constructor.call(this);
};

// Make FlattenedTreeDataSource subclass of oj.DataSource
oj.Object.createSubclass(oj.FlattenedTreeDataSource, oj.DataSource, "oj.FlattenedTreeDataSource");

/**
 * Initializes the data source.
 * @export
 */
oj.FlattenedTreeDataSource.prototype.Init = function()
{
    var expanded;

    // super
    oj.FlattenedTreeDataSource.superclass.Init.call(this);

    // we have to react if the underlying TreeDataSource has changed
    this.m_wrapped.on('change', this._handleModelEvent.bind(this));

    // retrieves the fetch size against the underlying data source
    this.m_fetchSize = parseInt(this.m_options['fetchSize'], 10);
    if (isNaN(this.m_fetchSize))
    {
        this.m_fetchSize = 25;
    }
    // retrieves the maximum number of rows to fetch from the underlying data source
    // once the maximum count has been reached, this data source should stop fetching
    // until either a collapse occurs or a delete model change event.
    this.m_maxCount = parseInt(this.m_options['maxCount'], 10);
    if (isNaN(this.m_maxCount))
    {
        this.m_maxCount = 500;
    }

    // retrieves the initial expanded row keys.  If the expanded is specified to 'all',
    // then mark that all rows should be expanded initially.
    expanded = this.m_options['expanded'];
    if (Array.isArray(expanded))
    {
        this.m_expandedKeys = expanded;
    }
    else
    {
        if (expanded === 'all')
        {
            // if expand all, we'll need to keep track of collapsed keys instead
            this.m_collapsedKeys = [];
        }
        // keep track of expanded row keys
        this.m_expandedKeys = [];
    }

    // cache to keep track of indexes
    // PRIVATE.  Subclass should never need to access this directly.
    // and implementation might change to use different form of caching strategy.
    this.m_cache = [];
};

/**
 * Handle the event
 * @param {string} eventType  event type
 * @param {Object} event  event
 * @export
 */
oj.FlattenedTreeDataSource.prototype.handleEvent = function(eventType, event)
{
    oj.FlattenedTreeDataSource.superclass.handleEvent.call(this, eventType, event);
};

/**
 * Destory the data source.
 * @export
 */
oj.FlattenedTreeDataSource.prototype.Destory = function()
{
    // free internal cache
    delete this.m_cache;
    delete this.m_expandedKeys;

    // unload listener
    this.m_wrapped.off('change');

    // delegate to underlying data source
    if (this.m_wrapped.Destory)
    {
        this.m_wrapped.Destory();
    }
};

/**
 * Retrieves the expanded row keys
 * @return {Array.<Object>|string} an array of expanded row keys or 'all' if 
 *         all rows are expanded.
 * @export
 */
oj.FlattenedTreeDataSource.prototype.getExpandedKeys = function()
{
    return this.m_expandedKeys;
};

/**
 * Retreives the value of the specified option.
 * @param {string} option the option to retrieve the value.
 * @return {Object} the value of the specified option.  Returns null if the
 *         value is null or if the option is not recognized.
 * @export
 */
oj.FlattenedTreeDataSource.prototype.getOption = function(option)
{
    if (this.m_options != null)
    {
        return this.m_options[option];
    }

    // unrecoginzed option or no options set
    return null;
};

/**
 * Retrieves the underlying TreeDataSource.
 * @return {Object} the underlying oj.TreeDataSource.
 * @export
 */
oj.FlattenedTreeDataSource.prototype.getWrappedDataSource = function()
{
    return this.m_wrapped;
};

/**
 * Fetch a range of rows from the underlying data source.  This is a convenient method that
 * the subclasses should use to fetch from the underlying TreeDataSource.  This method will take
 * care of the index mapping between a flattened range to tree indexes.
 * @param {Object} range the range of rows to fetch.  This is the range in a flattened view.
 * @param {number} range.start the start of the range in a flattened view
 * @param {number} range.count the number of rows to fetch
 * @protected
 */ 
oj.FlattenedTreeDataSource.prototype.fetchRows = function(range, callbacks)
{
    // check if we should fetch rows from descendents result set or walk the tree
    // to retrieve children
    if (this._isExpandAll())
    {
        this._fetchRowsFromDescendents(range, callbacks);
    }
    else
    {
        this._fetchRowsFromChildren(range, callbacks);
    }
};

/**
 * Fetch a range of rows from the underlying TreeDataSource.  
 * @param {Object} range the range of rows to fetch.  This is the range in a flattened view.
 * @param {number} range.start the start of the range in a flattened view
 * @param {number} range.count the number of rows to fetch
 * @protected
 */ 
oj.FlattenedTreeDataSource.prototype._fetchRowsFromChildren = function(range, callbacks)
{
    var maxFetchSize, lastEntry, parent, count, index, depth, processed, nodeSet;

    // this condition should always be true since in high watermark scrolling we are
    // always asking for rows after the current last row
    if (range['start'] > this._getLastIndex())
    {
        maxFetchSize = this._getMaxFetchSize();
        // initial fetch
        if (this._getLastIndex() < 0)
        {
            // adjust fetch count if neccessary
            range['count'] = Math.min(maxFetchSize, range['count']);
            this.m_wrapped.fetchChildren(null, range, {"success": function(nodeSet){this._handleFetchSuccess(nodeSet, null, 0, range, 0, callbacks);}.bind(this)});

            return;
        }
        else if (maxFetchSize > 0)
        {
            lastEntry = this._getLastEntry();
            parent = lastEntry['parent'];
            count = this.m_wrapped.getChildCount(parent);
            index = lastEntry['index'];
            depth = lastEntry['depth'];

            // see if we are fetching within the parent
            if (count === -1 || index < count-1)
            {
                range['start'] = index+1;
                if (count === -1)
                {
                    range['count'] = this.m_fetchSize;
                }
                else
                {
                    range['count'] = Math.min(maxFetchSize, Math.min(this.m_fetchSize, count - range['start']));
                }
                this.m_wrapped.fetchChildren(parent, range, {"success": function(nodeSet){this._handleFetchSuccess(nodeSet, parent, depth, range, count, callbacks);}.bind(this)});
            }
            else if (index === count-1)
            {
                // if this is the last child within the parent, then we are done
                nodeSet = new oj.EmptyNodeSet(null, range['start']);
                // invoke original success callback
                if (callbacks != null && callbacks['success'] != null)
                {
                    callbacks['success'].call(null, nodeSet);
                }
            }
            else
            {
                // fetch size is greater than the number of children remaining to fetch
                // so we'll need to go up the path (recursively if necessary) and see if
                // if we need to fetch from ancestors.
                processed = this._fetchFromAncestors(parent, depth, callbacks, maxFetchSize);
                if (!processed)
                {
                    // nothing is used from node set, just return a empty node set
                    nodeSet = new oj.EmptyNodeSet(null, range['start']);
                    // invoke original success callback
                    if (callbacks != null && callbacks['success'] != null)
                    {
                        callbacks['success'].call(null, nodeSet);
                    }
                }
            }
            return;
        }
    }

    // the only case we'll ended up here is if the max count has been reached or
    // for some reason the caller is asking for count = 0
    this.handleMaxCountReached(range, callbacks);
};

/**
 * Determine the maximum possible fetch size.
 * @return {number} the maximum fetch size
 * @private
 */
oj.FlattenedTreeDataSource.prototype._getMaxFetchSize = function()
{
    return this.m_maxCount - (this._getLastIndex()+1);
};

/**
 * Process success callback for fetchChildren operation before handing it back to original caller.
 * @param {Object} nodeSet the set of fetched nodes
 * @param {Object} parent the parent key of the fetch operation
 * @param {number} depth the depth of the nodes
 * @param {Object} range the request range for the fetch operation
 * @param {number} count the child count of the parent, -1 if count is unknown
 * @param {Object} callbacks the original callbacks passed to the fetch operation
 * @private
 */
oj.FlattenedTreeDataSource.prototype._handleFetchSuccess = function(nodeSet, parent, depth, range, count, callbacks)
{
    var toExpand, processed;

    // handle result nodeSet
    toExpand = [];
    // wrap it to inject additional metadata
    nodeSet = new oj.NodeSetWrapper(nodeSet, this.insertMetadata.bind(this), range);
    this._processNodeSet(nodeSet, parent, depth, toExpand);

    // if child count is unknown and the result fetched from parent is less than what we asked for 
    // and it's not a root node, go up one level and try to fetch results from its grandparent
    if (count === -1 && nodeSet.getCount() === 0 && parent != null && depth > 0)
    {
        processed = this._fetchFromAncestors(parent, depth, callbacks);
        if (!processed)
        {
            // if nothing is fetched from ancestors, then just return the original empty set
            if (callbacks != null && callbacks['success'] != null)
            {
                callbacks['success'].call(null, nodeSet);
            }
        }
    }
    else
    {
        // invoke original success callback
        if (callbacks != null && callbacks['success'] != null)
        {
            callbacks['success'].call(null, nodeSet);
        }

        // see if there's rows that need to be expand
        this._expandRows(toExpand);
    }
};

/**
 * Go up ancestors and fetch build up fetch requests (if possible) until the fetch size is met.
 * @param {Object} parent the parent key of the fetch operation
 * @param {number} depth the depth of the nodes
 * @param {Object} callbacks the original callbacks passed to the fetch operation
 * @param {number=} maxFetchSize maximum fetch size, optional
 * @return {boolean} true if results are fetched, false if nothing is fetched
 * @private
 */
oj.FlattenedTreeDataSource.prototype._fetchFromAncestors = function(parent, depth, callbacks, maxFetchSize)
{
    var options, remainToFetch, current, i, currEntry, currDepth, count, index, countUnknown, range;

    if (maxFetchSize === undefined)
    {
        maxFetchSize = this._getMaxFetchSize();
    }

    // fetch size is greater than the number of children remaining to fetch
    // so we'll need to go up the path (recursively if necessary) and see if
    // if we need to fetch from ancestors.
    if (this._isBatchFetching())
    {
        options = {'queueOnly': true};
    }

    remainToFetch = this.m_fetchSize;
    current = this._getLastIndex();
    for (i=current-1; i>=0; i--)
    {
        currEntry = this._getEntry(i);
        currDepth = currEntry['depth'];
        if (currDepth < depth)
        {
            parent = currEntry['parent'];
            count = this.m_wrapped.getChildCount(parent);
            index = currEntry['index'];

            countUnknown = (count === -1);
            if (countUnknown || index < count-1)
            {
                range = {};
                range['start'] = index+1;
                if (countUnknown)
                {
                    range['count'] = Math.min(maxFetchSize, Math.max(0, remainToFetch));
                    // if count is unknown, we cannot do batch fetch
                    options = undefined;
                    // stop going up parents
                }
                else
                {
                    range['count'] = Math.min(maxFetchSize, Math.min(remainToFetch, count - range['start']));
                }

                // if there's nothing to fetch, quit
                if (range['count'] == 0)
                {
                    break;
                }
                
                // it's always attached at the end
                this.m_wrapped.fetchChildren(parent, range, {"success": function(nodeSet){this._handleFetchSuccess(nodeSet, parent, currDepth, range, count, callbacks);}.bind(this)}, options);

                // go up one level
                depth = currDepth;
                // update remaining fetch count
                remainToFetch = Math.max(0, remainToFetch - range['count']);

                // done if count is unknown or we've reach the root or we've reach total number of rows we want to fetch
                if (countUnknown || currDepth === 0 || remainToFetch === 0)                
                {
                    break;
                }
            }
        }
    }            

    // if batching is used, fire a final fetch children call to flush the queue
    if (options != undefined)
    {
        this.m_wrapped.fetchChildren(parent, {'start': range['count'], 'count': 0}, {"success": function(nodeSet){this._handleFetchSuccess(nodeSet, parent, currDepth, range, count, callbacks);}.bind(this)});
    }

    // return false if no results are fetched
    return (remainToFetch != this.m_fetchSize);
};

/**
 * Walk the node set and do whatever processing is neccessary.
 * @param {Object} nodeSet the node set to process
 * @param {Object} parent the parent key of the nodes
 * @param {number} depth the depth of the nodes
 * @param {Array.<Object>=} toExpand the set of keys to be expand.  It is populated by this method.
 * @private
 */
oj.FlattenedTreeDataSource.prototype._processNodeSet = function(nodeSet, parent, depth, toExpand)
{
    var nodeStart, nodeCount, i, metadata, key;

    nodeStart = nodeSet.getStart();
    nodeCount = nodeSet.getCount();

    // walk the node set and populate the internal cache
    for (i=0; i<nodeCount; i++)
    {
        metadata = nodeSet.getMetadata(nodeStart+i);
        key = metadata['key'];

        this._addEntry(key, depth, nodeStart+i, parent);

        if (this._isExpanded(key))
        {
            // keep track of rows that needs to expand later
            toExpand.push(key);
        }
    }
};

/**
 * A hook for FlattenedTreeDataSource to inject additional metadata into the NodeSet
 * @param {Object} key the row key identifying the row
 * @param {Object} metadata the existing metadata to inject into
 * @protected
 */
oj.FlattenedTreeDataSource.prototype.insertMetadata = function(key, metadata)
{
    if (this._isExpanded(key) && !metadata['leaf'])
    {
        // also update metadata with state info
        metadata['state'] = 'expanded';
    }
    else
    {
        // include state metadata for row expander to render correct icon
        if (metadata['leaf'])
        {
            metadata['state'] = 'leaf';
        }
        else
        {
            metadata['state'] = 'collapsed';
        }
    }
};

/**
 * Fetch a range of rows from the underlying TreeDataSource using the fetchDescendents method.
 * @param {Object} range the range of rows to fetch.  This is the range in a flattened view.
 * @param {number} range.start the start of the range in a flattened view
 * @param {number} range.count the number of rows to fetch
 */ 
oj.FlattenedTreeDataSource.prototype._fetchRowsFromDescendents = function(range, callbacks)
{
    // give implementation a hint of maximum to fetch, implementation can choose to ignore it
    var options = {'maxCount': this.m_maxCount};

    // give implementation a hint of where to start, implementation can choose to ignore it
    if (this._getLastIndex() >= 0)
    {
        options['start'] = this._getEntry(this._getLastIndex())['key'];
    }

    // invoke method on TreeDataSource
    this.m_wrapped.fetchDescendents(null, null, {"success": function(nodeSet){this._handleFetchDescendentsSuccess(nodeSet, range, callbacks);}.bind(this)}, options);
};

/**
 * Process success callback for fetchDescendents operation before handing it back to original caller.
 * @param {Object} nodeSet the set of fetched nodes
 * @param {Object} range the request range for the fetch operation
 * @param {Object} callbacks the original callbacks passed to the fetch operation
 * @private
 */
oj.FlattenedTreeDataSource.prototype._handleFetchDescendentsSuccess = function(nodeSet, range, callbacks)
{
    var maxFetchSize, count, lastEntry, options, actualStart;

    // this condition should always be true since in high watermark scrolling we are
    // always asking for rows after the current last row
    if (range['start'] > this._getLastIndex())
    {
        maxFetchSize = this._getMaxFetchSize();
        count = Math.min(maxFetchSize, range['count']);

        // wrap it to inject additional metadata
        nodeSet = new oj.NodeSetWrapper(nodeSet, this.insertMetadata.bind(this));

        if (this._getLastIndex() >= 0)
        {
            // in fetchDescendents case, the result node set would probably contains more than what
            // we would return.  The issue is we can't really use range to filter the set since the 
            // range in the current view does not map one-to-one to the expand all node set as some 
            // node might have been collapsed before the fetch.
            // the solution is to use the last cached entry to find where new data starts in the
            // result node set, and use range count to limit what to return
            lastEntry = this._getLastEntry();
            options = {'index': 0, 'found': false, 'count': 0};
            this._processDescendentsNodeSet(nodeSet, null, 0, lastEntry, count, options);
            actualStart = options['index'] + 1;
        }
        else
        {
            // initial fetch case, just specify the count to limit result
            options = {'count': 0};
            this._processDescendentsNodeSet(nodeSet, null, 0, null, count, options);
            actualStart = 0;
        }

        if (callbacks != null && callbacks['success'] != null)
        {
            if (options != null)
            {
                if (options['count'] === 0)
                {
                    // nothing is used from node set, just return a empty node set
                    nodeSet = new oj.EmptyNodeSet(null, range['start']);
                }
                else 
                {
                    // wraps node set with a filter that only returns nodes that
                    // have not been fetched already
                    nodeSet = new oj.FlattenedNodeSet(nodeSet, actualStart);
                }
            }
            else
            {
                nodeSet = new oj.FlattenedNodeSet(nodeSet);
            }
            callbacks['success'].call(null, nodeSet);
        }

        return;
    }

    // the only case we'll ended up here is if the max count has been reached or
    // for some reason the caller is asking for count = 0
    this.handleMaxCountReached(range, callbacks);
};

/**
 * Walk the node set and do whatever processing is neccessary.
 * @param {Object} nodeSet the node set to process
 * @param {Object} parent the parent key of the nodes
 * @param {number} depth the depth of the nodes
 * @param {Object} lastEntry the last fetched entry
 * @param {number} maxCount the maximum number of rows to process
 * @param {Object=} options this object carries information collected in this method
 * @private
 */
oj.FlattenedTreeDataSource.prototype._processDescendentsNodeSet = function(nodeSet, parent, depth, lastEntry, maxCount, options)
{
    var nodeStart, nodeCount, i, metadata, key, childNodeSet;

    nodeStart = nodeSet.getStart();
    nodeCount = nodeSet.getCount();

    // walk the node set and populate the internal cache
    for (i=0; i<nodeCount; i++)
    {
        // see if we have enough results
        if (options['count'] == maxCount)
        {
            return;
        }

        metadata = nodeSet.getMetadata(nodeStart+i);
        key = metadata['key'];

        // see if we need to check depth
        if (options['checkDepth'])
        {
            if (lastEntry['depth'] === depth)
            {
                options['found'] = true;
                options['checkDepth'] = false;
            }
        }

        if (lastEntry == null || options['found'])
        {
            this._addEntry(key, depth, nodeStart+i, parent);

            options['count'] = options['count'] + 1;

            // include state metadata for row expander
            // in the fetchDescendents case the state is always 'expanded'
            if (metadata['leaf'])
            {
                metadata['state'] = 'leaf';
            }
            else
            {
                metadata['state'] = 'expanded';
            }
        }

        // mark we found the entry in node set that matches the last key
        // the rest of node set we can start pushing to cache
        if (lastEntry != null && !options['found'])
        {
            // we'll need to also check whether the last entry is expanded (or not leaf)
            // if it is collapsed, then we can't add any nodes from the node set until
            // we found child in the node set that has the same depth
            if (key === lastEntry['key'])
            {
                if (metadata['leaf'] || this._isExpanded(key))
                {
                    options['found'] = true;
                }
                else
                {
                    // collapsed.  Mark to check the depth of the next node before
                    // setting found to true.
                    options['checkDepth'] = true;
                }
            }
            else
            {
                options['index'] = options['index'] + 1;
            }
        }

        // process child node set, if any
        if (nodeSet.getChildNodeSet)
        {
            childNodeSet = nodeSet.getChildNodeSet(i);
            if (childNodeSet != null)
            {
                this._processDescendentsNodeSet(childNodeSet, key, depth+1, lastEntry, maxCount, options);
            }
        }
    }
};

/**
 * Expand the specified row.
 * @param {Object} rowKey the key of the row to expand
 * @export
 */
oj.FlattenedTreeDataSource.prototype.expand = function(rowKey)
{
    this._expand(rowKey);
};

/**
 * Expand the specified row with options
 * @param {Object} rowKey the key of the row to expand
 * @param {Object=} options additional options to pass to fetchChildren method
 * @private
 */
oj.FlattenedTreeDataSource.prototype._expand = function(rowKey, options)
{
    var count, fetchSize, refIndex;

    count = this.m_wrapped.getChildCount(rowKey);
    fetchSize = Math.min(this.m_fetchSize, (count == -1) ? this.m_fetchSize:count);

    // if cache is full, check if the rowKey is the last row, if it's
    // the last row do nothing
    if (this._getLastIndex()+1 === this.m_maxCount)
    {
       refIndex = this.getIndex(rowKey);
       if (refIndex == this.m_maxCount-1)
           return;
    }

    // nothing to do
    if (fetchSize == 0)
    {
        return;
    }

    this.m_wrapped.fetchChildren(rowKey, {"start": 0, "count": fetchSize}, {"success": function(nodeSet){this.handleExpandSuccess(rowKey, nodeSet, count);}.bind(this)}, {"success": this});

    // fire event
    this.handleEvent("expand", {'rowKey':rowKey});
};

/**
 * Collapse the specified row.
 * @param {Object} rowKey the key of the row to collapse
 * @export
 */
oj.FlattenedTreeDataSource.prototype.collapse = function(rowKey)
{
    var rowIndex, parent, count, depth, lastIndex, i, j, keys;

    rowIndex = this.getIndex(rowKey) + 1;
    parent = this._getEntry(rowIndex-1);

    // keeping track of how many rows to remove
    count = 0;

    depth = parent['depth'];
    lastIndex = this._getLastIndex();
    for (j=rowIndex; j<lastIndex+1; j++)
    {
        var rowData = this._getEntry(j);
        var rowDepth = rowData['depth'];
        if (rowDepth > depth)
        {
            count = count + 1;
        }
        else if (rowDepth == depth)
        {
            break;
        }
    }

    // nothing to do
    if (count == 0)
    {
        return;
    }

    // remove from expanded keys or add to collapsed keys
    if (this._isExpandAll())
    {
        this.m_collapsedKeys.push(rowKey);
    }
    else
    {
        this._removeExpanded(rowKey);
    }

    // remove rows from view
    keys = [];
    for (i=0; i<count; i++)
    {
        keys.push({"key": this._getEntry(rowIndex+i)['key'], "index":rowIndex+i});
    }

    // remove from cache.  Note this has to be done before firing row remove event
    // since it could cause a fetch which relies on the internal cache being up to date.
    this._removeEntry(rowIndex, count);    

    // (firing of event to view)
    this.removeRows(keys);

    // fire datasource event
    this.handleEvent("collapse", {'rowKey':rowKey});
};

/**
 * Checks whether the row key is expanded.
 * @param {Object} rowKey the key of the row to inquire the state
 * @return {boolean} true if the row is/should be expanded.  False otherwise.
 * @private
 */
oj.FlattenedTreeDataSource.prototype._isExpanded = function(rowKey)
{
    if (this._isExpandAll())
    {
        if (this.m_collapsedKeys && this.m_collapsedKeys.length > 0)
        {
            // call helper method to check collapsed keys
            return (this._getCollapsedKeyIndex(rowKey) === -1);
        }
        else
        {
            // everything expanded
            return true;
        }
    }
    else
    {
        if (this.m_expandedKeys && this.m_expandedKeys.length > 0)
        {
            // call helper method to check expanded keys
            return (this._getExpandedKeyIndex(rowKey) > -1);
        }
        else
        {
            // nothing expanded
            return false;
        }
    }
};

/**
 * Helper method to retrieve the index of the row key in the set of collapsed row keys
 * @param {Object} rowKey the key of the row
 * @return {number} the index of the key in the collapsed key array
 * @private
 */ 
oj.FlattenedTreeDataSource.prototype._getCollapsedKeyIndex = function(rowKey)
{
    return this._getKeyIndex(this.m_collapsedKeys, rowKey);
};

/**
 * Helper method to retrieve the index of the row key in the set of expanded row keys
 * @param {Object} rowKey the key of the row
 * @return {number} the index of the key in the expanded key array
 * @private
 */ 
oj.FlattenedTreeDataSource.prototype._getExpandedKeyIndex = function(rowKey)
{
    return this._getKeyIndex(this.m_expandedKeys, rowKey);
};

/**
 * Helper method to retrieve the index of the row key in a specified array
 * @param {Object} rowKey the key of the row
 * @return {number} the index of the key in the array
 * @private
 */ 
oj.FlattenedTreeDataSource.prototype._getKeyIndex = function(arr, rowKey)
{
    var i, index;

    index = -1;
    for (i=0; i<arr.length; i++)
    {
        if (arr[i] === rowKey)
        {
            index = i;
        }
    }

    return index;
}

/**
 * Remove the row key from the expanded cache
 * @param {Object} rowKey the key to remove
 * @private
 */
oj.FlattenedTreeDataSource.prototype._removeExpanded = function(rowKey)
{
    var index = this._getExpandedKeyIndex(rowKey);

    // index found, remove from array
    if (index > -1)
    {
        this.m_expandedKeys.splice(index, 1);    
    }
};

/**
 * Remove the row key from the collapsed cache
 * @param {Object} rowKey the key to remove
 * @private
 */
oj.FlattenedTreeDataSource.prototype._removeCollapsed = function(rowKey)
{
    var index = this._getCollapsedKeyIndex(rowKey);

    // index found, remove from array
    if (index > -1)
    {
        this.m_collapsedKeys.splice(index, 1);    
    }
};

/**
 * Callback method to handle fetch success on expand operation.
 * @param {Object} rowKey the key of the expanded row
 * @param {Object} nodeSet the node set that describes the children of the expanded row
 * @param {number} origCount the original count in the fetch request
 * @protected
 */
oj.FlattenedTreeDataSource.prototype.handleExpandSuccess = function(rowKey, nodeSet, origCount)
{
    var refIndex, rangeStart, rowStart, rowCount, parent, depth, metadata, key, toExpand, i;

    // wrap it to inject additional metadata
    nodeSet = new oj.NodeSetWrapper(nodeSet, this.insertMetadata.bind(this));

    refIndex = this.getIndex(rowKey) + 1;
    rangeStart = refIndex;

    rowStart = nodeSet.getStart();
    rowCount = nodeSet.getCount();

    parent = this._getEntry(refIndex-1);
    depth = parent['depth']+1;

    toExpand = [];

    // go through the node set and insert an entry with info about the row into internal cache
    for (i=rowStart; i<rowCount; i++)
    {
        metadata = nodeSet.getMetadata(i);
        key = metadata['key'];
        if (this._isExpanded(key))
        {
            // expand it if the user specified it to be expand (or the
            // parent was previously collapsed before and now expanded again, 
            // the expanded child would need to be expanded also)
            toExpand.push(key);
        }

        // add to cache
        this._insertRow(refIndex, metadata, parent['key'], i, depth);

        refIndex++;
    }

    // keep track of expanded row or collapsed row for expand all case
    if (this._isExpandAll())
    {
        this._removeCollapsed(rowKey);
    }
    else
    {
        // check whether it's already in expanded keys, which is the case
        // if it is expanded by initial expansion
        if (this.m_expandedKeys.indexOf(rowKey) === -1)
        {
            this.m_expandedKeys.push(rowKey);
        }
    }

    // fire event to insert the expanded rows
    this.insertRows(rangeStart, rowKey, nodeSet);

    // if actual count is > fetch or count is unknown and requested fetch count is the same as result set size, 
    // then delete all rows that comes after the reference row so that we can trigger a fetch when user scroll to the end
    // ALSO delete all rows that comes after reference row if the reference row is the last row (according to max row count)
    if ((origCount === -1 && rowCount === this.m_fetchSize) || origCount > rowCount || refIndex == this.m_maxCount)
    {
        this._deleteAllRowsBelow(refIndex);
    }
    else if (this._getLastIndex() >= this.m_maxCount)
    {
        // also clean up rows that goes beyond max row count after expand
        this._deleteAllRowsBelow(this.m_maxCount);
    }

    // expand any child rows that should be expanded
    this._expandRows(toExpand);
};

/**
 * Expands the specified array of rows.  Use batch fetching if supported.
 * @param {Array.<Object>} keys an array of row keys.
 * @private
 */
oj.FlattenedTreeDataSource.prototype._expandRows = function(keys)
{
    var options, i;

    // use batch fetching if supported so we'll have less trip to server.
    if (this._isBatchFetching())
    {
        options = {'queueOnly': true};
    }

    // expand each of the rows
    for (i=0; i<keys.length; i++)
    {
        // last expand should not have any options set to flush to batch queue
        if (i == keys.length-1)
        {
            this._expand(keys[i]);
        }
        else
        {
            this._expand(keys[i], options);
        }            
    }
};

/**
 * Insert a single row of data into the cache
 * @param {number} index the index (based on flattened view) where this is inserted
 * @param {Object} metadata the metadata of the inserted node
 * @param {Object} parentKey the key of the parent node
 * @param {number} childIndex the index relative to its parent where this is inserted
 * @param {number} depth the depth of the node
 * @private
 */
oj.FlattenedTreeDataSource.prototype._insertRow = function(index, metadata, parentKey, childIndex, depth)
{
    var key, rowData;

    key = metadata['key'];

    if (index <= this._getLastIndex())    
    {
        this._addEntry(key, depth, childIndex, parentKey, index);
    }
    else
    {
        this._addEntry(key, depth, childIndex, parentKey);
    }
};

/**
 * Remove all rows below the row of the specified index including this row.
 * @param {number} index the index from which we start to delete rows 
 * @param {number=} count the number of rows to delete.  If not specified, then delete until the end.
 * @private
 */
oj.FlattenedTreeDataSource.prototype._deleteAllRowsBelow = function(index, count)
{
    var keys, event;

    if (count == undefined)
    {
        count = this._getLastIndex()+1 - index;
    }

    keys = [];
    for (var i=0; i<count; i++)
    {
        keys.push({"row": this._getEntry(index+i)['key']});
    }

    // update internal cache
    this._removeEntry(index, count);    

    // fire event to remove rows from view
    this.removeRows(keys);
};

/**
 * Handles model event from underlying TreeDataSource.
 * @param {Event} event the model change event
 * @private
 */
oj.FlattenedTreeDataSource.prototype._handleModelEvent = function(event)
{
    var operation, ancestors, parentKey, index;

    operation = event['operation'];
    ancestors = event['parent'];
    if (Array.isArray(ancestors))
    {
        // take the direct key of direct parent
        parentKey = ancestors[ancestors.length-1];
    }
    else
    {
        // single element or null, value is the parent key
        parentKey = ancestors;
    }
    index = event['index'];

    if (operation === 'insert')
    {
        this._handleInsertEvent(parentKey, index, event['data']);
    }
    else if (operation === 'delete')
    {
        this._handleDeleteEvent(parentKey, index);
    }
    else if (operation === 'refresh')
    {
        this._handleRefreshEvent(parentKey);
    }
};

/**
 * Handles insert event from TreeDataSource.
 * @param {Object} parentKey the key of the parent where the node is inserted
 * @param {number} index the index relative to its parent where the noce is inserted
 * @param {Object} nodeSet the node set containing the single insert data
 * @private
 */
oj.FlattenedTreeDataSource.prototype._handleInsertEvent = function(parentKey, index, nodeSet)
{
    var parentIndex, parent, depth, insertIndex, metadata;

    parentIndex = this.getIndex(parentKey);
    parent = this._getEntry(parentIndex);
    depth = parent['depth']+1;
    insertIndex = parentIndex + index + 1;

    // there should only be one row in the set
    metadata = nodeSet.getMetadata(nodeSet.getStart());

    // insert into cache
    this._insertRow(insertIndex, metadata, parentKey, index, depth)    
};

/**
 * Handles delete event from TreeDataSource.
 * @param {Object} parentKey the key of the parent where the node is inserted
 * @param {number} index the index relative to its parent where the noce is inserted
 * @private
 */
oj.FlattenedTreeDataSource.prototype._handleDeleteEvent = function(parentKey, index)
{
    var parentIndex, parent, startIndex, start, count, currentIndex, lastIndex, current;

    parentIndex = this.getIndex(parentKey);
    parent = this._getEntry(parentIndex);

    startIndex = parentIndex + index;
    start = this._getEntry(startIndex);

    // make sure the child data is valid
    oj.Assert.assert(start['parent'] === parent && start['depth'] === parent['depth']+1); 

    // remove the entry and all of its children from cache
    count = 1;
    currentIndex = startIndex + 1;
    lastIndex = this._getLastIndex();
    while (currentIndex <= lastIndex)
    {
        current = this._getEntry(currentIndex);
        // check if we have reached the last child of the deleted node
        if (current['depth'] != start['depth'])
        {
            break;
        }      
        currentIndex++;
    }

    // remove rows
    this._deleteAllRowsBelow(startIndex, count);
};

/**
 * Handles refresh event from TreeDataSource.
 * @param {Object} parentKey the key of the parent where the node is inserted
 * @private
 */
oj.FlattenedTreeDataSource.prototype._handleRefreshEvent = function(parentKey)
{
    if (parentKey == null)
    {
        // the entire tree is refreshed
        // clean up internal cache
        this.refresh();
    }
};

/**
 * Checks whether all rows should be expanded.
 * @return {boolean} true if expand all rows, false otherwise.
 * @private
 */
oj.FlattenedTreeDataSource.prototype._isExpandAll = function()
{
    var capability = this.m_wrapped.getCapability('fetchDescendents');
    return (this.m_collapsedKeys != undefined && capability != null && capability != 'disable');
};

/**
 * Checks whether batch fetching is supported.
 * @return {boolean} true if batch fetching is supported, false otherwise.
 * @private
 */
oj.FlattenedTreeDataSource.prototype._isBatchFetching = function()
{
    var capability = this.m_wrapped.getCapability('batchFetch');
    return (capability === 'enable');
};

/////////////////////////////// helper methods subclass should find useful //////////////////////////////////////////////
/**
 * Refresh the data source.  Clear out any state.
 * @protected
 */
oj.FlattenedTreeDataSource.prototype.refresh = function()
{
    // clear the cache
    this._clearAll();

    // todo: more work here to force fetch (remove then insert)
};

/**
 * Determine the flattened index for the specified key
 * @param {Object} rowKey the key to find the index
 * @return {number} the index representing the specified key.  Returns -1 if the index
 *         cannot be found.
 * @protected
 */
oj.FlattenedTreeDataSource.prototype.getIndex = function(rowKey)
{
    var lastIndex, i, rowData;

    lastIndex = this._getLastIndex();
    for (i=0; i<=lastIndex; i++)
    {
        rowData = this._getEntry(i);
        if (rowData['key'] == rowKey)
        {
            return i;
        }
    }

    // can't find it, return -1
    return -1;
};

/**
 * Determines the key for the specified flattened index
 * @param {number} index the index in flattened view
 * @return {Object|null} the key for the specified index.  Returns null if the index has not been
 *         fetched yet or is invalid.
 * @protected
 */
oj.FlattenedTreeDataSource.prototype.getKey = function(index)
{
    // ensure the index is valid and in range
    if (index < 0 || index > this._getLastIndex())
    {
        return null;
    }

    // just return from internal cache
    return this._getEntry(index)['key'];
};

/**
 * Returns the currently fetched range.
 * @return {Object} the fetched range (start, end).
 * @protected
 */
oj.FlattenedTreeDataSource.prototype.getFetchedRange = function()
{
    return {'start': 0, 'end': this._getLastIndex()+1};
};

///////////////////////////////////// methods subclass must override ////////////////////////////////////////////////////////
/**
 * Handles what happened when the maximum row count has been reached.
 * @param {Object} range the range of the fetch request which caused the max count to be reached.
 * @param {Object} callbacks the callbacks of the fetch request which caused the max count to be reached.
 * @protected
 */
oj.FlattenedTreeDataSource.prototype.handleMaxCountReached = function(range, callbacks)
{
    // send an error by default
    if (callbacks != null && callbacks['error'] != null)
    {
        callbacks['error'].call(null);
    }
};

/**
 * Abstract method to insert a set of rows into the DataGrid/Table
 * @param {number} insertAtIndex the flattened index of the node where the rows are inserted.
 * @param {Object} insertAtKey the key of the node where the rows are inserted (the parent key)
 * @param {Object} nodeSet the node set containing data/metadata of inserted rows
 * @protected
 */
oj.FlattenedTreeDataSource.prototype.insertRows = function(insertAtIndex, insertAtKey, nodeSet)
{
    oj.Assert.failedInAbstractFunction();
};

/**
 * Abstract method to remove the specified rows in the DataGrid/Table
 * @param {Array.<Object>} rowKeys an array of keys of the rows to be remove.
 * @protected
 */
oj.FlattenedTreeDataSource.prototype.removeRows = function(rowKeys)
{
    oj.Assert.failedInAbstractFunction();
};

///////////////////////////////// methods that manipulates the internal cache ///////////////////////////////////
/**
 * Retrieve the flattened index of the last entry fetched so far
 * @return {number} the flattened index of the last entry
 * @private
 */
oj.FlattenedTreeDataSource.prototype._getLastIndex = function()
{
    return this.m_cache.length-1;
};

/**
 * Retrieve the metadata for the last entry fetched so far
 * @return {Object} the metadata for the last entry
 * @private
 */
oj.FlattenedTreeDataSource.prototype._getLastEntry = function()
{
    return this.m_cache[this._getLastIndex()];
};

/**
 * Retrieve metadata info for the specified index.
 * @param {number} index the flattened index 
 * @return {Object} the metadata info
 * @private
 */
oj.FlattenedTreeDataSource.prototype._getEntry = function(index)
{
    return this.m_cache[index];
};

/**
 * Add or insert entry to the cache
 * @param {Object} key the key
 * @param {number} depth the depth 
 * @param {number} index the index relative to its parent
 * @param {Object} parent the parent
 * @param {number=} insertAt insert the metadata entry at this flattened index
 * @private
 */
oj.FlattenedTreeDataSource.prototype._addEntry = function(key, depth, index, parent, insertAt)
{
    var rowData = new Object();
    rowData['key'] = key;
    rowData['depth'] = depth;
    rowData['index'] = index;
    rowData['parent'] = parent;

    if (insertAt === undefined)
    {
        this.m_cache.push(rowData);
    }
    else
    {
        this.m_cache.splice(insertAt, 0, rowData);
    }
};

/**
 * Remove entry from cache
 * @param {number} index the flattened index to start remove entry
 * @param {number} count how many entries to remove starting from the flattened index
 * @private
 */
oj.FlattenedTreeDataSource.prototype._removeEntry = function(index, count)
{
    this.m_cache.splice(index, count);
};

/**
 * Clears the internal cache
 * @private
 */
oj.FlattenedTreeDataSource.prototype._clearAll = function()
{
    this.m_cache.length = 0;
};
//////////////////// _JsonTreeNodeDataSource ///////////////////////////////////

/**
 * Helper class to implement sort recursive features for tree.
 * @constructor
 * @private
 */
oj._JsonTreeNodeDataSource = function()
{
    this.id = null;
    this.depth = 0;
    this.parent = null;
    this.children = [];
    this.title = null;
    this.attr = null;
    this.leaf = null;
};

/**
 * Helper comparer method for ascending sort.
 * @private
 */
oj._JsonTreeNodeDataSource.prototype._ascending = function(key)
{
    return function(a, b) 
    {
        if (a.attr && b.attr) 
        {
            if (a.attr[key] && b.attr[key])
            {
                return a.attr[key] < b.attr[key] ? 0 : 1;
            }
        }
        return a[key] < b[key] ? 0 : 1;
    }
};

/**
 * Helper comparer method for descending sort.
 * @private
 */
oj._JsonTreeNodeDataSource.prototype._descending = function(key)
{
    return function(a, b) 
    {
        if (a.attr && b.attr) 
        {
            if (a.attr[key] && b.attr[key])
            {
                return a.attr[key] < b.attr[key] ? 1 : 0;
            }
        }
        return a[key] < b[key] ? 1 : 0;
    }
};

/**
 * Helper method for recursive sort.
 * @param {Object} criteria the sort criteria.
 * @param {Object} criteria.key the key identifying the attribute to sort on
 *        {string} criteria.direction the sort direction, valid values are "ascending", "descending".
 * @private
 */
oj._JsonTreeNodeDataSource.prototype._sortRecursive = function(criteria)
{
    var key = criteria['key'];
    if (criteria['direction'] === 'ascending')
    {
        this.children.sort(this._ascending(key));
    }
    else if (criteria['direction'] === 'descending')
	{
		this.children.sort(this._descending(key));
	}
    for (var i = 0, l = this.children.length; i < l; i++)
    {
        this.children[i]._sortRecursive(criteria);
    }
    return this;
};

///////////// JsonTreeDataSource //////////////////   

/**
 * A json object based implementation of the TreeDataSource.
 * @param {Object} data the json object
 * @constructor
 * @export
 */
oj.JsonTreeDataSource = function(data)
{
    var tree;

    tree = new oj._JsonTreeNodeDataSource(); // that's the root node

    if (!data.id)
    {
        tree.id = "root";
    }

    this.data = this._createTreeDataSource(0, tree, data);

    oj.JsonTreeDataSource.superclass.constructor.call(this, tree);
};

// Subclass from oj.TreeDataSource
oj.Object.createSubclass(oj.JsonTreeDataSource, oj.TreeDataSource, "oj.JsonTreeDataSource");

/**
 * Initial the json object based data source.
 * @export
 */
oj.JsonTreeDataSource.prototype.Init = function()
{
    // call super
    oj.JsonTreeDataSource.superclass.Init.call(this);
};

/**
 * Returns tree based structure/object from json data.
 * @param {Object} target the final tree structure. 
 * @param {Object} source the json object.
 * @param {number=} depth used recursively for depth calculation.
 */
oj.JsonTreeDataSource.prototype._createTreeDataSource = function(c, target, source, depth)
{
    var children, node, child, prop, propr, prp, prpr, j;

    if (!depth)
    {
        depth = 0;
    }

    for (prop in source)
    {
        if (prop == "children" || (depth == 0 && source instanceof Array))
        {
            if (depth == 0 && source instanceof Array)
            {
                children = source;
            }
            else
            {
                children = source[prop];
            }

            depth++;
            for (j = 0; j < children.length; j++)
            {
                child = children[j];
                node = new oj._JsonTreeNodeDataSource();
                if (!child.id) 
                {
					c++;
                    if (!child.attr) 
                    {
                        node.id = 'rid_' + c;//Math.floor((Math.random() * 1000) + 1);
                    } 
                    else if (!child.attr.id) 
                    {
                        child.attr.id = 'rid_' + c;//Math.floor((Math.random() * 1000) + 1);
                    }
                }
                for (propr in child)
                {
                    for (prp in node)
                    {
                        if (propr == prp && propr != "children")
                        {    
                            node[prp] = child[propr];
                        }
                        if (prp == "depth")
                        {
                            node[prp] = depth;
                        }
                    }
                }
                target.children.push(node);
                for (prp in child)
                {
                    if (prp == "children")
                    {
                        this._createTreeDataSource(c, target.children[j], child, depth);
                    }
                }
            }
        }
    }
    return target;
};

/**
 * Returns the number of children for a specified parent.  If the value returned is not >= 0 then it is automatically assumed
 * that the child count is unknown.
 * @param {Object} parentKey the parent key.  Specify null if inquiring child count of the root.
 * @return {number|null} the number of children for the specified parent.
 * @export
 */
oj.JsonTreeDataSource.prototype.getChildCount = function(parentKey)
{
    var parent;

    if (!parentKey)
    {
        parentKey = this.data.id;
    }

    parent = this._searchTreeById(this.data, parentKey);

    if (parent.children)
    {
        return parent.children.length;
    }
    else
    {
        return null;
    }
};

/**
 * Fetch the children
 * @param {Object} parentKey the parent key.  Specify null if fetching children from the root.
 * @param {Object} range information about the range, it must contain the following properties: start, count.
 * @param {number} range.start the start index of the range in which the children are fetched.
 * @param {number} range.count the size of the range in which the children are fetched.  
 * @param {Object} callbacks the callbacks to be invoke when fetch children operation is completed.  The valid callback
 *        types are "success" and "error".
 * @param {function(oj.JsonNodeSet)} callbacks.success the callback to invoke when fetch completed successfully.
 * @param {function({status: Object})} callbacks.error the callback to invoke when fetch children failed.
 * @param {Object=} options optional parameters for this operation.
 * @param {boolean=} options.queueOnly true if this fetch request is to be queued and not execute yet.  The implementation must maintain 
 *        the order of the fetch operations.  When queueOnly is false/null/undefined, any queued fetch operations are then
 *        flushed and executed in the order they are queued.  This flag is ignored if the datasource does not support batching.
 * @export
 */
oj.JsonTreeDataSource.prototype.fetchChildren = function(parentKey, range, callbacks, options)
{
    var i, childStart, childEnd, nodeSet, results, parent, node;

    childStart = 0;
    childEnd = 0;
    results = [];

    if (!parentKey)
    {
        parentKey = this.data.id;
    }

    parent = this._searchTreeById(this.data, parentKey);

    if (!range)
    {
        range = [];
        range['start'] = 0;
        range['count'] = parent.children.length;
    }

    if (!range['count'])
    {
        range['count'] = parent.children.length;
    }

    if (!range['start'])
    {
        range['start'] = 0;
    }

    childStart = range['start'];
    childEnd = Math.min(parent.children.length, childStart + range['count']);

    // now populate results from data array
    for (i = childStart; i < childEnd; i += 1)
    {
        node = new oj._JsonTreeNodeDataSource();
        if(parent.children[i].attr)
        {
            node.attr = parent.children[i].attr;
        }
        if(parent.children[i].id)
        {
            node.id = parent.children[i].id;
        }
        if(parent.children[i].depth)
        {
            node.depth = parent.children[i].depth;
        }
        if(parent.children[i].title)
        {
            node.title = parent.children[i].title;
        }
        if(parent.children[i].parent)
        {
            node.parent = parent.children[i].parent;
        }
        if(parent.children[i].children.length > 0)
        {
            node.leaf = false;
        }
        else 
        {
            node.leaf = true;
        }
        results.push(node);
    }

    // invoke callback
    nodeSet = new oj.JsonNodeSet(childStart, childEnd, results, parentKey, parent.depth);

    // invoke original success callback
    if (callbacks != null && callbacks['success'] != null)
    {
        callbacks['success'].call(null, nodeSet);
    }
};

/**
 * Fetch all children and their children recursively from a specified parent.
 * @param {Object} parentKey the parent key.  Specify null to fetch everything from the root (i.e. expand all)
 * @param {Object} callbacks the callbacks to be invoke when fetch children operation is completed.  The valid callback
 *        types are "success" and "error".
 * @param {function(oj.JsonNodeSet)} callbacks.success the callback to invoke when fetch completed successfully.
 * @param {function({status: Object})} callbacks.error the callback to invoke when fetch children failed.
 * @param {number=} maxCount the maximum number of children to fetch.  If a non-positive number is specified, then the value is ignored and
 *        there is no maximum fetch count.
 * @export
 */
oj.JsonTreeDataSource.prototype.fetchDescendents = function(parentKey, range, callbacks, maxCount)
{
    var i, childStart, childEnd, nodeSet, results, parent;

    childStart = 0;
    childEnd = 0;
    results = [];

    if (!parentKey)
    {
        parentKey = this.data.id;
    }

    parent = this._searchTreeById(this.data, parentKey);

    if (!range)
    {
        range = [];
        range['start'] = 0;
        range['count'] = parent.children.length;
    }

    if (!range['count'])
    {
        range['count'] = parent.children.length;
    }

    if (!range['start'])
    {
        range['start'] = 0;
    }

    childStart = range['start'];
    childEnd = Math.min(parent.children.length, childStart + range['count']);

    // now populate results from data array
    for (i = childStart; i < childEnd; i += 1)
    {       
	if(parent.children[i].children.length > 0)
        {
            parent.children[i].leaf = false;
        }
        else 
        {
            parent.children[i].leaf = true;
        }
        results.push(parent.children[i]); 
    }

    // invoke callback
    nodeSet = new oj.JsonNodeSet(0, results.length, results, parentKey, parent.depth);

    // invoke original success callback
    if (callbacks != null && callbacks['success'] != null)
    {
        callbacks['success'].call(null, nodeSet);
    }
};

/**
 * Moves a node from one location to another (different position within the same parent or a completely different parent)
 * @param {null|string} nodeToMove the key of the node to move
 * @param {null|string} referenceNode the key of the reference node which combined with position are used to determine 
 *        the destination of where the node should moved to.
 * @param {number|string} position The position of the moved node relative to the reference node.  
 *        This can be a string: "before", "after", "inside", "first", "last", or the zero based index to position 
 *        the element at a specific point among the reference node's current children.
 * @param {function()} callbacks.success the callback to invoke when the move completed successfully.  
 * @param {function({status: Object})} callbacks.error the callback to invoke when move failed.
 * @export
 */
oj.JsonTreeDataSource.prototype.move = function(nodeToMove, referenceNode, position, callbacks)
{
    var moveNode, refNode, moveNodeKey, refNodeKey, pos, parent, index;

    pos = position;
    moveNodeKey = nodeToMove;
    refNodeKey = referenceNode;

    if ((!refNodeKey || refNodeKey == this.data.id))
    {
        if (pos != "inside")
        {
            console.log("Error: root can not be the reference node if position equals to " + pos);
            return;
        }
        else
        {
            if (!refNodeKey)
            {
                refNodeKey = this.data.id;
            }
        }
    }

    //get node to move;
    moveNode = this._searchTreeById(null, moveNodeKey);
    //if the moveNode doesn't contain the reference node as its sub-tree the action is allowed
    if (!this._searchTreeById(moveNode, refNodeKey))
    {
        refNode = this._searchTreeById(null, refNodeKey);

        parent = this._getParentById(refNodeKey);
        //remove moveNode from the original position;
        this._removeFromTree(moveNode);
        if (pos == "inside")
        {
            this._updateDepth(moveNode, moveNode.depth - (refNode.depth + 1));
            refNode.children.push(moveNode);
        }
        else if (pos == "before")
        {
            this._updateDepth(moveNode, moveNode.depth - refNode.depth);
            index = parent.children.indexOf(refNode);
            if (index > -1)
            {
                if (index != 0)
                {
                    parent.children.splice(index - 1, 0, moveNode);
                }
                else
                {
                    parent.children.unshift(moveNode);
                }
            }
        }
        else if (pos == "after")
        {
            this._updateDepth(moveNode, moveNode.depth - refNode.depth);
            index = parent.children.indexOf(refNode);
            if (index > -1)
            {
                parent.children.splice(index, 0, moveNode);
            }
        }
        else if (pos == "first")
        {
            this._updateDepth(moveNode, moveNode.depth - refNode.depth);
            parent.children.unshift(moveNode);
        }
        else if (pos == "last")
        {
            //update depth recursively
            this._updateDepth(moveNode, moveNode.depth - refNode.depth);
            parent.children.push(moveNode);
        }

        // invoke original success callback
        if (callbacks != null && callbacks['success'] != null)
        {
            callbacks['success'].call(null, this.data);
        }
    }
    else
    {
        console.log("Error: the node to move contains the reference node as its sub-tree.");
    }
};

/**
 * Performs a sort operation on the tree data.
 * @param {Object} criteria the sort criteria.  It must contain the following properties: key, direction
 * @param {Object} criteria.key the key identifying the attribute (column) to sort on
 *        {string} criteria.direction the sort direction, valid values are "ascending", "descending", "none" (default)
 * @param {function()} callbacks.success the callback to invoke when the sort completed successfully.  
 * @param {function({status: Object})} callbacks.error the callback to invoke when sort failed.
 * @export
 */
oj.JsonTreeDataSource.prototype.sort = function(criteria, callbacks)
{
    var parent, parentKey;

    parentKey = null;

    if (!parentKey)
    {
        parentKey = this.data.id;
    }

    parent = this._searchTreeById(this.data, parentKey);

    parent._sortRecursive(criteria);

    // invoke original success callback
    if (callbacks != null && callbacks['success'] != null)
    {
        callbacks['success'].call(null, parent);
    }
};

/**
 * @param {string|number} refNodeKey
 * @param {Object=} currNode
 * @return {Object|null} the node with required key value.
 * @private
 */
oj.JsonTreeDataSource.prototype._getParentById = function(refNodeKey, currNode)
{
    var i, parent = null, parentIsFound = false;

    if ((refNodeKey == this.data.id))
    {
        return null;
    }

    if (!currNode)
    {
        currNode = this.data;
    }

    if (currNode.children && currNode.children.length > 0)
    {
        for (i = 0; i < currNode.children.length; i++)
        {
            if ((currNode.children[i].id && currNode.children[i].id == refNodeKey) || (currNode.children[i].attr && currNode.children[i].attr.id == refNodeKey))
            {
                parentIsFound = true;
                return currNode;
                break;
            }
        }
        if (!parentIsFound)
        {
            for (i = 0; i < currNode.children.length; i++)
            {
                parent = this._getParentById(refNodeKey, currNode.children[i]);
                if (parent)
                {
                    parentIsFound = true;
                    return parent;
                    break;
                }
            }

        }
    }
    return parent;
};

/**
 * Helper method to traverse through the tree and return the node with required key.
 * @param {Object|null} currChild the start tree node.
 * @param {string|null} parentKey the node key for search.
 * @return {Object|null} the node with required key value.
 * @private
 */
oj.JsonTreeDataSource.prototype._searchTreeById = function(currChild, parentKey)
{
    var i, result = null;

    if (!currChild)
    {
        currChild = this.data;
    }

    if ((currChild.id && currChild.id == parentKey) || (currChild.attr && currChild.attr.id == parentKey))
    {
        return currChild;
    }
    else if (currChild.children != null)
    {
        for (i = 0; i < currChild.children.length; i++)
        {
            if (result)
            {
                return result;
                break;
            }
            if ((currChild.children[i].id && currChild.children[i].id == parentKey) || (currChild.children[i].attr && currChild.children[i].attr.id == parentKey))
            {
                result = currChild.children[i];
            }
            else
            {
                result = this._searchTreeById(currChild.children[i], parentKey);
            }
        }
        return result;
    }
    return result;
};

/**
 * Helper method to update the node's depth alongside with its children.
 * @param {Object} currChild the node to update.
 * @param {number} offset the difference between current and updated depth values.
 * @private
 */
oj.JsonTreeDataSource.prototype._updateDepth = function(currChild, offset)
{
    var i;

    currChild.depth = currChild.depth - offset;

    if (currChild.children && currChild.children.length != 0)
    {
        for (i = 0; i < currChild.children.length; i++)
        {
            this._updateDepth(currChild.children[i], offset);
        }
    }
};


/**
 * Helper method to remove node from the tree (based on depth value).
 * @param {Object} currChild the node to remove.
 * @private
 */
oj.JsonTreeDataSource.prototype._removeFromTree = function(currChild)
{
    var parent, index, key;

    if (currChild.id)
    {
        key = currChild.id;
    }
    else if (currChild.attr)
    {
        key = currChild.attr.id;
    }

    parent = this._getParentById(key);
    if (!parent)
    {
        parent = this.data;
    }
    index = parent.children.indexOf(currChild);
    if (index > -1)
    {
        parent.children.splice(index, 1);
    }
};

/**
 * Helper method to traverse through the tree and collect children into results set.
 * @param {Object} currChild the start tree node.
 * @param {number|undefined|null} maxCount the max number of children to fetch.
 * @param {Array=} results.
 * @return {Array|null} results the array of children.
 * @private
 */
oj.JsonTreeDataSource.prototype._traverseTree = function(currChild, maxCount, results)
{
    var i;

    if (maxCount && maxCount <= 0)
    {
        maxCount = null;
    }

    if (currChild.children != null)
    {
        for (i = 0; i < currChild.children.length; i++)
        {
            if (maxCount)
            {
                if (results.length == maxCount)
                {
                    return results;
                    break;
                }
            }
	    results.push(currChild.children[i]);
            this._traverseTree(currChild.children[i], maxCount, results);
        }
        return results;
    }
    return null;
};

/**
 * Determines whether this TreeDataSource supports the specified feature.
 * @param {string} feature the feature in which its capabilities is inquired.  Currently the valid features "sort", 
 *        "move", "fetchDescendents", "batchFetch"
 * @return {string|null} the name of the feature.  Returns null if the feature is not recognized.
 *         For "sort", the valid return values are: "default", "none".  
 *         For "fetchDescendents", the valid return values are: "enable", "disable", "suboptimal".  
 *         For "move", the valid return values are: "default", "none".  
 *         For "batchFetch", the valid return values are: "enable", "disable".  
 * @export
 */
oj.JsonTreeDataSource.prototype.getCapability = function(feature)
{
    if (feature === 'fetchDescendents')
    {
        return "enable";
    }
    else if (feature === 'sort')
    {
        return "default";
    }
    else if (feature === 'batchFetch')
    {
        return "disable";
    }
    else
    {
        return null;
    }
};
/*jslint browser: true*/

/**
 * @export
 * @class oj.Row
 * @classdesc Object representing name/value pairs for a row of data
 *
 * @param {Object=} attributes Initial set of attribute/value pairs with which to seed this Row object 
 * @param {Object=} options 
 *                  rowSet: rowSet for this row
 *                  context: context for this row
 * @constructor
 */
oj.Row = function(attributes, options)
{
  oj.Row._init(this, attributes, options, null);
};


// Subclass from oj.Object 
oj.Object.createSubclass(oj.Row, oj.Object, "Row.Row");

oj.Row.prototype.Init = function()
{
  oj.Row.superclass.Init.call(this);
};

/**
 * 
 * @export
 * @desc Attribute/value pairs held by the Row.
 * 
 * @type Object
 */
oj.Row.prototype.attributes = {};

/**
 * 
 * @export
 * @desc Attribute/value pairs for context held by the Row.
 * 
 * @type Object
 */
oj.Row.prototype.context = {};

/**
 * @export
 * @desc The Row's unique ID. 
 * 
 * @type String
 */
oj.Row.prototype.id = null;

/**
 * @export
 * @desc The name of the row property to be used as the unique ID. See property id. This defaults to a value of "id".
 *  
 * @type String
 */
oj.Row.prototype.idAttribute = null;

oj.Row._init = function(row, attributes, options, properties)
{
  var prop = null, attrCopy;

  row.Init();

  row.index = -1;

  options = options || {};
  row.attributes = {};

  // First, copy all properties passed in
  for (prop in properties)
  {
    if (properties.hasOwnProperty(prop))
    {
      row[prop] = properties[prop];
    }
  }
  
  row['rowSet'] = options['rowSet'];
  row['context'] = options['context'];
};

/**
 * @export
 * Return a copy of the Row with identical attributes and settings
 */
oj.Row.prototype.clone = function()
{
  oj.Assert.failedInAbstractFunction();
  return null;
};

/**
 * Returns the value of the property from the Row.
 * @param {string} property Property to get from row
 * @return {Object} value of property
 * @export
 */
oj.Row.prototype.get = function(property)
{
  oj.Assert.failedInAbstractFunction();
  return null;
};

/**
 * Set the value(s) of one or more attributes of the row
 * @param {string||Object} property Property attribute name to set, or an Object containing attribute/value pairs
 * @param {Object=} value Value for property if property is not an Object containing attribute/value pairs
 * @param {Object=} options Options may be passed in
 * @returns {Object||boolean} the row itself, false if failed
 * @export
 */
oj.Row.prototype.set = function(property, value, options)
{
  oj.Assert.failedInAbstractFunction();
  return null;
};

/**
 * @export
 * Return all of the Row's attributes as an array
 * 
 * @returns {Array} array of all the Row's attributes
 */
oj.Row.prototype.keys = function()
{
  oj.Assert.failedInAbstractFunction();
  return null;
};

/**
 * @export
 * Return all of the Row's attributes values as an array
 * 
 * @returns {Array} array of all the Row's attributes values
 */
oj.Row.prototype.values = function()
{
  oj.Assert.failedInAbstractFunction();
  return null;
};

/**
 * @export
 * Return an array of attributes/value pairs found in the Row 
 * 
 * @returns {Object} returns the Row's attribute/value pairs as an object property bag
 */
oj.Row.prototype.pairs = function()
{
  oj.Assert.failedInAbstractFunction();
  return null;
};

/*jslint browser: true*/

/**
 * @export
 * @class oj.RowSet
 * @classdesc RowSet of Row objects 
 * 
 * @param {Array=} rows Set of row objects or JS array of data to put into rowSet at construction time 
 * @param {Object=} options Passed through to the user's initialize routine, if any, upon construction 
 * @constructor
 */
oj.RowSet = function(rows, options)
{
  // Initialize
  oj.RowSet._init(this, rows, options, null);
};

/**
 * @export
 * @desc If set, sort the rowSet using the given attribute of a row (if string); function(Row) returning a string attribute
 * by which the sort should take place; function(Row1, Row2) if a user-defined function comparing Row1 and Row2 (see the
 * JavaScript array.sort() for details)
 * 
 * @type {String|function(Object)|function(Object,Object)}
 */
oj.RowSet.prototype.comparator = null;

/**
 * @export
 * @desc Set to true if sort is supported.
 * 
 * @type boolean
 */
oj.RowSet.prototype.sortSupported = true;


// Subclass from oj.Object 
oj.Object.createSubclass(oj.RowSet, oj.Object, "RowSet.RowSet");

oj.RowSet.prototype.Init = function()
{
  oj.RowSet.superclass.Init.call(this);
};

oj.RowSet._init = function(rowSet, rows, options, properties)
{
  var prop;
  rowSet._eventHandlers = [];
  rowSet.Init();

  // First, copy all properties passed in
  if (properties)
  {
    for (prop in properties)
    {
      if (properties.hasOwnProperty(prop))
      {
        rowSet[prop] = properties[prop];
      }
    }
  }
};

/**
 * Return the Row object found at the given index of the RowSet, or a promise object that will return the Row to a function
 * in the done() call.
 * 
 * @param {number} index Index for which to return the Row object. 
 * @param {Object=} options <p>
 *                  fetchSize: fetch size to use if the call needs to fetch more records from the server, if virtualized.  Overrides the overall fetchSize setting <p>
 *                  deferred: if true, return a deferred/promise object as described below.  If not specified, the return value will
 *                   be determined by whether or not the RowSet is virtual
 * @return {Object} Row object located at index. If index is out of range, returns null.  If this is a paging/virtual RowSet or
 *                  if deferred is specified and true, at will return a jQuery promise object which will call its done function,
 *                  passing the value at(index) 
 * @export
 */
oj.RowSet.prototype.at = function(index, options)
{
  oj.Assert.failedInAbstractFunction();
  return null;
};

/**
 * Loads the data into the RowSet
 * @param {Object=} options Options to control fetch<p>
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.RowSet
 * @instance
 */
oj.RowSet.prototype.fetch = function(options)
{
  oj.Assert.failedInAbstractFunction();
}

/**
 * Return the first Row object from the RowSet whose Row id value is the given id
 * Note this method will not function as expected if the id is not set
 * @param {Object|string} id ID for which to return the Row object, if found. 
 * @param {Object=} options <p>
 *                  fetchSize: fetch size to use if the call needs to fetch more records from the server, if virtualized.  Overrides the overall fetchSize setting<p>
 *                  deferred: if true, return a promise as though this RowSet were virtual whether it is or not
 * @return {Object} First Row object in the RowSet where Row.id = id. If none are found, returns null.
 *                  If deferred or virtual, return a promise passing the Row when done
 * @export
 */
oj.RowSet.prototype.get = function(id, options)
{
  oj.Assert.failedInAbstractFunction();
  return null;
};

/**
 * @export
 * Return whether there is more data which can be fetched.
 * @return {boolean} whether there is more data
 */
oj.RowSet.prototype.hasMore = function()
{
  oj.Assert.failedInAbstractFunction();
  return false;
};

/**
 * Return the array index location of the given Row object.
 * @param {Object} row Row object to locate 
 * @param {Object=} options deferred: if true, return a promise as though this RowSet were virtual whether it is or not
 
 * @return {number} The index of the given Row object, or a promise that will call with the index when complete.
 *                  If the object is not found, returns -1.
 * @export
 */
oj.RowSet.prototype.indexOf = function(row, options)
{
  oj.Assert.failedInAbstractFunction();
  return 0;
};

/**
 * @export
 * Determine if the RowSet has any Rows
 * 
 * @returns {boolean} true if RowSet is empty
 */
oj.RowSet.prototype.isEmpty = function()
{
  oj.Assert.failedInAbstractFunction();
  return true;
};

/**
 * @export
 * Return the length of the RowSet
 * @returns {number} length of the RowSet
 */
oj.RowSet.prototype.size = function()
{
  oj.Assert.failedInAbstractFunction();
  return 0;
};

/**
 * @export
 * Sort the Rows in the RowSet
 */
oj.RowSet.prototype.sort = function()
{
  oj.Assert.failedInAbstractFunction();
};

/**
 * @export
 * Return the total length of the RowSet
 * @returns {number} length of the RowSet
 */
oj.RowSet.prototype.totalSize = function()
{
  oj.Assert.failedInAbstractFunction();
  return 0;
};

/**
 * Attach an event handler to the datasource
 * @param {string} eventType eventType supported by the datasource
 * @param {function(Object)} eventHandler event handler function
 * @export
 */
oj.RowSet.prototype.on = function(eventType, eventHandler)
{
  var foundEventHandler = false, i;
  for (i = 0; i < this._eventHandlers.length; i++)
  {
    if (this._eventHandlers[i]['eventType'] == eventType &&
      this._eventHandlers[i]['eventHandlerFunc'] == eventHandler)
    {
      foundEventHandler = true;
      break;
    }
  }
  if (!foundEventHandler) {
    this._eventHandlers.push({'eventType': eventType, 'eventHandlerFunc': eventHandler});
  }
};

/**
 * Detach an event handler from the datasource
 * @param {string} eventType eventType supported by the datasource
 * @param {function(Object)} eventHandler event handler function
 * @export
 */
oj.RowSet.prototype.off = function(eventType, eventHandler)
{
  var i;
  for (i = 0; i < this._eventHandlers.length; i++)
  {
    if (this._eventHandlers[i]['eventType'] == eventType &&
      this._eventHandlers[i]['eventHandlerFunc'] == eventHandler)
    {
      this._eventHandlers.remove(this._eventHandlers[i]);
      break;
    }
  }
};

/**
 * Handle the event
 * @param {string} eventType  event type
 * @param {?} event  event
 * @export
 */
oj.RowSet.prototype._handleEvent = function(eventType, event)
{
  var i;
  for (i = 0; i < this._eventHandlers.length; i++)
  {
    var eventHandler = this._eventHandlers[i];
    if (eventHandler['eventType'] == eventType)
    {
      eventHandler['eventHandlerFunc'](event);
    }
  }
};

/**
 * @export
 * Event types
 * @enum {string}
 */
oj.RowSet.EventType =
  {
    /** Triggered when a Row is added to a RowSet */
    'ADD': "add",
    /** Triggered when a Row is removed from a RowSet */
    'REMOVE': "remove",
    /** Triggered when a RowSet is reset (see oj.RowSet.reset) */
    'RESET': "reset",
    /** Triggered when a RowSet is sorted */
    'SORT': "sort",
    /** Triggered when a Row's attributes are changed */
    'CHANGE': "change",
    /** Triggered when a Row is deleted from the data service (and thus from its RowSet) */
    'DESTROY': "destroy",
    /** Triggered when a Row or RowSet has sent a request to the data service */
    'REQUEST': "request",
    /** Triggered when a Row or RowSet has been updated from the data service */
    'SYNC': "sync",
    /** Triggered when a Row has failed to update on the data service */
    'ERROR': "error",
    /** Triggered when a Row being saved has been invalidated by the caller */
    'INVALID': "invalid",
    /** Triggered for any of the above events */
    'ALL': "all"
  };

/**
 * @export
 * Event types
 * @enum {string}
 */
oj.RowSet._ROW_STATUSES =
  {
    _ADDED: 'added',
    _DELETED: 'deleted',
    _UPDATED: 'updated',
    _NONE: 'none'
  };
/*jslint browser: true*/

/**
 * @export
 * @class oj.Row
 * @classdesc Object representing name/value pairs for a row of data
 *
 * @param {Object=} attributes Initial set of attribute/value pairs with which to seed this Row object 
 * @param {Object=} options 
 *                  rowSet: rowSet for this row
 * @constructor
 */
oj.ArrayRow = function(attributes, options)
{
  oj.ArrayRow._init(this, attributes, options, null);
};


// Subclass from oj.Object 
oj.Object.createSubclass(oj.ArrayRow, oj.Row, "ArrayRow.ArrayRow");

oj.ArrayRow.prototype.Init = function()
{
  oj.ArrayRow.superclass.Init.call(this);
};

/**
 * 
 * @export
 * @desc Attribute/value pairs held by the Model.
 * 
 * @type Object
 */
oj.ArrayRow.prototype.attributes = {};

/**
 * @export
 * @desc The Row's unique ID. 
 * 
 * @type String
 */
oj.ArrayRow.prototype.id = null;

/**
 * @export
 * @desc The name of the row property to be used as the unique ID. See property id. This defaults to a value of "id".
 *  
 * @type String
 */
oj.ArrayRow.prototype.idAttribute = null;

oj.ArrayRow._init = function(row, attributes, options, properties)
{
  var prop = null, attrCopy;

  row.Init();

  row.index = -1;

  options = options || {};
  row.attributes = attributes;

  // First, copy all properties passed in
  for (prop in properties)
  {
    if (properties.hasOwnProperty(prop))
    {
      row[prop] = properties[prop];
    }
  }
  
  row['idAttribute'] = options['idAttribute'];
  row['context'] = options['context'];
  row._setupId();
};

/**
 * @export
 * Return a copy of the Row with identical attributes and settings
 */
oj.ArrayRow.prototype.clone = function()
{
  var c = new this.constructor(), prop;

  for (prop in this)
  {
    // Shallow copy all but data
    if (this.hasOwnProperty(prop) && this[prop] !== this.attributes)
    {
      c[prop] = this[prop];
    }
  }
  // Deep copy data
  c.attributes = oj.ArrayRow._cloneAttributes(this.attributes, null);

  c._setupId();

  return c;
};

/**
 * Returns the value of the property from the Row.
 * @param {string} property Property to get from row
 * @return {Object} value of property
 * @export
 */
oj.ArrayRow.prototype.get = function(property)
{
  return this.attributes[property];
};

/**
 * Set the value(s) of one or more attributes of the row
 * @param {string||Object} property Property attribute name to set, or an Object containing attribute/value pairs
 * @param {Object=} value Value for property if property is not an Object containing attribute/value pairs
 * @param {Object=} options Options may be passed in
 * @returns {Object||boolean} the row itself, false if failed
 * @export
 */
oj.ArrayRow.prototype.set = function(property, value, options)
{
  var opts = {}, ignoreLastArg = false, prop, i, valid = true;

  if (arguments)
  {
    if (arguments.length > 0)
    {
      // Check if the last argument is not the first argument
      if (arguments.length > 1)
      {
        if (arguments[arguments.length - 1])
        {
          // Last arg is options: ignore later
          ignoreLastArg = true;
          opts = arguments[arguments.length - 1] || {};
        }
      }
      // Check if first arg is property bag
      if (oj.ArrayRow._hasProperties(property))
      {
        this._setProp(property, opts);
      }
      else
      {
        // Not a property bag?  We assume it's a series of property/value arguments
        for (i = 0; i < arguments.length; i += 2)
        {
          // Process the arg as long as its: defined, and isn't the last argument where we're supposed to ignore the last argument
          // due to it being 'options'
          if (arguments[i] !== undefined || i < arguments.length - 1 || (!ignoreLastArg && i === arguments.length - 1))
          {
            this._setProp(arguments[i], arguments[i + 1]);
          }
        }
      }
    }
  }
  return this;
};

/**
 * @export
 * Return all of the Row's attributes as an array
 * 
 * @returns {Array} array of all the Row's attributes
 */
oj.ArrayRow.prototype.keys = function()
{
  var prop, retArray = [];

  for (prop in this.attributes)
  {
    if (this.attributes.hasOwnProperty(prop))
    {
      retArray.push(prop);
    }
  }
  return retArray;
};

/**
 * @export
 * Return all of the Row's attributes values as an array
 * 
 * @returns {Array} array of all the Row's attributes values
 */
oj.ArrayRow.prototype.values = function()
{
  var prop, retArray = [];

  for (prop in this.attributes)
  {
    if (this.attributes.hasOwnProperty(prop))
    {
      retArray.push(this.get(prop));
    }
  }
  return retArray;
};

/**
 * @export
 * Return an array of attributes/value pairs found in the Row 
 * 
 * @returns {Object} returns the Row's attribute/value pairs as an object property bag
 */
oj.ArrayRow.prototype.pairs = function()
{
  var prop, retObj = {};
  for (prop in this.attributes)
  {
    if (this.attributes.hasOwnProperty(prop))
    {
      retObj[prop] = this.get(prop);
    }
  }
  return retObj;
};

oj.ArrayRow.prototype._getIdAttr = function()
{
  return this['idAttribute'] || 'id';
};

// Might be a property value or a function
oj.ArrayRow.prototype._getProp = function(prop)
{
  if (this[prop] instanceof Function)
  {
    return this[prop]();
  }
  return this[prop];
};

oj.ArrayRow._hasProperties = function(object)
{
  var prop;
  if (object && object instanceof Object)
  {
    for (prop in object)
    {
      if (object.hasOwnProperty(prop))
      {
        return true;
      }
    }
  }
  return false;
};

oj.ArrayRow.prototype._setupId = function()
{
  var idAttr = this._getIdAttr();
  this['id'] = this.attributes[idAttr];
};

oj.ArrayRow.prototype._setPropInternal = function(prop, value)
{
  if (!oj.Object.innerEquals(this.attributes[prop], value))
  {
    this.attributes[prop] = value;
    this._setupId();
    return true;
  }
  return false;
};

/**
 * @param {Object||string} prop
 * @param {Object} value
 * @returns {boolean}
 */
oj.ArrayRow.prototype._setProp = function(prop, value)
{
  if (prop == null)
  {
    return true;
  }

  var attrs = {}, p;

  if (arguments.length > 1)
  {
    attrs[prop] = value;
  }
  else
  {
    for (p in prop)
    {
      if (prop.hasOwnProperty(p))
      {
        attrs[p] = prop[p];
      }
    }
  }

  for (p in attrs)
  {
    if (attrs.hasOwnProperty(p))
    {
      this._setPropInternal(p, attrs[p]);
    }
  }
  return true;
};

oj.ArrayRow._cloneAttributes = function(oldData, newData)
{
  var prop;
  newData = newData || {};
  for (prop in oldData)
  {
    if (oldData.hasOwnProperty(prop)) {// && oldData[prop] !== undefined) {
      if (typeof (oldData[prop]) !== 'object')
      {
        // Only overwrite if not undefined
        if (newData.hasOwnProperty(prop))
        {
          if (oldData[prop] !== undefined)
          {
            newData[prop] = oldData[prop];
          }
        }
        else
        {
          newData[prop] = oldData[prop];
        }
      }
      else
      {
        newData[prop] = oj.ArrayRow._cloneAttributes(oldData[prop], null);
      }
    }
  }
  return newData;
};


/*jslint browser: true*/

/**
 * @export
 * @class oj.ArrayRowSet
 * @classdesc RowSet of Row objects 
 * 
 * @param {Array=} rows Set of row objects or JS array of data to put into rowSet at construction time 
 * @param {Object=} options Passed through to the user's initialize routine, if any, upon construction 
 * @constructor
 */
oj.ArrayRowSet = function(rows, options)
{
  // Initialize
  oj.ArrayRowSet._init(this, rows, options, null);
};

/**
 * @export
 * @desc If set, sort the rowSet using the given attribute of a row (if string); function(Row) returning a string attribute
 * by which the sort should take place; function(Row1, Row2) if a user-defined function comparing Row1 and Row2 (see the
 * JavaScript array.sort() for details)
 * 
 * @type {String|function(Object)|function(Object,Object)}
 */
oj.ArrayRowSet.prototype.comparator = null;

/**
 * @export
 * @desc Set to true if sort is supported.
 * 
 * @type boolean
 */
oj.ArrayRowSet.prototype.sortSupported = true;


// Subclass from oj.Object 
oj.Object.createSubclass(oj.ArrayRowSet, oj.RowSet, "ArrayRowSet.ArrayRowSet");

oj.ArrayRowSet.prototype.Init = function()
{
  oj.ArrayRowSet.superclass.Init.call(this);
};

oj.ArrayRowSet._init = function(rowSet, rows, options, properties)
{
  var prop;
  rowSet._eventHandlers = [];
  rowSet._startIndex = 0;

  rowSet.Init();

  // First, copy all properties passed in
  if (properties)
  {
    for (prop in properties)
    {
      if (properties.hasOwnProperty(prop))
      {
        rowSet[prop] = properties[prop];
      }
    }
  }

  // Check options
  options = options || {};

  rowSet._rows = [];

  if (rows != null && rows !== undefined)
  {
    rowSet._data = (rows instanceof Array) ? rows : rows();

    if (!(rows instanceof Array))
    {
      // subscribe to observableArray
      (/** @type {{subscribe: Function}} */(rows))['subscribe'](function(values) {
        var rowArray = rowSet._getRowArray(values, null, null);
        rowSet.reset(rowArray);
      }, null, 'change');
    }

    rowSet._totalSize = rowSet._data.length;

    rowSet._idAttribute = 'id';
    if (options != null && options['idAttribute'] != null)
    {
      rowSet._idAttribute = options['idAttribute'];
    }
  }
};

/**
 * Add an instance of this RowSet's Row(s) to the end of the RowSet.
 * @param {Object} m Row object (or array of rows) to add. These can be already-created instance of the oj.Row object, or sets of attribute/values, which will be wrapped by add().
 * @param {Object=} options at: splice the new Row into the RowSet at the value given (at:index) <p>
 *                          deferred: if true, return a promise as though this RowSet were virtual whether it is or not
 *                          silent: if set, do not fire an add event 
 * 
 * @returns {Object} if deferred or virtual, return a promise when the set has completed
 * @export
 */
oj.ArrayRowSet.prototype.add = function(m, options)
{
  options = options || {};
  var index = options['at'];
  var deferred = options['deferred'];

  this._addToRowSet(m, index, options);

  if (deferred)
  {
    return $.Deferred().resolve().promise();
  }
  return null;
};

/**
 * Return the Row object found at the given index of the RowSet, or a promise object that will return the Row to a function
 * in the done() call.
 * 
 * @param {number} index Index for which to return the Row object. 
 * @param {Object=} options <p>
 *                  fetchSize: fetch size to use if the call needs to fetch more records from the server, if virtualized.  Overrides the overall fetchSize setting <p>
 *                  deferred: if true, return a deferred/promise object as described below.  If not specified, the return value will
 *                   be determined by whether or not the RowSet is virtual
 * @return {Object} Row object located at index. If index is out of range, returns null.  If this is a paging/virtual RowSet or
 *                  if deferred is specified and true, at will return a jQuery promise object which will call its done function,
 *                  passing the value at(index) 
 * @export
 */
oj.ArrayRowSet.prototype.at = function(index, options)
{
  options = options || {};
  var deferred = options['deferred'];

  if (index < 0 || index >= this._rows.length)
  {
    return null;
  }
  var row = this._rows[index];

  if (deferred)
  {
    return $.Deferred().resolve(row).promise();
  }
  return row;
};

/**
 * @export
 * Return a copy of the RowSet
 * @return {Object} copy of the RowSet
 */
oj.ArrayRowSet.prototype.clone = function()
{
  var rs = new this.constructor(), i;

  var row;
  for (i = 0; i < this._rows.length; i = i + 1)
  {
    row = this.at(i, null);
    if (row)
    {
      rs.add(row.clone(), {'at': i});
    }
  }

  return rs;
};

/**
 * Loads the data into the RowSet
 * @param {Object=} options Options to control fetch<p>
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.RowSet
 * @instance
 */
oj.ArrayRowSet.prototype.fetch = function(options)
{
  options = options || {};
  this._startFetch();
  var pageSize = options['pageSize'] > 0 ? options['pageSize'] : -1;
  this._startIndex = options != null ? (options['startIndex'] != null ? options['startIndex'] : 0) : 0;
  this._rows = this._getRowArray(this._data, this._idAttribute, this._startIndex, pageSize);
  this._endFetch(true);
}

/**
 * Return the first Row object from the RowSet whose Row id value is the given id
 * Note this method will not function as expected if the id is not set
 * @param {string} id ID for which to return the Row object, if found. 
 * @param {Object=} options <p>
 *                  fetchSize: fetch size to use if the call needs to fetch more records from the server, if virtualized.  Overrides the overall fetchSize setting<p>
 *                  deferred: if true, return a promise as though this RowSet were virtual whether it is or not
 * @return {Object} First Row object in the RowSet where Row.id = id. If none are found, returns null.
 *                  If deferred or virtual, return a promise passing the Row when done
 * @export
 */
oj.ArrayRowSet.prototype.get = function(id, options)
{
  options = options || {};
  var deferred = options['deferred'];
  var i;
  var row = null;
  for (i = 0; i < this._rows.length; i = i + 1)
  {
    row = this._rows[i];
    if (row !== undefined && row['id'] == id)
    {
      if (deferred)
      {
        return $.Deferred().resolve(row);
      }
      return row;
    }
  }
  return row;
};

/**
 * @export
 * Return whether there is more data which can be fetched.
 * @return {boolean} whether there is more data
 */
oj.ArrayRowSet.prototype.hasMore = function()
{
  return false;
};

/**
 * Return the array index location of the given Row object.
 * @param {Object} row Row object to locate 
 * @param {Object=} options deferred: if true, return a promise as though this RowSet were virtual whether it is or not
 
 * @return {number} The index of the given Row object, or a promise that will call with the index when complete.
 *                  If the object is not found, returns -1.
 * @export
 */
oj.ArrayRowSet.prototype.indexOf = function(row, options)
{
  var location;
  options = options || {};
  var deferred = options['deferred'];

  if (deferred)
  {
    return this.get(row['id'], null).then(function(loc) {
      return loc.index;
    });
  }
  location = this.get(row['id']);

  return location.index;
};

/**
 * @export
 * Determine if the RowSet has any Rows
 * 
 * @returns {boolean} true if RowSet is empty
 */
oj.ArrayRowSet.prototype.isEmpty = function()
{
  return this._rows.length === 0;
};

/**
 * Remove a Row from the RowSet, if found.
 * @param {Object} row Row object
 * @param {Object=} options silent: if set, do not fire a remove event 
 * @export
 */
oj.ArrayRowSet.prototype.remove = function(row, options)
{
  options = options || {};
  this._removeInternal(row, -1, options);
};

/**
 * Remove and replace the RowSet's entire list of Rows with a new set of Rows, if provided. Otherwise, empty the RowSet.
 * @param {Object=} data Array of Row objects with which to replace the RowSet's data. 
 * @param {Object=} options user options, passed to event
 * @export
 */
oj.ArrayRowSet.prototype.reset = function(data, options)
{
  var i;

  options = options || {};
  options['previousRows'] = this._rows;
  options['silent'] = true;

  if (data === undefined || data == null || (data instanceof Array && data.length == 0))
  {
    for (i = 0; i < this._rows.length; i = i + 1)
    {
      if (this._rows[i])
      {
        this._rows[i]['rowSet'] = null;
      }
    }
    this._rows = [];
  }
  else
  {
    this._rows = [];

    if (data instanceof Array)
    {
      for (i = 0; i < data.length; i = i + 1)
      {
        this.add(/** @type oj.Row */ (data[i]), options);
      }
    }
    else
    {
      this.add(/** @type oj.Row */ (data), options);
    }
  }
  oj.ArrayRowSet.superclass._handleEvent.call(this, oj.RowSet.EventType['RESET'], null);
};

/**
 * @export
 * Return the length of the RowSet
 * @returns {number} length of the RowSet
 */
oj.ArrayRowSet.prototype.size = function()
{
  return this._rows.length;
};

/**
 * @export
 * Sort the Rows in the RowSet
 */
oj.ArrayRowSet.prototype.sort = function()
{
  var comparator = this['comparator'], self;

  // Check for comparator
  if (!this._hasComparator())
  {
    return;
  }

  self = this;
  this._rows.sort(function(a, b)
  {
    return oj.ArrayRowSet._sortFunc(a, b, comparator, self, self);
  });
  this._realignRowIndices(0);
  oj.ArrayRowSet.superclass._handleEvent.call(this, oj.RowSet.EventType['SORT'], null);
};

/**
 * @export
 * Return the total length of the RowSet
 * @returns {number} length of the RowSet
 */
oj.ArrayRowSet.prototype.totalSize = function()
{
  return this._totalSize;
};

/**
 * @param {Object} m Row instance or array of Rows or sets of attribute/values
 * @param {number} index Index value
 * @param {Object=} options silent: if set, do not fire an add event 
 */
oj.ArrayRowSet.prototype._addToRowSet = function(m, index, options)
{
  var i, row;
  options = options || {};
  var silent = options['silent'];
  
  if (!(m instanceof Array))
  {
    m = [m];
  }
  for (i = 0; i < m.length; i++)
  {
    row = m[i];
    
    if (!(row instanceof oj.ArrayRow))
    {
      row = new oj.ArrayRow(row, {'idAttribute': this._idAttribute});
    }
    if (index === undefined)
    { 
      this._rows.push(row);
      row['index'] = this._rows.length - 1;
    }
    else
    {
      this._rows[index + i] = row;
      row['index'] = index + i;
    }
    row['rowSet'] = this;
    if (!silent)
    {
      oj.ArrayRowSet.superclass._handleEvent.call(this, oj.RowSet.EventType['ADD'], {'rowIdx': row['index'], 'row': row});
    }
  }
}

oj.ArrayRowSet._compareKeys = function(keyA, keyB, sortDirection)
{
  if (sortDirection === -1)
  {
    if (keyA < keyB)
    {
      return 1;
    }
    if (keyB < keyA)
    {
      return -1;
    }
  }
  else
  {
    if (keyA > keyB)
    {
      return 1;
    }
    if (keyB > keyA)
    {
      return -1;
    }
  }
  return 0;
};

oj.ArrayRowSet._getKey = function(val, attr) {
  if (val instanceof oj.Row) {
    return val.get(attr);
  }
  if ($.isFunction(val[attr])) {
    return val[attr]();
  }
  return val[attr];
};

oj.ArrayRowSet.prototype._getRowArray = function(values, idAttribute, startIndex, pageSize)
{
  var endIndex = values.length - 1;
  if (pageSize > 0)
  {
    endIndex = startIndex + pageSize - 1;
  }

  if (endIndex != null)
  {
    endIndex = endIndex > values.length - 1 ? values.length - 1 : endIndex;
  }
  else
  {
    endIndex = values.length;
  }

  var rowArray = [], i, prop;
  for (i = 0; i <= endIndex; i++)
  {
    var clonedRowValues = {};
    var rowValues = null;
    if (values[i] instanceof oj.Row)
    {
      rowValues = values[i].pairs();
    }
    else
    {
      rowValues = values[i];
    }
    for (prop in rowValues)
    {
      if (rowValues.hasOwnProperty(prop))
      {
        clonedRowValues[prop] = rowValues[prop];
      }
    }
    var row = new oj.ArrayRow(clonedRowValues, {'idAttribute': idAttribute});
    row['index'] = i;
    rowArray[i] = row;
  }

  return rowArray;
};

oj.ArrayRowSet.prototype._getSortAttrs = function(sortStr)
{
  if (sortStr === undefined)
  {
    return [];
  }
  return sortStr.split(",");
};

oj.ArrayRowSet.prototype._getSortDirStr = function()
{
  if (this['sortDirection'] === -1)
  {
    return "dsc";
  }
  return "asc";
};

oj.ArrayRowSet.prototype._hasComparator = function()
{
  var comparator = this['comparator'];
  return comparator !== undefined && comparator !== null;
};

// Realign all the indices of the rows (after sort for example)
oj.ArrayRowSet.prototype._realignRowIndices = function(start)
{
  var row;
  for (var i = start; i < this._rows.length; i++)
  {
    row = this._rows[i];
    if (row)
    {
      row['index'] = i;
    }
  }
};

oj.ArrayRowSet.prototype._removeInternal = function(row, index, options)
{
  options = options || {};
  index = index == -1 ? this.get(row).index : index;
  var silent = options['silent'];

  if (index > -1)
  {
    // only unset the RowSet setting if it's mine
    if (row !== undefined && row.rowSet === this)
    {
      row.rowSet = null;
    }
    this._rows.splice(index, 1);
    if (!silent)
    {
      var opt = {};
      options['index'] = index;
      if (row !== undefined)
      {
        oj.ArrayRowSet.superclass._handleEvent.call(this, oj.RowSet.EventType['REMOVE'], {'rowIdx': index, 'row': row});
      }
    }
  }
  return row;
};

oj.ArrayRowSet.prototype._setRow = function(index, row)
{
  this._rows[index] = row;
  row['index'] = index;
};

oj.ArrayRowSet._sortFunc = function(a, b, comparator, rowSet, self)
{
  var keyA, keyB, i, retVal;

  if ($.isFunction(comparator))
  {
    // How many args?
    if (comparator.length === 1)
    {
      // "sortBy" comparator option
      keyA = comparator.call(self, a);
      keyB = comparator.call(self, b);
      var attrs1 = oj.StringUtils.isString(keyA) ? keyA.split(",") : [keyA];
      var attrs2 = oj.StringUtils.isString(keyB) ? keyB.split(",") : [keyB];
      for (i = 0; i < attrs1.length; i++)
      {
        retVal = oj.ArrayRowSet._compareKeys(attrs1[i], attrs2[i], rowSet['sortDirection']);
        if (retVal !== 0)
        {
          return retVal;
        }
      }
    }
    // "sort" comparator option
    return comparator.call(self, a, b);
  }
  // String option
  if (oj.StringUtils.isString(comparator))
  {
    var attrs = comparator.split(",");

    for (i = 0; i < attrs.length; i++)
    {
      keyA = oj.ArrayRowSet._getKey(a, attrs[i]);
      keyB = oj.ArrayRowSet._getKey(b, attrs[i]);
      retVal = oj.ArrayRowSet._compareKeys(keyA, keyB, rowSet['sortDirection']);
      if (retVal !== 0)
      {
        return retVal;
      }
    }
  }
  return 0;
};

/**
 * Indicate starting fetch
 * @private
 */
oj.ArrayRowSet.prototype._startFetch = function()
{
  oj.ArrayRowSet.superclass._handleEvent.call(this, oj.RowSet.EventType['REQUEST'], null);
};

/**
 * Indicate ending fetch
 * @param {boolean} refresh whether the listener should refresh based on the fetched data
 * @private
 */
oj.ArrayRowSet.prototype._endFetch = function(refresh)
{
  oj.ArrayRowSet.superclass._handleEvent.call(this, oj.RowSet.EventType['SYNC'], refresh);
};
/**
 * Convenient class that represents an empty node set
 * @param {Object} parent the parent key
 * @param {number} start the start index
 * @constructor
 * @export
 */
oj.EmptyNodeSet = function(parent, start)
{
    this.m_parent = parent;
    this.m_start = start;
};

/**
 * Gets the parent
 * @return {Object} the key of the parent.
 * @export
 */
oj.EmptyNodeSet.prototype.getParent = function()
{
    return this.m_parent;
};

/**
 * Gets the start index of the result set.  
 * @return {number} the start index of the result set.  
 * @export
 */
oj.EmptyNodeSet.prototype.getStart = function()
{
    return this.m_start;
};

/**
 * Gets the actual count of the result set.  
 * @return {number} the actual count of the result set.  
 * @export
 */
oj.EmptyNodeSet.prototype.getCount = function()
{
    return 0;
};

/**
 * Gets the data of the specified index.  An error is throw when 1) the range is not yet available and
 * 2) the index specified is out of bounds. 
 * @param {number} index the index of the node/row in which we want to retrieve the data from.  
 * @return {Object} the data for the specified index.
 * @export
 */
oj.EmptyNodeSet.prototype.getData = function(index)
{
    return null;
};

/**
 * Gets the metadata of the specified index.  An error is throw when 1) the range is not yet available and 
 * 2) the index specified is out of bounds. 
 * The metadata that the data source must return are:
 *  1) key - Object, the key of the node/row.
 *  2) state - state of the node, valid values are 'expanded', 'collapsed', 'leaf'. 
 *  3) depth - number, the depth of the node/row. 
 * @param {number} index the index of the node/row in which we want to retrieve the metadata from.  
 * @return {Object} the metadata object for the specific index.
 * @export
 */
oj.EmptyNodeSet.prototype.getMetadata = function(index)
{
    return null;
};
/**
 * Wraps around the NodeSet to provide additional metadata
 * @param {Object} nodeSet the node set to wrap
 * @param {function(Object, Object)} metadataCallback callback to inject additional metadata information
 * @param {Object=} range the requested range
 * @constructor
 * @export
 */
oj.NodeSetWrapper = function(nodeSet, metadataCallback, range)
{
    this.m_nodeSet = nodeSet;
    this.m_callback = metadataCallback;
    this.m_range = range;
};

/**
 * Gets the parent
 * @return {Object} the key of the parent.
 * @export
 */
oj.NodeSetWrapper.prototype.getParent = function()
{
    return this.m_nodeSet.getParent();
};

/**
 * Gets the start index of the result set.  
 * @return {number} the start index of the result set.  
 * @export
 */
oj.NodeSetWrapper.prototype.getStart = function()
{
    // if the requested start is a subset of the result set, adjust
    // accordingly
    if (this.m_range != null)
    {
        return this.m_range['start'];
    }
    else
    {
        return this.m_nodeSet.getStart();
    }
};

/**
 * Gets the actual count of the result set.  
 * @return {number} the actual count of the result set.  
 * @export
 */
oj.NodeSetWrapper.prototype.getCount = function()
{
    var nodeStart, nodeCount;

    nodeStart = this.m_nodeSet.getStart();
    nodeCount = this.m_nodeSet.getCount();

    // if the requested start is a subset of the NodeSet, adjust
    // accordingly
    if (this.m_range != null)
    {
        if (this.m_range['start'] > nodeStart)
        {
            nodeCount = Math.min(0, nodeCount - (this.m_range['start'] - nodeStart));
        }
        else if (this.m_range['start'] < nodeStart)
        {
            // this is an invalid NodeSet, so just return 0
            nodeCount = 0;
        }
    }

    return nodeCount;
};

/**
 * Gets the data of the specified index.  An error is throw when 1) the range is not yet available and
 * 2) the index specified is out of bounds. 
 * @param {number} index the index of the node/row in which we want to retrieve the data from.  
 * @return {Object} the data for the specified index.
 * @export
 */
oj.NodeSetWrapper.prototype.getData = function(index)
{
    return this.m_nodeSet.getData(index);
};

/**
 * Gets the metadata of the specified index.  An error is throw when 1) the range is not yet available and 
 * 2) the index specified is out of bounds. 
 * The metadata that the data source must return are:
 *  1) key - Object, the key of the node/row.
 *  2) state - state of the node, valid values are 'expanded', 'collapsed', 'leaf'. 
 *  3) depth - number, the depth of the node/row. 
 * @param {number} index the index of the node/row in which we want to retrieve the metadata from.  
 * @return {Object} the metadata object for the specific index.
 * @export
 */
oj.NodeSetWrapper.prototype.getMetadata = function(index)
{
    var metadata, rowKey;

    metadata = this.m_nodeSet.getMetadata(index);
    metadata['index'] = index;
    metadata['parentKey'] = this.getParent();
    rowKey = metadata['key'];

    // inject additional metadata
    this.m_callback.call(null, rowKey, metadata);

    return metadata;
};

/**
 * Gets the node set child of the specified index.
 * @param {number} index the index of the node/row in which we want to retrieve the child node set
 * @return {Object|null} the child node set representing the child tree data.
 * @export
 */
oj.NodeSetWrapper.prototype.getChildNodeSet = function(index) 
{
    var result;
    if (this.m_nodeSet.getChildNodeSet)
    {
        result = this.m_nodeSet.getChildNodeSet(index);
        if (result != null)
        {
            // wraps the child nodeset too
            return new oj.NodeSetWrapper(result, this.m_callback);
        }
    }
    return null;
};
/**
 * A JsonNodeSet represents a collection of nodes.  The JsonNodeSet is an object returned by the success callback
 * of the fetchChildren method on TreeDataSource.  
 * @constructor
 * @export
 */
oj.JsonNodeSet = function(startNode, endNode, data, currKey, depth)
{
    // assert startNode/endNode are number
    oj.Assert.assertNumber(startNode, null);
    oj.Assert.assertNumber(endNode, null);

    this.m_depth = depth;
    this.m_key = currKey;
    this.m_startNode = startNode;
    this.m_endNode = endNode;
    this.m_nodes = data;
};

/**
 * Gets the parent key for this result set.  
 * @return {Object} the parent key for this result set. 
 * @export
 */
oj.JsonNodeSet.prototype.getParent = function()
{
    return this.m_key;
};

/**
 * Gets the start index of the result set.  
 * @return {number} the start index of the result set.
 * @export	
 */
oj.JsonNodeSet.prototype.getStart = function()
{
    return this.m_startNode;
};

/**
 * Gets the actual count of the result set.  
 * @return {number} the actual count of the result set.
 * @export	
 */
oj.JsonNodeSet.prototype.getCount = function()
{
    return Math.max(0, this.m_endNode - this.m_startNode);
};

/**
 * Gets the data of the specified index.  An error is throw when 1) the range is not yet available and
 * 2) the index specified is out of bounds. 
 * @param {number} index the index of the node/row in which we want to retrieve the data from.  
 * @return {Object} the data for the specified index.  oj.RowData should be returned for data that represents a row
 *         with a number of columns.
 * @export
 */
oj.JsonNodeSet.prototype.getData = function(index)
{
    // make sure index are valid
    oj.Assert.assert(index <= this.m_endNode && index >= this.m_startNode);
    if (this.m_nodes[index])
        return this.m_nodes[index].attr;
    else
        return null;
};

/**
 * Gets the metadata of the specified index.  An error is throw when 1) the range is not yet available and 
 * 2) the index specified is out of bounds. 
 * The metadata that the data source must return are:
 *  1) key - Object, the key of the node/row.
 *  2) leaf - boolean, true if it's a leaf, false otherwise. 
 *  3) depth - number, the depth of the node/row. 
 * @param {number} index the index of the node/row in which we want to retrieve the metadata from.  
 * @return {Object} the metadata object for the specific index.
 * @export
 */
oj.JsonNodeSet.prototype.getMetadata = function(index)
{
    var metadata = [];

    // make sure index are valid
    oj.Assert.assert(index <= this.m_endNode && index >= this.m_startNode);

    metadata["key"] = this.m_nodes[index].id ? this.m_nodes[index].id : this.m_nodes[index].attr.id;
    metadata["leaf"] = this.m_nodes[index].leaf;
    metadata["depth"] = this.m_nodes[index].depth;

    if(metadata["leaf"] == null)
    {
        if (this.m_nodes[index].children && this.m_nodes[index].children.length > 0)
        {
            metadata["leaf"] = false;
        }
        else
        {
            metadata["leaf"] = true;
        }
    }

    return metadata;
};

/**
 * Helper method to update the node's depth recursively with its children.
 * @param {Object} currChild the node to update.
 * @param {number} offset the difference between current and updated depth values.
 * @private
 */
oj.JsonNodeSet.prototype._updateDepth = function (currChild, offset)
{
    var i;

    offset++;
    currChild.depth = offset;

    if (currChild.children && currChild.children.length != 0)
    {
        for (i = 0; i < currChild.children.length; i++)
	{
            this._updateDepth(currChild.children[i], offset);
	}
    }
};

/**
 * Gets the node set child of the specified index.
 * @param {number} index the index of the node/row in which we want to retrieve the child node set
 * @return {oj.JsonNodeSet|null} the child node set representing the child tree data.
 * @export
 */
oj.JsonNodeSet.prototype.getChildNodeSet = function(index) {

    var results, key, depth, i;

    depth = this.m_nodes[index].depth;
    results = this.m_nodes[index].children;
    if(results.length == 0)
    {
        return null;
    }
    key = this.m_nodes[index].id ? this.m_nodes[index].id : this.m_nodes[index].attr.id;
    for(i = 0; i < results.length; i++)
    {
        this._updateDepth(results[i], depth);
    }

    return new oj.JsonNodeSet(0, results.length, results, key, 0);
};
/**
 * Flattens a hierarchical node set, which can happen in node set returned from
 * fetchDescendents call.
 * @param {Object} nodeSet the node set to flatten
 * @param {number=} actualStart in the fetch descendent case the result set would
 *        be a subset of the node set.  This param gives the exact start index in the
 *        wrapped node set where the result should start.
 * @constructor
 * @export
 */
oj.FlattenedNodeSet = function(nodeSet, actualStart)
{
    this.m_nodeSet = nodeSet;
    this.m_start = actualStart;
};

/**
 * Gets the parent
 * @return {Object} the key of the parent.
 * @export
 */
oj.FlattenedNodeSet.prototype.getParent = function()
{
    return this.m_nodeSet.getParent();
};

/**
 * Gets the start index of the result set.  
 * @return {number} the start index of the result set.  
 * @export
 */
oj.FlattenedNodeSet.prototype.getStart = function()
{
    // if explicit start index is specified, use it, otherwise
    // delegate to wrapped node set
    if (this.m_start != undefined)
    {
        return this.m_start;
    }
    else
    {
        return this.m_nodeSet.getStart();
    }
};

/**
 * Gets the actual count of the result set.  
 * @return {number} the actual count of the result set.  
 * @export
 */
oj.FlattenedNodeSet.prototype.getCount = function()
{
    // see if it's calculated already
    if (this.m_count === undefined)
    {
        this.m_count = this._getCount(this.m_nodeSet, 0);

        // if explicit start is specified (subset), need to take that into
        // account when calculating total count
        if (this.m_start != undefined)
        {
            this.m_count = this.m_count - this.m_start;
        }
    }

    return this.m_count;
};

/**
 * Recursive function to calculate the total number of nodes in the node set.
 * @param {Object} nodeSet the node set to calculate count
 * @param {number} total the total number of nodes so far 
 * @return {number} the total number of nodes
 * @private
 */
oj.FlattenedNodeSet.prototype._getCount = function(nodeSet, total)
{
    var start, count, i, child;

    start = nodeSet.getStart();
    count = nodeSet.getCount();
    total = total + count;

    // if there's child node set
    if (nodeSet.getChildNodeSet)
    {
        for (i=0; i<count; i++)
        {
            child = nodeSet.getChildNodeSet(i+start);
            if (child != null)
                total = this._getCount(child, total); 
        }
    }

    return total;
};

/**
 * Gets the data of the specified index.  An error is throw when 1) the range is not yet available and
 * 2) the index specified is out of bounds. 
 * @param {number} index the index of the node/row in which we want to retrieve the data from.  
 * @return {Object} the data for the specified index.
 * @export
 */
oj.FlattenedNodeSet.prototype.getData = function(index)
{
    return this._getDataOrMetadata(this.m_nodeSet, index, {'index': this.m_nodeSet.getStart()}, this._getData);
};

/**
 * Gets the metadata of the specified index.  An error is throw when 1) the range is not yet available and 
 * 2) the index specified is out of bounds. 
 * The metadata that the data source must return are:
 *  1) key - Object, the key of the node/row.
 *  2) state - state of the node, valid values are 'expanded', 'collapsed', 'leaf'. 
 *  3) depth - number, the depth of the node/row. 
 * @param {number} index the index of the node/row in which we want to retrieve the metadata from.  
 * @return {Object} the metadata object for the specific index.
 * @export
 */
oj.FlattenedNodeSet.prototype.getMetadata = function(index)
{
    return this._getDataOrMetadata(this.m_nodeSet, index, {'index': this.m_nodeSet.getStart()}, this._getMetadata);
};

/**
 * Callback function to retrieve metadata of specified index in node set
 * @param {Object} nodeSet the node set to retrieve metadata from
 * @param {number} index the index to retrieve metadata from
 * @return {Object} the metadata
 * @private
 */
oj.FlattenedNodeSet.prototype._getMetadata = function(nodeSet, index)
{
    return nodeSet.getMetadata(index);
};

/**
 * Callback function to retrieve data of specified index in node set
 * @param {Object} nodeSet the node set to retrieve data from
 * @param {number} index the index to retrieve data from
 * @return {Object} the data
 * @private
 */
oj.FlattenedNodeSet.prototype._getData = function(nodeSet, index)
{
    return nodeSet.getData(index);
};

/**
 * Retrieve data or metadata (depending on callback function) from the node set
 * @param {Object} nodeSet the node set to retrieve data from
 * @param {number} index the index to retrieve data from
 * @param {Object} current contains the current index keep track by the method
 * @param {function(Object, number)} func the callback function to retrieve data or metadata
 * @return {Object} the data or metadata
 * @private
 */
oj.FlattenedNodeSet.prototype._getDataOrMetadata = function(nodeSet, index, current, func)
{
    var start, count, i, currIndex, child, result;

    // walk the node set recursively until we found the index
    start = nodeSet.getStart();
    count = nodeSet.getCount();
    for (i=0; i<count; i++)
    {
        currIndex = current['index'];
        // found the index
        if (currIndex === index)
            return func.call(this, nodeSet, i+start);

        current['index'] = currIndex+1;
        // if there's child node set
        if (nodeSet.getChildNodeSet)
        {
            child = nodeSet.getChildNodeSet(i+start);
            if (child != null)
            {
                result = this._getDataOrMetadata(child, index, current, func); 
                if (result != null)
                    return result;
            }
        }
    }       

    return null;
};

/**
 * The base class for DataGridDataSource.  
 * @export
 * @extends oj.DataSource
 * @constructor
 */
oj.DataGridDataSource = function(data)
{
    // oj.DataSource would calls Init
    oj.DataGridDataSource.superclass.constructor.call(this, data);
};

// Subclass DataGridDataSource to DataSource
oj.Object.createSubclass(oj.DataGridDataSource, oj.DataSource, "oj.DataGridDataSource");

/**
 * Returns the total number of rows or columns.  If the value return is not >= 0 then it is automatically assumed
 * that the total count is unknown.
 * @param {string} axis the axis in which we inquire for the total count.  Valid values are "row" and "column".
 * @return {number} the total number of rows/columns.
 * @export
 */
oj.DataGridDataSource.prototype.getCount = function(axis)
{
    return 0;
};

/**
 * Returns whether the total count returned in getCount function is an actual or an estimate.
 * @param {string} axis the axis in which we inquire whether the total count is an estimate.  Valid values are 
 *        "row" and "column".
 * @return {string} "exact" if the count returned in getCount function is the actual count, "estimate" if the 
 *         count returned in getCount function is an estimate.  The default value is "exact".
 * @export
 */
oj.DataGridDataSource.prototype.getCountPrecision = function(axis)
{
    return "exact";
};

/**
 * Fetch a range of headers from the data source.
 * @param {Object} headerRange information about the header range, it must contain the following properties:
 *        axis, start, count.
 * @param {string} headerRange.axis the axis of the header that are fetched.  Valid values are "row" and "column".
 * @param {number} headerRange.start the start index of the range in which the header data are fetched.
 * @param {number} headerRange.count the size of the range in which the header data are fetched.  
 * @param {Object} callbacks the callbacks to be invoke when fetch headers operation is completed.  The valid callback
 *        types are "success" and "error".
 * @param {function(oj.HeaderSet)} callbacks.success the callback to invoke when fetch headers completed successfully.
 * @param {function({status: Object})} callbacks.error the callback to invoke when fetch cells failed.
 * @param {Object=} callbackObjects the object in which the callback function is invoked on.  This is optional.  
 *        You can specify the callback object for each callbacks using the "success" and "error" keys.
 * @export
 */
oj.DataGridDataSource.prototype.fetchHeaders = function(headerRange, callbacks, callbackObjects)
{
    oj.Assert.failedInAbstractFunction();
};

/**
 * Fetch a range of cells from the data source.
 * @param {Array.<Object>} cellRange Information about the cell range.  A cell range is defined by an array 
 *        of range info for each axis, where each range contains three properties: axis, start, count.
 * @param {string} cellRange.axis the axis associated with this range where cells are fetched.  Valid 
 *        values are "row" and "column".
 * @param {number} cellRange.start the start index of the range for this axis in which the cells are fetched.
 * @param {number} cellRange.count the size of the range for this axis in which the cells are fetched. 
 * @param {Object} callbacks the callbacks to be invoke when fetch cells operation is completed.  The valid callback
 *        types are "success" and "error".
 * @param {function(oj.CellSet)} callbacks.success the callback to invoke when fetch cells completed successfully.
 * @param {function({status: Object})} callbacks.error the callback to invoke when fetch cells failed.
 * @param {Object=} callbackObjects the object in which the callback function is invoked on.  This is optional.  
 *        You can specify the callback object for each callbacks using the "success" and "error" keys.
 * @export
 */
oj.DataGridDataSource.prototype.fetchCells = function(cellRange, callbacks, callbackObjects)
{
    oj.Assert.failedInAbstractFunction();
};

/**
 * Returns the keys based on the indexes. 
 * @param {Object} indexes the index for each axis
 * @param {Object} indexes.row the index for the row axis
 * @param {Object} indexes.column the index for the column axis
 * @return {Object.<Object, Object>} an object containing the keys for each axis
 * @export
 */
oj.DataGridDataSource.prototype.keys = function(indexes)
{
    oj.Assert.failedInAbstractFunction();
    return null;
};

/**
 * Returns the row and column index based on the keys.
 * @param {Object} keys the key for each axis
 * @param {Object} keys.row the key for the row axis
 * @param {Object} keys.column the key for the column axis
 * @return {Object.<number, number>} indexes an object containing the index for each axis
 * @export
 */
oj.DataGridDataSource.prototype.indexes = function(keys)
{
    oj.Assert.failedInAbstractFunction();
    return null;
};

/**
 * Performs a sort on the data source.
 * @param {Object} criteria the sort criteria. 
 * @param {string} criteria.axis The axis in which the sort is performed, valid values are "row", "column"
 * @param {Object} criteria.key The key that identifies which header to sort
 * @param {string} criteria.direction the sort direction, valid values are "ascending", "descending", "none" (default)
 * @param {Object} callbacks the callbacks to be invoke upon completion of the sort operation.  The callback
 *        properties are "success" and "error".
 * @param {function()} callbacks.success the callback to invoke when the sort completed successfully.  
 * @param {function({status: Object})} callbacks.error the callback to invoke when sort failed.
 * @param {Object=} callbackObjects the object in which the callback function is invoked on.  This is optional.  
 *        You can specify the callback object for each callbacks using the "success" and "error" properties.
 * @export
 */
oj.DataGridDataSource.prototype.sort = function(criteria, callbacks, callbackObjects)
{
    oj.Assert.failedInAbstractFunction();
};

/**
 * Determines whether this DataGridDataSource supports certain feature.
 * @param {string} feature the feature in which its capabilities is inquired.  Currently the only valid feature is "sort".
 * @return {string|null} the name of the feature.  For "sort", the valid return values are: "full", "none", "row", "column".  
 *         Returns null if the feature is not recognized.
 * @export
 */
oj.DataGridDataSource.prototype.getCapability = function(feature)
{
    return null;
};
/**
 * An array based implementation of the DataGridDataSource.
 * @param {Array} data the data in the form of array.
 * @param {Object=} options the options specific to this DataGridDataSource.
 * @param {string=} options.rowHeader the key to the header designated as the row header.
 * @export
 * @constructor
 * @extends oj.DataGridDataSource
 */
oj.ArrayDataGridDataSource = function(data, options)
{
    if (options != null)
    {
        this.rowHeaderKey = options['rowHeader'];
    }

    oj.ArrayDataGridDataSource.superclass.constructor.call(this, data);
};

// Subclass from oj.DataGridDataSource
oj.Object.createSubclass(oj.ArrayDataGridDataSource, oj.DataGridDataSource, "oj.ArrayDataGridDataSource");

/**
 * Initial the array based data source.
 * @export
 */
oj.ArrayDataGridDataSource.prototype.Init = function()
{
    // suck out the column definition from data
    this.columns = this._getColumnsForScaffolding(this.data);
    this._initializeRowKeys();
    
    // call super
    oj.ArrayDataGridDataSource.superclass.Init.call(this);
};

/**
 * Initialize the generated row keys.
 * @private
 */
oj.ArrayDataGridDataSource.prototype._initializeRowKeys = function()
{
    var i;
    this.rowKeys = [];
    for (i=0; i<this.data.length; i+=1)
    {
        this.rowKeys[i] = i.toString();
    }
};

/**
 * Get the column headers from the data, if it is an array of arrays with no row header key set,
 * gets the column number as the column header.
 * @param {Object} data the data to extract the column information.
 * @return {Array} the columns extracted from the data.
 * @private
 */
oj.ArrayDataGridDataSource.prototype._getColumnsForScaffolding = function(data) 
{
    var propertyName, columns;
    if ((typeof data.length !== 'number') || data.length === 0)
    {
        return [];
    }

    columns = [];
    for (propertyName in data[0])
    {
        if (data[0].hasOwnProperty(propertyName)){
            if (!(this.rowHeaderKey != undefined && propertyName == this.rowHeaderKey)){
                columns.push(propertyName);
            }
        }
    }

    return columns;
};

/**
 * Returns the total number of rows or columns.  If the value return is not >= 0 then it is automatically assumed
 * that the total count is unknown.
 * @param {string} axis the axis in which we inquire for the total count.  Valid values are "row" and "column".
 * @return {number} the total number of rows/columns.
 * @export
 */
oj.ArrayDataGridDataSource.prototype.getCount = function(axis)
{
    if (axis === "row")
    {
        return this.data.length;
    }

    if (axis === "column")
    {
        return this.columns.length;
    }

    return 0;
};

/**
 * Retrieve the data for the header of a specified index.
 * @param {string} axis the axis of the header.  Valid values are "row" and "column".
 * @param {number} index the index in which to get the data.
 * @protected
 */
oj.ArrayDataGridDataSource.prototype.getHeaderData = function(axis, index)
{
    if (axis === 'row')
    {
        // if row header is specified
        if (this.rowHeaderKey != undefined)
        {
            return this.data[index][this.rowHeaderKey];
        }
        else if (this.data.length > 0 && this.data[0] instanceof Array)
        {
            // generate default row header for two dimensional array
            if (this.rowKeys[index] === undefined)
            {
                return index.toString();
            }
            else
            {
                return this.rowKeys[index];
            }   
        }
        else
        {
            return null;
        }
    }
    else if (axis === 'column')
    {
        return this.columns[index];
    }
};

/**
 * Retrieve the metadata for the header of a specified index.
 * @param {string} axis the axis of the header.  Valid values are "row" and "column".
 * @param {number} index the index in which to get the metadata.
 * @protected
 */
oj.ArrayDataGridDataSource.prototype.getHeaderMetadata = function(axis, index)
{
    if (axis === 'row')
    {
        if (this.rowHeaderKey != undefined)
        {
            return {'key':index.toString()};            
        }
    }

    return {'key': this.getHeaderData(axis, index)};
};

/**
 * Fetch a range of headers from the data source.
 * @param {Object} headerRange information about the header range, it must contain the following properties:
 *        axis, start, count.
 * @param {string} headerRange.axis the axis of the header that are fetched.  Valid values are "row" and "column".
 * @param {number} headerRange.start the start index of the range in which the header data are fetched.
 * @param {number} headerRange.count the size of the range in which the header data are fetched.  
 * @param {Object} callbacks the callbacks to be invoke when fetch headers operation is completed.  The valid callback
 *        types are "success" and "error".
 * @param {function(HeaderSet)} callbacks.success the callback to invoke when fetch headers completed successfully.
 * @param {function({status: Object})} callbacks.error the callback to invoke when fetch cells failed.
 * @param {Object=} callbackObjects the object in which the callback function is invoked on.  This is optional.  
 *        You can specify the callback object for each callbacks using the "success" and "error" keys.
 * @export
 */
oj.ArrayDataGridDataSource.prototype.fetchHeaders = function(headerRange, callbacks, callbackObjects)
{
    var axis, start, count, end, headerSet;
    
    axis = headerRange.axis;
    start = headerRange.start;
    count = headerRange.count;
  
    oj.Assert.assert(axis === 'row' || axis === 'column');
    oj.Assert.assert(start < this.getCount(axis));
    oj.Assert.assert(count > 0);

    start = Math.max(0, start);
    if (axis === "column")
    {
        end = Math.min(this.columns.length, start+count);
    }
    else
    {
        // check if no row header is available
        if (this.rowHeaderKey === undefined && !(this.data.length > 0 && this.data[0] instanceof Array))
        {
            // header count = 0
            end = start;
        }
        else
        {
            end = Math.min(this.data.length, start+count);
        }
    }
    headerSet = new oj.ArrayHeaderSet(start, end, axis, this);

    if (callbacks != null && callbacks['success'] != null)
    {
        // make sure callbackObjects is not null
        if (callbackObjects == null)
        {
            callbackObjects = {};
        }        
        callbacks['success'].call(callbackObjects['success'], headerSet, headerRange);
    }
 
};

/**
 * Retrieve the data for the cell of a specified indexes.
 * @param {number} row the row index in which to get the data.
 * @param {number} column the column index in which to get the data.
 * @protected
 */
oj.ArrayDataGridDataSource.prototype.getCellData = function(row, column)
{
    var col = this.columns[column];
    return this.data[row][col];
};

/**
 * Retrieve the metadata for the cell of a specified indexes.
 * @param {number} row the row index in which to get the data.
 * @param {number} column the column index in which to get the data.
 * @protected
 */
oj.ArrayDataGridDataSource.prototype.getCellMetadata = function(row, column)
{
    var keys = {"row": this.rowKeys[row], "column": this.columns[column]};
    return {"keys": keys};
};

/**
 * Fetch a range of cells from the data source.
 * @param {Array.<Object>} cellRanges Information about the cell range.  A cell range is defined by an array 
 *        of range info for each axis, where each range contains three properties: axis, start, count.
 * @param {string} cellRanges.axis the axis associated with this range where cells are fetched.  Valid 
 *        values are "row" and "column".
 * @param {number} cellRanges.start the start index of the range for this axis in which the cells are fetched.
 * @param {number} cellRanges.count the size of the range for this axis in which the cells are fetched. 
 * @param {Object} callbacks the callbacks to be invoke when fetch cells operation is completed.  The valid callback
 *        types are "success" and "error".
 * @param {function(CellSet)} callbacks.success the callback to invoke when fetch cells completed successfully.
 * @param {function({status: Object})} callbacks.error the callback to invoke when fetch cells failed.
 * @param {Object=} callbackObjects the object in which the callback function is invoked on.  This is optional.  
 *        You can specify the callback object for each callbacks using the "success" and "error" keys.
 * @export
 */
oj.ArrayDataGridDataSource.prototype.fetchCells = function(cellRanges, callbacks, callbackObjects)
{
    var i, cellRange, rowStart, rowEnd, cellSet, colStart, colEnd;
   
    // extract the start and end row/column info from cellRanges (there should only be two, one for each axis)
    for (i=0; i<cellRanges.length; i+=1)
    {
        cellRange = cellRanges[i];   
        oj.Assert.assert(cellRange['axis'] === 'row' || cellRange['axis'] === 'column');
        oj.Assert.assert(cellRange['start'] < this.getCount(cellRange['axis']));
        oj.Assert.assert(cellRange['count'] > 0);        
        if (cellRange['axis'] === "row")
        {
            rowStart = cellRange['start'];
            rowEnd = Math.min(this.data.length, rowStart + cellRange['count']);
        }
        else if (cellRange['axis'] === "column")
        {
            colStart = cellRange['start'];
            colEnd = Math.min(this.columns.length, colStart + cellRange['count']);
        }
    }

    // check for errors
    if (rowEnd === undefined || colEnd === undefined)
    {
        if (callbacks != null && callbacks['error'] != null)
        {
            // make sure callbackObjects is not null
            if (callbackObjects == null)
            {
                callbackObjects = {};
            }            
            callbacks['error'].call(callbackObjects['error']);
        }
        return;
    }

    cellSet = new oj.ArrayCellSet(rowStart, rowEnd, colStart, colEnd, this);

    if (callbacks != null && callbacks['success'] != null)
    {
        // make sure callbackObjects is not null
        if (callbackObjects == null)
        {
            callbackObjects = {};
        }            
        callbacks['success'].call(callbackObjects['success'], cellSet, cellRanges);
    }    
};

/**
 * Returns the keys based on the indexes. 
 * @param {Object} indexes the index for each axis
 * @param {Object} indexes.row the index for the row axis
 * @param {Object} indexes.column the index for the column axis
 * @return {Object.<Object, Object>} an object containing the keys for each axis
 * @export
 */
oj.ArrayDataGridDataSource.prototype.keys = function(indexes)
{
    var rowIndex = indexes['row'], columnIndex = indexes['column'];
    return {"row": this.rowKeys[rowIndex], "column": this.columns[columnIndex]};
};

/**
 * Returns the row and column index based on the keys.
 * @param {Object} keys the key for each axis
 * @param {Object} keys.row the key for the row axis
 * @param {Object} keys.column the key for the column axis
 * @return {Object.<number, number>} indexes an object containing the index for each axis
 * @export
 */
oj.ArrayDataGridDataSource.prototype.indexes = function(keys)
{
    var rowKey = keys['row'], columnKey = keys['column'];
    return {"row": this.rowKeys.indexOf(rowKey), "column": this.columns.indexOf(columnKey)};
};

/**
 * Performs a sort on the data source.
 * @param {Object} criteria the sort criteria. 
 * @param {string} criteria.axis The axis in which the sort is performed, valid values are "row", "column"
 * @param {Object} criteria.key The key that identifies which header to sort
 * @param {string} criteria.direction the sort direction, valid values are "ascending", "descending", "none" (default)
 * @param {Object} callbacks the callbacks to be invoke upon completion of the sort operation.  The callback
 *        properties are "success" and "error".
 * @param {function()} callbacks.success the callback to invoke when the sort completed successfully.  
 * @param {function({status: Object})} callbacks.error the callback to invoke when sort failed.
 * @param {Object=} callbackObjects the object in which the callback function is invoked on.  This is optional.  
 *        You can specify the callback object for each callbacks using the "success" and "error" properties.
 * @export
 */
oj.ArrayDataGridDataSource.prototype.sort = function(criteria, callbacks, callbackObjects)
{
    var sortArray = [], indices = [], newData = [], newColumns = [], newRowKeys = [], i, headerIndex, axis, headerKey, direction; 
            
    axis = criteria['axis']; 
    headerKey = criteria['key']; 
    direction = criteria['direction'];
    
    // make sure callbackObjects is non null
    if (callbacks != null && callbackObjects == null)
    {
        callbackObjects = {};
    }

    if (axis === 'column')
    {
        headerIndex = this.columns.indexOf(headerKey);
        //get the values in the column and create an array of each index
        for (i=0; i<this.data.length; i+=1)
        {
            sortArray[i] = this.data[i][this.columns[headerIndex]];
            indices[i] = i;
        }
        
        //sort the indicies so we can map where everything needs to move
        indices.sort(this._naturalSort(sortArray, direction));

        //reorder the data
        for (i=0; i<this.data.length; i+=1)
        {
            newData[i] = this.data[indices[i]];
            newRowKeys[i] = this.rowKeys[indices[i]];
        }
        
        //set the data
        this.data = newData;
        this.rowKeys = newRowKeys;
        if (callbacks != null && callbacks['success'] != null)
        {
            callbacks['success'].call(callbackObjects['success']);
        }
    }
    else if (axis === 'row')
    {
        headerIndex = this.rowKeys.indexOf(headerKey);
        for (i=0; i<this.columns.length; i+=1)
        {
            sortArray[i] = this.data[headerIndex][this.columns[i]];
            indices[i] = i;
        }
        
        indices.sort(this._naturalSort(sortArray, direction));
        
        for (i=0; i<this.columns.length; i+=1)
        {
            newColumns[i] = this.columns[indices[i]];
        }
        
        this.columns = newColumns;
        if (callbacks !== null && callbacks['success'] != null)
        {
            callbacks['success'].call(callbackObjects['success']);
        }        
    }
    else
    {
        if (callbacks !== null && callbacks['error'] != null)
        {
            callbacks['error'].call(callbackObjects['error'], "Invalid axis value");
        }    
    }
};

/**
 * Determines whether this DataGridDataSource supports certain feature.
 * @param {string} feature the feature in which its capabilities is inquired.  Currently the only valid feature is "sort".
 * @return {string|null} the name of the feature.  For sort, the valid return values are: "full", "none".  Returns null if the
 *         feature is not recognized.
 * @export
 */
oj.ArrayDataGridDataSource.prototype.getCapability = function(feature)
{
    if (feature === 'sort')
    {
        // array based data source supports column sorting only
        return 'column';
    }
    if (feature === 'move')
    {
        return 'row';
    }
    return null;
};

/**
 * Get a comparator fuicntion for natural sorting of objects
 * @param {Array} sortArray the array to actually sort based on
 * @param {string} direction ascending, descending 
 * @returns {function(Object, Object)|undefined} a comapartor function, dependent on direction
 * @private
 */
oj.ArrayDataGridDataSource.prototype._naturalSort = function(sortArray, direction) 
{
    if (direction === 'ascending')
    {
        return function(a, b) 
        {
            var as, bs;
            //Get the values the array we're sorting
            a = sortArray[a];
            b = sortArray[b];
            //Strings of numbers return false, so we can compare strings of numebers with numbers                
            as = isNaN(a);
            bs = isNaN(b);
            //If they are strings, check to see if they are dates, if they are, turn the string to a sortable date formatted string           
            if (a instanceof Date) {
                a = a.toISOString();
                as = true;
            }
            if (b instanceof Date) {
                b = b.toISOString();
                bs = true;
            }
            //both are string
            if (as && bs)
            {
                return a < b ? -1 : a === b ? 0 : 1;
            }
            //only a is a string
            if (as)
            {
                return 1;
            }
            //only b is a string
            if (bs)
            {
                return -1;
            }
            //both are numbers
            return a - b;
        };
    }
    if (direction === 'descending')
    {
        return function(a, b) 
        {
            var as, bs;
            a = sortArray[a];
            b = sortArray[b];
            as = isNaN(a);
            bs = isNaN(b);
            if (a instanceof Date) {
                a = a.toISOString();
                as = true;
            }
            if (b instanceof Date) {
                b = b.toISOString();
                bs = true;
            }
            if (as && bs)
            {
                return a > b ? -1 : a === b ? 0 : 1;
            }
            if (as)
            {
                return -1;
            }
            if (bs)
            {
                return 1;
            }
            return b - a;
        };
    }

    // only if direction is not recognized
    return;
};


/**
 * Move a model to a new index in the collection
 * @export
 */
oj.ArrayDataGridDataSource.prototype.move = function(moveKey, atKey)
{
    var moveKeyIndex, moveData, atKeyIndex, event;
    moveKeyIndex = this.rowKeys.indexOf(moveKey);

    this.rowKeys.splice(moveKeyIndex,1);
    moveData = this.data.splice(moveKeyIndex,1)[0];
    
    event = {'source': this, 'operation':'delete', 'keys':{'row':moveKey, 'column':null}};
    this.handleEvent("change", event);    
    
    if (atKey === null)
    {
        this.rowKeys.push(moveKey);
        this.data.push(moveData);    
    }
    else
    {
        atKeyIndex = this.rowKeys.indexOf(atKey);
        this.rowKeys.splice(atKeyIndex,0, moveKey);
        this.data.splice(atKeyIndex,0, moveData);    
    }

    event = {'source': this, 'operation':'insert', 'keys':{'row':moveKey, 'column':null}};
    this.handleEvent("change", event);
};


//////// testing methods to get properties /////////

/**
 * Gets the rowHeaderKey property
 * @export
 */
oj.ArrayDataGridDataSource.prototype.getRowHeaderKey = function()
{
    return this.rowHeaderKey;
};

/**
 * Gets the columns property
 * @export
 */
oj.ArrayDataGridDataSource.prototype.getColumns = function()
{
    return this.columns;
};

/**
 * Gets the rowKeys property
 * @export
 */
oj.ArrayDataGridDataSource.prototype.getRowKeys = function()
{
    return this.rowKeys;
};

/**
 * Gets the data property
 * @export
 */
oj.ArrayDataGridDataSource.prototype.getData = function()
{
    return this.data;
};
/*jslint browser: true*/
/**
 * @export    
 * This class captures all translation resources and style classes used by the DataGrid.
 * This should be populated with information extracted through the framework and set on the DataGrid.
 * Internal.  Developers should never use this class.
 * @constructor
 */
oj.DataGridResources = function(rtlMode, translationFunction)
{
    this.rtlMode = rtlMode;
    this.translationFunction = translationFunction;
    this.styles = {};
    this.styles['datagrid'] = "oj-datagrid";
    this.styles['cell'] = "oj-datagrid-cell";
    this.styles['banded'] = "oj-datagrid-banded";
    this.styles['row'] = "oj-datagrid-row";
    this.styles['databody'] = "oj-datagrid-databody";
    this.styles['topcorner'] = "oj-datagrid-top-corner";
    this.styles['bottomcorner'] = "oj-datagrid-bottom-corner";
    this.styles['rowheaderspacer'] = "oj-datagrid-row-header-spacer";
    this.styles['colheaderspacer'] = "oj-datagrid-column-header-spacer";
    this.styles['status'] = "oj-datagrid-status";
    this.styles['emptytext'] = "oj-datagrid-empty-text";
    this.styles['header'] = "oj-datagrid-header";                
    this.styles['headercell'] = "oj-datagrid-header-cell";
    this.styles['headercellcontent'] = "oj-datagrid-header-cell-content";
    this.styles['rowheader'] = "oj-datagrid-row-header";
    this.styles['colheader'] = "oj-datagrid-column-header";
    this.styles['colheadercell'] = "oj-datagrid-column-header-cell";
    this.styles['rowheadercell'] = "oj-datagrid-row-header-cell";
    this.styles['scroller-mobile'] = "oj-datagrid-scroller-touch";
    this.styles['scroller'] = "oj-datagrid-scroller";
    this.styles['scrollers'] = "oj-datagrid-scrollers";
    this.styles['hover'] = "oj-hover";
    this.styles['active'] = "oj-active";
    this.styles['selected'] = "oj-selected";
    this.styles['disabled'] = "oj-disabled";
    this.styles['enabled'] = "oj-enabled";
    this.styles['default'] = "oj-default";
    this.styles['sortcontainer'] = "oj-datagrid-sort-icon-container";
    this.styles['sortascending'] = "oj-datagrid-sort-ascending-icon";
    this.styles['sortdescending'] = "oj-datagrid-sort-descending-icon";
    this.styles['icon'] = "oj-component-icon";
    this.styles['clickableicon'] = "oj-clickable-icon-nocontext";    
    this.styles['info'] = "oj-helper-hidden-accessible";
    this.styles['rowexpander'] = "oj-rowexpander";
    this.styles['cut'] = "oj-datagrid-cut";
    this.styles['move'] = "oj-datagrid-move";
    this.styles['droptarget'] = "oj-datagrid-drop-target";
    
    this.commands = {};
    this.commands['sortCol'] = "oj-datagrid-sortCol";
    this.commands['sortColAsc'] = "oj-datagrid-sortColAsc";
    this.commands['sortColDsc'] = "oj-datagrid-sortColDsc";
    this.commands['sortRow'] = "oj-datagrid-sortRow";
    this.commands['sortRowAsc'] = "oj-datagrid-sortRowAsc";
    this.commands['sortRowDsc'] = "oj-datagrid-sortRowDsc";
    this.commands['resize'] = "oj-datagrid-resize";
    this.commands['resizeWidth'] = "oj-datagrid-resizeWidth";
    this.commands['resizeHeight'] = "oj-datagrid-resizeHeight";
    this.commands['cut'] = "oj-datagrid-cut";
    this.commands['paste'] = "oj-datagrid-paste";
    
    this.attributes = {};
    this.attributes['key'] = "data-oj-key";
    this.attributes['resizable'] = "data-oj-resizable";
    this.attributes['sortable'] = "data-oj-sortable";    
    this.attributes['sortDir'] = "data-oj-sortdir";    
    this.attributes['expander'] = "data-oj-expander";    
    this.attributes['expanderIndex'] = "data-oj-expander-index";    
    this.attributes['container'] = oj.Components._OJ_CONTAINER_ATTR;
};

/**
 * Whether the reading direction is right to left.
 * @return {boolean} true if reading direction is right to left, false otherwise.
 * @export
 */
oj.DataGridResources.prototype.isRTLMode = function()
{
    return (this.rtlMode === "rtl") ? true : false;
};

/**
 * Gets the translated text
 * @param {string} key the key to the translated text
 * @param {Array=} args optional arguments to format the translated text
 * @return {string|null} the translated text
 * @export
 */
oj.DataGridResources.prototype.getTranslatedText = function(key, args)
{
    return this.translationFunction(key, args);
};

/**
 * Gets the mapped style class
 * @param {string} key the key to the style class
 * @return {string|null} the style class
 * @export
 */
oj.DataGridResources.prototype.getMappedStyle = function(key)
{
    if (key != null)
    {
        return this.styles[key];
    }
    return null;
};

/**
 * Gets the mapped command class
 * @param {string} key the key to the command class
 * @return {string|null} the command class
 * @export
 */
oj.DataGridResources.prototype.getMappedCommand = function(key)
{
    if (key != null)
    {
        return this.commands[key];
    }
    return null;
};

/**
 * Gets the mapped attribute
 * @param {string} key the key to the attribute
 * @return {string|null} the attribute
 * @export
 */
oj.DataGridResources.prototype.getMappedAttribute = function(key)
{
    if (key != null)
    {
        return this.attributes[key];
    }
    return null;
};
/**
 * @class 
 * @name oj.ojDataGrid
 * @augments oj.baseComponent
 *
 * @classdesc
 * <h3 id="datagridOverview-section">
 *   JET DataGrid Component
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#datagridOverview-section"></a>
 * </h3>
 * <p>Description:</p>
 * <p>A JET DataGrid is a themable, WAI-ARIA compliant component that displays data in a cell oriented grid.  Data inside the DataGrid can be associated with row and column headers.  Page authors can customize the content rendered inside cells and headers.</p>
 *
 * <h3 id="data-section">
 *   Data
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#data-section"></a>
 * </h3>
 * <p>The JET DataGrid gets its data from a DataGridDataSource.  There are several types of DataGridDataSource that are provided out of the box:</p>
 * <ul>
 * <li>oj.ArrayDataGridDataSource</li>
 * <li>oj.CollectionDataGridDataSource</li>
 * <li>oj.PagingDataGridDataSource</li>
 * <li>oj.FlattenedTreeDataGridDataSource</li>
 * </ul>
 *
 * <p>oj.ArrayDataGridDataSource - Use this when the undering data is a static array.  The ArrayDataGridDataSource supports both single array (in which case each item in the array represents a row of data in the DataGrid) and two dimensional array (in which case each item in the array represents a cell in the DataGrid).  See the documentation for oj.ArrayDataGridDataSource for more details on the available options.</p>
 *
 * <p>oj.CollectionDataGridDataSource - Use this when oj.Collection is the model for the underlying data.  Note that the DataGrid will automatically react to model event from the underlying oj.Collection.  See the documentation for oj.CollectionDataGridDataSource for more details on the available options.</p>
 *
 * <p>oj.PagingDataGridDataSource - Use this when the DataGrid is driven by an associating ojPagingControl.  See the documentation for oj.PagingDataGridDataSource for more details on the available options.</p>
 *
 * <p>oj.FlattenedTreeDataGridDataSource - Use this when hierarchical data is displayed in the DataGrid.  The FlattenedDataGridDataSource takes an oj.TreeDataSource and adapts that to the DataGridDataSource.  The ojRowExpander works with the FlattenedTreeDataGridDataSource to enable expanding/collapsing of rows.</p>
 *
 * <p>Developer can also create their own DataSource by extending the oj.DataGridDataSource class.  See the cookbook for an example of a custom DataGridDataSource.</p>
 *
 * <h3 id="keyboard-section">
 *   Keyboard interaction
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
 * </h3>
 *
 * <p>When a data cell has focus:</p>
 * <table class="keyboard-table">
 *   <thead>
 *     <tr>
 *       <th>Key</th>
 *       <th>Use</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td><kbd>Tab</kbd></td>
 *       <td>The first Tab into the DataGrid moves focus to the first cell of the first row.  The second Tab moves focus to the next focusable element outside of the DataGrid.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Left Arrow</kbd></td>
 *       <td>Moves focus to the cell of the previous column within the current row.  There is no wrapping at the beginning or end of the columns.  If a row header is present, then the row header next to the first column of the current row will gain focus.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Right Arrow</kbd></td>
 *       <td>Moves focus to the cell of the next column within the current row.  There is no wrapping at the beginning or end of the columns.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Up Arrow</kbd></td>
 *       <td>Moves focus to the cell of the previous row within the current column.  There is no wrapping at the beginning or end of the rows.  If a column header is present, then the column header above the first row of the current column will gain focus.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Down Arrow</kbd></td>
 *       <td>Moves focus to the cell of the next row within the current column.  There is no wrapping at the beginning or end of the rows.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Home</kbd></td>
 *       <td>Moves focus to the first (available) cell of the current row.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>End</kbd></td>
 *       <td>Moves focus to the last (available) cell of the current row.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Page Up</kbd></td>
 *       <td>Moves focus to the first (available) cell in the current column.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Page Down</kbd></td>
 *       <td>Moves focus to the last (available) cell in the current column.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Contrl+Space</kbd></td>
 *       <td>Selects all the cells of the current column.  This is only available if multiple cell selection mode is enabled.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Shift+Space</kbd></td>
 *       <td>Selects all the cells of the current row.  This is only available if multiple cell selection mode is enabled.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Shift+Arrow</kbd></td>
 *       <td>Extends the current selection.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Shift+F8</kbd></td>
 *       <td>Freezes the current selection, therefore allowing user to move focus to another location to add additional cells to the current selection.  This is used to accomplish non-contiguous selection.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Shift+F10</kbd></td>
 *       <td>Brings up the context menu.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Ctrl+X</kbd></td>
 *       <td>Marks the current row to move if dnd is enabled and the datasource supports move operation.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Ctrl+V</kbd></td>
 *       <td>Move the row that is marked to directly under the current row.  If the row with the focused cell is the last row, then it will be move to the row above the current row.</td>
 *     </tr>
 *   </tbody>
 * </table>
 *
 * <p></p>
 * <p>When a column header cell has focus:</p>
 * <table class="keyboard-table">
 *   <thead>
 *     <tr>
 *       <th>Key</th>
 *       <th>Use</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td><kbd>Left Arrow</kbd></td>
 *       <td>Moves focus to the previous column header.  There is no wrapping at the beginning or end of the column headers.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Right Arrow</kbd></td>
 *       <td>Moves focus to the next column header.  There is no wrapping at the beginning or end of the column headers.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Down Arrow</kbd></td>
 *       <td>Moves focus to the cell of the first row directly below the column header.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Enter</kbd></td>
 *       <td>Toggle the sort order of the column if the column is sortable.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Shift+F10</kbd></td>
 *       <td>Brings up the context menu.</td>
 *     </tr>
 *   </tbody>
 * </table>
 *
 * <p></p>
 * <p>When a row header cell has focus:</p>
 * <table class="keyboard-table">
 *   <thead>
 *     <tr>
 *       <th>Key</th>
 *       <th>Use</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td><kbd>Up Arrow</kbd></td>
 *       <td>Moves focus to the previous row header.  There is no wrapping at the beginning or end of the row headers.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Down Arrow</kbd></td>
 *       <td>Moves focus to the next row header.  There is no wrapping at the beginning or end of the row headers.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Right Arrow</kbd></td>
 *       <td>Moves focus to the cell of the first column directly next to the row header.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Left Arrow</kbd></td>
 *       <td>Moves focus to the cell of the first column directly next to the row header in RTL direction.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Enter</kbd></td>
 *       <td>Toggle the sort order of the row if the row is sortable.</td>
 *     </tr>
 *   </tbody>
 * </table>
 *
 * <h3 id="context-section">
 *   Header Context And Cell Context
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#context-section"></a>
 * </h3>
 *
 * <p>For all header and cell options, developers can specify a function as the return value.  The function takes a single argument, which is an object that contains contextual information about the particular header or cell.  This gives developers the flexibility to return different value depending on the context.</p>
 *
 * <p>For header options, the context paramter contains the following keys:</p>
 * <table class="keyboard-table">
 *   <thead>
 *     <tr>
 *       <th>Key</th>
 *       <th>Description</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td><kbd>axis</kbd></td>
 *       <td>The axis of the header.  Possible values are 'row' and 'column'.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>component</kbd></td>
 *       <td>A reference to the DataGrid component.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>index</kbd></td>
 *       <td>The index of the header, where 0 is the index of the first header.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>key</kbd></td>
 *       <td>The key of the header.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>data</kbd></td>
 *       <td>The data object for the header.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>parentElement</kbd></td>
 *       <td>The header cell element.  The renderer can use this to directly append content to the header cell element.</td>
 *     </tr>
 *   </tbody>
 * </table>
 *
 * <p></p>
 * <p>For cell options, the context paramter contains the following keys:</p>
 * <table class="keyboard-table">
 *   <thead>
 *     <tr>
 *       <th>Key</th>
 *       <th>Description</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td><kbd>component</kbd></td>
 *       <td>A reference to the DataGrid component.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>datasource</kbd></td>
 *       <td>A reference to the data source object.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>indexes</kbd></td>
 *       <td>The object that contains both the zero based row index and column index in which the cell is bound to.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>keys</kbd></td>
 *       <td>The object that contains both the row key and column key which identifies the cell.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>data</kbd></td>
 *       <td>The data object for the cell.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>parentElement</kbd></td>
 *       <td>The data cell element.  The renderer can use this to directly append content to the data cell element.</td>
 *     </tr>
 *   </tbody>
 * </table>
 *
 * <p></p>
 * <p>If a FlattenedTreeDataGridDataSource is used, the following additional contextual information are available:</p>
 * <table class="keyboard-table">
 *   <thead>
 *     <tr>
 *       <th>Key</th>
 *       <th>Description</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td><kbd>depth</kbd></td>
 *       <td>The depth of the row.  The depth of root row is 0.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>index</kbd></td>
 *       <td>The index of the row relative to its parent.  The index of the first child is 0.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>state</kbd></td>
 *       <td>The state of the row.  Possible values are "expanded", "collapsed", "leaf".</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>parentKey</kbd></td>
 *       <td>The key of the parent row.  For root row the parent key is null.</td>
 *     </tr>
 *   </tbody>
 * </table>
 *
 * <p></p>
 * <p>Note that a custom DataGridDataSource can return additional header and cell context information.  Consult the documentation of the DataGridDataSource API for details.</p>
 *
 * <h3 id="context-section">
 *   Selection
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#selection-section"></a>
 * </h3>
 *
 * <p>The DataGrid supports both cell based and row based selection mode, which developers can specify using the selectionMode option.  For each mode developers can also specify whether single or multiple cells/rows can be selected.</p>
 * <p>Developers can specify or retrieve selection from the DataGrid using the selection option.  A selection in DataGrid consists of an array of ranges.  Each range contains the following keys: startIndex, endIndex, startKey, endKey.  Each of the keys contains value for 'row' and 'column'.  If endIndex and endKey are not specified, that means the range is unbounded, i.e. the cells of the entire row/column are selected.</p>
 *
 * <h3 id="menu-section">
 *   Context menu
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#menu-section"></a>
 * </h3>
 *
 * <p>The DataGrid has a default context menu for operations such as header resize and sort.  Developers can also specify their own context menu by using the contextMenu option.  See the option for details.</p>
 * 
 * <h3 id="geometry-section">
 *   Geometry Management
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#geometry-section"></a>
 * </h3>
 *
 * <p>If the DataGrid is not styled with a fixed size, then it will responds to a change to the size of its container.  Note that unlike Table the content of the cell does not affect the height of the row.  The height of the rows must be pre-determined and specified by the developer or a default size will be used.</p>
 *
 * <h3 id="rtl-section">
 *   Reading direction
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#rtl-section"></a>
 * </h3>
 * 
 * <p>The order of the column headers will be rendered in reverse order in RTL reading direction.  The location of the row header will also be different between RTL and LTR direction.  It is up to the developers to ensure that the content of the header and data cell are rendered correctly according to the reading direction.</p>
 * <p>As with any JET component, in the unusual case that the directionality (LTR or RTL) changes post-init, the datagrid must be <code class="prettyprint">refresh()</code>ed.  

 */
oj.__registerWidget('oj.ojDataGrid', $['oj']['baseComponent'],
{
    version: "1.0.0",
    widgetEventPrefix: 'oj',
    options:
            {
                /**
                 * Banding interval for rows/columns within the data grid body.
                 * 
                 * @expose 
                 * @memberof! oj.ojDataGrid
                 * @instance
                 * @type {Object.<string, number>}
                 * @default <code class="prettyprint">{ "row":0, "column":0 }</code>
                 * 
                 * @example <caption>Initialize the data grid with the row banding interval set to every other row:</caption>
                 * $( ".selector" ).ojDataGrid({ "data":data, "bandingInterval": {"row":1} });
                 * 
                 * @example <caption>Get or set the <code class="prettyprint">rowBanding</code> option, after initialization:</caption>
                 * // getter
                 * var bandingInterval = $( ".selector" ).ojDataGrid( "option", "bandingInterval" );
                 * 
                 * // setter
                 * $( ".selector" ).ojDataGrid( "option", "bandingInterval", {"row":1, "column":1 } );
                 */
                bandingInterval: {row: 0, column: 0},
                /**
                 * The data source for the DataGrid. If an array (single or two-dimensional) 
                 * or oj collection is specified, the widget will automatically create 
                 * the appropriate adapter for it. A custom data source can be passed in as well.
                 * To specify a row header key or index pass in an Object as such:
                 * {"data": {oj.DataGridDataSource|oj.Collection|Array}, "rowHeader":{string|number}
                 * If the data attribute is not specified, an empty data grid is displayed.
                 * 
                 * @expose 
                 * @memberof! oj.ojDataGrid
                 * @instance
                 * @type {oj.DataGridDataSource|oj.Collection|Array|Object|null}
                 * @default <code class="prettyprint">null</code>
                 * 
                 * @example <caption>Initialize the data grid with a one-dimensional array:</caption>
                 * $( ".selector" ).ojDataGrid({ "data":[1,2,3]});
                 * 
                 * @example <caption>Initialize the data grid with a two-dimensional array:</caption>
                 * $( ".selector" ).ojDataGrid({ "data":['X','X','O'],['O','X','O'],['O','O','X']});
                 * 
                 * @example <caption>Initialize the data grid with a two-dimensional array and set an index for row headers:</caption>
                 * $( ".selector" ).ojDataGrid({ "data":{"rowHeader":2 , "data":['1','2','Cat'],['1','4','Dog'],['5','1','Bird']}});
                 * 
                 * @example <caption>Initialize the data grid with an oj.Collection:</caption>
                 * $( ".selector" ).ojDataGrid({ "data": new oj.Collection.extend({url: 'file.json'}) });
                 * 
                 * @example <caption>Initialize the data grid with an oj.Collection and specify a row header:</caption>
                 * $( ".selector" ).ojDataGrid({ "data":{ "data":new oj.Collection.extend({url: 'file.json'}), "rowHeader":'key' }});
                 * 
                 * @example <caption>Initialize the data grid with a custom data source</caption>
                 * $( ".selector" ).ojDataGrid({ "data":new CustomDataSource()});
                 */
                data: null,
                /**
                 * The text to display when there are no data in the Grid. If it is not defined, 
                 * then a default empty text is extracted from the resource bundle.
                 * 
                 * @expose 
                 * @memberof! oj.ojDataGrid
                 * @instance
                 * @type {String|null}
                 * @default <code class="prettyprint">"There are no data to display"</code>
                 * 
                 * @example <caption>Initialize the data grid with the empty text set to 'no data':</caption>
                 * $( ".selector" ).ojDataGrid({ "data":data, "emptyText": "no data" });
                 */
                emptyText: null,
                /**
                 * Specifies whether or not the horizontal/vertical grid lines are visible. Gridlines are
                 * visible by default, and must be set to 'hidden' in order to be hidden.
                 * 
                 * @expose 
                 * @memberof! oj.ojDataGrid
                 * @instance
                 * @type {Object.<string, string>}
                 * @default <code class="prettyprint">{"horizontal": "visible", "vertical": "visible"}</code>
                 * 
                 * @example <caption>Initialize the data grid with only horizontal gridlines visible:</caption>
                 * $( ".selector" ).ojDataGrid({ "data":data, "gridlines": {"horizontal": "visible", "vertical": "hidden"} });
                 */
                gridlines: {"horizontal": "visible", "vertical": "visible"},
                /**
                 * The index or key of the row and/or column to display initially in the data grid.
                 * 
                 * @expose 
                 * @memberof! oj.ojDataGrid
                 * @instance
                 * @type {Object.<string, Object>|null}
                 * @default <code class="prettyprint">null</code>
                 * 
                 * @example <caption>Initialize the data grid to scroll to row index 5 and column index 7:</caption>
                 * $( ".selector" ).ojDataGrid({ "data":data, "scrollPosition": {"index":{"row": 5, "column": 7}}});
                 * 
                 * @example <caption>Initialize the data grid to scroll to row key 'id5' and column key 'id7':</caption>
                 * $( ".selector" ).ojDataGrid({ "data":data, "scrollPosition": {"key":{"row": "id5", "column": "id7"}}}); 
                 */
                scrollPosition: null,
                /**
                 * Specifies whether row/cell selection can be made and the cardinality 
                 * of each (single/multiple/none) selection in the Grid.
                 * 
                 * @expose 
                 * @memberof! oj.ojDataGrid
                 * @instance
                 * @type {Object.<string, string>|null}
                 * @default <code class="prettyprint">null</code>
                 * 
                 * @example <caption>Initialize the data grid to enable single row selection:</caption>
                 * $( ".selector" ).ojDataGrid({ "data":data, "selectionMode": {"row":"single"}});
                 * 
                 * @example <caption>Initialize the data grid to enable multiple cell selection:</caption>
                 * $( ".selector" ).ojDataGrid({ "data":data, "selectionMode": {"cell":"multiple"}});
                 */
                selectionMode: null,
                /**
                 * Specifies whether the user is permitted to reorder the rows within the same datagrid using drag and drop.</br></br>
                 * Specify an object with the property "reorder" set to <code class="prettyprint">'disable'</code> to enable
                 * reordering.  Setting the <code class="prettyprint">"reorder"</code> property to <code class="prettyprint">'disable'</code>,
                 * or setting the <code class="prettyprint">"dnd"</code> property to <code class="prettyprint">'null</code> (or omitting
                 * it), disables reordering support. 
                 * 
                 * @example <caption>Initialize the data grid to enable single row reorder:</caption>
                 * $( ".selector" ).ojDataGrid({ "data":data, "dnd" : {"reorder":"enable"}});
                 * 
                 * @type {Object}
                 * @default <code class="prettyprint">false</code>
                 * @expose
                 * @instance
                 * @memberof! oj.ojDataGrid
                 */
                dnd : {reorder:'disable'},             
                /** @expose */
                header: {
                    /** @expose */
                    row: {
                        /**
                         * A CSS style class to use for the row header.
                         * 
                         * @expose 
                         * @memberof! oj.ojDataGrid
                         * @instance
                         * @type {string|null}
                         * @default <code class="prettyprint">null</code>
                         * 
                         * @example <caption>Initialize the data grid with row header style calss set to 'rhstyle':</caption>
                         * $( ".selector" ).ojDataGrid({ "data":data, "header": { "row": {"className":"rhstyle"} } });
                         */
                        className: null,
                        /**
                         * The renderer function that renders the content of the row header cell. 
                         * The headerContext contains information about the header such as its index, 
                         * axis, data, and parent element. The function returns  either a String or 
                         * a DOM element of the content inside the header. If the developer chooses 
                         * to manipulate the header element directly, the function should return 
                         * nothing. If no renderer is specified, the Grid will treat the cell data as a String.
                         * 
                         * @expose 
                         * @memberof! oj.ojDataGrid
                         * @instance
                         * @type {function(Object)|null}
                         * @default <code class="prettyprint">null</code>
                         * 
                         * @example <caption>Initialize the data grid with row header renderer that capitalizes each character in the row header cells:</caption>
                         * $( ".selector" ).ojDataGrid({ "data":data, "header": { "row": {"renderer": function(headerContext) {
                         *                                            return headerContext['key'].toUpperCase();}}}});
                         */
                        renderer: null,
                        /**
                         * Whether the header width or height or both can be resize. Note 
                         * that for column header, function cannot be used with "height" 
                         * and for row header, function cannot be used with "width".
                         * 
                         * @expose 
                         * @memberof! oj.ojDataGrid
                         * @instance
                         * @type {Object.<string, string>}
                         * @default <code class="prettyprint">{"width": "disable", "height": "disable"}</code>
                         * 
                         * @example <caption>Initialize the data grid with row header height resizable only:</caption>
                         * $( ".selector" ).ojDataGrid({ "data":data, "header": { "row": {"resizable": {"height":"enable"}}}});
                         */
                        resizable: {width: 'disable', height: 'disable'},
                        /**
                         * Whether or not the field bounded by this header is sortable. The 
                		 * data source associated with the DataGrid must have the sort function defined.
                         * 
                         * @expose 
                         * @memberof! oj.ojDataGrid
                         * @instance
                         * @type {string}
                         * @default <code class="prettyprint">"auto"</code>
                         * 
                         * @example <caption>Initialize the data grid with row header sort disabled:</caption>
                         * $( ".selector" ).ojDataGrid({ "data":data, "header": { "row": {"sortable": "disable"}}});
                         */
                        sortable: "auto",
                        /**
                         * The CSS style to set on the header element.
                         * 
                         * @expose 
                         * @memberof! oj.ojDataGrid
                         * @instance
                         * @type {string|null}
                         * @default <code class="prettyprint">null</code>
                         * 
                         * @example <caption>Initialize the data grid with row headers to have green backgrounds:</caption>
                         * $( ".selector" ).ojDataGrid({ "data":data, "header": { "row": {style: "background-color: green"}}});
                         * 
                         * @example <caption>Initialize the data grid with every other row header to have a green background:</caption>
                         * $( ".selector" ).ojDataGrid({ "data":data, "header": { "row": {style: function(headerContext) {
                         *                                            if (headerContext['index'] % 2 === 0)
                         *                                               return "background-color: green";
                         *                                            return;}}}});           
                         */
                        style: null
                    },
                    /** @expose */
                    column: {
                        /**
                         * A CSS style class to use for the column header.
                         * 
                         * @expose 
                         * @memberof! oj.ojDataGrid
                         * @instance
                         * @type {string|null}
                         * @default <code class="prettyprint">null</code>
                         * 
                         * @example <caption>Initialize the data grid with row header style calss set to 'rhstyle':</caption>
                         * $( ".selector" ).ojDataGrid({ "data":data, "header": { "column": {"className":"rhstyle"} } });
                         */
                        className: null,
                        /**
                         * The renderer function that renders the content of the column header cell. 
                         * The headerContext contains information about the header such as its index, 
                         * axis, data, and parent element. The function returns  either a String or 
                         * a DOM element of the content inside the header. If the developer chooses 
                         * to manipulate the header element directly, the function should return 
                         * nothing. If no renderer is specified, the Grid will treat the cell data as a String.
                         * 
                         * @expose 
                         * @memberof! oj.ojDataGrid
                         * @instance
                         * @type {function(Object)|null}
                         * @default <code class="prettyprint">null</code>
                         * 
                         * @example <caption>Initialize the data grid with column header renderer that capitalizes each character in the column header cells:</caption>
                         * $( ".selector" ).ojDataGrid({ "data":data, "header": { "column": {"renderer": function(headerContext) {
                         *                                            return headerContext['key'].toUpperCase();}}}});
                         */
                        renderer: null,
                        /**
                         * Whether the header width or height or both can be resize. Note 
                         * that for column header, function cannot be used with "height" 
                         * and for row header, function cannot be used with "width".
                         * 
                         * @expose 
                         * @memberof! oj.ojDataGrid
                         * @instance
                         * @type {Object.<string, string>|null}
                         * @default <code class="prettyprint">{"width": "disable", "height": "disable"}</code>
                         * 
                         * @example <caption>Initialize the data grid with column header width resizable only:</caption>
                         * $( ".selector" ).ojDataGrid({ "data":data, "header": { "row": {"resizable": {"width":"enable"}}}});
                         */
                        resizable: {width: 'disable', height: 'disable'},
                        /**
                         * Whether or not the field bounded by this header is sortable. The 
                         * data source associated with the DataGrid must have the sort function defined.
                         * 
                         * @expose 
                         * @memberof! oj.ojDataGrid
                         * @instance
                         * @type {string}
                         * @default <code class="prettyprint">"auto"</code>
                         * 
                         * @example <caption>Initialize the data grid with column header sort disabled:</caption>
                         * $( ".selector" ).ojDataGrid({ "data":data, "header": { "column": {"sortable": "disable"}}});
                         */
                        sortable: "auto",
                        /**
                         * The CSS style to set on the header element.
                         * 
                         * @expose 
                         * @memberof! oj.ojDataGrid
                         * @instance
                         * @type {string|null}
                         * @default <code class="prettyprint">null</code>
                         * 
                         * @example <caption>Initialize the data grid with column headers to have green backgrounds:</caption>
                         * $( ".selector" ).ojDataGrid({ "data":data, "header": { "column": {style: "background-color: green"}}});
                         * 
                         * @example <caption>Initialize the data grid with every other column header to have a green background:</caption>
                         * $( ".selector" ).ojDataGrid({ "data":data, "header": { "column": {style: function(headerContext) {
                         *                                            if (headerContext['index'] % 2 === 0)
                         *                                               return "background-color: green";
                         *                                            return;}}}});           
                         */
                        style: null
                    }
                },
                /** @expose */
                cell: {
                    /**
                     * A CSS style class to use for the cell.
                     * 
                     * @expose 
                     * @memberof! oj.ojDataGrid
                     * @instance
                     * @type {string|null}
                     * @default <code class="prettyprint">null</code>
                     * 
                     * @example <caption>Initialize the data grid with row header style calss set to 'rhstyle':</caption>
                     * $( ".selector" ).ojDataGrid({ "data":data, "cell":{"className":"cellstyle"} });
                     */
                    className: null,
                    /**
                     * The renderer function that renders the content of the cell. 
                     * The headerContext contains information about the header such as its index, 
                     * axis, data, and parent element. The function returns  either a String or 
                     * a DOM element of the content inside the header. If the developer chooses 
                     * to manipulate the header element directly, the function should return 
                     * nothing. If no renderer is specified, the Grid will treat the cell data as a String.
                     * 
                     * @expose 
                     * @memberof! oj.ojDataGrid
                     * @instance
                     * @type {function(Object)|null}
                     * @default <code class="prettyprint">null</code>
                     * 
                     * @example <caption>Initialize the data grid with column header renderer that capitalizes each character in the cells:</caption>
                     * $( ".selector" ).ojDataGrid({ "data":data, "cell": {"renderer": function(headerContext) {
                     *                                            return headerContext['key'].toUpperCase();}}});
                     */
                    renderer: null,
                    /**
                     * The CSS style to set on the cell.
                     * 
                     * @expose 
                     * @memberof! oj.ojDataGrid
                     * @instance
                     * @type {string|null}
                     * @default <code class="prettyprint">null</code>
                     * 
                     * @example <caption>Initialize the data grid with cells to have green backgrounds:</caption>
                     * $( ".selector" ).ojDataGrid({ "data":data, "cell":{style: "background-color: green"}});
                     * 
                     * @example <caption>Initialize the data grid with every other column header to have a green background:</caption>
                     * $( ".selector" ).ojDataGrid({ "data":data, "cell": {style: function(headerContext) {
                     *                                            if (headerContext['index'] % 2 === 0)
                     *                                               return "background-color: green";
                     *                                            return;}}});           
                     */
                    style: null
                },

                /**
                 * Triggered when a portion of the data grid is selected
                 *
                 * @expose 
                 * @event 
                 * @memberof! oj.ojDataGrid
                 * @instance
                 * @property {Event} event <code class="prettyprint">jQuery</code> event object
                 * @property {Object} ui Parameters
                 * @property {Array} ui.selection the datagrid selection object
                 * 
                 * @example <caption>Initialize the data grid with the <code class="prettyprint">select</code> callback specified:</caption>
                 * $( ".selector" ).ojDataGrid({
                 *     "select": function( event, ui ) {}
                 * });
                 *
                 * @example <caption>Bind an event listener to the <code class="prettyprint">ojselect</code> event:</caption>
                 * $( ".selector" ).on( "ojselect", function( event, ui ) {} );
                 */
                select: null,

                /**
                 * Triggered when a portion of the data grid is resized
                 *
                 * @expose 
                 * @event 
                 * @memberof! oj.ojDataGrid
                 * @instance
                 * @property {Event} event <code class="prettyprint">jQuery</code> event object
                 * @property {Object} ui Parameters
                 * @property {Element} ui.header the header Element which was resized
                 * @property {string} ui.size the new pixel size string (ex: '75px')
                 *
                 * @example <caption>Initialize the data grid with the <code class="prettyprint">resize</code> callback specified:</caption>
                 * $( ".selector" ).ojDataGrid({
                 *     "resize": function( event, ui ) {}
                 * });
                 *
                 * @example <caption>Bind an event listener to the <code class="prettyprint">ojresize</code> event:</caption>
                 * $( ".selector" ).on( "ojresize", function( event, ui ) {} );
                 */
                resize: null,				

                /**
                 * Triggered when a sort is performed on the data grid
                 *
                 * @expose 
                 * @event 
                 * @memberof! oj.ojDataGrid
                 * @instance
                 * @property {Event} event <code class="prettyprint">jQuery</code> event object
                 * @property {Object} ui Parameters
                 * @property {Element} ui.header the header Element which was sorted on				 
                 * @property {string} ui.direction the direction of the sort ascending/descending
                 * 
                 * @example <caption>Initialize the data grid with the <code class="prettyprint">sort</code> callback specified:</caption>
                 * $( ".selector" ).ojDataGrid({
                 *     "sort": function( event, ui ) {}
                 * });
                 *
                 * @example <caption>Bind an event listener to the <code class="prettyprint">ojsort</code> event:</caption>
                 * $( ".selector" ).on( "ojsort", function( event, ui ) {} );
                 */
                sort: null	
            },
    /**
     * Create the grid
     * @memberof! oj.ojDataGrid
     * @private
     */
    _create: function()
    {
        $(this.root).addClass("oj-component");
        this._super();
        this.root = this.element[0];
        this.rootId = this.root.getAttribute('id');        
        this.grid = new DvtDataGrid();    
	this.redrawSet = {'data':'all', 'header':['className','renderer','style','template']}; //vvc    
    },
    /**
     * Initialize the grid
     * @memberof! oj.ojDataGrid
     * @private
     */            
    _init: function()
    {     
        var self = this;
        $(this.root).empty();
        this._super();          
        this.resources = new oj.DataGridResources(this._GetReadingDirection(), this._getTranslation.bind(self));
        this._setDataSource();

        this._addContextMenu();    
        if (this.datasource != null)
        {
            this.grid.SetDataSource(this.datasource);
        }
        this.grid.SetOptions(this.options);
        this.grid.SetResources(this.resources);
        this.grid.SetCreateContextCallback(this._modifyContext.bind(self));

        //listen for resizing, selection, sort and trigger relevent events
        this.grid.addListener('resize', function(details)
        {
            self._trigger('resize', details['event'], details['ui']);
        });
        this.grid.addListener('select', function(details)
        {
            self._trigger('select', details['event'], details['ui']);
        });
        this.grid.addListener('sort', function(details)
        {
            self._trigger('sort', details['event'], details['ui']);
        });
        this.grid.addListener('keydown', function(details)
        {
            self._trigger('keydown', details['event'], details['ui']);
        });
        this.grid.addListener('active', function(details)
        {
            self._trigger('active', details['event'], details['ui']);
        });
        
        //  Possible handler for contextmenu touch support
        // _showContextMenu requires a jquery event object
        //this.grid.addListener('contextmenu', function(details)
        //{
             //contextmenu 
        //   var menu = $("#" + self.options.contextMenu['menu']).data( "oj-ojMenu" );
        //   var e = jQuery.Event( "touchend" );
        //   e.originalEvent = details['event'];
        //  self._showContextMenu(menu,  e);
        //});
        
        this.grid.render(this.root);   
    },
    /**
     * Redraw the entire data grid after having made some external modifications.
     *      
     * <p>This method does not accept any arguments.
     * 
     * @expose 
     * @memberof! oj.ojDataGrid
     * @instance
     * 
     * @example <caption>Invoke the <code class="prettyprint">refresh</code> method:</caption>
     * $( ".selector" ).ojDataGrid( "refresh" );
     */
    refresh: function()
    {
        this._super();	
        $(this.root).empty();
        this._setDataSource();
        if (this.datasource != null)
        {
            this.grid.SetDataSource(this.datasource);
        }
        this.grid.SetOptions(this.options);
        this.grid.SetResources(this.resources);        
        this.grid.refresh(this.root);
    },
    /**
     * Destroy the grid
     * @memberof! oj.ojDataGrid
     * @private
     */
    _destroy: function()
    {
        this.grid.destroy();
        $(this.root).empty();
    },


    /**
     * Sets multiple options 
     * @param {Object} options the options object
     * @override
     * @private
     */
    _setOptions: function( options ) //vvc
    { 
	var key;

        if(!this.datasource)
        {
            for ( key in options ) 
            {
                this._setOption(key, options[key]);           
            }
        }
        else
        {            
            this._setUpdatedOptions(options); 
        }
    },

    /**
     * Updates multiple options 
     * @param {Object} options the options object
     * @private
     */
    _setUpdatedOptions: function( options ) //vvc
    { 
        var i, key, isRefresh, elm, itm;

        //Traversing through the header object to retreave option value 
        //header -> column/row -> resizable -> width/heigh

        isRefresh = false;

        for (key in options) 
        {
            if(key  in this.redrawSet)
            {
                //Walk through the header object to retrieve the option value 
                if(key == "header")
                {
                    for(elm in options["header"])
                    {
                        if(elm == "column" || elm == "row" || elm == "cell")
                        {
                            for(itm in options["header"][elm])
                            {
                                //And check this option against the redraw list,
                                //if the option is in it isRefresh flag is true
                                for(i =0; i < this.redrawSet["header"].length; i++)
                                {
                                    if(itm == this.redrawSet["header"][i])
                                    {
                                        isRefresh = true;
                                        break;
                                    }
                                }
                                if(isRefresh)
                                {
                                    break;
                                }
                            }
                        }
                        if(isRefresh)
                        {
                            break;
                        }
                    }
                } 
                else 
                {
                    isRefresh = true;
                }
            }
        }
        
        //Set updated option
	for ( key in options ) 
        {
            this._setOption(key, options[key]);           
	}
          
        if(isRefresh)
        {
            //redraw whole grid if required 
            this.refresh();
        }
        else
        {
            //or process updated option(s) through the DvtDataGrid
            this.grid.UpdateOptions(options);
        }
    },

    /**
     * Sets a single option value
     * @param {Object} key the option key
     * @param {Object} value the option value
     * @override
     * @private
     */
    _setOption: function(key, value)
    {
        this._super(key, value);
    },
                        
    /**
     * Checks if resize is enabled along a given axis width/height
     * @private	 
     * @param {string} axis column/row
     * @param {string} direction width/height
     * @return {boolean} true if resize is not set to 'disable'
     */
    _isResizeEnabled: function(axis, direction)
    {
        return this.options['header'][axis]['resizable'][direction] !== 'disable';
    },
            
    /**
     * Add a default context menu to the grid if there is none. If there is
     * a context menu set on the grid options we use that one. Add listeners
     * for context menu before show and select. 
     * @private	 
     */
    _addContextMenu: function()
    {
        var self, menuContainer, rootId, resizeMenu = null, sortMenu = null, moveMenu = null, listItems, temp;
        self = this;

        if (this.options["contextMenu"] == null)
        {
            if (this.datasource != null) {
                menuContainer = $('<ul>');
                menuContainer.css('display', 'none').attr('id', this.rootId + 'contextmenu');
                $(this.root).append(menuContainer);
                if (this._isResizeEnabled('column', 'width') || this._isResizeEnabled('column', 'height') ||
                        this._isResizeEnabled('row', 'width') || this._isResizeEnabled('row', 'height'))
                {
                    resizeMenu = this._buildContextMenuItem('resize');
                }
                switch (this.datasource.getCapability('sort'))
                {
                    case 'none':
                        break;
                    case 'column':
                        sortMenu = this._buildContextMenuItem('sortCol');
                        break;
                    case 'row':
                        sortMenu = this._buildContextMenuItem('sortRow');
                        break;
                    default:
                        temp = this._buildContextMenuItem('sortCol');
                        sortMenu = temp.add(this._buildContextMenuItem('sortRow'));
                }

                if (this.options['dnd']['reorder'] === 'enable')
                {
                    switch (this.datasource.getCapability('move'))
                    {
                        case 'none':
                            break;
                        default:
                            moveMenu = $(this._buildContextMenuListItem('cut')).add($(this._buildContextMenuListItem('paste')));
                    }
                }
                menuContainer.append(resizeMenu).append(sortMenu).append(moveMenu);
                menuContainer.ojMenu();
                this._setOption("contextMenu", '#' + menuContainer.attr('id'));
                menuContainer.on("ojbeforeshow", this._handleContextMenuBeforeShow.bind(this));
                menuContainer.on("ojselect", this._handleContextMenuSelect.bind(this));
            }
        }
        else
        {
            menuContainer = $(this.options["contextMenu"]);
            listItems = menuContainer.find('[data-oj-command]');
            listItems.each(function(){
                var command;
                if ($(this).children('a').length === 0)
                {
                    command = $(this).attr('data-oj-command').split("-");
                    $(this).replaceWith(self._buildContextMenuItem(command[command.length-1]));
                }
            });
            menuContainer.ojMenu('refresh');
            menuContainer.on("ojbeforeshow", this._handleContextMenuBeforeShow.bind(this));
            menuContainer.on("ojselect", this._handleContextMenuSelect.bind(this));
        }
    },
            
    /**
     * Builds a menu for a command, takes care of submenus where appropriate
     * @private	 
     */            
    _buildContextMenuItem: function(command)
    {
        if (command === 'resize')
        {
            return $(this._buildContextMenuListItem('resize')).append($('<ul></ul>').append($(this._buildContextMenuListItem('resizeWidth'))).append($(this._buildContextMenuListItem('resizeHeight'))));
        }
        else if(command === 'sortCol')
        {
            return $(this._buildContextMenuListItem('sortCol')).append($('<ul></ul>').append($(this._buildContextMenuListItem('sortColAsc'))).append($(this._buildContextMenuListItem('sortColDsc'))));
        }
        else if(command === 'sortRow')
        {
            return $(this._buildContextMenuListItem('sortRow')).append($('<ul></ul>').append($(this._buildContextMenuListItem('sortRowAsc'))).append($(this._buildContextMenuListItem('sortRowDsc'))));
        }        
        else if (Object.keys(this.resources.commands).indexOf(command) != -1)
        {
            return $(this._buildContextMenuListItem(command));         
        }
    },
            
    /**
     * Builds a context menu list item from a command
     * @param {string} command the string to look up command value for as well as translation
     * @return {string} an HTML string containing a list item and a  
     * @private	 
     */
    _buildContextMenuListItem: function(command)
    {
        return '<li data-oj-command=' + this._getMappedCommand(command) + '>' + this._buildContextMenuLabel(command) + '</li>';
    },
    /**
     * Builds a context menu label by looking up command translation
     * @param {string} command the string to look up translation for
     * @return {string} an HTML string containing a label  
     * @private	 
     */
    _buildContextMenuLabel: function(command)
    {
        // convert to the translation key convention
        var key = 'label' + command.charAt(0).toUpperCase() + command.slice(1);
        return '<a href="#">' + this._getTranslation(key) + '</a>';
    },        
            
    /**
     * Get the context menu from the grid
     * @return {Array.<Element>|Element} the context menu element that is set in the options
     * @private	 
     */
    _getContextMenu: function()
    {
        return $(this.options["contextMenu"]).get(0);
    },
    /**
     * Get a translation from the translation resources or one the user set
     * @param {string} key the key of the translation to look up
     * @param {Array|Object|null} args the arguments to pass into the translated string
     * @return {string} the string returned from the resources
     * @private	 
     */
    _getTranslation: function(key, args)
    {        
        return this.getTranslatedString(key, args);
    },
    /**
     * Callback from the resize dialog box, which sends the results to the grid
     * @param {Event} event the event that triggered the dialog button press
     * @private	 
     */
    _handleResizeDialog: function(event)
    {
        var value = $('#' + this.rootId + 'spinner').ojInputNumber("option", "value");
        $('#' + this.rootId + 'dialog').ojDialog('destroy');
        $('#' + this.rootId + 'spinner').ojInputNumber('destroy');
        this.grid.handleContextMenuReturn(this.contextMenuEvent, this.menuItemFunction, value);
        this.contextMenuEvent['target'].focus();
    },
    /**
     * Build the html for the resize dialog and add it to the root node
     * @param {string} title the header title for the dialog
     * @param {number} initialSize the initial size to put in the spinner
     * @private	 
     */            
    _buildResizeDialog: function(title, initialSize)
    {
        var dialog, dialogBody, spinner, dialogFooter, dialogOKButton;
        //create the base dialog
        dialog =  $('#' + this.rootId + 'dialog');
        spinner = $('#' + this.rootId + 'spinner');
        if (dialog.length === 0 || spinner.length === 0)
        {
            dialog = $('<div>');
            dialog.attr('id', this.rootId + 'dialog');
            dialog.attr('title', title);
            dialogBody = $('<div class="oj-dialog-body"></div>');
            dialogFooter = $('<div class="oj-dialog-footer"></div>');
            dialog.append(dialogBody).append(dialogFooter);

            //create the dialog content
            spinner = $('<input id="' + this.rootId + 'spinner"/>');
            dialogOKButton = $('<button>');

            dialogBody.append(spinner);
            dialogFooter.append(dialogOKButton);
            $(this.root).append(dialog);
        
            dialogOKButton.ojButton({component: 'ojButton', label: 'OK'});
            dialogOKButton.on('click', this._handleResizeDialog.bind(this));
        }
        spinner.ojInputNumber({component: 'ojInputNumber', max:1000, min:20, step:1, value:initialSize});
        dialog.ojDialog({initialVisibility:'show', position:{my: "center center", at: "center center", collision:"none", of:$(this.root)}});
    },
    /**
     * Handle an ojselect event on a menu item, if sort call the handler on the core.
     * If resize prompt the user with a dialog box
     * @private	 
     */
    _handleContextMenuSelect: function(event, ui)
    {
        var initialSize, parent;
        
        this.menuItemFunction = ui.item.attr('data-oj-command');
        if (this.menuItemFunction === this._getMappedCommand('sortColAsc') || this.menuItemFunction === this._getMappedCommand('sortColDsc')
            || this.menuItemFunction === this._getMappedCommand('cut') || this.menuItemFunction === this._getMappedCommand('paste'))
        {
            this.grid.handleContextMenuReturn(this.contextMenuEvent, this.menuItemFunction, null);
            //this.contextMenuEvent['target'].focus();
        }
        else if (this.menuItemFunction === this._getMappedCommand('resizeWidth') || this.menuItemFunction === this._getMappedCommand('resizeHeight'))
        {
            parent = this._findFirstAncestor($(this.contextMenuEvent['target']), "oj-datagrid-headercell");
            if (parent != null)
            {
                initialSize = this.menuItemFunction === this._getMappedCommand('resizeWidth') ? parent.outerWidth() : parent.outerHeight();
            }
            else
            {
                initialSize = this.menuItemFunction === this._getMappedCommand('resizeWidth') ? $(this.contextMenuEvent['target']).outerWidth() : $(this.contextMenuEvent['target']).outerHeight();
            }
            this._buildResizeDialog(ui.item.text(), initialSize);
        }
    },
    /**
     * Handle an ojbeforeshow event on the context menu. Set the position correctly for keyboard events and store the Keyboard/Mouse event that called the context menu
     * @private	 
     */
    _handleContextMenuBeforeShow: function(event, ui)
    {
        var contextMenu, cell, header, capabilities;
        contextMenu = $(this._getContextMenu());
        
		this.contextMenuEvent = event['originalEvent']['originalEvent'];
        if (this.contextMenuEvent['type'] === 'keydown')
        {
            contextMenu.ojMenu("option", "menuPosition", {"my": "left top", "at": "left bottom", "of": this.contextMenuEvent['target']});
        }
        else
        {
            contextMenu.ojMenu("option", "menuPosition", {"my": "left top", "at": "left bottom"});
        }

        cell = this._findFirstAncestor($(this.contextMenuEvent['target']).eq(0), this._getMappedStyle('cell'));
        if (cell != null)
        {
            capabilities = this._getCellCapability(cell);
        }
        else
        {
            header = this._findFirstAncestor($(this.contextMenuEvent['target']).eq(0), this._getMappedStyle('headercell'));
            capabilities = this._getHeaderCapability(header);
        }

        this._manageContextMenu(capabilities);
    },    
    /**
     * Add the disabled class to the menu item with a given command
     * @param {string} command the command to add the diabled attribute to
     * @private	 
     */            
    _addContextMenuCapability: function(command)
    {
        var contextMenu;
        contextMenu = $(this._getContextMenu());
        if (!contextMenu.find("[data-oj-command=" + command + "]").hasClass('oj-disabled'))
        {
            contextMenu.find("[data-oj-command=" + command + "]").addClass('oj-disabled');
        }
    },
    /**
     * Remove the disabled class to the menu item with a given command
     * @param {string} command the command to remove the diabled attribute to
     * @private	 
     */                    
    _removeContextMenuCapability: function(command)
    {
        $(this._getContextMenu()).find("[data-oj-command=" + command + "]").removeClass('oj-disabled');
    },
    /**
     * Based on an object containing the capabilities, add or remove the disable attribute
     * @param {Object} capabilities an object with keys of resizable, sortable
     * @private	 
     */              
    _manageContextMenu: function(capabilities)
    {
        var property, command;
        for (property in capabilities)
        {
            if (capabilities.hasOwnProperty(property))
            {
                command = this.resources.getMappedCommand(property);
                if (capabilities[property] === 'disable')
                {
                    this._addContextMenuCapability(command);
                }
                else
                {
                    this._removeContextMenuCapability(command);
                }
            }
        }
    },
            
    /**
     * Find the first ancestor of an element with a specific class name
     * @param {Object} element the element to find the nearest class name to
     * @param {string} className the class name to look for
     * @return {Object|null} the element with the className, if there is none returns null 
     * @private	 
     */                  
    _findFirstAncestor: function(element, className) {
        var parents;
        if (element.hasClass(className))
        {
            return element;
        }
        parents = element.parents("."+className);
        if (parents.length != 0)
        {
            return parents.eq(0);
        }
        return null;
    },
    /**
     * Find the index of a cell
     * @param {Object} element the cell to find the index of
     * @return {Object} an object containing rowIndex and columnIndex 
     * @private	 
     */                     
    _findCellIndex: function(element) {
        var row, rowIndex, columnIndex;
        row = element.parent();
        columnIndex = row.children().index(element);
        rowIndex = row.parent().children().index(row) - 1;
        return {'rowIndex': rowIndex, 'columnIndex': columnIndex};
    },
            
    /**
     * Find the headers corresponding to a cell indicies
     * @param {Object} index the index to find the headers at
     * @return {Object} an object containing rowHeader and columnHeader 
     * @private	 
     */                     
    _findHeadersByCellIndex: function(index) {
        var rowHeader, columnHeader;
        rowHeader = this._getRowHeader().children().eq(0).children().eq(index['rowIndex'] + 1);
        columnHeader = this._getColumnHeader().children().eq(0).children().eq(index['columnIndex']);
        return {'rowHeader': rowHeader, 'columnHeader': columnHeader};
    },       
            
    /**
     * @private	 
     */   			
    _getGrid: function()
    {
        return $(this.root);
    },     
	
    /**
     * @private	 
     */   		            
    _getColumnHeader: function() {
        return $('#' + this.rootId + '\\:columnHeader');
    },
	
    /**
     * @private	 
     */   		            
    _getRowHeader: function() {
        return $('#' + this.rootId + '\\:rowHeader');
    },
	
    /**
     * @private	 
     */   		            
    _getDatabody: function() {
        return $('#' + this.rootId + '\\:databody');
    },
            
    /**
     * @private	 
     */   		            
    _getDatabodyRows: function() {
        return $('#' + this.rootId + '\\:databody .'+ this._getMappedStyle('row'));
    },            
    
	/**
     * @private	 
     */   		
    _getCellCapability: function(cell) {
        var index, headers, capabilities, rowHeader, columnHeader;
        index = this._findCellIndex(cell);
        headers = this._findHeadersByCellIndex(index);
        capabilities = {resizeWidth: 'disable', resizeHeight: 'disable', sortRow: 'disable', sortCol: 'disable'};
        rowHeader = headers['rowHeader'];
        columnHeader = headers['columnHeader'];
        if (columnHeader.length !== 0)
        {
            if (columnHeader.attr(this._getMappedAttribute('resizable')) === 'true')
            {
                capabilities['resizeWidth'] = 'enable';
            }
            if (columnHeader.attr(this._getMappedAttribute('sortable')) === 'true')
            {
                capabilities['sortCol'] = 'enable';
            }
        }
        if (rowHeader.length !== 0)
        {
            if (rowHeader.attr(this._getMappedAttribute('resizable')) === 'true')
            {
                capabilities['resizeHeight'] = 'enable';
            }
            if (rowHeader.attr(this._getMappedAttribute('sortable')) === 'true')
            {
                capabilities['sortRow'] = 'enable';
            }
        }
        return capabilities;
    },

    /**
     * @private	 
     */   			
    _getHeaderCapability: function(header) {
        var capabilities;
        capabilities = {resizeWidth: 'disable', resizeHeight: 'disable', sortRow: 'disable', sortCol: 'disable'};
        if (header !== null)
        {
            if (header.hasClass(this._getMappedStyle('colheadercell')))
            {
                if (header.attr(this._getMappedAttribute('resizable')) === 'true')
                {
                    capabilities['resizeWidth'] = 'enable';
                }
                capabilities['resizeHeight'] = this._isResizeEnabled('column', 'height') ? 'enable' : 'disable';
                if (header.attr(this._getMappedAttribute('sortable')) === 'true')
                {
                    capabilities['sortCol'] = 'enable';
                }
            }
            else
            {
                if (header.attr(this._getMappedAttribute('resizable')) === 'true')
                {
                    capabilities['resizeHeight'] = 'enable';
                }
                capabilities['resizeWidth'] = this._isResizeEnabled('row', 'width') ? 'enable' : 'disable';
                if (header.attr(this._getMappedAttribute('sortable')) === 'true')
                {
                    capabilities['sortRow'] = 'enable';
                }
            }
        }
        return capabilities;
    },

    /**
     * @private	 
     */   			
    _setDataSource: function()
    {
        if (this.options['data'] != null)
        {
            this.datasource = this.options['data'];
        }
        else
        {
            this.datasource = null;
        }
    },
       
    /**
     * Modify the header and cell context before passing to the renderer.
     * @param {Object} context the header or cell context.
     * @private
     */
    _modifyContext: function(context)
    {
        context['component'] = this;
    },

    /**
     * Sets accessible context information about the current active cell.
     * Invoked by row expander to set accessible context info on the datagrid (and
     * the info is then read by the screen reader)
     * @private
     */
    _setAccessibleContext: function(context)
    {
        this.grid.SetAccessibleContext(context);
    },

    /**
     * If no arguments are passed in, gets the current selections in the Grid. 
     * Returns an empty array if there's no selection. Returns "all" if everything 
     * is selected. Returns an array of range objects for all other cases.
     * 
     * <p> If argument passed in, sets the current selections in the Grid
     *      
     * 
     * @expose 
     * @memberof! oj.ojDataGrid
     * @instance
     * @param {Array.<Object>=} ranges optional, an array of selection objects
     * 
     * @example <caption>Get the current selection:</caption>
     * $( ".selector" ).ojDataGrid( "selection" );
     * 
     * @example <caption>Set a row selection on the grid:</caption>
     * $(".selector").ojDataGrid("selection", [{startIndex: "row":1}, endIndex:{"row":3}}]);
     * 
     * @example <caption>Set a cell selection on the grid:</caption>
     * $(".selector").ojDataGrid("selection", [{start: {"row":1, "column":2}, end: {"row":3, "column":4}}]);
     */
    selection: function(ranges)
    {
        if (ranges === undefined)
        {
            return this.grid.GetSelection();
        }
        this.grid.SetSelection(ranges);
    },
            
    /**
     * @expose
     * Return the subcomponent node represented by the documented locator attribute values.
     * 
     * To lookup a cell the locator object should have the following:
     *          subId: 'oj-datagrid-cell'
     *          rowIndex: number
     *          columnIndex: number
     *          
     * To lookup a header the locator object should have the following:
     *          subId: 'oj-datagrid-header'
     *          axis: 'column'/'row'
     *          index: number      
     *          
     * To lookup a sort icon the locator object should have the following:
     *          subId: 'oj-datagrid-sort-ascending'/'oj-datagrid-sort-descending'
     *          axis: 'column'/'row'
     *          index: number                
     * 
     * @override
     * @param {Object} locator An Object containing at minimum a subId property whose value is a string
     * 
     */
    getNodeBySubId: function(locator)
    {
        var subId, className, rowIndex,columnIndex, index, axis;
        if (locator == null)
        {
          return this.element ? this.element[0] : null;
        }

        subId = locator['subId'];
        switch (subId)
        {
            case 'oj-datagrid-cell':
                className = this._getMappedStyle('cell');
                break;
            case'oj-datagrid-header':
                className = this._getMappedStyle('headercell');                
                break;
            case 'oj-datagrid-sort-ascending':
                className = 'oj-datagrid-sort-ascending-icon';                                
                break;
            case 'oj-datagrid-sort-descending':
                className = 'oj-datagrid-sort-descending-icon';                                
                break;
            default:
                return null;
        }
        
        if (subId === 'oj-datagrid-cell')
        {
            rowIndex = locator['rowIndex'];
            columnIndex = locator['columnIndex'];
            return this._getDatabodyRows().eq(rowIndex).children().eq(columnIndex);
        }
        else
        {
            axis = locator['axis'];
            index = locator['index'];
            if (axis === 'column')
            {
                return $('#' + this.rootId + '\\:columnHeader .' + className).eq(index);
            }
            else if (axis === 'row')
            {
                return $('#' + this.rootId + '\\:rowHeader .' + className).eq(index);
            }
        }

        // Non-null locators have to be handled by the component subclasses
        return null;
    },              
          
    /**
     * Get the mapped style from the resources
	 * @private
     */
    _getMappedStyle: function(key)
    {
        return this.resources.getMappedStyle(key);
    },
            
    /**
     * Get the mapped attribute from the resources
	 * @private
     */
    _getMappedAttribute: function(key)
    {
        return this.resources.getMappedAttribute(key);
    },
            
    /**
     * Get the mapped command from the resources
	 * @private
     */
    _getMappedCommand: function(key)
    {
        return this.resources.getMappedCommand(key);
    }             
});

/**
 * A CellSet represents a collection of cells.  The CellSet is an object returned by the success callback
 * of the fetchCells method on DataGridDataSource.  The FlattenedTreeCellSet is a FlattenedDataGridDataSource specific 
 * implementation of methods on CellSet. 
 * @param {number} startRow the start row index of the cell set
 * @param {number} endRow the end row index of the cell set
 * @param {number} startColumn the start column index of the cell set
 * @param {number} endColumn the end column index of the cell set
 * @param {Object} nodeSet the node set in which this cell set wraps around
 * @param {Array|null} columns the set of column keys
 * @constructor
 * @export
 */
oj.FlattenedTreeCellSet = function(startRow, endRow, startColumn, endColumn, nodeSet, columns)
{
    // assert startRow/startColumn are number
    oj.Assert.assertNumber(startRow, null);
    oj.Assert.assertNumber(endRow, null);
    oj.Assert.assertNumber(startColumn, null);
    oj.Assert.assertNumber(endColumn, null);
    oj.Assert.assertArrayOrNull(columns);

    this.m_startRow = startRow;
    this.m_endRow = endRow;
    this.m_startColumn = startColumn;
    this.m_endColumn = endColumn;
    this.m_nodeSet = nodeSet;
    this.m_columns = columns;
};

/**
 * Gets the data of the specified index.  An error is throw when 1) the range is not yet available 
 * 2) the index specified is out of bounds. 
 * @param {Object} indexes the index of each axis in which we want to retrieve the data from.  
 * @param {number} indexes.row the index of the row axis.
 * @param {number} indexes.column the index of the column axis.
 * @return {Object} the data object for the specified index.
 * @export
 */
oj.FlattenedTreeCellSet.prototype.getData = function(indexes)
{
    var relIndex, row, column, columnKey, rowData;

    // convert to relative index
    relIndex = this._getRelIndexes(indexes);
    if (relIndex == null)
    {
        return null;
    }

    row = relIndex[0];
    column = relIndex[1];

    // make sure index are valid
    oj.Assert.assert(row < this.m_nodeSet.getStart()+this.m_nodeSet.getCount() && column < this.m_columns.length);

    columnKey = this.m_columns[column];
    rowData = this.m_nodeSet.getData(row);
    if (rowData != null)
    {
        if (rowData.get)
        {
            return rowData.get(columnKey);
        }
        else
        {
            return rowData[columnKey];
        }
    }
    return null;
};

/**
 * Gets the metadata of the specified index.  An error is throw when 1) the range is not yet available 
 * 2) the index specified is out of bounds. 
 * @param {Object} indexes the index of each axis in which we want to retrieve the metadata from.  
 * @param {number} indexes.row the index of the row axis.
 * @param {number} indexes.column the index of the column axis.
 * @return the metadata object for the specific index.  The metadata that the DataGrid supports are: 
 *         1) keys - the key (of each axis) of the cell.
 * @export
 */
oj.FlattenedTreeCellSet.prototype.getMetadata = function(indexes)
{
    var relIndex, row, column, columnKey, metadata, rowKey;

    // convert to relative index
    relIndex = this._getRelIndexes(indexes);
    if (relIndex == null)
    {
        return null;
    }

    row = relIndex[0];
    column = relIndex[1];

    // make sure index are valid
    oj.Assert.assert(row < this.m_nodeSet.getStart()+this.m_nodeSet.getCount() && column < this.m_columns.length);

    columnKey = this.m_columns[column];

    metadata = this.m_nodeSet.getMetadata(row);
    rowKey = metadata['key'];

    metadata['keys'] = {"row": rowKey, "column": columnKey};

    return metadata;
};

/**
 * Helper method to validate and retrieve the relative indexes.
 * @param {Object} indexes the row and column index
 * @param {number} indexes.row the index of the row axis.
 * @param {number} indexes.column the index of the column axis.
 * @return {Object.<number, number>} the relative indexes
 * @private
 */
oj.FlattenedTreeCellSet.prototype._getRelIndexes = function(indexes)
{
    var row, column;

    oj.Assert.assertObject(indexes);

    if (this.m_nodeSet == null || this.m_nodeSet.length == 0)
    {
        return null;
    }

    // map to the index in nodeSet
    row = indexes['row'] - this.m_startRow + this.m_nodeSet.getStart();
    column = indexes['column'];

    // make sure index are valid
    oj.Assert.assertNumber(row, null);
    oj.Assert.assertNumber(column, null);
    oj.Assert.assert(row >= 0 && column >= 0); 

    return [row, column];
};

/**
 * Gets the start index of the result set for the specified axis.
 * @param {string} axis the axis in which to inquire the actual count of the result set.  
 *        Valid values are "row" and "column".
 * @return {number} the start of the index of the result set for the specified axis.  
 * @export
 */
oj.FlattenedTreeCellSet.prototype.getStart = function(axis)
{
    if (axis === "row")
    {
        return this.m_startRow;
    }

    if (axis === "column")
    {
        return this.m_startColumn;
    }

    return 0;
};

/**
 * Gets the actual count of the result set for the specified axis. 
 * @param {string} axis the axis in which to inquire the actual count of the result set.  
 *        Valid values are "row" and "column".
 * @return {number} the actual count of the result set for the specified axis.  
 * @export
 */
oj.FlattenedTreeCellSet.prototype.getCount = function(axis)
{
    if (axis === "row")
    {
        return Math.min(this.m_endRow - this.m_startRow, this.m_nodeSet.getCount());
    }
    
    if (axis === "column")
    {
        return this.m_endColumn - this.m_startColumn;
    }

    return 0;
};
/**
 * A HeaderSet represents a collection of headers.  The HeaderSet is an object returned by the success callback
 * of the fetchHeaders method on DataGridDataSource.  This is an OJ collection specific implementation of the HeaderSet.
 * @param {number} start the start index of header set.
 * @param {number} end the end index of the header set.
 * @param {Array} headers the array of headers.  Required for column headers.
 * @param {Object=} nodeSet the node set containing data about the row header.  Required for row headers.
 * @param {string=} rowHeader the id of the row header column.  Required for row headers.
 * @constructor
 * @export
 */
oj.FlattenedTreeHeaderSet = function(start, end, headers, nodeSet, rowHeader)
{
    // assert start/end are number
    oj.Assert.assertNumber(start, null);
    oj.Assert.assertNumber(end, null);
    oj.Assert.assertArrayOrNull(headers);

    this.m_start = start;
    this.m_end = end;
    this.m_headers = headers;
    this.m_nodeSet = nodeSet;
    this.m_rowHeader = rowHeader;
};

/**
 * Gets the data of the specified index.  An error is throw when 1) the range is not yet available and
 * 2) the index specified is out of bounds. 
 * @param {number} index the index of the header in which we want to retrieve the header from.  
 * @return {Object} the data object for the specific index.
 * @export
 */
oj.FlattenedTreeHeaderSet.prototype.getData = function(index)
{
    var rowData;

    // make sure index are valid
    oj.Assert.assert(index <= this.m_end && index >= this.m_start); 

    // row or column header
    if (this.m_rowHeader != null && this.m_nodeSet != null)
    {
        rowData = this.m_nodeSet.getData(index);
        if (rowData != null)
            return rowData.get(this.m_rowHeader);
        else
            return null;
    }
    else
    {
        return this.m_headers[index];
    }
};

/**
 * Gets the metadata of the specified index.  An error is throw when 1) the range is not yet available and 
 * 2) the index specified is out of bounds. 
 * The metadata that the data source can optionally return are:
 *  1) sortDirection - the initial sort direction of the header.  Valid values are "ascending" and "descending".
 *  2) key - the key of the row/column header.
 * @param {number} index the index of the header in which we want to retrieve the metadata from.  
 * @return {Object} the metadata object for the specific index.
 * @export
 */
oj.FlattenedTreeHeaderSet.prototype.getMetadata = function(index)
{
    var data;

    if (this.m_rowHeader != null && this.m_nodeSet != null)
    {
        return this.m_nodeSet.getMetadata(index);
    }
    else
    {
        data = this.getData(index);
        return {'key': data};
    }
};

/**
 * Gets the actual count of the result set.
 * @return {number} the actual count of the result set.  
 * @export
 */
oj.FlattenedTreeHeaderSet.prototype.getCount = function()
{
    if (this.m_rowHeader != null && this.m_nodeSet != null)
    {
        return Math.min(this.m_nodeSet.getCount(), this.m_end - this.m_start);
    }
    else
    {
        return Math.max(0, this.m_end - this.m_start);
    }
};
/**
 * A CellSet represents a collection of cells.  The CellSet is an object returned by the success callback
 * of the fetchCells method on DataGridDataSource.  This implementation of CellSet is used by the
 * array DataGridDataSource.   
 * @param {number} startRow the start row index of the cell set
 * @param {number} endRow the end row index of the cell set
 * @param {number} startColumn the start column index of the cell set
 * @param {number} endColumn the end column index of the cell set
 * @param {Object} callback the callback to invoke on to retrieve data and metadata. 
 * @constructor
 * @export
 */
oj.ArrayCellSet = function(startRow, endRow, startColumn, endColumn, callback)
{
    // assert startRow/startColumn are number
    oj.Assert.assertNumber(startRow, null);
    oj.Assert.assertNumber(endRow, null);
    oj.Assert.assertNumber(startColumn, null);
    oj.Assert.assertNumber(endColumn, null);

    this.m_startRow = startRow;
    this.m_endRow = endRow;
    this.m_startColumn = startColumn;
    this.m_endColumn = endColumn;
    this.m_callback = callback;
};

/**
 * Gets the data of the specified index.  An error is throw when 1) the range is not yet available 
 * 2) the index specified is out of bounds. 
 * @param {Object} indexes the index of each axis in which we want to retrieve the data from.  
 * @param {number} indexes.row the index of the row axis.
 * @param {number} indexes.column the index of the column axis.
 * @return {Object} the data object for the specified index.
 * @export
 */
oj.ArrayCellSet.prototype.getData = function(indexes)
{
    return this.m_callback.getCellData(indexes['row'], indexes['column']);
};

/**
 * Gets the metadata of the specified index.  An error is throw when 1) the range is not yet available 
 * 2) the index specified is out of bounds. 
 * @param {Object} indexes the index of each axis in which we want to retrieve the metadata from.  
 * @param {number} indexes.row the index of the row axis.
 * @param {number} indexes.column the index of the column axis.
 * @return the metadata object for the specific index.  The metadata that the DataGrid supports are: 
 *         1) keys - the key (of each axis) of the cell.
 * @export
 */
oj.ArrayCellSet.prototype.getMetadata = function(indexes)
{
    return this.m_callback.getCellMetadata(indexes['row'], indexes['column']);
};

/**
 * Gets the start index of the result set for the specified axis.  Valid values are "row" and "column".
 * @param {string} axis the axis in which to inquire the actual count of the result set.
 * @return {number} the start index of the result set for the specified axis.  
 * @export
 */
oj.ArrayCellSet.prototype.getStart = function(axis)
{
    if (axis == "row")
    {
        return this.m_startRow;
    }
    else if (axis == "column")
    {
        return this.m_startColumn;
    }

    return -1;
};

/**
 * Gets the actual count of the result set for the specified axis.  Valid values are "row" and "column".
 * @param {string} axis the axis in which to inquire the actual count of the result set.
 * @return {number} the actual count of the result set for the specified axis.  
 * @export
 */
oj.ArrayCellSet.prototype.getCount = function(axis)
{
    if (axis === "row")
    {
        return Math.max(0, this.m_endRow - this.m_startRow);
    }
    
    if (axis === "column")
    {
        return Math.max(0, this.m_endColumn - this.m_startColumn);
    }

    return 0;
};

////// testing methods to get properties //////
/**
 * Gets the start row property
 * @export
 */
oj.ArrayCellSet.prototype.getStartRow = function()
{
    return this.m_startRow;
};

/**
 * Gets the start column property
 * @export
 */
oj.ArrayCellSet.prototype.getStartColumn = function()
{
    return this.m_startColumn;
};
/**
 * The DataGrid specific implementation of the FlattenedTreeDataSource class.
 * @param {Object} treeDataSource the instance of TreeDataSource to flattened
 * @param {Object=} options the options set on this data source.  See documentation for a list
 *        of supported options.
 * @constructor
 * @export
 */
oj.FlattenedTreeDataGridDataSource = function(treeDataSource, options)
{
    oj.FlattenedTreeDataGridDataSource.superclass.constructor.call(this, treeDataSource, options);
};

// Subclass from oj.FlattenedTreeDataSource
oj.Object.createSubclass(oj.FlattenedTreeDataGridDataSource, oj.FlattenedTreeDataSource, "oj.FlattenedTreeDataGridDataSource");

/**
 * Initializes the data source.
 * @export
 */
oj.FlattenedTreeDataGridDataSource.prototype.Init = function()
{
    oj.FlattenedTreeDataGridDataSource.superclass.Init.call(this);

    this.m_columns = oj.FlattenedTreeDataGridDataSource.superclass.getOption.call(this, 'columns');
    this.m_rowHeader = oj.FlattenedTreeDataGridDataSource.superclass.getOption.call(this, 'rowHeader');
};

/**
 * Returns whether the total count returned in getCount function is an actual or an estimate.
 * @param {string} axis the axis in which we inquire whether the total count is an estimate.  Valid values are 
 *        "row" and "column".
 * @return {string} "exact" if the count returned in getCount function is the actual count, "estimate" if the 
 *         count returned in getCount function is an estimate.  The default value is "exact".
 * @export
 */
oj.FlattenedTreeDataGridDataSource.prototype.getCountPrecision = function(axis)
{
    // always returns estimate row count to ensure high watermark scrolling is used.
    if (axis === "row")
    {
        return "estimate";
    }

    return "actual";
};

/**
 * Returns the total number of rows or columns.  If the value return is not >= 0 then it is automatically assumed
 * that the total count is unknown.
 * @param {string} axis the axis in which we inquire for the total count.  Valid values are "row" and "column".
 * @return {number} the total number of rows/columns.
 * @export
 */
oj.FlattenedTreeDataGridDataSource.prototype.getCount = function(axis)
{
    // always returns -1 to ensure high watermark scrolling is used.
    if (axis === "row")
    {
        return -1;
    }

    if (axis === "column")
    {
        return this.m_columns.length;
    }

    return 0;
};

/**
 * Fetch a range of headers from the data source.
 * @param {Object} headerRange information about the header range, it must contain the following properties:
 *        axis, start, count.
 * @param {string} headerRange.axis the axis of the header that are fetched.  Valid values are "row" and "column".
 * @param {number} headerRange.start the start index of the range in which the header data are fetched.
 * @param {number} headerRange.count the size of the range in which the header data are fetched.  
 * @param {Object} callbacks the callbacks to be invoke when fetch headers operation is completed.  The valid callback
 *        types are "success" and "error".
 * @param {function(oj.HeaderSet)} callbacks.success the callback to invoke when fetch headers completed successfully.
 * @param {function({status: Object})} callbacks.error the callback to invoke when fetch cells failed.
 * @param {Object=} callbackObjects the object in which the callback function is invoked on.  This is optional.  
 *        You can specify the callback object for each callbacks using the "success" and "error" keys.
 * @export
 */
oj.FlattenedTreeDataGridDataSource.prototype.fetchHeaders = function(headerRange, callbacks, callbackObjects)
{
    var axis, headerSet;

    axis = headerRange['axis'];
    if (axis === "column")
    {
        headerSet = new oj.FlattenedTreeHeaderSet(headerRange['start'], headerRange['start']+headerRange['count'], this.m_columns);
    }
    else if (axis === "row")
    {
        if (this.m_rowHeader != null)
        {
            // assumes that a fetch header request is immediately followed by a fetch cells request
            // avoid doing two fetch requests for the same set of data, wait until fetch cells request is available
            // before handling the header request
            // since the two fetches are converge on fetchCell, the range should always be in sync
            this.m_fetchHeaderRequest = {'range': headerRange, 'callbacks': callbacks, 'callbackObjects': callbackObjects};
            return;
        }
        else
        {
            // no row header, return empty result set
            headerSet = new oj.ArrayHeaderSet(headerRange['start'], headerRange['start'], axis, null);
        }
    }

    if (headerSet != null)
    {
        if (callbacks != null && callbacks['success'] != null)
        {
            // todo: get rid of callbackObjects
            if (callbackObjects == null)
            {
                callbackObjects = {};
            }	            
            callbacks['success'].call(callbackObjects['success'], headerSet, headerRange);
        }
    }
};

/**
 * Fetch a range of cells from the data source.
 * @param {Array.<Object>} cellRanges Information about the cell range.  A cell range is defined by an array 
 *        of range info for each axis, where each range contains three properties: axis, start, count.
 * @param {string} cellRanges.axis the axis associated with this range where cells are fetched.  Valid 
 *        values are "row" and "column".
 * @param {number} cellRanges.start the start index of the range for this axis in which the cells are fetched.
 * @param {number} cellRanges.count the size of the range for this axis in which the cells are fetched. 
 * @param {Object} callbacks the callbacks to be invoke when fetch cells operation is completed.  The valid callback
 *        types are "success" and "error".
 * @param {function(oj.CellSet)} callbacks.success the callback to invoke when fetch cells completed successfully.
 * @param {function({status: Object})} callbacks.error the callback to invoke when fetch cells failed.
 * @param {Object=} callbackObjects the object in which the callback function is invoked on.  This is optional.  
 *        You can specify the callback object for each callbacks using the "success" and "error" keys.
 * @export
 */
oj.FlattenedTreeDataGridDataSource.prototype.fetchCells = function(cellRanges, callbacks, callbackObjects)
{
    var i, cellRange, rowStart, rowCount;

    // extract row range information needed to make the fetchRows call
    for (i=0; i<cellRanges.length; i++)
    {
        cellRange = cellRanges[i];   
        if (cellRange['axis'] == "row")
        {
            rowStart = cellRange['start'];
            rowCount = cellRange['count'];
            break;
        }
    }

    oj.FlattenedTreeDataGridDataSource.superclass.fetchRows.call(this, {'start': rowStart, 'count': rowCount}, {"success": function(nodeSet){this._handleFetchRowsSuccess(nodeSet, cellRanges, callbacks, callbackObjects, 0);}.bind(this), "error": function(status){this._handleFetchRowsError(status, {'start': rowStart, 'count': rowCount}, callbacks, callbackObjects);}.bind(this)}); 
};

/**
 * Returns the keys based on the indexes. 
 * @param {Object} indexes the index for each axis
 * @param {Object} indexes.row the index for the row axis
 * @param {Object} indexes.column the index for the column axis
 * @return {Object.<Object, Object>} an object containing the keys for each axis
 * @export
 */
oj.FlattenedTreeDataGridDataSource.prototype.keys = function(indexes)
{
    var rowIndex, colIndex, rowKey, colKey;

    rowIndex = indexes['row'];
    colIndex = indexes['column'];

    // if it hasn't been fetched yet or invalid column index, return null
    if (rowIndex > oj.FlattenedTreeDataGridDataSource.superclass.getFetchedRange.call(this)['end'] || colIndex > this.m_columns.length)
        return null;

    rowKey = oj.FlattenedTreeDataGridDataSource.superclass.getKey.call(this, rowIndex);
    colKey = this.m_columns[colIndex];

    return {"row": rowKey, "column": colKey};
};

/**
 * Returns the row and column index based on the keys.
 * @param {Object} keys the key for each axis
 * @param {Object} keys.row the key for the row axis
 * @param {Object} keys.column the key for the column axis
 * @return {Object.<number, number>} indexes an object containing the index for each axis. 
 *         Return null if the indexes cannot be found.
 * @export
 */
oj.FlattenedTreeDataGridDataSource.prototype.indexes = function(keys)
{
    var rowIndex, colIndex, rowKey, colKey, i;

    rowKey = keys['row'];
    colKey = keys['column'];

    // call helper method to find the flattened index
    rowIndex = oj.FlattenedTreeDataGridDataSource.superclass.getIndex.call(this, rowKey);
    // for column index, just search through the column keys array
    for (i=0; i<this.m_columns.length; i++)
    {
        if (this.m_columns[i] === colKey)
        {
            colIndex = i;
            break;
        }
    }

    // make sure the indexes are valid
    if (rowIndex >= 0 && colIndex >= 0)
    {
        return {"row": rowIndex, "column": colIndex};
    }

    // can't find it
    return null;
};

/**
 * Performs a sort on the data source.
 * @param {Object} criteria the sort criteria. 
 * @param {string} criteria.axis The axis in which the sort is performed, valid values are "row", "column"
 * @param {Object} criteria.key The key that identifies which header to sort
 * @param {string} criteria.direction the sort direction, valid values are "ascending", "descending", "none" (default)
 * @param {Object} callbacks the callbacks to be invoke upon completion of the sort operation.  The callback
 *        properties are "success" and "error".
 * @param {function()} callbacks.success the callback to invoke when the sort completed successfully.  
 * @param {function({status: Object})} callbacks.error the callback to invoke when sort failed.
 * @param {Object=} callbackObjects the object in which the callback function is invoked on.  This is optional.  
 *        You can specify the callback object for each callbacks using the "success" and "error" properties.
 * @export
 */
oj.FlattenedTreeDataGridDataSource.prototype.sort = function(criteria, callbacks, callbackObjects)
{
    var dataSource = oj.FlattenedTreeDataGridDataSource.superclass.getWrappedDataSource.call(this);

    // delegates to the underlying TreeDataSource but intercept the success callback so that we can clear the cache
    return dataSource.sort(criteria, {"success": function(){this._handleSortSuccess(callbacks, callbackObjects);}.bind(this), "error": callbacks['error']});
};

/**
 * Handles sort success callback.
 * @param {Object} callbacks the original callbacks for the sort operation
 * @param {Object} callbackObjects the original callbackObjects for the sort operation
 * @private
 */
oj.FlattenedTreeDataGridDataSource.prototype._handleSortSuccess = function(callbacks, callbackObjects)
{
    // reset state
    this.refresh();

    // invoke original sort success callback
    if (callbacks['success'])
    {
        // todo: get rid of callbackObjects
        if (callbackObjects == null)
        {
            callbackObjects = {};
        }	            
        callbacks['success'].call(callbackObjects['success']);
    }
};

/**
 * Determines whether this DataGridDataSource supports certain feature.
 * @param {string} feature the feature in which its capabilities is inquired.  Currently the only valid feature is "sort".
 * @return {string|null} the name of the feature.  For "sort", the valid return values are: "full", "none", "row", "column".  
 *         Returns null if the feature is not recognized.
 * @export
 */
oj.FlattenedTreeDataGridDataSource.prototype.getCapability = function(feature)
{
    var dataSource = oj.FlattenedTreeDataGridDataSource.superclass.getWrappedDataSource.call(this);

    // just delegates to the underlying TreeDataSource
    return dataSource.getCapability(feature);
};

/**
 * A hook for FlattenedTreeDataSource to inject additional metadata into the NodeSet
 * @param {Object} key the row key identifying the row
 * @param {Object} metadata the existing metadata to inject into
 * @protected
 */
oj.FlattenedTreeDataGridDataSource.prototype.insertMetadata = function(key, metadata)
{
    // just call super
    oj.FlattenedTreeDataGridDataSource.superclass.insertMetadata.call(this, key, metadata);
};

/**
 * Callback method to handle success callback for fetchRows operation on FlattenedTreeDataSource.
 * @param {Object} nodeSet the result node set from the fetchRows called.
 * @param {Array.<Object>} cellRanges Information about the cell range.  A cell range is defined by an array 
 *        of range info for each axis, where each range contains three properties: axis, start, count.
 * @param {string} cellRanges.axis the axis associated with this range where cells are fetched.  Valid 
 *        values are "row" and "column".
 * @param {number} cellRanges.start the start index of the range for this axis in which the cells are fetched.
 * @param {number} cellRanges.count the size of the range for this axis in which the cells are fetched. 
 * @param {Object} callbacks the callbacks to be invoke when fetch cells operation is completed.  The valid callback
 *        types are "success" and "error".
 * @param {function(oj.CellSet)} callbacks.success the callback to invoke when fetch cells completed successfully.
 * @param {function({status: Object})} callbacks.error the callback to invoke when fetch cells failed.
 * @param {Object=} callbackObjects the object in which the callback function is invoked on.  This is optional.  
 *        You can specify the callback object for each callbacks using the "success" and "error" keys.
 * @private
 */
oj.FlattenedTreeDataGridDataSource.prototype._handleFetchRowsSuccess = function(nodeSet, cellRanges, callbacks, callbackObjects)
{
    var i, cellRange, rowStart, rowCount, columnStart, columnCount, headerRange, cellSet;

    // extract range information
    for (i=0; i<cellRanges.length; i++)
    {
        cellRange = cellRanges[i];   
        if (cellRange['axis'] == "row")
        {
            rowStart = cellRange['start'];
            rowCount = cellRange['count'];
        }
        else if (cellRange['axis'] == "column")
        {
            columnStart = cellRange['start'];
            columnCount = cellRange['count'];
        }
    }

    // checks whether there is an outstanding fetch header request with the same range
    if (this.m_fetchHeaderRequest)
    {
        headerRange = this.m_fetchHeaderRequest['range'];
        if (headerRange['start'] == rowStart && headerRange['count'] == rowCount)
        {
            // handle row header request
            this._handleRowHeaderFetchSuccess(nodeSet, headerRange, this.m_fetchHeaderRequest['callbacks'], this.m_fetchHeaderRequest['callbackObjects']);
        }
        this.m_fetchHeaderRequest = null;
    }

    // create wrapper
    cellSet = new oj.FlattenedTreeCellSet(rowStart, rowStart+rowCount, columnStart, columnStart+columnCount, nodeSet, this.m_columns);
    // invoke success callback
    if (callbacks['success'])
    {
        // todo: get rid of callbackObjects
        if (callbackObjects == null)
        {
            callbackObjects = {};
        }            
        callbacks["success"].call(callbackObjects['success'], cellSet, cellRanges);
    }
};

/**
 * Callback method to handle error callback for fetchRows operation on FlattenedTreeDataSource.
 * @param {Object} status the error status.
 * @param {Object} range Information about the row range.  
 * @param {Object} callbacks the callbacks to be invoke when fetch cells operation is completed.  The valid callback
 *        types are "success" and "error".
 * @param {function(oj.CellSet)} callbacks.success the callback to invoke when fetch cells completed successfully.
 * @param {function({status: Object})} callbacks.error the callback to invoke when fetch cells failed.
 * @param {Object=} callbackObjects the object in which the callback function is invoked on.  This is optional.  
 *        You can specify the callback object for each callbacks using the "success" and "error" keys.
 * @private
 */
oj.FlattenedTreeDataGridDataSource.prototype._handleFetchRowsError = function(status, range, callbacks, callbackObjects)
{
    var headerRange, headerCallbacks, headerCallbackObjects;

    // checks whether there is an outstanding fetch header request with the same range
    if (this.m_fetchHeaderRequest)
    {
        headerRange = this.m_fetchHeaderRequest['range'];
        if (headerRange['start'] == range['start'] && headerRange['count'] == range['count'])
        {
            // invoke error callback on fetch header
            headerCallbacks = this.m_fetchHeaderRequest['callbacks'];
            headerCallbackObjects = this.m_fetchHeaderRequest['callbackObjects'];

            if (headerCallbacks['error'])
            {
                // todo: get rid of callbackObjects
                if (headerCallbackObjects == null)
                {
                    headerCallbackObjects = {};
                }            
                headerCallbacks['error'].call(headerCallbackObjects['error'], status);
            }
        }
        this.m_fetchHeaderRequest = null;
    }

    // invoke error callback
    if (callbacks['error'])
    {
        // todo: get rid of callbackObjects
        if (callbackObjects == null)
        {
            callbackObjects = {};
        }            
        callbacks["success"].call(callbackObjects['error'], status);
    }
};

/**
 * Handles header fetch success request based on results from fetch cell operation.
 * @param {Object} nodeSet the result node set from the fetchRows called.
 * @param {Object} headerRange information about the header range, it must contain the following properties:
 *        axis, start, count.
 * @param {string} headerRange.axis the axis of the header that are fetched.  Valid values are "row" and "column".
 * @param {number} headerRange.start the start index of the range in which the header data are fetched.
 * @param {number} headerRange.count the size of the range in which the header data are fetched.  
 * @param {Object} callbacks the callbacks to be invoke when fetch headers operation is completed.  The valid callback
 *        types are "success" and "error".
 * @param {function(oj.HeaderSet)} callbacks.success the callback to invoke when fetch headers completed successfully.
 * @param {function({status: Object})} callbacks.error the callback to invoke when fetch cells failed.
 * @param {Object=} callbackObjects the object in which the callback function is invoked on.  This is optional.  
 *        You can specify the callback object for each callbacks using the "success" and "error" keys.
 * @private
 */
oj.FlattenedTreeDataGridDataSource.prototype._handleRowHeaderFetchSuccess = function(nodeSet, headerRange, callbacks, callbackObjects)
{
    // create wrapper
    var headerSet = new oj.FlattenedTreeHeaderSet(headerRange['start'], headerRange['start']+headerRange['count'], this.m_columns, nodeSet, this.m_rowHeader);
    // invoke success callback
    if (callbacks['success'])
    {
        // todo: get rid of callbackObjects
        if (callbackObjects == null)
        {
            callbackObjects = {};
        }            
        callbacks['success'].call(callbackObjects['success'], headerSet, headerRange);
    }
};

/**
 * Implementation of abstract method to insert a set of rows into the DataGrid
 * @param {number} insertAtIndex the flattened index of the node where the rows are inserted.
 * @param {Object} insertAtRowKey the key of the node where the rows are inserted (the parent key)
 * @param {Object} nodeSet the node set containing data/metadata of inserted rows
 * @protected
 */
oj.FlattenedTreeDataGridDataSource.prototype.insertRows = function(insertAtIndex, insertAtRowKey, nodeSet)
{
    var cellSet, event;

    // create a CellSet that wraps around a RowSet 
    cellSet = new oj.FlattenedTreeCellSet(insertAtIndex, insertAtIndex+nodeSet.getCount(), 0, this.m_columns.length, nodeSet, this.m_columns);

    // construct model insert event with a set of rows to insert
    event = {};
    event['source'] = this;
    event['operation'] = 'insert';
    event['result'] = cellSet;
    event['keys'] = {"row": insertAtRowKey};

    oj.FlattenedTreeDataGridDataSource.superclass.handleEvent.call(this, "change", event);
};

/**
 * Implementation of bstract method to remove the specified rows in the DataGrid
 * @param {Array.<Object>} rowKeys an array of keys of the rows to be remove.
 * @protected
 */
oj.FlattenedTreeDataGridDataSource.prototype.removeRows = function(rowKeys)
{
    var keys, i, event;
    
    // extract the keys
    keys = [];
    for (i=0; i<rowKeys.length; i++)
    {
        keys.push({"row": rowKeys[i]['key']});
    }

    // construct model delete event with a set of row keys to delete
    event = {};
    event['source'] = this;
    event['operation'] = 'delete';
    event['keys'] = keys;

    oj.FlattenedTreeDataGridDataSource.superclass.handleEvent.call(this, "change", event);
};

/**
 * Handles the case when the maximum number of rows have been reached
 * @param {Object} range the range of the fetch request that cause the max count to be reached
 * @param {number} range.start the start index of the range
 * @param {number} range.count the count of the range
 * @protected
 */
oj.FlattenedTreeDataGridDataSource.prototype.handleMaxCountReached = function(range, callbacks)
{
    var empty = new oj.EmptyNodeSet(null, range['start']);
    callbacks["success"].call(null, empty);
};
/*jslint browser: true,devel:true*/
/**
 * @export
 * @class oj.PagingDataGridDataSource
 * @classdesc Object representing data used by the paging component
 * @param {oj.DataGridDataSource|null} dataSource
 * @param {Object|null} options Array of options for the PagingControlDataSource
 * @extends oj.PagingDataSource
 * @constructor
 */
oj.PagingDataGridDataSource = function(dataSource, options) 
{
    // Initialize
    if (!(dataSource instanceof oj.CollectionDataGridDataSource))
    {
        // we only support Array, oj.Collection, or ko.observableArray. To
        // check for observableArray, we can't do instanceof check because it's
        // a function. So we just check if it contains a subscribe function.
        throw new oj.Message('Not a datagridatasource', 'Not a datagridatasource', oj.Message.SEVERITY_LEVEL['ERROR']);
    }
    this.dataSource = dataSource;
    this._startIndex = 0;
    this.Init();
};

// Subclass from oj.DataSource 
oj.Object.createSubclass(oj.PagingDataGridDataSource, oj.PagingDataSource, "oj.PagingDataGridDataSource");

/**
 * Initializes the instance.
 * @export
 */
oj.PagingDataGridDataSource.prototype.Init = function()
{
    oj.PagingDataGridDataSource.superclass.Init.call(this);
};

/**
 * Calls fetch on the datasource with paging options.
 * @param {Object=} options Options to control fetch<p>
 *                  startIndex: The index at which to start fetching records.<p>
 *                  pageSize: The number of records to be fetched.<p>
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.PagingControlDataSource
 * @instance
 */
oj.PagingDataGridDataSource.prototype.fetch = function (options) 
{
    this._startIndex = options.startIndex;

    this.dataSource.setPageSize(this._currentPageSize);
    this.dataSource.fetch(options);
};

/**
 * @export
 * Return whether there is more data which can be fetched.
 * @returns {boolean} whether there is more data
 * @expose
 * @memberof! oj.PagingControlDataSource
 * @instance
 */
oj.PagingDataGridDataSource.prototype.hasMore = function() { 
    return this.dataSource.hasMore();
};

/**
 * Calls fetch for the next page of data. No-op if no more data.
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.PagingControlDataSource
 * @instance
 */
oj.PagingDataGridDataSource.prototype.next = function () 
{
  if (this.dataSource.totalSize() > this._startIndex)
  {
    this._currentPageSize = this._currentPageSize + this._pageSize;
    this.dataSource.setPageSize(this._currentPageSize);
    this.fetch({startIndex: this._startIndex});
  }
};

/**
 * Calls fetch for the previous page of data. No-op if at the beginning.
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.PagingControlDataSource
 * @instance
 */
oj.PagingDataGridDataSource.prototype.previous = function () 
{
  if (this._startIndex != 0 || this._startIndex != -1)
  {
    this._startIndex = this._startIndex - this._pageSize;
    this._startIndex = this._startIndex < 0 ? 0 : this._startIndex;
    this._currentPageSize = this._currentPageSize + this._pageSize;
    this.dataSource.setPageSize(this._currentPageSize);
    this.fetch({startIndex: this._startIndex});
  }
};

/**
 * Set or change the number of models in a page
 * 
 * @param {number} n page size
 */
oj.PagingDataGridDataSource.prototype.setPageSize = function(n) {
  this._pageSize = n;
  this._currentPageSize = this._startIndex + n;
  this.dataSource.setPageSize(this._currentPageSize);
};

/**
 * @export
 * Return current start index. -1 if initial fetch has not been done yet.
 * @returns {number} start index
 * @expose
 * @memberof! oj.PagingControlDataSource
 * @instance
 */
oj.PagingDataGridDataSource.prototype.startIndex = function() { 
  return this._startIndex;
};

/**** start delegated functions ****/


/**
 * Returns the total number of rows or columns.  If the value return is not >= 0 then it is automatically assumed
 * that the total count is unknown. In the case of paging returns the total number of rows/colums on the page.
 * @param {string} axis the axis in which we inquire for the total count.  Valid values are "row" and "column".
 * @return {number} the total number of rows/columns.
 * @export
 */
oj.PagingDataGridDataSource.prototype.getCount = function(axis)
{
    return this.dataSource.getCount(axis);
};

/**
 * Returns whether the total count returned in getCount function is an actual or an estimate.
 * @param {string} axis the axis in which we inquire whether the total count is an estimate.  Valid values are 
 *        "row" and "column".
 * @return {string} "actual" if the count returned in getCount function is the actual count, "estimate" if the 
 *         count returned in getCount function is an estimate.  The default value is "actual".
 * @export
 */
oj.PagingDataGridDataSource.prototype.getCountPrecision = function(axis)
{
  return this.dataSource.getCountPrecision(axis);
};

/**
 * Fetch a range of headers from the data source.
 * @param {Object} headerRange information about the header range, it must contain the following properties:
 *        axis, start, count.
 * @param {string} headerRange.axis the axis of the header that are fetched.  Valid values are "row" and "column".
 * @param {number} headerRange.start the start index of the range in which the header data are fetched.
 * @param {number} headerRange.count the size of the range in which the header data are fetched.  
 * @param {Object} callbacks the callbacks to be invoke when fetch headers operation is completed.  The valid callback
 *        types are "success" and "error".
 * @param {function(HeaderSet)} callbacks.success the callback to invoke when fetch headers completed successfully.
 * @param {function({status: Object})} callbacks.error the callback to invoke when fetch cells failed.
 * @param {Object=} callbackObjects the object in which the callback function is invoked on.  This is optional.  
 *        You can specify the callback object for each callbacks using the "success" and "error" keys.
 * @export
 */
oj.PagingDataGridDataSource.prototype.fetchHeaders = function(headerRange, callbacks, callbackObjects)
{
  return this.dataSource.fetchHeaders(headerRange, callbacks, callbackObjects);
};

/**
 * Fetch a range of cells from the data source.
 * @param {Array.<Object>} cellRanges Information about the cell range.  A cell range is defined by an array 
 *        of range info for each axis, where each range contains three properties: axis, start, count.
 * @param {string} cellRanges.axis the axis associated with this range where cells are fetched.  Valid 
 *        values are "row" and "column".
 * @param {number} cellRanges.start the start index of the range for this axis in which the cells are fetched.
 * @param {number} cellRanges.count the size of the range for this axis in which the cells are fetched. 
 * @param {Object} callbacks the callbacks to be invoke when fetch cells operation is completed.  The valid callback
 *        types are "success" and "error".
 * @param {function(CellSet)} callbacks.success the callback to invoke when fetch cells completed successfully.
 * @param {function({status: Object})} callbacks.error the callback to invoke when fetch cells failed.
 * @param {Object=} callbackObjects the object in which the callback function is invoked on.  This is optional.  
 *        You can specify the callback object for each callbacks using the "success" and "error" keys.
 * @export
 */
oj.PagingDataGridDataSource.prototype.fetchCells = function(cellRanges, callbacks, callbackObjects)
{
  return this.dataSource.fetchCells(cellRanges, callbacks, callbackObjects);
};

/**
 * Returns the keys based on the indexes. 
 * @param {Object} indexes the index for each axis
 * @param {Object} indexes.row the index for the row axis
 * @param {Object} indexes.column the index for the column axis
 * @return {Object.<Object, Object>} an object containing the keys for each axis
 * @export
 */
oj.PagingDataGridDataSource.prototype.keys = function(indexes)
{
  return this.dataSource.keys(indexes);
};

/**
 * Returns the row and column index based on the keys.
 * @param {Object} keys the key for each axis
 * @param {Object} keys.row the key for the row axis
 * @param {Object} keys.column the key for the column axis
 * @return {Object.<number, number>} indexes an object containing the index for each axis
 * @export
 */
oj.PagingDataGridDataSource.prototype.indexes = function(keys)
{
  return this.dataSource.indexes(keys);
};

/**
 * Attach an event handler to the datasource
 * @param {string} eventType eventType supported by the datasource
 * @param {function(Object)} eventHandler event handler function
 * @export
 */
oj.PagingDataGridDataSource.prototype.on = function(eventType, eventHandler)
{
  var dataSource = (/** @type {{on: Function}} */ (this.dataSource));
  return dataSource.on(eventType, eventHandler);
};

/**
 * Detach an event handler from the datasource
 * @param {string} eventType eventType supported by the datasource
 * @param {function(Object)} eventHandler event handler function
 * @export
 */
oj.PagingDataGridDataSource.prototype.off = function(eventType, eventHandler)
{
  var dataSource = (/** @type {{off: Function}} */ (this.dataSource));
  return dataSource.off(eventType, eventHandler);
};

/**
 * Determines whether this DataGridDataSource supports certain feature.
 * @param {string} feature the feature in which its capabilities is inquired.  Currently the only valid feature is "sort".
 * @return {string|null} the name of the feature.  For sort, the valid return values are: "full", "none".  Returns null if the
 *         feature is not recognized.
 * @export
 */
oj.PagingDataGridDataSource.prototype.getCapability = function(feature)
{
  if (feature === 'move')
  {
      return "none"
  }
  return this.dataSource.getCapability(feature);
};

/**
 * @export
 * Return the size of the data locally in the dataSource. -1 if an initial fetch has not been
 * done yet.
 * @returns {number} size of data
 * @expose
 * @memberof! oj.PagingDataGridDataSource
 * @instance
 */
oj.PagingDataGridDataSource.prototype.size = function()
{
  return this.dataSource.size();
};

/**
 * Performs a sort on the data source.
 * @param {Object} criteria the sort criteria. 
 * @param {string} criteria.axis The axis in which the sort is performed, valid values are "row", "column"
 * @param {Object} criteria.key The key that identifies which header to sort
 * @param {string} criteria.direction the sort direction, valid values are "ascending", "descending", "none" (default)
 * @param {Object} callbacks the callbacks to be invoke upon completion of the sort operation.  The callback
 *        properties are "success" and "error".
 * @param {function()} callbacks.success the callback to invoke when the sort completed successfully.  
 * @param {function({status: Object})} callbacks.error the callback to invoke when sort failed.
 * @param {Object=} callbackObjects the object in which the callback function is invoked on.  This is optional.  
 *        You can specify the callback object for each callbacks using the "success" and "error" properties.
 * @export
 */
oj.PagingDataGridDataSource.prototype.sort = function(criteria, callbacks, callbackObjects)
{
  this.dataSource.sort(criteria, callbacks, callbackObjects);
};

/**
 * @export
 * Return the total size of data available, including server side if not local.
 * @returns {number} total size of data
 * @expose
 * @memberof! oj.PagingDataGridDataSource
 * @instance
 */
oj.PagingDataGridDataSource.prototype.totalSize = function()
{
  return this.dataSource.totalSize();
};

oj.PagingDataGridDataSource.prototype.move = function(moveKey, atKey)
{
  return this.dataSource.move(moveKey, atKey);
};



/**** end delegated functions ****/



/**
 * A HeaderSet represents a collection of headers.  The HeaderSet is an object returned by the success callback
 * of the fetchHeaders method on DataGridDataSource.  This implementation of HeaderSet is used by the
 * array DataGridDataSource.   
 * @param {number} start the start index of the header set.
 * @param {number} end the end index of the header set.
 * @param {string} axis the axis of the header, value is either 'row' or 'column'.
 * @param {Object} callback the callback to invoke on to retrieve data and metadata. 
 * @constructor
 * @export
 */
oj.ArrayHeaderSet = function(start, end, axis, callback)
{
    // assert start/end are number
    oj.Assert.assertNumber(start, null);
    oj.Assert.assertNumber(end, null);

    this.m_start = start;
    this.m_end = end;
    this.m_axis = axis;
    this.m_callback = callback;
};

/**
 * Gets the data of the specified index.  An error is throw when 1) the range is not yet available and
 * 2) the index specified is out of bounds. 
 * @param {number} index the index of the header in which we want to retrieve the header from.  
 * @return {Object} the data object for the specific index.
 * @export
 */
oj.ArrayHeaderSet.prototype.getData = function(index)
{
    if (this.m_callback == null)
    {
        return null;
    }

    // make sure index are valid
    oj.Assert.assert(index <= this.m_end && index >= this.m_start); 

    return this.m_callback.getHeaderData(this.m_axis, index);
};

/**
 * Gets the metadata of the specified index.  An error is throw when 1) the range is not yet available and 
 * 2) the index specified is out of bounds. 
 * The metadata that the data source can optionally return are:
 *  1) sortDirection - the initial sort direction of the header.  Valid values are "ascending" and "descending".
 *  2) key - the key of the row/column header.
 * @param {number} index the index of the header in which we want to retrieve the metadata from.  
 * @return {Object} the metadata object for the specific index.
 * @export
 */
oj.ArrayHeaderSet.prototype.getMetadata = function(index)
{
    if (this.m_callback == null)
    {
        return null;
    }

    // make sure index are valid
    oj.Assert.assert(index <= this.m_end && index >= this.m_start); 

    return this.m_callback.getHeaderMetadata(this.m_axis, index);
};

/**
 * Gets the actual count of the result set.
 *
 * @return {number} the actual count of the result set.  
 * @export
 */
oj.ArrayHeaderSet.prototype.getCount = function()
{
    if (this.m_callback == null)
    {
        return 0;
    }

    return Math.max(0, this.m_end - this.m_start);
};

/**
 * Gets the start index of the result set.
 * @return {number} the start index of the result set.
 * @export
 */
oj.ArrayHeaderSet.prototype.getStart = function()
{
    return this.m_start;
};
/*
Copyright 2012 Igor Vaynberg

Version: @@ver@@ Timestamp: @@timestamp@@

This software is licensed under the Apache License, Version 2.0 (the "Apache License") or the GNU
General Public License version 2 (the "GPL License"). You may choose either license to govern your
use of this software only upon the condition that you accept all of the terms of either the Apache
License or the GPL License.

You may obtain a copy of the Apache License and the GPL License at:

http://www.apache.org/licenses/LICENSE-2.0
http://www.gnu.org/licenses/gpl-2.0.html

Unless required by applicable law or agreed to in writing, software distributed under the
Apache License or the GPL Licesnse is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
CONDITIONS OF ANY KIND, either express or implied. See the Apache License and the GPL License for
the specific language governing permissions and limitations under the Apache License and the GPL License.
 */

  var _ComboUtils = {
    KEY:
    {
      TAB : 9,
      ENTER : 13,
      ESC : 27,
      SPACE : 32,
      LEFT : 37,
      UP : 38,
      RIGHT : 39,
      DOWN : 40,
      SHIFT : 16,
      CTRL : 17,
      ALT : 18,
      PAGE_UP : 33,
      PAGE_DOWN : 34,
      HOME : 36,
      END : 35,
      BACKSPACE : 8,
      DELETE : 46,
      isArrow : function (k)
      {
        k = k.which ? k.which : k;
        switch (k)
        {
        case _ComboUtils.KEY.LEFT:
        case _ComboUtils.KEY.RIGHT:
        case _ComboUtils.KEY.UP:
        case _ComboUtils.KEY.DOWN:
          return true;
        }
        return false;
      },
      isControl : function (e)
      {
        var k = e.which;
        switch (k)
        {
        case _ComboUtils.KEY.SHIFT:
        case _ComboUtils.KEY.CTRL:
        case _ComboUtils.KEY.ALT:
          return true;
        }
        if (e.metaKey)
          return true;
        return false;
      },
      isFunctionKey : function (k)
      {
        k = k.which ? k.which : k;
        return k >= 112 && k <= 123;
      }
    },

    lastMousePosition: {x : 0, y : 0},
    nextUid: (function () {var counter = 1; return function () { return counter++; };}()),

    //TODO:
    scrollBarDimensions: null,

    /*
     * 4-10 times faster .each replacement
     * it overrides jQuery context of element on each iteration
     */
    each2: function(list, c)
    {
      var j = $(list[0]),
      i = -1,
      l = list.length;
      while (
        ++i < l
          && (j.context = j[0] = list[i])
          && c.call(j[0], i, j) !== false //i=index, j=jQuery object
      )
      {};
      return list;
    },

    measureScrollbar: function()
    {
      var $template = $("<div class='oj-listbox-measure-scrollbar'></div>");
      $template.appendTo('body');
      var dim =
        {
          width : $template.width() - $template[0].clientWidth,
          height : $template.height() - $template[0].clientHeight
        };
      $template.remove();
      return dim;
    },

    /*
     * Splits the string into an array of values, trimming each value. 
     * An empty array is returned for nulls or empty
     */
    splitVal: function(string, separator)
    {
      var val,
      i,
      l;
      if (string === null || string.length < 1)
        return [];
      val = string.split(separator);
      for (i = 0, l = val.length; i < l; i = i + 1)
        val[i] = $.trim(val[i]);
      return val;
    },

    getSideBorderPadding: function(element)
    {
      return element.outerWidth(false) - element.width();
    },

    installKeyUpChangeEvent: function(element)
    {
      var key = "keyup-change-value";
      element.on("keydown", function ()                 
        {
          if ($.data(element, key) === undefined)
          {
            $.data(element, key, element.val());
          }
        });

      element.on("keyup", function (e)
        {
          if (e.which === _ComboUtils.KEY.ENTER)
          {
            e.stopPropagation();
            return;
          }
          var val = $.data(element, key);
          if (val !== undefined && element.val() !== val)
          {
            $.removeData(element, key);
            element.trigger("keyup-change");
          }
        });
    },

    /*
     * filters mouse events so an event is fired only if the mouse moved.
     *
     * filters out mouse events that occur when mouse is stationary but
     * the elements under the pointer are scrolled.
     */
    installFilteredMouseMove: function(element)
    {
      element.on("mousemove", function (e)
        {
          var lastpos = _ComboUtils.lastMousePosition;
          if (lastpos === undefined || lastpos.x !== e.pageX || lastpos.y !== e.pageY)
          {
            $(e.target).trigger("mousemove-filtered", e);
            _ComboUtils.lastMousePosition.x = e.pageX;
            _ComboUtils.lastMousePosition.y = e.pageY;
          }
        });
    },

    thunk: function(formula)
    {
      var evaluated = false,
      value;
      return function ()
        {
          if (evaluated === false)
          {
            value = formula();
            evaluated = true;
          }
          return value;
        };
    },

    _focus: function($el)
    {
      if ($el[0] === document.activeElement)
        return;

      /* set the focus in a 0 timeout - that way the focus is set after the processing
         of the current event has finished - which seems like the only reliable way
         to set focus */
      window.setTimeout(function ()
        {
          var el = $el[0],
          pos = $el.val().length,
          range;
          $el.focus();

          /* make sure el received focus so we do not error out when trying to manipulate the caret.
             sometimes modals or others listeners may steal it after its set */
          if ($el.is(":visible") && el === document.activeElement)
          {
            /* after the focus is set move the caret to the end, necessary when we val()
               just before setting focus */
            if (el.setSelectionRange)
              el.setSelectionRange(pos, pos);
            else if (el.createTextRange)
            {
              range = el.createTextRange();
              range.collapse(false);
              range.select();
            }
          }
        }, 0);
    },

    getCursorInfo: function (el)
    {
      el = $(el)[0];
      var offset = 0;
      var length = 0;
      if ('selectionStart' in el)
      {
        offset = el.selectionStart;
        length = el.selectionEnd - offset;
      }
      else if ('selection' in document)
      {
        el.focus(); //Fixed???
        var sel = document.selection.createRange();
        length = document.selection.createRange().text.length;
        sel.moveStart('character', -el.value.length);
        offset = sel.text.length - length;
      }
      return {offset : offset, length : length};
    },

    killEvent: function(event)
    {
      event.preventDefault();
      event.stopPropagation();
    },

    killEventImmediately: function(event)
    {
      event.preventDefault();
      event.stopImmediatePropagation();
    },

    defaultEscapeMarkup: function(markup)
    {
      var replace_map =
      {
        '\\' : '&#92;',
        '&' : '&amp;',
        '<' : '&lt;',
        '>' : '&gt;',
        '"' : '&quot;',
        "'" : '&#39;'
      };
      return String(markup).replace(/[&<>"'\\]/g, function (match)
        {
          return replace_map[match];
        });
    },

    /*
     * Produces a query function that works with a local array
     */
    local: function(options)
    {
      var data = options, // data elements
          dataText,
          tmp,
          // function used to retrieve the text portion of a data item that is matched against the search
          text = function (item)
            {
              return "" + item.text;
            };

      if ($.isArray(data))
      {
        tmp = data;
        data =
          {
            results : tmp
          };
      }
      if ($.isFunction(data) === false)
      {
        tmp = data;
        data = function ()
          {
            return tmp;
          };
      }
      var dataItem = data();
      if (dataItem.text)
      {
        text = dataItem.text;
        // if text is not a function we assume it to be a key name
        if (!$.isFunction(text))
        {
          // we need to store this in a separate variable because in the next step data gets reset 
          // and data.text is no longer available
          dataText = dataItem.text; 
          text = function (item)
            {
              return item[dataText];
            };
        }
      }
      return function (query)
        {
          var t = query.term,
          filtered =
            {
              results : []
            },
          process;
          if (t === "")
          {
            query.callback(data());
            return;
          }
          process = function (datum, collection)
            {
              var group,
              attr;
              datum = datum[0];
              if (datum.children)
              {
                group = {};
                for (attr in datum)
                {
                  if (datum.hasOwnProperty(attr))
                    group[attr] = datum[attr];
                }
                group.children = [];
                _ComboUtils.each2($(datum.children), function (i, childDatum)
                 {
                   process(childDatum, group.children);
                 });

                if (group.children.length || query.matcher(t, text(group), datum))
                {
                  collection.push(group);
                }
              }
              else
              {
                if (query.matcher(t, text(datum), datum))
                {
                  collection.push(datum);
                }
              }
            };
          _ComboUtils.each2($(data().results), function (i, datum)
            {
              process(datum, filtered.results);
            });

          query.callback(filtered);
        };
    },

    checkFormatter: function (ojContext, formatter, formatterName)
    {
      if ($.isFunction(formatter))
        return true;
      if (!formatter)
        return false;

      throw new Error(formatterName + " must be a function or a false value");
    },

    /*
     * Creates a new class
     */
    clazz: function(SuperClass, methods)
    {
      var constructor = function ()  {};
      oj.Object.createSubclass(constructor, SuperClass, '');
      constructor.prototype = $.extend(constructor.prototype, methods);
      return constructor;
    }

  };


  var _AbstractOjChoice = _ComboUtils.clazz(Object,
    {
      _bind : function (func)
      {
        var self = this;
        return function ()
        {
          func.apply(self, arguments);
        };
      },
      _init : function (opts)
      {
        var results,
        search,
        className = this._classNm,
        elemName = this._elemNm,
        resultsSelector = ".oj-listbox-results";

        this.ojContext = opts.ojContext;
        this.opts = opts = this._prepareOpts(opts);
        this.id = opts.id;

        // destroy if called on an existing component
        if (opts.element.data(elemName) !== undefined &&
          opts.element.data(elemName) !== null)
        {
          opts.element.data(elemName)._destroy();
        }
        this.container = this._createContainer();
        this.containerId = "ojChoiceId_" + (opts.element.attr("id") || "autogen" + _ComboUtils.nextUid());
        this.containerSelector = "#" + this.containerId.replace(/([;&,\.\+\*\~':"\!\^#$%@\[\]\(\)=>\|])/g, '\\$1');
        this.container.attr("id", this.containerId);
        // cache the body so future lookups are cheap
        this.body = _ComboUtils.thunk(function ()
          {
            return opts.element.closest("body");
          }
          );
        this.container.attr("style", opts.element.attr("style"));
        this.elementTabIndex = this.opts.element.attr("tabindex");

        // swap container for the element
        this.opts.element
        .data(elemName, this)
        .attr("tabindex", "-1")
        .before(this.container);
        this.container.data(elemName, this);
        this.dropdown = this.container.find(".oj-listbox-drop");
        this.dropdown.data(elemName, this);
        this.dropdown.on("click", _ComboUtils.killEvent);
        this.results = results = this.container.find(resultsSelector);
        this.search = search = this.container.find("input." + className + "-input");
        this.queryCount = 0;
        this.resultsPage = 0;
        this.context = null;

        // initialize the container
        this._initContainer();
        this.container.on("click", _ComboUtils.killEvent);
        _ComboUtils.installFilteredMouseMove(this.results);
        this.dropdown.on("mousemove-filtered touchstart touchmove touchend", resultsSelector, this._bind(this._highlightUnderEvent));
        // do not propagate change event from the search field out of the component
        $(this.container).on("change", "." + className + "-input", function (e)
        {
          e.stopPropagation();
        }
        );
        $(this.dropdown).on("change", "." + className + "-input", function (e)
        {
          e.stopPropagation();
        }
        );
        _ComboUtils.installKeyUpChangeEvent(search);
        search.on("keyup-change input paste", this._bind(this._updateResults));
        search.on("focus", function ()
        {
          search.addClass(className + "-focused");
        }
        );
        search.on("blur", function ()
        {
          search.removeClass(className + "-focused");
        }
        );
        this.dropdown.on("mouseup", resultsSelector, this._bind(function (e)
          {
            if ($(e.target).closest(".oj-listbox-result-selectable").length > 0)
            {
              this._highlightUnderEvent(e);
              this._selectHighlighted(null, e);
            }
          }
          ));
        // trap all mouse events from leaving the dropdown. sometimes there may be a modal that is listening
        // for mouse events outside of itself so it can close itself. since the dropdown is now outside the combobox's
        // dom it will trigger the popup close, which is not what we want
        this.dropdown.on("click mouseup mousedown", function (e)
        {
          e.stopPropagation();
        }
        );
        if ($.isFunction(this.opts.initSelection))
        {
          // initialize selection based on the current value of the source element
          ///reduce number of call to setVal
          ///multple combobox init values fail without this setVal
          if (opts.value && (this._elemNm === "ojcombobox" ||
                             ! Array.isArray(opts.value)))
          {
            // TODO: pavitra
            // this.setVal() calls super._SetValue() during component creation. This is incorrect!! 
            // By calling _SetValue, you cause converters and validators to run, and triger 
            // optionChange event.
            // _SetValue() should only called as a result of user interaction.
            // So to initialize options, override _InitOptions() and then set this.options.value 
            // by reading DOM entries, if undefined. If DOM not set, I am not sure what the default 
            // should be for your component. null is one. Please send email.
            this.setVal(opts.value);
          }

          ///support ko options-binding
          this._initSelection();
        }
        var disabled = opts.element.prop("disabled");
        if (disabled === undefined)
          disabled = false;
        this._enable(!disabled);
        var readonly = opts.element.prop("readonly");
        if (readonly === undefined)
          readonly = false;
        this._readonly(readonly);
        // Calculate size of scrollbar
        _ComboUtils.scrollBarDimensions = _ComboUtils.scrollBarDimensions || 
                                          _ComboUtils.measureScrollbar();
        this.autofocus = opts.element.prop("autofocus");
        opts.element.prop("autofocus", false);
        if (this.autofocus)
          this._focus();
      },
      _destroy : function ()
      {
        var element = this.opts.element,
            ojcomp = element.data(this._elemNm);

        this.close();
        if (this.propertyObserver)
        {
          delete this.propertyObserver;
          this.propertyObserver = null;
        }
        if (ojcomp !== undefined)
        {
          ojcomp.container.remove();
          ojcomp.dropdown.remove();
          element
          .removeClass(this._classNm + "-offscreen")
          .removeData(this._elemNm)
          .off("." + this._classNm)
          .prop("autofocus", this.autofocus || false);
          if (this.elementTabIndex)
          {
            element.attr(
            {
              tabindex : this.elementTabIndex
            }
            );
          }
          else
          {
            element.removeAttr("tabindex");
          }
          element.show();
        }
      },
      /*
       * Processes option element and return data object
       */
      _optionToData : function (element)
      {
        if (element.is("option"))
        {
          return {
            id : element.prop("value"),
            text : element.text(),
            element : element.get(),
            css : element.attr("class"),
            disabled : element.prop("disabled"),
            locked : (element.attr("locked") === "locked") || (element.data("locked") === true)
          };
        }
        else if (element.is("optgroup"))
        {
          return {
            text : element.attr("label"),
            children : [],
            element : element.get(),
            css : element.attr("class")
          };
        }
      },
      /*
       * Prepares the option items to display in the drop down
       */
      _prepareOpts : function (opts)
      {
        var element,
        datalist,
        idKey,
        self = this;

        element = opts.element;
        var tagName = element.get(0).tagName.toLowerCase();
        if (tagName === "input" && element.attr("list"))
        {
          this.datalist = datalist = $('#' + element.attr("list"));
        }

        ///ojselect
        else if (tagName === "select" && element.children().length > 0)
        {
          this.datalist = datalist = element;
        }

        opts = $.extend({},
          {
            populateResults : function (container, results, query)
            {
              var populate,
              id = this.opts.id;

              populate = function (results, container, depth)
              {
                var i,
                l,
                result,
                selectable,
                disabled,
                node,
                label,
                innerContainer,
                formatted;

                for (i = 0, l = results.length; i < l; i = i + 1)
                {
                  result = results[i];
                  disabled = (result.disabled === true);
                  selectable = (!disabled) && (id(result) !== undefined);

                  node = $("<li></li>");
                  node.addClass("oj-listbox-results-dept-" + depth);
                  node.addClass("oj-listbox-result");
                  node.addClass(selectable ? "oj-listbox-result-selectable" : "oj-listbox-result-unselectable");
                  if (disabled)
                  {
                    node.addClass("oj-disabled");
                  }
                  if (result.children)
                  {
                    node.addClass("oj-listbox-result-with-children");
                  }
                  node.attr("role", "presentation");

                  label = $(document.createElement("div"));
                  label.addClass("oj-listbox-result-label");
                  label.attr("id", "oj-listbox-result-label-" + _ComboUtils.nextUid());
                  label.attr("role", "option");
                  if (disabled)
                    label.attr("aria-disabled", "true");

                  formatted = opts.formatResult(result, label, query, self.opts.escapeMarkup);
                  if (formatted !== undefined)
                  {
                    label.html(formatted);
                  }

                  node.append(label);

                  if (result.children && result.children.length > 0)
                  {
                    innerContainer = $("<ul></ul>");
                    innerContainer.addClass("oj-listbox-result-sub");
                    populate(result.children, innerContainer, depth + 1);
                    node.append(innerContainer);
                  }

                  node.data(self._elemNm, result);
                  container.append(node);
                }
              };
              populate(results, container, 0);
            }
          }, _ojChoice_defaults, (tagName === "select") ? null : _ojCombobox_methods, opts);

        if (typeof(opts.id) !== "function")
        {
          idKey = opts.id;
          opts.id = function (e)
          {
            return e[idKey];
          };
        }

        if (datalist)
        {
          opts.query = this._bind(function (query)
            {
              var data =
              {
                results : [],
                more : false
              },
              term = query.term,
              children,
              process;

              process = function (element, collection)
              {
                var group;
                if (element.is("option"))
                {
                  if (query.matcher(term, element.text(), element))
                  {
                    collection.push(self._optionToData(element));
                  }
                }
                else if (element.is("optgroup"))
                {
                  group = self._optionToData(element);
                  _ComboUtils.each2(element.children(), function (i, elm)
                  {
                    process(elm, group.children);
                  }
                  );
                  if (group.children.length > 0)
                  {
                    collection.push(group);
                  }
                }
              };

              children = datalist.children();

              ///ojselect placeholder
              // filter out the placeholder option if there is one
              if (this._getPlaceholder() !== undefined && children.length > 0)
              {
                var placeholderOption = this._getPlaceholderOption();
                if (placeholderOption)
                {
                  children = children.not(placeholderOption);
                }
              }

              _ComboUtils.each2(children, function (i, elm)
              {
                process(elm, data.results);
              }
              );
              query.callback(data);
            }
            );
          // this is needed because inside val() we construct choices from options and there id is hardcoded
          opts.id = function (e)
          {
            return e.id;
          };
        }
        else if ("data" in opts)
        {
          opts.query = _ComboUtils.local(opts.data);
        }

        return opts;
      },
      _triggerSelect : function (data)
      {
        var evt = $.Event(this._elemNm + "-selecting",
          {
            val : this.id(data),
            object : data
          }
          );
        this.opts.element.trigger(evt);
        return !evt.isDefaultPrevented();
      },
      /*
       * triggers the optionChange event
       * TODO: only use in multiCombobox
       */
      _triggerChange : function ()
      {
        this.ojContext._SetValue(this.getVal());
      },
      _isInterfaceEnabled : function ()
      {
        return this.enabledInterface === true;
      },
      _enableInterface : function ()
      {
        var enabled = this._enabled && !this._readonly,
        disabled = !enabled;

        if (enabled === this.enabledInterface)
          return false;

        this.container.toggleClass("oj-disabled", disabled);
        this.close();
        this.enabledInterface = enabled;

        return true;
      },
      _enable : function (enabled)
      {
        if (enabled === undefined)
          enabled = true;
        if (this._enabled === enabled)
          return;
        this._enabled = enabled;

        this.opts.element.prop("disabled", !enabled);
        this._enableInterface();
      },
      _disable : function ()
      {
        this._enable(false);
      },
      _readonly : function (enabled)
      {
        if (enabled === undefined)
          enabled = false;
        if (this._readonly === enabled)
          return false;
        this._readonly = enabled;

        this.opts.element.prop("readonly", enabled);
        this._enableInterface();
        return true;
      },
      _opened : function ()
      {
        return this.container.hasClass("oj-listbox-dropdown-open");
      },
      _positionDropdown : function ()
      {
        var $dropdown = this.dropdown,
        offset = this.container.offset(),
        height = this.container.outerHeight(false),
        width = this.container.outerWidth(false),
        dropHeight = $dropdown.outerHeight(false),
        $window = $(window),
        windowWidth = $window.width(),
        windowHeight = $window.height(),
        viewPortRight = $window.scrollLeft() + windowWidth,
        viewportBottom = $window.scrollTop() + windowHeight,
        dropTop = offset.top + height,
        dropLeft = offset.left,
        enoughRoomBelow = dropTop + dropHeight <= viewportBottom,
        enoughRoomAbove = (offset.top - dropHeight) >= this.body().scrollTop(),
        dropWidth = $dropdown.outerWidth(false),
        enoughRoomOnRight = dropLeft + dropWidth <= viewPortRight,
        aboveNow = $dropdown.hasClass("oj-listbox-drop-above"),
        bodyOffset,
        above,
        changeDirection,
        css,
        resultsListNode;

        // always prefer the current above/below alignment, unless there is not enough room
        if (aboveNow)
        {
          above = true;
          if (!enoughRoomAbove && enoughRoomBelow)
          {
            changeDirection = true;
            above = false;
          }
        }
        else
        {
          above = false;
          if (!enoughRoomBelow && enoughRoomAbove)
          {
            changeDirection = true;
            above = true;
          }
        }

        //if we are changing direction we need to get positions when dropdown is hidden;
        if (changeDirection)
        {
          $dropdown.hide();
          offset = this.container.offset();
          height = this.container.outerHeight(false);
          width = this.container.outerWidth(false);
          dropHeight = $dropdown.outerHeight(false);
          viewPortRight = $window.scrollLeft() + windowWidth;
          viewportBottom = $window.scrollTop() + windowHeight;
          dropTop = offset.top + height;

          ///ojselect move 1px up to cover up the border bottom of the select box
          if (!above && this._hasSearchBox())
            dropTop -= 1;

          dropLeft = offset.left;
          dropWidth = $dropdown.outerWidth(false);
          enoughRoomOnRight = dropLeft + dropWidth <= viewPortRight;
          $dropdown.show();
        }

        ///ojselect move 1px up to cover up the border bottom of the select box
        else if (!above && this._hasSearchBox())
          dropTop -= 1;

        if (this.opts.dropdownAutoWidth)
        {
          resultsListNode = $(".oj-listbox-results", $dropdown)[0];
          $dropdown.addClass("oj-listbox-drop-auto-width");
          $dropdown.css('width', '');
          // Add scrollbar width to dropdown if vertical scrollbar is present
          dropWidth = $dropdown.outerWidth(false) + 
            (resultsListNode.scrollHeight === resultsListNode.clientHeight ? 0 : 
             _ComboUtils.scrollBarDimensions.width);
          dropWidth > width ? width = dropWidth : dropWidth = width;
          enoughRoomOnRight = dropLeft + dropWidth <= viewPortRight;
        }
        else
        {
          this.container.removeClass("oj-listbox-drop-auto-width");
        }

        // fix positioning when body has an offset and is not position: static
        if (this.body().css('position') !== 'static')
        {
          bodyOffset = this.body().offset();
          dropTop -= bodyOffset.top;
          dropLeft -= bodyOffset.left;
        }

        if (!enoughRoomOnRight)
        {
          dropLeft = offset.left + width - dropWidth;
        }

        css =
        {
          left : dropLeft,
          width : width
        };

        if (above)
        {
          css.bottom = windowHeight - offset.top;
          css.top = 'auto';
          this.container.addClass("oj-listbox-drop-above");
          $dropdown.addClass("oj-listbox-drop-above");
        }
        else
        {
          css.top = dropTop;
          css.bottom = 'auto';
          this.container.removeClass("oj-listbox-drop-above");
          $dropdown.removeClass("oj-listbox-drop-above");
        }

        $dropdown.css(css);
      },
      _shouldOpen : function ()
      {
        var event;

        if (this._opened())
          return false;
        if (this._enabled === false || this._readonly === true)
          return false;

        event = $.Event(this._elemNm + "-opening");
        this.opts.element.trigger(event);
        return !event.isDefaultPrevented();
      },
      _clearDropdownAlignmentPreference : function ()
      {
        // clear the classes used to figure out the preference of where the dropdown should be opened
        this.container.removeClass("oj-listbox-drop-above");
        this.dropdown.removeClass("oj-listbox-drop-above");
      },
      /*
       * Opens the dropdown
       *
       * @return {boolean} whether or not dropdown was opened. This method will return false if, for example,
       * the dropdown is already open, or if the 'open' event listener on the element called preventDefault().
       */
      open : function ()
      {
        if (!this._shouldOpen())
          return false;
        this._opening();
        return true;
      },
      _clearPlaceholder : function ()
      {
        if (this.search.hasClass(this._classNm + "-default"))
        {
          this.search.val("").removeClass(this._classNm + "-default");
        }
      },
      _opening : function ()
      {
        var cid = this.containerId,
        scroll = "scroll." + cid,
        resize = "resize." + cid,
        orient = "orientationchange." + cid,
        className = this._classNm,
        elemName = this._elemNm,
        mask;

        this._clearPlaceholder();
        this.container.addClass("oj-listbox-dropdown-open");

        this._clearDropdownAlignmentPreference();

        if (this.dropdown[0] !== this.body().children().last()[0])
        {
          this.dropdown.detach().appendTo(this.body());
        }

        // create the dropdown mask if doesnt already exist
        mask = $("#oj-listbox-drop-mask" + cid);
        if (mask.length == 0)
        {
          mask = $(document.createElement("div"));
          mask.attr("id", "oj-listbox-drop-mask" + cid).attr("class", "oj-listbox-drop-mask");
          mask.hide();
          mask.appendTo(this.body());

          mask.on("mousedown touchstart click", function (e)
          {
            var dropdown = $("#oj-listbox-drop"),
            self;
            if (dropdown.length > 0)
            {
              self = dropdown.data(elemName);
              if (self.opts.selectOnBlur)
              {
                self._selectHighlighted(
                {
                  noFocus : true
                }, e   ///pass original event
                );
              }
              self.close();
              e.preventDefault();
              e.stopPropagation();
            }
          }
          );
        }

        // ensure the mask is always right before the dropdown
        if (this.dropdown.prev()[0] !== mask[0])
        {
          this.dropdown.before(mask);
        }

        // move the global id to the correct dropdown
        $("#oj-listbox-drop").removeAttr("id");
        this.dropdown.attr("id", "oj-listbox-drop");

        // show the elements
        mask.show();

        this._positionDropdown();
        this.dropdown.show();
        this._positionDropdown();

        ///select: accessibility
        this._getActiveContainer().attr("aria-expanded", true);

        // attach listeners to events that can change the position of the container and thus require
        // the position of the dropdown to be updated as well so it does not come unglued from the container
        var that = this;
        this.container.parents().add(window).each(function ()
        {
          $(this).on(resize + " " + scroll + " " + orient, function (e)
          {
            that._positionDropdown();
          }
          );
        }
        );

      },
      close : function ()
      {
        if (!this._opened())
          return;

        var cid = this.containerId,
        scroll = "scroll." + cid,
        resize = "resize." + cid,
        orient = "orientationchange." + cid;

        // unbind event listeners
        this.container.parents().add(window).each(function ()
        {
          $(this).off(scroll).off(resize).off(orient);
        }
        );

        this._clearDropdownAlignmentPreference();

        $("#oj-listbox-drop-mask" + this.containerId).hide();
        this.dropdown.removeAttr("id");
        this.dropdown.hide();
        this.container.removeClass("oj-listbox-dropdown-open");
        this.results.empty();

        ///select: accessibility
        this._getActiveContainer().attr("aria-expanded", false);
      },
      _clearSearch : function ()  {},
      _ensureHighlightVisible : function ()
      {
        var results = this.results,
        children,
        index,
        child,
        hb,
        rb,
        y,
        more;

        index = this._highlight();

        if (index < 0)
          return;

        if (index == 0)
        {
          // if the first element is highlighted scroll all the way to the top,
          // that way any unselectable headers above it will also be scrolled
          // into view
          results.scrollTop(0);
          return;
        }

        children = this._findHighlightableChoices().find(".oj-listbox-result-label");
        child = $(children[index]);
        hb = child.offset().top + child.outerHeight(true);

        // if this is the last child lets also make sure oj-combobox-more-results is visible
        if (index === children.length - 1)
        {
          more = results.find("li.oj-listbox-more-results");
          if (more.length > 0)
          {
            hb = more.offset().top + more.outerHeight(true);
          }
        }

        rb = results.offset().top + results.outerHeight(true);
        if (hb > rb)
        {
          results.scrollTop(results.scrollTop() + (hb - rb));
        }
        y = child.offset().top - results.offset().top;

        // make sure the top of the element is visible
        if (y < 0 && child.css('display') != 'none')
        {
          results.scrollTop(results.scrollTop() + y); // y is negative
        }
      },
      _findHighlightableChoices : function ()
      {
        return this.results.find(".oj-listbox-result-selectable:not(.oj-disabled, .oj-listbox-selected)");
      },
      _moveHighlight : function (delta)
      {
        var choices = this._findHighlightableChoices(),
        index = this._highlight();
        while (index > -1 && index < choices.length)
        {
          index += delta;
          var choice = $(choices[index]);
          if (choice.hasClass("oj-listbox-result-selectable") && !choice.hasClass("oj-disabled") && 
              !choice.hasClass("oj-listbox-selected"))
          {
            this._highlight(index);
            break;
          }
        }
      },
      _highlight : function (index)
      {
        var choices = this._findHighlightableChoices(),
        choice,
        data;

        if (arguments.length === 0)
        {
          return choices.get().indexOf(choices.filter(".oj-listbox-highlighted")[0]);
        }

        if (index >= choices.length)
          index = choices.length - 1;
        if (index < 0)
          index = 0;

        this._removeHighlight();

        choice = $(choices[index]);
        choice.addClass("oj-listbox-highlighted");

        // ensure assistive technology can determine the active choice
        ///select: accessibility
        this._getActiveContainer().attr("aria-activedescendant", 
                                        choice.find(".oj-listbox-result-label").attr("id"));
          
        this._ensureHighlightVisible();
      },
      _removeHighlight : function ()
      {
        this.results.find(".oj-listbox-highlighted").removeClass("oj-listbox-highlighted");
      },
      _highlightUnderEvent : function (event)
      {
        var el = $(event.target).closest(".oj-listbox-result-selectable");
        if (el.length > 0 && !el.is(".oj-listbox-highlighted"))
        {
          var choices = this._findHighlightableChoices();
          this._highlight(choices.index(el));
        }
        else if (el.length == 0)
        {
          // if we are over an unselectable item remove all highlights
          this._removeHighlight();
        }
      },
      _updateResults : function (initial)
      {
        var search = this.search,
        results = this.results,
        opts = this.opts,
        data,
        self = this,
        input,
        term = search.val(),
        lastTerm = $.data(this.container, this._classNm + "-last-term"),
        // sequence number used to drop out-of-order responses
        queryNumber;

        // prevent duplicate queries against the same term
        if (initial !== true && lastTerm && (term === lastTerm))
          return;

        $.data(this.container, this._classNm + "-last-term", term);

        function postRender()
        {
          self._positionDropdown();
        }

        function render(html)
        {
          results.html(html);
          postRender();
        }

        queryNumber = ++this.queryCount;

        this._removeHighlight();
        input = this.search.val();
        if (input !== undefined && input != null && initial !== true)
        {
          term = input;
        }
        else
        {
          term = "";
        }

        this.resultsPage = 1;

        opts.query(
        {
          element : opts.element,
          term : term,
          page : this.resultsPage,
          context : null,
          matcher : opts.matcher,
          callback : this._bind(function (data)
          {
            var def; // default choice

            // ignore old responses
            if (queryNumber != this.queryCount)
            {
              return;
            }

            // ignore a response if the oj-combobox has been closed before it was received
            if (!this._opened())
            {
              return;
            }

            // save context, if any
            this.context = (data.context === undefined) ? null : data.context;
            // create a default choice and prepend it to the list

            ///ojselect doesn't allow adding a new option
            if (data.results.length === 0 && this.opts.manageNewEntry && search.val() !== "")
            {
              def = this.opts.manageNewEntry.call(self, search.val(), data.results);
              if (def !== undefined && def !== null && self.id(def) !== undefined && self.id(def) !== null)
              {
                if ($(data.results).filter(
                    function ()
                  {
                    return self.id(this) === self.id(def);
                  }
                  ).length === 0)
                {
                  data.results.unshift(def);
                }
              }
            }

            if (data.results.length === 0 && _ComboUtils.checkFormatter(self.ojContext, opts.formatNoMatches, "formatNoMatches"))
            {
              render("<li class='" + "oj-listbox-no-results'>" + opts.formatNoMatches(self.ojContext, search.val()) + "</li>");
              return;
            }

            results.empty();
            self.opts.populateResults.call(this, results, data.results,
            {
              term : search.val(),
              page : this.resultsPage,
              context : null
            }
            );
            this._postprocessResults(data, initial);
            postRender();
          }
          )
        }
        );
      },
      _cancel : function ()
      {
        this.close();
      },

      _focusSearch : function ()
      {
        _ComboUtils._focus(this.search);
      },

      _selectHighlighted : function (options, event)
      {
        var index = this._highlight(),
        highlighted = this.results.find(".oj-listbox-highlighted"),
        data = highlighted.closest(".oj-listbox-result").data(this._elemNm);

        if (data)
        {
          this._highlight(index);
          this._onSelect(data, options, event);
        }
        else if (options && options.noFocus)
        {
          this.close();
        }
      },
      _getPlaceholder : function ()
      {
        return this.opts.element.attr("placeholder") ||
        this.opts.element.attr("data-placeholder") || // jquery 1.4 compat
        this.opts.element.data("placeholder") ||
        this.opts.placeholder;
      },

      ///ojselect placeholder
      _getPlaceholderOption : function ()
      {
        return undefined;
      },

      _initContainerWidth : function ()
      {
        function resolveContainerWidth()
        {
          var style,
          attrs,
          matches,
          i,
          l,
          attr;

          // check if there is inline style on the element that contains width
          style = this.opts.element.attr('style');
          if (style !== undefined)
          {
            attrs = style.split(';');
            for (i = 0, l = attrs.length; i < l; i = i + 1)
            {
              attr = attrs[i].replace(/\s/g, '');
              matches = attr.match(/^width:(([-+]?([0-9]*\.)?[0-9]+)(px|em|ex|%|in|cm|mm|pt|pc))/i);
              if (matches !== null && matches.length >= 1)
                return matches[1];
            }
          }
        };

        var width = resolveContainerWidth.call(this);
        if (width !== null)
        {
          this.container.css("width", width);
        }
      },

      ///ojselect
      getVal: function () {
        return this.ojContext.option("value");
      },

      ///ojselect
      ///pass original event
      setVal: function (val, event) {
        if (typeof val === "string")
          this.ojContext._SetValue([val], event);
        else
          this.ojContext._SetValue(val, event);
        // also set on the input element
        this.opts.element.val(val);
      },

      ///select: accessibility
      _getActiveContainer : function ()
      {
        return this.search;
      },

      ///ojselect
      _hasSearchBox : function ()
      {
        return (this.opts.minimumResultsForSearch !== undefined &&
          this.container._hasSearchBox !== undefined);
      }

    }
    );

  var _ojChoice_defaults =
  {
    closeOnSelect : true,
    openOnEnter : true,
    formatResult : function (result, container, query, escapeMarkup)
    {
      var markup = [];
      markup.push(escapeMarkup(result.text));
      return markup.join("");
    },
    formatSelection : function (data, container, escapeMarkup)
    {
      return (data && data.text) ? escapeMarkup(data.text) : undefined;
    },
    formatNoMatches : function (ojContext, val)
    {
//      return ojContext.getTranslatedString("noMatchesFound");
      return "No matches found";
    },
    id : function (e)
    {
      return e.id;
    },
    matcher : function (term, text)
    {
      return ('' + text).toUpperCase().indexOf(('' + term).toUpperCase()) >= 0;
    },

    separator : ",",
    escapeMarkup : _ComboUtils.defaultEscapeMarkup,
    blurOnChange : false,
    selectOnBlur : false
  };

  var _ojCombobox_methods =
  {
    manageNewEntry : function (term)
    {
      return {
        id : $.trim(term),
        text : $.trim(term)
      };
    }
  };


  ///ojselect
  var _AbstractSingleChoice = _ComboUtils.clazz(_AbstractOjChoice,
    {
      _enableInterface : function ()
      {
        if (_AbstractSingleChoice.superclass._enableInterface.apply(this, arguments))
        {
          this.search.prop("disabled", !this._isInterfaceEnabled());
        }
      },

      _focus : function ()
      {
        if (this._opened())
        {
          this.close();
        }
      },

      _destroy : function ()
      {
        $("label[for='" + this.search.attr('id') + "']")
        .attr('for', this.opts.element.attr("id"));
        _AbstractSingleChoice.superclass._destroy.apply(this, arguments);
      },

      _clear : function ()
      {
        var data = this.selection.data(this._elemNm);
        if (data)
        { // guard against queued quick consecutive clicks
          this.setVal([]);
          this.search.val("");
          this.selection.removeData(this._elemNm);
        }
        this._setPlaceholder();
      },

      _initSelection : function ()
      {
        var selected,
        element,
        self = this;


        ///support ko options-binding
//        if (this.datalist || this.getVal())
//        {
          if (this.datalist)
            element = this.datalist;
          else
            element = this.opts.element;
          this.opts.initSelection.call(null, element, function (selected)
          {
            if (selected !== undefined && selected !== null)
            {
              ///reduce number of call to setVal
              ///only setVal when selected != prevVal
              var prevVal = self.getVal();
              if (Array.isArray(prevVal))
                prevVal = prevVal[0];

              if (self.id(selected) !== prevVal)
                self.setVal(self.id(selected));

              self._updateSelection(selected);
              self.close();
            }
          }
          );
//        }
      },

      _containerKeydownHandler : function (e)
      {
        if (!this._isInterfaceEnabled())
          return;

        if (e.which === _ComboUtils.KEY.PAGE_UP || e.which === _ComboUtils.KEY.PAGE_DOWN)
        {
          // prevent the page from scrolling
          _ComboUtils.killEvent(e);
          return;
        }

        switch (e.which)
        {
        case _ComboUtils.KEY.UP:
        case _ComboUtils.KEY.DOWN:
          if (this._opened())
          {
            this._moveHighlight((e.which === _ComboUtils.KEY.UP) ? -1 : 1);
          }
          else
          {
            this.open();
          }
          _ComboUtils.killEvent(e);
          return;

        case _ComboUtils.KEY.ENTER:
          this._selectHighlighted(null, e);
          _ComboUtils.killEvent(e);
          return;

        case _ComboUtils.KEY.TAB:
          this._selectHighlighted(
            {
              noFocus : true
            }, e   ///pass original event
          );
          return;

        case _ComboUtils.KEY.ESC:
          this._cancel(e);
          _ComboUtils.killEvent(e);
          return;
        }

        ///ojselect: used by select
        this._userTyping = true;

        if (!this._opened())
          this.open();
      },

      _containerKeyupHandler : function (e)
      {
        if (this._isInterfaceEnabled())
        {
          if (!this._opened())
            this.open();
        }
      },

      _initContainer : function ()
      {
        var selection,
        container = this.container,
        dropdown = this.dropdown,
        idSuffix = _ComboUtils.nextUid(),
        elementLabel;

        this.selection = selection = container.find("." + this._classNm + "-choice");

        elementLabel = $("label[for='" + this.opts.element.attr("id") + "']");
        if (!elementLabel.attr("id"))
          elementLabel.attr('id', this._classNm + "-label-" + idSuffix);

        // add aria associations
        selection.find("." + this._classNm + "-input").attr("id", this._classNm + "-input-" + idSuffix);
        this.results.attr("id", "oj-listbox-results-" + idSuffix);
        this.search.attr("aria-owns", "oj-listbox-results-" + idSuffix);
        this.search.attr("aria-labelledby", elementLabel.attr("id"));

        this.search.on("keydown", this._bind(this._containerKeydownHandler));
        this.search.on("keyup-change input", this._bind(this._containerKeyupHandler));

        selection.on("mousedown", "abbr", this._bind(function (e)
          {
            if (!this._isInterfaceEnabled())
              return;
            this._clear();
            _ComboUtils.killEventImmediately(e);
            this.close();
            this.selection.focus();
          }
          ));

        selection.on("mousedown", this._bind(function (e)
          {
            ///prevent user from focusing on disabled select
            if (this.opts.element.prop("disabled"))
              _ComboUtils.killEvent(e);

            if (this._opened())
            {
              this.close();
            }
            else if (this._isInterfaceEnabled())
            {
              this.open();
            }
            this.search.focus();
          }
          ));

        selection.on("focus", this._bind(function (e)
          {
            _ComboUtils.killEvent(e);
          }
          ));

        this.search.on("blur", this._bind(function ()
          {
            this.search.removeClass(this._classNm + "-focused");
          }
          ));

        this._initContainerWidth();
        this.opts.element.addClass(this._classNm + "-offscreen");
        this._setPlaceholder();

      },

      _prepareOpts : function ()
      {
        var opts = _AbstractSingleChoice.superclass._prepareOpts.apply(this, arguments),
        self = this;

        ///ojselect set initial selected value
        var tagName = opts.element.get(0).tagName.toLowerCase();
        if ((tagName === "input" && opts.element.prop("list")) ||
          (tagName === "select" && opts.element.children().length > 0))
        {
          // install the selection initializer
          opts.initSelection = function (element, callback)
          {
            var selected;
            var value = self.getVal();
            if (Array.isArray(value))
              value = value[0];

            if (value !== undefined && value !== null)
            {
              selected = self._optionToData(element.find("option").filter(function ()
                  {
                    return this.value === value;
                  }
                  ));
            }
            else
            {
              selected = self._optionToData(element.find("option").filter(function ()
                  {
                    return this.selected;
                  }
                  ));
            }
            callback(selected);
          };
        }
        else if ("data" in opts || (this.getVal() && this.getVal().length > 0))
        {
          // install default initSelection when applied to hidden input and data is local
          opts.initSelection = opts.initSelection || function (element, callback)
          {
            var id = "";
            if (self.getVal() && self.getVal().length)
              id = self.getVal()[0];

            //search in data by id, storing the actual matching item
            var first = null;
            var match = null;
            opts.query(
            {
              matcher : function (term, text, el)
              {
                var is_match = (id === opts.id(el));
                if (is_match)
                {
                  match = el;
                }
                ///ojselect save the 1st option
                if (!first)
                {
                  first = el;
                }
                return is_match;
              },
              callback : !$.isFunction(callback) ? $.noop : function ()
              {
                ///ojselect if no match, pick the 1st option
                if (!match && tagName === "select")
                {
                  match = first;
                }
                callback(match);
              }
            }
            );
          };
        }
        return opts;
      },

      _setPlaceholder : function ()
      {
        var placeholder = this._getPlaceholder();

        if (placeholder === undefined)
          placeholder = "";
        this.search.val(placeholder).addClass(this._classNm + "-default");
        this.container.removeClass(this._classNm + "-allowclear");
      },

      _postprocessResults : function (data, initial, noHighlightUpdate)
      {
        var selected = 0,
        self = this,
        highlightableChoices;

        highlightableChoices = this._findHighlightableChoices();
        _ComboUtils.each2(highlightableChoices, function (i, elm)
        {
          if (self.getVal() && self.getVal()[0] === self.id(elm.data(self._elemNm)))
          {
            selected = i;
            return false;
          }
        }
        );

        // and highlight it
        if (noHighlightUpdate !== false)
        {
          if (initial === true && selected >= 0)
          {
            this._highlight(selected);
          }
          else
          {
            this._highlight(0);
          }
        }
      },

      ///pass original event
      _onSelect : function (data, options, event)
      {
        if (!this._triggerSelect(data))
        {
          return;
        }

        var old = this.getVal()? this.getVal()[0] : null,
            oldData = this._data();

        ///reduce number of call to setVal
        ///this.setVal(this.id(data));
        this._updateSelection(data);
        this.close();

        if (!(old === this.id(data)))
        {
          ///reduce number of call to setVal
          ///setVal with correct value
          ///this._triggerChange();
          this.setVal(this.id(data), event);
        }
      },

      val : function ()
      {
        var val,
        data = null,
        self = this,
        oldData = this._data();

        if (arguments.length === 0)
        {
          return this.getVal();
        }

        val = arguments[0];

        if (this.datalist)
        {
          var selected;

          selected = this.datalist
            .val(val)
            .find("option").filter(function ()
            {
              return this.selected
            }
            );

          _ComboUtils.each2(selected, function (i, elm)
          {
            data = self._optionToData(elm);
            return false;
          }
          );
          this.setVal(val);
          this._updateSelection(data);
          this._setPlaceholder();
        }
        else
        {
          // val is an id. !val is true for [undefined,null,'',0] - 0 is legal
          if (!val && val !== 0)
          {
            this._clear();
            return;
          }
          if (this.opts.initSelection === undefined)
          {
            throw new Error("cannot call val() if initSelection() is not defined");
          }
          this.setVal(val);
          this.opts.initSelection(this.opts.element, function (data)
          {
            self.setVal(!data ? [] : self.id(data));
            self._updateSelection(data);
            self._setPlaceholder();
          }
          );
        }
      },

      _clearSearch : function ()
      {
        this.search.val("");
      },

      _data : function (value)
      {
        var data;

        if (arguments.length === 0)
        {
          data = this.selection.data(this._elemNm);
          if (data === undefined)
            data = null;
          return data;
        }
        else
        {
          if (!value)
          {
            this._clear();
          }
          else
          {
            data = this._data();
            this.setVal(!value ? [] : this.id(value));
            this._updateSelection(value);
          }
        }
      }

    }
    );


  var _OjSingleCombobox = _ComboUtils.clazz(_AbstractSingleChoice,
    {
      _elemNm : "ojcombobox",
      _classNm : "oj-combobox",

      _createContainer : function ()
      {
        var container = $(document.createElement("div")).attr(
          {
            "class" : "oj-combobox oj-component"
          }
          ).html([
              "<div class='oj-combobox-choice' tabindex='-1' role='presentation'>",
              "   <span class='oj-combobox-search'><input type='text' autocomplete='off' autocorrect='off' autocapitalize='off'",
              "       spellcheck='false' class='oj-combobox-input' role='combobox' aria-expanded='false' aria-autocomplete='list' />",
              "   </span><abbr class='oj-combobox-search-choice-close' role='presentation'></abbr>",
              "   <a class='oj-combobox-arrow' role='presentation'><b class='oj-combobox-icon oj-component-icon oj-clickable-icon oj-combobox-open-icon' role='presentation'></b></a>",
              "</div>",
              "<div class='oj-listbox-drop oj-combobox-display-none' role='presentation'>",
              "   <ul class='oj-listbox-results' role='listbox'>",
              "   </ul>",
              "</div>"].join(""));
        return container;
      },
      close : function ()
      {
        if (!this._opened())
          return;
        _OjSingleCombobox.superclass.close.apply(this, arguments);

        if (this.search.val() == "")
          this._clear();
        else if (!this._data() && this.search.val !== "")
          this._clearSearch();
        else
          this.search.val(this._data().text);
      },

      _opening : function (event)
      {
        var el,
        range,
        len;
        _OjSingleCombobox.superclass._opening.apply(this, arguments);

        el = this.search.get(0);
        if (el.createTextRange)
        {
          range = el.createTextRange();
          range.collapse(false);
          range.select();
        }
        else if (el.setSelectionRange)
        {
          len = this.search.val().length;
          el.setSelectionRange(len, len);
        }

        this._updateResults(true);
        this.opts.element.trigger($.Event("ojexpand"));
      },

      _updateSelection : function (data)
      {
        var formatted;

        this.selection.data(this._elemNm, data);
        if (data !== null)
        {
          formatted = this.opts.formatSelection(data, this.search, this.opts.escapeMarkup);
        }
        if (formatted !== undefined)
        {
          this.search.val(formatted);
        }
        this.search.removeClass(this._classNm + "-default");
        if (this.opts.allowClear)
        {
          this.container.addClass(this._classNm + "-allowclear");
        }
      }
    }
    );


  var _OjSingleSelect = _ComboUtils.clazz(_AbstractSingleChoice,
    {
      _elemNm : "ojselect",
      _classNm : "oj-select",
      _userTyping : false,


      _createContainer : function ()
      {
        var container = $(document.createElement("div")).attr(
          {
            "class" : "oj-select oj-component"
          }
          ).html([
              "<div class='oj-select-choice' tabindex='0' role='combobox' ",
              "     aria-autocomplete='none' aria-expanded='false' aria-ready='true'>",
              "  <span class='oj-select-box'>",
              "    <span class='oj-select-chosen'></span>",
              "    <abbr class='oj-select-search-choice-close' role='presentation'></abbr>",
              "    <a class='oj-component-icon oj-clickable-icon oj-select-open-icon' role='presentation'>",
              "    <b role='presentation'></b></a>",
              "  </span>",
              "</div>",

              "<div class='oj-listbox-drop oj-select-display-none' role='presentation'>",

              "  <div class='oj-select-search-wrapper'>",

              "  <div class='oj-select-search'>",
              "    <input type='text' autocomplete='off' autocorrect='off' autocapitalize='off'",
              "           spellcheck='false' class='oj-select-input' title='Search field' ",
              "           role='combobox' aria-expanded='false' aria-autocomplete='list' />",

              "    <span class='oj-select-spyglass-box'>",
              "      <span class='oj-component-icon oj-select-search-icon' role='presentation'>",
              "       <b role='presentation'></b></span>",
              "    </span>",
              "  </div>",

              "  </div>",

              "   <ul class='oj-listbox-results' role='listbox'>",
              "   </ul>",
              "</div>"

            ].join(""));


        //Don't allow focus on a disabled "select"
        if (this.opts.element.prop("disabled"))
        {
          container.find(".oj-select-choice").attr("tabindex", "-1");
          //Bug 18697446 - disabled select icon hover still shows chnages
          container.find(".oj-select-open-icon").addClass("oj-disabled");
        }

        return container;
      },

      close : function ()
      {
        if (!this._opened())
          return;
        _OjSingleSelect.superclass.close.apply(this, arguments);

        ///ojselect
        if (this.text.text() == "")
          this._clear();
        //always clear search text when dropdown close
        else
          this._clearSearch();

        //set focus to select box
        _ComboUtils._focus(this.selection);

        ///remove "mouse click" listeners on spyglass
        this.container.find(".oj-select-spyglass-box").off("mouseup click");
      },

      _opening : function (event)
      {
        var el,
        range,
        len;

        _OjSingleSelect.superclass._opening.apply(this, arguments);

        //select: focus still stay on the selectBox if open dropdown by mouse click
        this._showSearchBox();

        //James: tab out of an expanded poplist, focus is going all the way to the top of the page.
        if (this._hasSearchBox())
        {
          el = this.search.get(0);
          if (el.createTextRange)
          {
            range = el.createTextRange();
            range.collapse(false);
            range.select();
          }
          else if (el.setSelectionRange)
          {
            len = this.search.val().length;
            el.setSelectionRange(len, len);
          }
        }

        this._updateResults(true);
        this.opts.element.trigger($.Event("ojexpand"));
      },

      _initContainer : function ()
      {
        ///ojselect placeholder
        this.text = this.container.find(".oj-select-chosen");
        _OjSingleSelect.superclass._initContainer.apply(this, arguments);

        ///select: accessibility
        this.container.find(".oj-select-choice")
          .attr("aria-owns", this.search.attr("aria-owns"))
          .attr("aria-labelledby", this.search.attr("aria-labelledby"));
        
        ///ojselect
        this.selection.on("keydown", this._bind(this._containerKeydownHandler));
        this.selection.on("keyup-change input", this._bind(this._containerKeyupHandler));
      },

      _initSelection : function ()
      {
        if (this._isPlaceholderOptionSelected())
        {
          this._updateSelection(null);
          this.close();
          this._setPlaceholder();
        }
        else
        {
          _OjSingleSelect.superclass._initSelection.apply(this, arguments);
        }

      },

      _updateSelection : function (data)
      {
        var formatted;

        this.selection.data(this._elemNm, data);
        //Bug 18326121 - ojet select displaying values incorrectly 
        if (data !== null)
        {
          ///ojselect
          this.text.text(data.text);
        }
        ///ojselect placeholder
        ///reduce number of call to setVal
        ///this.setVal(data? this.opts.id(data) : data);
        this.text.removeClass(this._classNm + "-default");

        if (this.opts.allowClear)
        {
          this.container.addClass(this._classNm + "-allowclear");
        }
      },

      _getActiveContainer : function ()
      {
        var expanded = this.search.attr("aria-expanded");
        return (expanded && this._hasSearchBox()) ? this.search : this.selection;
      },

      _getPlaceholderOption : function ()
      {
        var element = this.opts.element;
        var firstOption = element.children('option').first();
        if (firstOption.text() === "" && firstOption.val() === "")
        {
          return firstOption;
        }
      },

      _isPlaceholderOptionSelected : function ()
      {
        var placeholderOption;
        if (!this._getPlaceholder())
          return false; // no placeholder specified so no option should be considered

        var cval = this.getVal();
        return ((placeholderOption = this._getPlaceholderOption()) !== undefined && placeholderOption.prop("selected"))
         || (cval === "")
         || (cval === undefined)
         || (cval === null);
      },

      _getPlaceholder : function ()
      {
        // if a placeholder is specified on a single select without a valid placeholder option ignore it
        if (this._getPlaceholderOption() === undefined)
        {
          return undefined;
        }

        return _OjSingleSelect.superclass._getPlaceholder.apply(this, arguments);
      },

      _setPlaceholder : function ()
      {
        var placeholder = this._getPlaceholder();

        if (this._isPlaceholderOptionSelected() && placeholder !== undefined)
        {
          // check for a placeholder option if attached to a select
          if (this._getPlaceholderOption() === undefined)
            return;

          if (placeholder === undefined)
            placeholder = "";
          this.text.text(placeholder).addClass(this._classNm + "-default");
          this.container.removeClass(this._classNm + "-allowclear");
        }
      },

      _clearPlaceholder : function ()
      {
        if (this.text.hasClass(this._classNm + "-default"))
        {
          this.text.val("").removeClass(this._classNm + "-default");
        }
      },

      setVal: function (val, event)
      {
        ///pass original event
        _OjSingleSelect.superclass.setVal.call(this, val, event);
        this.selection.data("selectVal", val);
      },

      _containerKeydownHandler : function (e)
      {
        ///ignore shift key 
        if (_ComboUtils.KEY.isControl(e) || _ComboUtils.KEY.isFunctionKey(e))
        {
          return;
        }

        switch (e.which)
        {
        case _ComboUtils.KEY.TAB:
          this._selectHighlighted(
            {
              noFocus : true
            }, e   ///pass original event
          );

          //James: tab out of an expanded poplist, focus is going all the way to the top of the page.
          this.selection.focus();
          return;

        // open dropdown on Enter 
        case _ComboUtils.KEY.ENTER:
          if (e.target === this.selection[0] && ! this._opened())
          {
            this.open();
            _ComboUtils.killEvent(e);
            return;
          }
          break;
        }

       _OjSingleSelect.superclass._containerKeydownHandler.apply(this, arguments);
      },

      _showSearchBox : function ()
      {
        var focusOnSearchBox = false;
        var searchBox = this.dropdown.find(".oj-select-search");
        if (searchBox)
        {
          //hide and show the search box
          if (this._hasSearchBox())
          {
            this.dropdown.find(".oj-select-search-wrapper")
              .removeClass("oj-helper-hidden-accessible");

            $(searchBox).removeAttr("aria-hidden");

            focusOnSearchBox = true;
          }
          else
          {
            this.dropdown.find(".oj-select-search-wrapper")
              .addClass("oj-helper-hidden-accessible");

            $(searchBox)
            .attr(
            {
              "aria-hidden" : "true"
            }
            );
          }
        }

        //if search box is being displayed, focus on the search box otherwise focus on the select box
        _ComboUtils._focus(focusOnSearchBox ? this.search : this.selection);

        ///disable "click" on spyglass
        if (focusOnSearchBox)
        {
          var self = this;
          searchBox.find(".oj-select-spyglass-box").on("mouseup click", function (e)
          {
            self.search.focus();
            e.stopPropagation();
          });
        }

      },

      _hasSearchBox : function ()
      {
        var threshold = this.opts.minimumResultsForSearch;
        var len = this.datalist ? this.datalist[0].length : this.opts.data.length;
        return (len > threshold || this._userTyping);
      }

    }
    );


  /**
   * @class
   * @name oj.ojCombobox
   * @augments oj.editableValue
   *
   * @classdesc
   * <h3 id="comboboxOverview-section">
   *   JET Combobox Component
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#comboboxOverview-section"></a>
   * </h3>
   *
   * <p>Description: JET Combobox enhances a html input and datalist element into a Combobox that supports
   * single-select, multi-select, free text input, and search filtering.
   *
   * <p>A JET Combobox can be created with the following markup. By default, it creates a single-select
   * Combobox. The 'multiple' option can be specified to change it to a multi-select Combobox.
   *
   * <pre class="prettyprint">
   * <code>
   * &lt;input list="items" data-bind="ojComponent: {component: 'ojCombobox', multiple: true}"/>
   *   &lt;datalist id="items">
   *     &lt;option value="option 1">option 1&lt;/option>
   *     &lt;option value="option 2">option 2&lt;/option>
   *     &lt;option value="option 3">option 3&lt;/option>
   *     &lt;option value="option 4">option 4&lt;/option>
   *   &lt;/datalist>
   * </code></pre>
   *
   * <h3 id="keyboard-section">
   *   Keyboard interaction
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
   * </h3>
   *
   * <p>
   * <h5>When the focus is in the input element</h5>
   * </p>
   *
   * <table class="keyboard-table">
   *   <thead>
   *     <tr>
   *       <th>Key</th>
   *       <th>Use</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td><kbd>Enter</kbd></td>
   *       <td> Select the highlighted choice.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Tab</kbd></td>
   *       <td> Select the highlighted choice.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>UpArrow or DownArrow</kbd></td>
   *       <td> Highlight the option item on the drop down list in the direction of the arrow.
   *         If the drop down is not open, expand the drop down list.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>LeftArrow or RightArrow</kbd></td>
   *       <td> Move focus to the previous or next selected item in Multi-select Combobox.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Esc</kbd></td>
   *       <td> Collapse the drop down list. If the drop down is already closed, do nothing.</td>
   *     </tr>
   *
   *   </tbody>
   *  </table>
   *
   * <p>Disabled option items receive no highlight and are not selectable.
   *
   *
   * <h3 id="rtl-section">
   *   Reading direction
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#rtl-section"></a>
   * </h3>
   *
   * <p>As with any JET component, in the unusual case that the directionality (LTR or RTL) changes post-init, the Combobox must be <code class="prettyprint">refresh()</code>ed.
   *
   *
   * <h3 id="pseudos-section">
   *   Pseudo-selectors
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#pseudos-section"></a>
   * </h3>
   *
   * <p>The <code class="prettyprint">:oj-combobox</code> pseudo-selector can be used in jQuery expressions to select JET Combobox.  For example:
   *
   * <pre class="prettyprint">
   * <code>$( ":oj-combobox" ) // selects all JET Combobox on the page
   * $myEventTarget.closest( ":oj-combobox" ) // selects the closest ancestor that is a JET Combobox
   * </code></pre>
   *
   *
   * <h3 id="jqui2jet-section">
   *   JET for jQuery UI developers
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#jqui2jet-section"></a>
   * </h3>
   *
   * <p>Event names for all JET components are prefixed with "oj", instead of component-specific prefixes like "Combobox".
   *
   * @desc Creates a JET Combobox.
   * @example <caption>Initialize the Combobox with no options specified:</caption>
   * $( ".selector" ).ojCombobox();
   *
   * @example <caption>Initialize the Combobox with some options:</caption>
   * $( ".selector" ).ojCombobox( { "multiple": true, "placeholder": "Select multiple values." } );
   *
   * @example <caption>Initialize the Combobox via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
   * &lt;div id="combobox" data-bind="ojComponent: { component: 'ojCombobox',
   *                                                    multiple: true}">
   */
  oj.__registerWidget("oj.ojCombobox", $['oj']['editableValue'],
  {
    version : "1.0.0",
    defaultElement : "<input>",
    widgetEventPrefix : "oj",
    options :
    {
      /**
       * The placeholder text.
       *
       * @expose
       * @memberof! oj.ojCombobox
       * @instance
       * @type {string}
       *
       * @example <caption>Initialize the combobox with the <code class="prettyprint">placeholder</code> option specified:</caption>
       * $( ".selector" ).ojCombobox( { "placeholder": "Please select ..." } );
       */
      placeholder : "",
      /**
       * If multi-select is enabled for the combobox.
       *
       * @expose
       * @memberof! oj.ojCombobox
       * @instance
       * @type {boolean}
       * @default <code class="prettyprint">false</code>
       *
       * @example <caption>Initialize the Combobox with the <code class="prettyprint">multiple</code> option specified:</caption>
       * $( ".selector" ).ojCombobox( { "multiple": true } );
       */
      multiple : false,
      /**
       * The data for the Combobox. Instead of providing the option items in a datalist, the data can be specified as an array of objects containing id and text.
       * The id is used as the value of the option item and text as the label.
       *
       * @expose
       * @memberof! oj.ojCombobox
       * @instance
       * @type {Array}
       *
       * @example <caption>Initialize the Combobox with the <code class="prettyprint">data</code> option specified:</caption>
       * $( ".selector" ).ojCombobox( { "data": [{id: 'option1', text: 'option1'}, {id: 'option2', text: 'option2'}, {id: 'option3', text: 'option3'},] } );
       */
      data : null,
      /**
       * Triggered after the Combobox drop down has been expanded.
       *
       * @expose
       * @event
       * @memberof! oj.ojCombobox
       * @instance
       * @property {Event} event <code class="prettyprint">jQuery</code> event object
       * @property {Object} ui Parameters
       *
       * @example <caption>Initialize the Combobox with the <code class="prettyprint">expand</code> callback specified:</caption>
       * $( ".selector" ).ojCombobox({
       *     "expand": function( event, ui ) {}
       * });
       *
       * @example <caption>Bind an event listener to the <code class="prettyprint">ojexpand</code> event:</caption>
       * $( ".selector" ).on( "ojexpand", function( event, ui ) {} );
       */
      expand : null

    },

    /**
     * Returns a jQuery object containing the element visually representing the combobox.
     *
     * <p>This method does not accept any arguments.
     *
     * @expose
     * @memberof! oj.ojCombobox
     * @instance
     * @return {jQuery} the combobox
     */
    widget : function ()
    {
      return this.combobox.container;
    },

    /**
     * @override
     * @private
     */
    _ComponentCreate : function ()
    {
      this._super();
      this._setup();
    },

    _setup : function ()
    {
      var opts,
      multiple = this.options.multiple;
      opts = {};
      opts.element = this.element;
      opts.ojContext = this;
      opts = $.extend(this.options, opts);

      this.combobox = multiple ? new _OjMultiCombobox() : new _OjSingleCombobox();

      this.combobox._init(opts);
    },

    /**
     * @override
     * @private
     */
    _destroy : function ()
    {
      this.combobox._destroy();
    },
    
    /**
     * Refreshes the combobox.
     *
     * <p>This method does not accept any arguments.
     * 
     * @expose 
     * @memberof! oj.ojCombobox
     * @instance
     */
    refresh : function ()
    {
      this._super();

      this.combobox._destroy();
      this._setup();
    },

    /**
     * Expands the drop down list.
     *
     * This method does not accept any arguments.
     *
     * @expose
     * @memberof! oj.ojCombobox
     * @instance
     */
    expand : function (event)
    {
      this.combobox.open();
      this._trigger("ojexpand", event);
    },

    /**
     * Collapses the drop down list.
     *
     * This method does not accept any arguments.
     *
     * @expose
     * @memberof! oj.ojCombobox
     * @instance
     */
    collapse : function ()
    {
      this.combobox.close();
    },

    /**
     * Handles options specific to combobox.
     * @override
     * @protected
     * @memberof! oj.ojCombobox
     */
    _setOption : function (key, value)
    {
      this._super(key, value);

      if (key === "disabled")
      {
        if (value)
          this.combobox._disable();
        else
          this.combobox._enable();
      }
      else if (key === "value")
      {
        this.combobox._initSelection();
      }
    },

    /**
     * Returns the messaging launcher element
     *
     * @override
     * @protected
     * @memberof! oj.ojCombobox
     */
    _GetMessagingLauncherElement : function ()
    {
      return this.combobox.container;
    },
    
    /**
     * Returns the default styleclass for the component.
     * 
     * @return {string}
     * @expose
     * @memberof! oj.ojCombobox
     * @override
     * @protected
     */
    _GetDefaultStyleClass : function ()
    {
    return "oj-combobox";
    },
    
    /**
     * Return the subcomponent node represented by the documented locator 
     * attribute values.
     * Test authors should target sub elements using the following names:
     * <ul>
     * <li><b>oj-combobox-input</b>: the input field </li>
     * <li><b>oj-combobox-arrow</b>: the drop down arrow for single-select combobox </li>
     * <li><b>oj-combobox-drop</b>: the drop down box </li>
     * <li><b>oj-combobox-results</b>: the filtered result list </li>
     * </ul>
     * @expose
     * @memberof! oj.ojCombobox
     * @instance
     * @override
     * @param {Object} locator An Object containing at minimum a subId property 
     *        whose value is a string, documented by the component, that allows 
     *        the component to look up the subcomponent associated with that 
     *        string.  It contains:<p>
     *        component: optional - in the future there may be more than one 
     *        component contained within a page element<p>
     *        subId: the string, documented by the component, that the component 
     *        expects in getNodeBySubId to locate a particular subcomponent
     * @returns {Element|null} the subcomponent located by the subId string passed
     *          in locator, if found.<p>
     */
    getNodeBySubId: function(locator)
    {
	    if (locator == null)
	    {
        return this.combobox.container ? this.combobox.container[0] : null;
	    }
	    
	    var subId = locator['subId'];
      if (subId == "oj-combobox-drop")
        subId = "oj-listbox-drop";

      if (subId == "oj-combobox-results")
        subId = "oj-listbox-results";

      switch (subId)
      {
        case "oj-combobox-input":
        case "oj-combobox-arrow":
        case "oj-listbox-drop":
        case "oj-listbox-results":
          return this.widget().find(subId)[0];
          break;

	    }

	    // Non-null locators have to be handled by the component subclasses
	    return null;
    }

  }
  );


  /**
   * @class
   * @name oj.ojSelect
   * @augments oj.editableValue
   *
   * @classdesc
   * <h3 id="selectOverview-section">
   *   JET Select Component
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#selectOverview-section"></a>
   * </h3>
   *
   * <p>Description: JET Select enhances a html select and option elements into a Select that supports
   * single-select and search filtering. Note: the 'multiple' option is not supported in V1.
   *
   * <p>A JET Select can be created with the following markup. By default, it creates a single-select
   * Select. 
   *
   * <pre class="prettyprint">
   * <code>
   * &lt;select data-bind="ojComponent: {component: 'ojSelect'}">
   *     &lt;option value="option 1">option 1&lt;/option>
   *     &lt;option value="option 2">option 2&lt;/option>
   *     &lt;option value="option 3">option 3&lt;/option>
   *     &lt;option value="option 4">option 4&lt;/option>
   * &lt;/select>
   * </code></pre>
   *
   * <h3 id="keyboard-section">
   *   Keyboard interaction
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
   * </h3>
   *
   * <p>
   * <h5>When the focus is in the select element</h5>
   * </p>
   *
   * <table class="keyboard-table">
   *   <thead>
   *     <tr>
   *       <th>Key</th>
   *       <th>Use</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td><kbd>Enter</kbd></td>
   *       <td> Select the highlighted choice.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Tab</kbd></td>
   *       <td> Select the highlighted choice.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>UpArrow or DownArrow</kbd></td>
   *       <td> Highlight the option item on the drop down list in the direction of the arrow.
   *         If the drop down is not open, expand the drop down list.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Esc</kbd></td>
   *       <td> Collapse the drop down list. If the drop down is already closed, do nothing.</td>
   *     </tr>
   *
   *   </tbody>
   *  </table>
   *
   * <p>Disabled option items receive no highlight and are not selectable.
   *
   *
   * <h3 id="rtl-section">
   *   Reading direction
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#rtl-section"></a>
   * </h3>
   *
   * <p>As with any JET component, in the unusual case that the directionality (LTR or RTL) changes post-init, the Select must be <code class="prettyprint">refresh()</code>ed.
   *
   *
   * <h3 id="pseudos-section">
   *   Pseudo-selectors
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#pseudos-section"></a>
   * </h3>
   *
   * <p>The <code class="prettyprint">:oj-select</code> pseudo-selector can be used in jQuery expressions to select JET Select.  For example:
   *
   * <pre class="prettyprint">
   * <code>$( ":oj-select" ) // selects all JET Select on the page
   * $myEventTarget.closest( ":oj-select" ) // selects the closest ancestor that is a JET Select
   * </code></pre>
   *
   *
   * <h3 id="jqui2jet-section">
   *   JET for jQuery UI developers
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#jqui2jet-section"></a>
   * </h3>
   *
   * <p>Event names for all JET components are prefixed with "oj", instead of component-specific prefixes like "Select".
   *
   * @desc Creates a JET Select.
   * @example <caption>Initialize the Select with no options specified:</caption>
   * $( ".selector" ).ojSelect();
   *
   * @example <caption>Initialize the Select with some options:</caption>
   * $( ".selector" ).ojSelect( { "placeholder": "Select a value." } );
   *
   * @example <caption>Initialize the Select via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
   * &lt;div id="select" data-bind="ojComponent: { component: 'ojSelect' }">
   */
  oj.__registerWidget("oj.ojSelect", $['oj']['editableValue'],
  {
    version : "1.0.0",
    defaultElement : "<select>",
    widgetEventPrefix : "oj",
    options :
    {
      /**
       * The threshold for showing the search box in the dropdown when it's expanded.
       * The search box is always displayed when the results size is greater than
       * the threshold, otherwise the search box is initially turned off.
       * However, the search box is displayed as soon as the user starts typing.
       * This property only applies to single-select.
       *
       * @expose
       * @memberof! oj.ojSelect
       * @instance
       * @type {number}
       * @default <code class="prettyprint">10</code>
       */
      minimumResultsForSearch : 10,
      /**
       * The placeholder text. When placeholder is used for a single value select,
       * it requires that you include an empty <option></option> tag as your first option.
       *
       * @expose
       * @memberof! oj.ojSelect
       * @instance
       * @type {string}
       *
       * @example <caption>Initialize the select with the <code class="prettyprint">placeholder</code> option specified:</caption>
       * $( ".selector" ).ojSelect( { "placeholder": "Please select ..." } );
       */
      placeholder : "",
      /**
       * If multi-select is enabled for the select.
       *
       * @expose
       * @memberof! oj.ojSelect
       * @instance
       * @type {boolean}
       * @default <code class="prettyprint">false</code>
       *
       * @example <caption>Initialize the Select with the <code class="prettyprint">multiple</code> option specified:</caption>
       * $( ".selector" ).ojSelect( { "multiple": true } );

      multiple: false,
       */

      /**
       * The data for the Select. Instead of providing a list of option items, the data can be specified as an array of objects containing id and text.
       * The id is used as the value of the option item and text as the label.
       *
       * @expose
       * @memberof! oj.ojSelect
       * @instance
       * @type {Array}
       *
       * @example <caption>Initialize the Select with the <code class="prettyprint">data</code> option specified:</caption>
       * $( ".selector" ).ojSelect( { "data": [{id: 'option1', text: 'option1'}, {id: 'option2', text: 'option2'}, {id: 'option3', text: 'option3'},] } );
       */
      data : null,
      /**
       * Triggered after the Select drop down has been expanded.
       *
       * @expose
       * @event
       * @memberof! oj.ojSelect
       * @instance
       * @property {Event} event <code class="prettyprint">jQuery</code> event object
       * @property {Object} ui Parameters
       *
       * @example <caption>Initialize the Select with the <code class="prettyprint">expand</code> callback specified:</caption>
       * $( ".selector" ).ojSelect({
       *     "expand": function( event ) {}
       * });
       *
       * @example <caption>Bind an event listener to the <code class="prettyprint">ojexpand</code> event:</caption>
       * $( ".selector" ).on( "ojexpand", function( event ) {} );
       */
      expand : null

    },

    /**
     * Returns a jQuery object containing the element visually representing the select.
     *
     * <p>This method does not accept any arguments.
     *
     * @expose
     * @memberof! oj.ojSelect
     * @instance
     * @return {jQuery} the select
     */
    widget : function ()
    {
      return this.select.container;
    },

    /**
     * @override
     * @private
     */
    _ComponentCreate : function ()
    {
      this._super();
      this._setup();
    },

    _setup : function ()
    {
      var opts = {};
      opts.element = this.element;
      opts.ojContext = this;
      opts = $.extend(this.options, opts);

      this.select = new _OjSingleSelect();

      this.select._init(opts);
    },

    /**
     * Refreshes the visual state of the tabs. JET components require a <code class="prettyprint">refresh()</code> or re-init after the DOM is programmatically changed underneath the component.
     *
     * <p>This method does not accept any arguments.
     * 
     * @expose 
     * @memberof! oj.ojSelect
     * @instance
     */
    refresh : function ()
    {
      this._super();

      this.select._destroy();
      this._setup();
      //TODO: apply value in options for the selected value
    },

    /**
     * @override
     * @private
     */
    _destroy : function ()
    {
      this.select._destroy();
    },

    /**
     * Expands the drop down list.
     *
     * This method does not accept any arguments.
     *
     * @expose
     * @memberof! oj.ojSelect
     * @instance
     */
    expand : function ()
    {
      this.select.open();
    },

    /**
     * Collapses the drop down list.
     *
     * This method does not accept any arguments.
     *
     * @expose
     * @memberof! oj.ojSelect
     * @instance
     */
    collapse : function ()
    {
      this.select.close();
    },

    /**
     * Sets the placeholder text on the content element by default. It sets the placeholder attribute
     * on the element. Component subclasses can override this method to control where placeholder text
     * gets set.
     * @param {string} value
     * @expose
     * @memberof! oj.ojSelect
     * @instance
     * @override
     */
    _SetPlaceholder : function(value)
    {
      this._super(value);
      this.select.opts.placeholder = value;
      this.select._setPlaceholder();
    },
    
    /**
     * Handles options specific to select.
     * @override
     * @protected
     * @memberof! oj.ojSelect
     */
    _setOption : function (key, value)
    {
      this._super(key, value);

      if (key === "disabled")
      {
        if (value)
          this.select._disable();
        else
          this.select._enable();
      }
      else if (key === "data")
      {
        this._setup();
      }
      else if (key === "value")
      {
        // [pavitra] don't call setVal() here for the following reasons - 
        // 1. when _setOption() is called for the key === 'value', the value has already been 
        // written into the component option. So calling this.select.setVal() is incorrect because 
        // it ends up calling EditableValue._SetValue(). 
        // 2. EditableValue._SetValue is really intended to be called only when user interacts with 
        // your component and as a result you need to run converters and validators on the 
        // value. There are ways to call _SetValue() so it runs in restricted mode. See JSDocs.
        // 
        // 3. _setOption() method is called when the component value is updated programmatically. In 
        // those cases you don't want to run validations by calling _SetValue.
        this.select._initSelection();
      }

    },

    /**
     * Return the subcomponent node represented by the documented locator 
     * attribute values.
     * Test authors should target sub elements using the following names:
     * <ul>
     * <li><b>oj-select-chosen</b>: the selected text in the select box</li>
     * <li><b>oj-select-search</b>: the search box. Note the searchbox is not always visible</li>
     * <li><b>oj-select-drop</b>: the drop down box </li>
     * <li><b>oj-select-results</b>: the filtered result list </li>
     * </ul>
     * @expose
     * @memberof! oj.ojSelect
     * @instance
     * @override
     * @param {Object} locator An Object containing at minimum a subId property 
     *        whose value is a string, documented by the component, that allows 
     *        the component to look up the subcomponent associated with that 
     *        string.  It contains:<p>
     *        component: optional - in the future there may be more than one 
     *        component contained within a page element<p>
     *        subId: the string, documented by the component, that the component 
     *        expects in getNodeBySubId to locate a particular subcomponent
     * @returns {Element|null} the subcomponent located by the subId string passed
     *          in locator, if found.<p>
     */
    getNodeBySubId: function(locator)
    {
      if (locator == null)
      {
        return this.select.container ? this.select.container[0] : null;
      }
      
      var subId = locator['subId'];
      if (subId == "oj-select-drop")
        subId = "oj-listbox-drop";

      if (subId == "oj-select-results")
        subId = "oj-listbox-results";

      switch (subId) {
      case "oj-select-chosen":
      case "oj-select-search":
      case "oj-listbox-drop":
      case "oj-listbox-results":
        return this.widget().find("." + subId)[0];
      }
      
      // Non-null locators have to be handled by the component subclasses
      return null;
    },

    /**
     * Returns the default styleclass for the component. Currently this is 
     * used to pass to the _ojLabel component, which will append -label and 
     * add the style class onto the label. This way we can style the label
     * specific to the input component. For example, for inline labels, the
     * radioset/checkboxset components need to have margin-top:0, whereas all the
     * other inputs need it to be .5em. So we'll have a special margin-top style 
     * for .oj-label-inline.oj-radioset-label
     * All input components must override
     * 
     * @return {string}
     * @expose
     * @memberof! oj.ojSelect
     * @override
     * @protected
     */
    _GetDefaultStyleClass : function ()
    {
      return "oj-select";
    },

    /**
     * Returns the messaging launcher element
     *
     * @override
     * @protected
     * @memberof! oj.ojSelect
     */
    _GetMessagingLauncherElement : function ()
    {
      return this.select.container;
    }

  }
  );


  var _OjMultiCombobox = _ComboUtils.clazz(_AbstractOjChoice,
    {
      _elemNm : "ojcombobox",
      _classNm : "oj-combobox",

      _createContainer : function ()
      {
        var container = $(document.createElement("div")).attr(
          {
            "class" : "oj-combobox oj-combobox-multi oj-component"
          }
          ).html([
              "<ul class='oj-combobox-choices'>",
              "  <li class='oj-combobox-search-field'>",
              "    <input type='text' role='combobox' aria-expanded='false' aria-autocomplete='list' autocomplete='off' autocorrect='off' autocapitalize='off' spellcheck='false' class='oj-combobox-input'>",
              "  </li>",
              "</ul>",
              "<div class='oj-combobox-description oj-helper-hidden-accessible'/>",
              "<div class='oj-listbox-drop oj-listbox-drop-multi oj-combobox-display-none'>",
              "   <ul class='oj-listbox-results' role='listbox'>",
              "   </ul>",
              "</div>"].join(""));
        return container;
      },
      _prepareOpts : function ()
      {
        var opts = _OjMultiCombobox.superclass._prepareOpts.apply(this, arguments),
        self = this;

        if (opts.element.get(0).tagName.toLowerCase() === "input" && opts.element.prop("list"))
        {
          // install the selection initializer
          opts.initSelection = function (element, callback)
          {
            var data = [];
            if (opts.element.val())
            {
              var selected;
              var ids = _ComboUtils.splitVal(opts.element.val(), opts.separator);
              for (var i = 0; i < ids.length; i++)
              {
                var id = ids[i];
                selected = element.find("option").filter(function ()
                  {
                    return this.value === id;
                  }
                  );
                data.push(self._optionToData(selected));
              }
            }
            else
            {
              var selected;
              selected = element.find("option").filter(function ()
                {
                  return this.selected
                }
                );
              _ComboUtils.each2(selected, function (i, elm)
              {
                data.push(self._optionToData(elm));
              }
              );
            }
            callback(data);
          };
        }
        else if ("data" in opts)
        {
          // install default initSelection when applied to hidden input and data is local
          opts.initSelection = opts.initSelection || function (element, callback)
          {
            var ids = _ComboUtils.splitVal(element.val(), opts.separator);
            //search in data by array of ids, storing matching items in a list
            var matches = [];
            opts.query(
            {
              matcher : function (term, text, el)
              {
                var is_match = $.grep(ids, function (id)
                  {
                    return id === opts.id(el);
                  }
                  ).length;
                if (is_match)
                {
                  matches.push(el);
                }
                return is_match;
              },
              callback : !$.isFunction(callback) ? $.noop : function ()
              {
                // reorder matches based on the order they appear in the ids array because right now
                // they are in the order in which they appear in data array
                var ordered = [];
                for (var i = 0; i < ids.length; i++)
                {
                  var id = ids[i];
                  for (var j = 0; j < matches.length; j++)
                  {
                    var match = matches[j];
                    if (id === opts.id(match))
                    {
                      ordered.push(match);
                      matches.splice(j, 1);
                      break;
                    }
                  }
                }
                callback(ordered);
              }
            }
            );
          };
        }
        return opts;
      },
      _selectChoice : function (choice)
      {
        var selected = this.container.find("." + this._classNm + "-search-choice-focus");
        if (selected.length && choice && choice[0] == selected[0])
        {}

        else
        {
          if (selected.length)
          {
            this.opts.element.trigger("choice-deselected", selected);
          }
          selected.removeClass(this._classNm + "-search-choice-focus");
          if (choice && choice.length)
          {
            this.close();
            choice.addClass(this._classNm + "-search-choice-focus");
            this.container.find(".oj-combobox-description").html(choice.attr("valueText") + ". Press back space to delete.")
            .attr("aria-live", "assertive");
            this.opts.element.trigger("choice-selected", choice);
          }
        }
      },
      _destroy : function ()
      {
        $("label[for='" + this.search.attr('id') + "']")
        .attr('for', this.opts.element.attr("id"));
        _OjMultiCombobox.superclass._destroy.apply(this, arguments);
      },

      _initContainer : function ()
      {
        var selector = "." + this._classNm + "-choices",
        selection,
        idSuffix = _ComboUtils.nextUid(),
        elementLabel;

        this.searchContainer = this.container.find("." + this._classNm + "-search-field");
        this.selection = selection = this.container.find(selector);

        var _this = this;
        this.selection.on("click", "." + this._classNm + "-search-choice:not(." + this._classNm + "-locked)", function (e)
        {
          _this.search[0].focus(); //Fixed??
          _this._selectChoice($(this));
        }
        );

        elementLabel = $("label[for='" + this.opts.element.attr("id") + "']");
        if (!elementLabel.attr("id"))
          elementLabel.attr('id', this._classNm + "-label-" + idSuffix);

        // add aria associations
        this.results.attr("id", "oj-listbox-results-" + idSuffix);
        this.search.attr("aria-owns", "oj-listbox-results-" + idSuffix);
        this.search.attr("aria-labelledby", elementLabel.attr("id"));

        this.search.on("input paste", this._bind(function ()
          {
            if (!this._isInterfaceEnabled())
              return;
            if (!this._opened())
            {
              this.open();
            }
          }
          ));

        this.search.attr("tabindex", this.elementTabIndex);
        this.keydowns = 0;
        this.search.on("keydown", this._bind(function (e)
          {
            if (!this._isInterfaceEnabled())
              return;

            ++this.keydowns;
            var selected = selection.find("." + this._classNm + "-search-choice-focus");
            var prev = selected.prev("." + this._classNm + "-search-choice:not(." + this._classNm + "-locked)");
            var next = selected.next("." + this._classNm + "-search-choice:not(." + this._classNm + "-locked)");
            var pos = _ComboUtils.getCursorInfo(this.search);

            if (selected.length &&
              (e.which == _ComboUtils.KEY.LEFT || e.which == _ComboUtils.KEY.RIGHT || e.which == _ComboUtils.KEY.BACKSPACE || e.which == _ComboUtils.KEY.DELETE || e.which == _ComboUtils.KEY.ENTER))
            {
              var selectedChoice = selected;
              if (e.which == _ComboUtils.KEY.LEFT && prev.length)
              {
                selectedChoice = prev;
              }
              else if (e.which == _ComboUtils.KEY.RIGHT)
              {
                selectedChoice = next.length ? next : null;
              }
              else if (e.which === _ComboUtils.KEY.BACKSPACE)
              {
                this._unselect(selected.first());
                this.search.width(10);
                selectedChoice = prev.length ? prev : next;
              }
              else if (e.which == _ComboUtils.KEY.DELETE)
              {
                this._unselect(selected.first());
                this.search.width(10);
                selectedChoice = next.length ? next : null;
              }
              else if (e.which == _ComboUtils.KEY.ENTER)
              {
                selectedChoice = null;
              }

              this._selectChoice(selectedChoice);
              _ComboUtils.killEvent(e);
              if (!selectedChoice || !selectedChoice.length)
              {
                this.open();
              }
              return;
            }
            else if (((e.which === _ComboUtils.KEY.BACKSPACE && this.keydowns == 1)
                 || e.which == _ComboUtils.KEY.LEFT) && (pos.offset == 0 && !pos.length))
            {
              this._selectChoice(selection.find("." + this._classNm + "-search-choice:not(." + this._classNm + "-locked)").last());
              _ComboUtils.killEvent(e);
              return;
            }
            else
            {
              this._selectChoice(null);
            }

            if (this._opened())
            {
              switch (e.which)
              {
              case _ComboUtils.KEY.UP:
              case _ComboUtils.KEY.DOWN:
                this._moveHighlight((e.which === _ComboUtils.KEY.UP) ? -1 : 1);
                _ComboUtils.killEvent(e);
                return;
              case _ComboUtils.KEY.ENTER:
                this._selectHighlighted();
                _ComboUtils.killEvent(e);
                return;
              case _ComboUtils.KEY.TAB:
                this._selectHighlighted(
                {
                  noFocus : true
                }
                );
                this.close();
                return;
              case _ComboUtils.KEY.ESC:
                this._cancel(e);
                _ComboUtils.killEvent(e);
                return;
              }
            }

            if (e.which === _ComboUtils.KEY.TAB || _ComboUtils.KEY.isControl(e) || _ComboUtils.KEY.isFunctionKey(e)
               || e.which === _ComboUtils.KEY.BACKSPACE || e.which === _ComboUtils.KEY.ESC)
            {
              return;
            }

            if (e.which === _ComboUtils.KEY.ENTER)
            {
              if (this.opts.openOnEnter === false)
              {
                return;
              }
              else if (e.altKey || e.ctrlKey || e.shiftKey || e.metaKey)
              {
                return;
              }
            }

            this.open();

            if (e.which === _ComboUtils.KEY.PAGE_UP || e.which === _ComboUtils.KEY.PAGE_DOWN)
            {
              // prevent the page from scrolling
              _ComboUtils.killEvent(e);
            }

            if (e.which === _ComboUtils.KEY.ENTER)
            {
              // prevent form from being submitted
              _ComboUtils.killEvent(e);
            }

          }
          ));

        this.search.on("keyup", this._bind(function (e)
          {
            this.keydowns = 0;
            this._resizeSearch();
          }
          ));

        this.search.on("blur", this._bind(function (e)
          {
            this.search.removeClass(this._classNm + "-focused");
            this._selectChoice(null);
            if (!this._opened())
              this._clearSearch();
            e.stopImmediatePropagation();
          }
          ));

        this.container.on("click", selector, this._bind(function (e)
          {
            if (!this._isInterfaceEnabled())
              return;
            if ($(e.target).closest("." + this._classNm + "-search-choice").length > 0)
            {
              // clicked inside a oj-combobox search choice, do not open
              return;
            }
            this._selectChoice(null);
            this._clearPlaceholder();
            this.open();
            this._focusSearch();
            e.preventDefault();
          }
          ));

        this.container.on("focus", selector, this._bind(function ()
          {
            if (!this._isInterfaceEnabled())
              return;
            this._clearPlaceholder();
          }
          ));

        this._initContainerWidth();
        this.opts.element.addClass(this._classNm + "-offscreen");

        // set the placeholder if necessary
        this._clearSearch();
      },
      _enableInterface : function ()
      {
        if (_OjMultiCombobox.superclass._enableInterface.apply(this, arguments))
        {
          this.search.prop("disabled", !this._isInterfaceEnabled());
        }
      },
      _initSelection : function ()
      {
        var data;
        if (this.opts.element.val() === "" && this.opts.element.text() === "")
        {
          this._updateSelection([]);
          this.close();
          // set the placeholder if necessary
          this._clearSearch();
        }
        if (this.datalist || this.opts.element.val() !== "")
        {
          var self = this,
          element;
          if (this.datalist)
            element = this.datalist;
          else
            element = this.opts.element;
          this.opts.initSelection.call(null, element, function (data)
          {
            if (data !== undefined && data !== null)
            {
              self._updateSelection(data);
              self.close();
              // set the placeholder if necessary
              self._clearSearch();
            }
          }
          );
        }
      },
      _clearSearch : function ()
      {
        var placeholder = this._getPlaceholder(),
        maxWidth = this._getMaxSearchWidth();

        if (placeholder !== undefined && (!this.getVal() || this.getVal().length === 0))
        {
          this.search.val(placeholder).addClass(this._classNm + "-default");
          // stretch the search box to full width of the container so as much of the placeholder is visible as possible
          // we could call this._resizeSearch(), but we do not because that requires a sizer and we do not want to create one so early because of a firefox bug, see #944
          this.search.width(maxWidth > 0 ? maxWidth : this.container.css("width"));
        }
        else
        {
          this.search.val("").width(10);
        }
      },
      _clearPlaceholder : function ()
      {
        if (this.search.hasClass(this._classNm + "-default"))
        {
          this.search.val("").removeClass(this._classNm + "-default");
        }
      },
      _opening : function (event)
      {
        this._resizeSearch();
        _OjMultiCombobox.superclass._opening.apply(this, arguments);
        this._focusSearch();
        this._updateResults(true);
        this.search.focus();
        this.opts.element.trigger($.Event("ojexpand"));
      },
      close : function ()
      {
        if (!this._opened())
          return;
        this._clearSearch();
        _OjMultiCombobox.superclass.close.apply(this, arguments);
      },
      _focus : function ()
      {
        this.close();
        this.search.focus();
      },
      _updateSelection : function (data)
      {
        var ids = [],
        filtered = [],
        self = this;

        // filter out duplicates
        $(data).each(function ()
        {
          if (ids.indexOf(self.id(this)) < 0)
          {
            ids.push(self.id(this));
            filtered.push(this);
          }
        }
        );
        data = filtered;
        this.selection.find("." + this._classNm + "-search-choice").remove();
        $(data).each(function ()
        {
          self._addSelectedChoice(this);
        }
        );
        self._postprocessResults();
      },
      _onSelect : function (data, options)
      {
        if (!this._triggerSelect(data))
        {
          return;
        }
        this._addSelectedChoice(data);
        if (this.select || !this.opts.closeOnSelect)
          this._postprocessResults(data, false, this.opts.closeOnSelect === true);
        if (this.opts.closeOnSelect)
        {
          this.close();
          this.search.width(10);
        }
        else
        {
          if (this._findHighlightableChoices().length > 0)
          {
            this._clearSearch();
            this.search.width(10);
            this._resizeSearch();
            this._positionDropdown();
          }
          else
          {
            // if nothing left to select close
            this.close();
            this.search.width(10);
          }
        }
        // since its not possible to select an element that has already been
        // added we do not need to check if this is a new element before firing change
        this._triggerChange();

        if (!options || !options.noFocus)
          this._focusSearch();
      },
      _cancel : function ()
      {
        this.close();
        this._focusSearch();
      },
      _addSelectedChoice : function (data)
      {
        var enableChoice = !data.locked,
        enabledItem = $(
            "<li class='" + this._classNm + "-search-choice'>" +
            "    <div></div>" +
            "    <a href='#' onclick='return false;' class='" + this._classNm + "-search-choice-close' tabindex='-1'></a>" +
            "</li>"),
        disabledItem = $(
            //"<li class='oj-combobox-search-choice oj-combobox-locked'>" +
            "<li class='" + this._classNm + "-search-choice " + this._classNm + "-locked'>" +
            "<div></div>" +
            "</li>");
        var choice = enableChoice ? enabledItem : disabledItem,
        id = this.id(data),
        val = this.getVal(),
        formatted;

        formatted = this.opts.formatSelection(data, choice.find("div"), this.opts.escapeMarkup);
        if (formatted !== undefined)
        {
          choice.find("div").replaceWith("<div>" + formatted + "</div>");
          choice.attr("valueText", formatted);
        }
        if (enableChoice)
        {
          choice.find("." + this._classNm + "-search-choice-close")
          .on("mousedown", _ComboUtils.killEvent)
          .on("click dblclick", this._bind(function (e)
            {
              if (!this._isInterfaceEnabled())
                return;

              $(e.target).closest("." + this._classNm + "-search-choice").fadeOut('fast', this._bind(function ()
                {
                  this._unselect($(e.target));
                  this.selection.find("." + this._classNm + "-search-choice-focus").removeClass(this._classNm + "-search-choice-focus");
                  this.close();
                  this._focusSearch();
                }
                )).dequeue();
              _ComboUtils.killEvent(e);
            }
            ));
        }
        choice.data(this._elemNm, data);
        choice.insertBefore(this.searchContainer);
        $(data).each(function ()
        {
          if (val.indexOf(id) < 0)
          {
            val.push(id);
          }
        }
        );
        this.setVal(val);
      },
      _unselect : function (selected)
      {
        var val = this.getVal(),
        data,
        index;
        selected = selected.closest("." + this._classNm + "-search-choice");
        if (selected.length === 0)
        {
//TODO: translation string
          throw "Invalid argument: " + selected + ". Must be ." + this._classNm + "-search-choice";
        }
        data = selected.data(this._elemNm);
        if (!data)
        {
          // prevent a race condition when the 'x' is clicked really fast repeatedly the event can be queued
          // and invoked on an element already removed
          return;
        }
        while ((index = val.indexOf(this.id(data))) >= 0)
        {
          val.splice(index, 1);
          this.setVal(val);
          if (this.select)
            this._postprocessResults();
        }
        selected.remove();
        this._triggerChange();
      },
      _postprocessResults : function (data, initial, noHighlightUpdate)
      {
        var val = this.getVal(),
        choices = this.results.find(".oj-listbox-result"),
        compound = this.results.find(".oj-listbox-result-with-children"),
        self = this;

        _ComboUtils.each2(choices, function (i, choice)
        {
          var id = self.id(choice.data(self._elemNm));
          if (val.indexOf(id) >= 0)
          {
            choice.addClass("oj-listbox-selected");
            // mark all children of the selected parent as selected
            choice.find(".oj-listbox-result-selectable").addClass("oj-listbox-selected");
          }
        }
        );
        _ComboUtils.each2(compound, function (i, choice)
        {
          // hide an optgroup if it doesnt have any selectable children
          if (!choice.is(".oj-listbox-result-selectable")
             && choice.find(".oj-listbox-result-selectable:not(.oj-listbox-selected)").length === 0)
          {
            choice.addClass("oj-listbox-selected");
          }
        }
        );
        if (this._highlight() == -1 && noHighlightUpdate !== false)
        {
          self._highlight(0);
        }
        //If all results are chosen render formatNoMAtches
        if (!this.opts.manageNewEntry && 
            !choices.filter('.oj-listbox-result:not(.oj-listbox-selected)').length > 0)
        {
          if (!data || data && !data.more && this.results.find(".oj-listbox-no-results").length === 0)
          {
            if (_ComboUtils.checkFormatter(self.ojContext, self.opts.formatNoMatches, "formatNoMatches"))
            {
              this.results.append("<li class='oj-listbox-no-results'>" +
                                  self.opts.formatNoMatches(self.ojContext, self.search.val()) + "</li>");
            }
          }
        }
      },
      _getMaxSearchWidth : function ()
      {
        return this.selection.width() - _ComboUtils.getSideBorderPadding(this.search);
      },
      _resizeSearch : function ()
      {
        var minimumWidth,
        left,
        maxWidth,
        containerLeft,
        searchWidth,
        sideBorderPadding = _ComboUtils.getSideBorderPadding(this.search);

        minimumWidth = this.search.width() + 10;
        left = this.search.offset().left;
        maxWidth = this.selection.width();
        containerLeft = this.selection.offset().left;
        searchWidth = maxWidth - (left - containerLeft) - sideBorderPadding;
        if (searchWidth < minimumWidth)
        {
          searchWidth = maxWidth - sideBorderPadding;
        }
        if (searchWidth < 40)
        {
          searchWidth = maxWidth - sideBorderPadding;
        }
        if (searchWidth <= 0)
        {
          searchWidth = minimumWidth;
        }
        this.search.width(Math.floor(searchWidth));
      },
      
      getVal : function ()
      {
        var val;
        val = this.opts.element.val();
        return _ComboUtils.splitVal(val, this.opts.separator);

      },
      setVal : function (val)
      {
        var unique;
        unique = [];
        
        if (typeof val === "string")
          val = _ComboUtils.splitVal(val, this.opts.separator);
        // filter out duplicates
        $(val).each(function ()
        {
          if (unique.indexOf(this) < 0)
            unique.push(this);
        }
        );

        this.opts.element.val(unique.length === 0 ? "" : unique.join(this.opts.separator));
        this.search.attr("aria-activedescendant", this.opts.element.attr("id"));
      },
      val : function (val)
      {
        var oldData,
        self = this;

        if (arguments.length === 0)
        {
          return this.getVal();
        }
        oldData = this._data();
        if (!oldData.length)
          oldData = [];
        // val is an id. !val is true for [undefined,null,'',0] - 0 is legal
        if (!val && val !== 0)
        {
          this.opts.element.val(null);
          this._updateSelection([]);
          this._clearSearch();
          this._triggerChange();
          return;
        }
        // val is a list of ids
        this.setVal(val);
        if (this.select)
        {
          this.opts.initSelection(this.select, this._bind(this._updateSelection));
          this._triggerChange();
        }
        else
        {
          if (this.opts.initSelection === undefined)
          {
            throw new Error("cannot call val() if initSelection() is not defined");
          }

          this.opts.initSelection(this.opts.element, function (data)
          {
            var ids = $.map(data, self.id);
            self.setVal(ids);
            self._updateSelection(data);
            self._clearSearch();
            self._triggerChange();
          }
          );
        }
        this._clearSearch();
      },
      _data : function (values)
      {
        var self = this,
        ids,
        old;
        if (arguments.length === 0)
        {
          return this.selection
          .find("." + this._classNm + "-search-choice")
          .map(function ()
          {
            return $(this).data(self._elemNm);
          }
          )
          .get();
        }
        else
        {
          old = this._data();
          if (!values)
          {
            values = [];
          }
          ids = $.map(values, function (e)
            {
              return self.opts.id(e);
            }
            );
          this.setVal(ids);
          this._updateSelection(values);
          this._clearSearch();
        }
      }
    }
    );


/*!
 * jQuery UI Datepicker 1.10.1
 * http://jqueryui.com
 *
 * Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/datepicker/
 *
 * Depends:
 *  jquery.ui.core.js
 */

/*
 * Bind hover events for datepicker elements.
 * Done via delegate so the binding only occurs once in the lifetime of the parent div.
 * Global instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker.
 */
function bindHover(dpDiv)
{
  var selector = ".oj-datepicker-prev-icon, .oj-datepicker-prev-icon .oj-clickable-icon.oj-component-icon, .oj-datepicker-next-icon, .oj-datepicker-next-icon .oj-clickable-icon.oj-component-icon, .oj-datepicker-calendar td a";
  return dpDiv.delegate(selector, "mouseout", function ()
  {
    $(this).removeClass("oj-hover");
  }).delegate(selector, "mouseover", function ()
  {
    $(this).addClass("oj-hover");
  }).delegate(selector, "focus", function ()
  {
    $(this).addClass("oj-focus");
  }).delegate(selector, "blur", function ()
  {
    $(this).removeClass("oj-focus");
  });
};

var iso8601Week = function (date)
{
  var time, checkDate = new Date(date.getTime());

  // Find Thursday of this week starting on Monday
  checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));

  time = checkDate.getTime();
  checkDate.setMonth(0);// Compare with Jan 1
  checkDate.setDate(1);
  return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
};

//to display the suffix for the year
var yearDisplay = oj.Validation.converterFactory(oj.ConverterFactory.CONVERTER_TYPE_DATETIME).createConverter(
{
  "year" : "numeric"
});


/*!
 * JET Input Date @VERSION
 * http://jqueryui.com
 *
 * Copyright 2013 jQuery Foundertion and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * Depends:
 *  jquery.ui.widget.js
 */
/**
 * @class
 * @name oj.ojInputDate
 * @augments oj.inputBase
 * 
 * @classdesc
 * <h3 id="inputDateOverview-section">
 *   JET ojInputDate Component
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#inputDateOverview-section"></a>
 * </h3>
 * 
 * <p>Description: ojInputDate provides basic support for datepicker selection.
 * 
 * <h3 id="keyboard-section">
 *   Keyboard interaction
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
 * </h3>
 * 
 * <p>When focus is NOT on the grid and on the input element.
 * 
 * <table class="keyboard-table">
 *   <thead>
 *     <tr>
 *       <th>Key</th>
 *       <th>Use</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td><kbd>DownArrow or UpArrow</kbd></td>
 *       <td>Shows the grid and moves the focus into the expanded date grid</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Esc</kbd></td>
 *       <td>Close the grid.</tr>
 *     <tr>
 * </tbody></table>
 * 
 * <br/>
 * <p>When focus is on the grid.
 * 
 * <table class="keyboard-table">
 *   <thead>
 *     <tr>
 *       <th>Key</th>
 *       <th>Use</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td><kbd>Enter</kbd></td>
 *       <td>Select the currently focused day</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>UpArrow</kbd></td>
 *       <td>Move up in the grid.</tr>
 *     <tr>
 *       <td><kbd>DownArrow</kbd></td>
 *       <td>Move down in the grid.</tr>
 *     <tr>
 *       <td><kbd>RightArrow</kbd></td>
 *       <td>Move right in the grid.</tr>
 *     <tr>
 *       <td><kbd>LeftArrow</kbd></td>
 *       <td>Move left in the grid.</tr>
 *     <tr>
 *       <td><kbd>Esc</kbd></td>
 *       <td>Close the grid.</tr>
 *     <tr>
 *       <td><kbd>Home</kbd></td>
 *       <td>Move focus to first day of the month.</tr>
 *     <tr>
 *       <td><kbd>End</kbd></td>
 *       <td>Move focus to last day of the month.</tr>
 *     <tr>
 *       <td><kbd>PageUp</kbd></td>
 *       <td>Switch to previous month.</tr>
 *     <tr>
 *       <td><kbd>PageDown</kbd></td>
 *       <td>Switch to next month.</tr>
 *     <tr>
 *       <td><kbd>Alt + PageUp</kbd></td>
 *       <td>Switch to previous year.</tr>
 *     <tr>
 *       <td><kbd>Alt + PageDown</kbd></td>
 *       <td>Switch to next year.</tr>
 *     <tr>
 *       <td><kbd>Ctrl + Alt + PageUp</kbd></td>
 *       <td>Switch to previous by stepBigMonths.</tr>
 *     <tr>
 *       <td><kbd>Ctrl + Alt + PageDown</kbd></td>
 *       <td>Switch to next by stepBigMonths.</tr>
 *     <tr>
 *       <td><kbd>Ctrl + Alt + T</kbd></td>
 *       <td>Places focus on Today button if it exists.</tr>
 *     <tr>
 *       <td><kbd>Ctrl + Alt + D</kbd></td>
 *       <td>Places focus on Done button if it exists.</tr>
 * </tbody></table>
 * 
 * <h3 id="pseudos-section">
 *   Pseudo-selectors
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#pseudos-section"></a>
 * </h3>
 * 
 * <pre class="prettyprint">
 * <code>$( ":oj-inputDate" )            // selects all JET input on the page
 * </code>
 * </pre>
 * 
 * <h3 id="binding-section">
 *   Declarative Binding
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#binding-section"></a>
 * </h3>
 * 
 * <pre class="prettyprint">
 * <code>
 *    &lt;input id="dateId" data-bind="ojComponent: {component: 'ojInputDate'}" /&gt;
 * </code>
 * </pre>
 * 
 * @desc Creates or re-initializes a JET ojInputDate
 * 
 * @param {Object=} options a map of option-value pairs to set on the component
 * 
 * @example <caption>Initialize the input element with no options specified:</caption>
 * $( ".selector" ).ojInputDate();
 * 
 * * @example <caption>Initialize the input element with some options:</caption>
 * $( ".selector" ).ojInputDate( { "disabled": true } );
 * 
 * @example <caption>Initialize the input element via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;input id="dateId" data-bind="ojComponent: {component: 'ojInputDate'}" /&gt;
 */
oj.__registerWidget("oj.ojInputDate", $['oj']['inputBase'], 
{
  version : "1.0.0", 
  widgetEventPrefix : "oj", 
  
  //-------------------------------------From base---------------------------------------------------//
  _CLASS_NAMES : "oj-inputdatetime-input",
  _WIDGET_CLASS_NAMES : "oj-inputdatetime-date-only oj-component oj-inputdatetime",
  _INPUT_HELPER_KEY: "inputHelp",
  _ATTR_CHECK : [{"attr": "type", "setMandatory": "text"}],
  //-------------------------------------End from base-----------------------------------------------//
  
  _TRIGGER_CLASS : "oj-inputdatetime-input-trigger", 
  _TRIGGER_CALENDAR_CLASS : "oj-inputdatetime-calendar-icon", 
  
  _CURRENT_CLASS : "oj-datepicker-current-day", 
  _DAYOVER_CLASS : "oj-datepicker-days-cell-over",
  _UNSELECTABLE_CLASS : "oj-datepicker-unselectable",
  
  _DATEPICKER_DESCRIPTION_ID : "oj-datepicker-desc",
  _CALENDAR_DESCRIPTION_ID : "oj-datepicker-calendar", 
  _MAIN_DIV_ID : "oj-datepicker-div", 
  
  _INLINE_CLASS : "oj-datepicker-inline",
  _INPUT_CONTAINER_CLASS : " oj-inputdatetime-input-container",
  
  options : 
  {
    /**
     * Additional info to be used when rendering the day
     *
     * This should be in the following JSON format with the year, month, day based on Date.getFullYear(), Date.getMonth(), and Date.getDate():
     * {year: {month: {day: {disabled: true|false, className: "additionalCSS", tooltip: 'Stuff to display'}}}
     * 
     * There also exists a special '*' character which represents ALL within that field [i.e. * within year, represents for ALL year].
     *
     * @expose
     * @instance
     * @memberof! oj.ojInputDate
     * @default <code class="prettyprint">null</code>
     * @example <code class="prettyprint">{2013: {11: {25: {disabled: true, className: 'holiday', tooltip: 'Stuff to display'}, 5: {disabled: true}}}}}</code>
     */
    dayMetaData : null, 

    /**
     * When the datepicker should be shown.
     *
     * @expose
     * @instance
     * @memberof! oj.ojInputDate
     * @type {string}
     * @ojvalue {string} "focus" when the element receives focus or when the trigger calendar image is clicked
     * @ojvalue {string} "image" when the trigger calendar image is clicked
     * @default <code class="prettyprint">"image"</code>
     */
    showOn : "image", 

    /**
     * Whether the month should be rendered as a dropdown instead of text.
     *
     * @expose
     * @instance
     * @memberof! oj.ojInputDate
     * @type {string}
     * @ojvalue {string} "select" As a dropdown.
     * @ojvalue {string} "none" As a text.
     * @default <code class="prettyprint">"select"</code>
     */
    changeMonth : "select", 

    /**
     * Whether the year should be rendered as a dropdown instead of text.
     *
     * @expose
     * @instance
     * @memberof! oj.ojInputDate
     * @type {string}
     * @ojvalue {string} "select" As a dropdown.
     * @ojvalue {string} "none" As a text.
     * @default <code class="prettyprint">"select"</code>
     */
    changeYear : "select", 

    /** @expose */
    yearRange : "c-10:c+10", // Range of years to display in drop-down,
    // either relative to today's year (-nn:+nn), relative to currently displayed year
    // (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)
    
    /**
     * Will dictate the behavior of days outside the current viewing month.
     *
     * @expose
     * @instance
     * @memberof! oj.ojInputDate
     * @type {string}
     * @ojvalue {string} "hidden" Days outside the current viewing month will be hidden
     * @ojvalue {string} "visible" Days outside the current viewing month will be visible
     * @ojvalue {string} "selectable" Days outside the current viewing month will be visible + selectable
     * @default <code class="prettyprint">"hidden"</code>
     */
    daysOutsideMonth : "hidden", 

    /**
     * Whether week of the year will be shown.
     *
     * @expose
     * @instance
     * @memberof! oj.ojInputDate
     * @type {string}
     * @ojvalue {string} "number" Will show the week of the year as a number
     * @ojvalue {string} "none" Nothing will be shown
     * @default <code class="prettyprint">none</code>
     */
    weekDisplay : "none", // "number" to show week of the year, "none" to not show it
    
    /** 
     * How to calculate the week of the year, takes a Date and returns the number of the week for it
     * 
     * @expose 
     */
    calculateWeek : iso8601Week,
    
    /**
     * The minimum selectable date. When set to null, there is no minimum.
     *
     * <ul>
     *  <li> type string - should be in a format conforming to the converter
     *  <li> type Date - JavaScript Date object
     *  <li> null - no limit
     * </ul>
     *
     * @expose
     * @instance
     * @memberof! oj.ojInputDate
     * @default <code class="prettyprint">null</code>
     */
    min : undefined, 

    /**
     * The maximum selectable date. When set to null, there is no maximum.
     *
     * <ul>
     *  <li> type string - should be in a format conforming to the converter
     *  <li> type Date - JavaScript Date object
     *  <li> null - no limit
     * </ul>
     *
     * @expose
     * @instance
     * @memberof! oj.ojInputDate
     * @default <code class="prettyprint">null</code>
     */
    max : undefined, 

    /**
     * The number of months to show at once.
     *
     * @expose
     * @instance
     * @memberof! oj.ojInputDate
     * @default <code class="prettyprint">1</code>
     */
    numberOfMonths : 1, 

    /**
     * The position in multipe months at which to show the current month (starting at 0)
     *
     * @expose
     * @instance
     * @memberof! oj.ojInputDate
     * @default <code class="prettyprint">0</code>
     */
    currentMonthPos : 0, 

    /**
     * How the prev + next will step back/forward the months
     *
     * <ul>
     *  <li> type number - Number of months to step back/forward
     *  <li> type string - Will use numberOfMonths as value
     * </ul>
     *
     * @expose
     * @instance
     * @memberof! oj.ojInputDate
     * @default <code class="prettyprint">"block"</code>
     */
    stepMonths : "block", 

    /**
     * Number of months to step back/forward for the (Alt + Page up) + (Alt + Page down) key strokes
     *
     * @expose
     * @instance
     * @memberof! oj.ojInputDate
     * @default <code class="prettyprint">12</code>
     */
    stepBigMonths : 12, 

    /**
     * Will dictate button pane behavior underneath the calendar.
     *
     * @expose
     * @instance
     * @memberof! oj.ojInputDate
     * @type {string}
     * @ojvalue {string} "none" Do not show anything
     * @ojvalue {string} "default" The button pane contains two buttons, a Today button that links to the current day, and a Done button that closes the datepicker.
     * @default <code class="prettyprint">"none"</code>
     */
    buttonPanel : "none", 

    /**
     * Default converter for ojInputDate
     *
     * If one wishes to provide a custom converter for the ojInputDate override the factory returned for
     * oj.Validation.converterFactory(oj.ConverterFactory.CONVERTER_TYPE_DATETIME)
     *
     * @expose
     * @instance
     * @memberof! oj.ojInputDate
     * @default <code class="prettyprint">oj.Validation.converterFactory(oj.ConverterFactory.CONVERTER_TYPE_DATETIME).createConverter()</code>
     */
    converter : oj.Validation.converterFactory(oj.ConverterFactory.CONVERTER_TYPE_DATETIME).createConverter(
    {
      "day" : "2-digit", "month" : "2-digit", "year" : "2-digit"
    })
  },
  
  /**
   * @ignore
   * @protected
   * @override
   */
  _RegisterTranslatedOptionGetters : function (getters)
  {
    this._super(getters);
    
    // Add custom getters for properties from the LocaleElements bundle
    getters["firstDayOfWeek"] = function()
      {
        return oj.LocaleData.getFirstDayOfWeek();
      };
    getters["dayWide"] = function()
      {
        return oj.LocaleData.getDayNames("wide");
      };
    getters["dayNarrow"] = function()
      {
        return oj.LocaleData.getDayNames("narrow");
      };
    getters["monthWide"] = function()
      {
        return oj.LocaleData.getMonthNames("wide");
      };
    getters["monthAbbreviated"] = function()
      {
        return oj.LocaleData.getMonthNames("abbreviated");
      };
  },
  
  /**
   * Overridden to set the default value for options.value when it's not set
   * 
   * @ignore
   * @protected
   * @override
   * @instance
   * @memberof! oj.ojInputDate
   */    
  _InitOptions : function ()
  {
    this._super();
    
    if (!this.options["value"]) 
    {
      // we are doing same as _GetElementValue. 
      this.options["value"] = "";
    }
    
    var minMax = ["min", "max"];
    
    for(var i=0, j=minMax.length; i < j; i++) 
    {
      
      if (this.options[minMax[i]] === undefined) 
      {
        //try to see if set to the input attribute
        var resolved = null,
            attrVal = this.element.attr(minMax[i]);
        
        if (attrVal)
        {
          
          try 
          {
            resolved = Date.parse(attrVal);
            if (!isNaN(resolved))
            {
              resolved = new Date(resolved);
            }
          }
          catch (e)
          {
          }
        }
        
        this.options[minMax[i]] = resolved;
      }
    }
    
  },
  
  /**
   * @ignore
   * @protected
   */
  _InitBase : function __InitBase() 
  {
    this._datepickerShowing = false;
    this._triggerNode = null;
    this._isInLineVal = null;
    this._ignoreShow = false; //only case is when of showOn of focus and one hides the element [need to avoid showing]
    this._maxRows = 4;

    this._currentDay = 0;
    this._drawMonth = this._currentMonth = 0;
    this._drawYear = this._currentYear = 0;
    
    this._inputKeyDownHandler = null;
    this._showDatePickerHandler = null;
    
    this._datePickerDefaultValidators = {};
    
    var nodeName = this.element[0].nodeName.toLowerCase();
    this._isInLineVal = (nodeName === "div" || nodeName === "span");
    
    $(document).on("mousedown", $.proxy(this._checkExternalClick, this));
    
    this._dpDiv = bindHover($("<div id='" + this._GetSubId(this._MAIN_DIV_ID) + "' role='region' aria-describedby='" + this._GetSubId(this._DATEPICKER_DESCRIPTION_ID) + "' class='oj-datepicker-content'></div>"));
    $("body").append(this._dpDiv);
    
    if(this._isInLine()) 
    {
      //if inline then there is not input element so reset _CLASS_NAMES
      this._CLASS_NAMES = "";
    }
    else
    {
      //append input container class to be applied to the root node as well, since not inline
      //[note the special case where input container class will NOT be on the widget node is when 
      //ojInputDateTime is of inline and ojTime places container around the input element]
      this._WIDGET_CLASS_NAMES += this._INPUT_CONTAINER_CLASS;
    }
  },
  
  /**
   * @protected
   * @override
   * @instance
   * @memberof! oj.ojInputDate
   */
  _ComponentCreate : function __ComponentCreate()
  {
    
    this._InitBase();
    
    var retVal = this._super();
    
    //Need to set the currentDay, currentMonth, currentYear to either the value or the default of today's Date
    this._setCurrentDate(this._getDate());
    
    if (this._isInLine())
    {
      this.element.append(this._dpDiv);
      this.element.addClass(this._INLINE_CLASS);
      this._datepickerShowing = true;
      
      this._SetValue(this._getDate(), null, 
      {
        validationMode : this._VALIDATION_MODE.VALIDATORS_ONLY
      });
  
      // Set display:block in place of inst._dpDiv.show() which won't work on disconnected elements
      // http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height
      this._dpDiv.css("display", "block");
    }
    else 
    {
      this._attachTrigger();
      this._inputKeyDownHandler = $.proxy(this._doInputKeyDown, this);
      this.element.on("keydown", this._inputKeyDownHandler);
    }
    
    return retVal;
  },
  
  _setOption : function __setOption(key, value)
  {
    
    var retVal = null, 
        dateTimeRangeOptions = {}, 
        dateRestrictionOptions = {};
    
    if (key === "value")
    {
      //When a null, undefined, or "" value is passed in set to Today's value if element does not have val 
      //[otherwise will be resetting due to how the framework works]
      if(!value && this.element.val())
      {
        var temp = this._getTodayDate();
        if(this.options['value']) 
        {
          this._copyTimeOver(this.options['value'], temp);
        }
        value = temp;
      }
      
      retVal = this._super(key, value);
      this._setCurrentDate(value);
      return retVal;
    }
    
    retVal = this._superApply(arguments);

    if (key === "disabled")
    {
      this._disableEnable(value);
    }
    else if (key === "max" || key === "min") 
    {
      //since validators are immutable, they will contain min + max as local values. B/c of this will need to recreate
      dateTimeRangeOptions = {'min': this.options['min'], 
          'max': this.options['max'],
          'converter': this._GetConverter()};

      this._datePickerDefaultValidators[oj.ValidatorFactory.VALIDATOR_TYPE_DATETIMERANGE] = 
        oj.Validation.validatorFactory(oj.ValidatorFactory.VALIDATOR_TYPE_DATETIMERANGE).createValidator(dateTimeRangeOptions);
      
      this._ResetAllValidators();
    }
    else if (key === "dayMetaData") 
    {
      //since validators are immutable, they will contain dayMetaData as local values. B/c of this will need to recreate
      dateRestrictionOptions = {'dayMetaData': this.options["dayMetaData"], 
          'converter': this._GetConverter()};

      this._datePickerDefaultValidators[oj.ValidatorFactory.VALIDATOR_TYPE_DATERESTRICTION] = 
        oj.Validation.validatorFactory(oj.ValidatorFactory.VALIDATOR_TYPE_DATERESTRICTION).createValidator(dateRestrictionOptions);
      
      this._ResetAllValidators();
    }
    
    return retVal;
  },
  
  /**
   * @ignore
   * @protected
   * @override
   */
  _destroy : function __destroy()
  {
    var retVal = this._super();
    
    if (this._inputKeyDownHandler)
    {
      this.element.off("keydown", this._inputKeyDownHandler);
    }
    if (this._showDatePickerHandler)
    {
      this.element.off("focus", this._showDatePickerHandler);
    }
    
    if (this._triggerNode)
    {
      this._triggerNode.remove();
    }
    
    this._dpDiv.remove();
    return retVal;
  },
  
  /**
   * This function will create the necessary calendar trigger container [i.e. image to launch the calendar] 
   * and perform any attachment to events
   * 
   * @private
   */
  _attachTrigger : function __attachTrigger()
  {
    var showOn = this.options["showOn"], 
        triggerContainer = $($("<span>").addClass(this._TRIGGER_CLASS));

    if (showOn === "focus")
    {
      // pop-up date picker when in the marked field
      this._showDatePickerHandler = $.proxy(this.show, this);
      this.element.on("focus", this._showDatePickerHandler);
    }

    // pop-up date picker when button clicked
    var triggerCalendar = $($("<span/>").addClass(this._TRIGGER_CALENDAR_CLASS + " oj-clickable-icon oj-component-icon"));
    triggerContainer.append(triggerCalendar);

    var self = this;
    triggerCalendar.on("click", function ()
    {
      if (self._datepickerShowing)
      {
        self.hide();
      }
      else 
      {
        self.show();
      }
      return false;
    }).on("mouseenter", function ()
    {
      $(this).addClass("oj-hover");
    }).on("mousedown", function ()
    {
      $(this).addClass("oj-active");
    }).on("mouseleave", function ()
    {
      $(this).removeClass("oj-hover oj-active");
    });
    
    this._triggerNode = triggerContainer;
    this.element.after(triggerContainer);
  },
  
  //This handler is for the case where an user keys down on the input text element
  _doInputKeyDown : function __doInputKeyDown(event)
  {
    var kc = $.ui.keyCode, 
        handled = false;

    if (this._datepickerShowing)
    {

      switch (event.keyCode)
      {
        case kc.TAB: ;
        case kc.ESCAPE:
          this.hide();
          break;
        case kc.UP: ;
        case kc.DOWN:
          this._dpDiv.find(".oj-datepicker-calendar").focus();
          handled = true;
          break;
      }

    }
    else 
    {

      switch (event.keyCode)
      {
        case kc.UP: ;
        case kc.DOWN:
          this.show();
          handled = true;
          break;
      }

    }

    if (handled || event.keyCode === kc.ENTER)
    {
      event.preventDefault();
      event.stopPropagation();
      return false;
    }
  },
  
  //This handler is when an user keys down with the calendar having focus
  _doKeyDown : function __doKeyDown(event)
  {
    var sel, handled = false, 
        kc = $.ui.keyCode, 
        isRTL = this._IsRTL();

    if (this._datepickerShowing)
    {
      switch (event.keyCode)
      {
        case 84: //t character
          if (event.altKey && event.ctrlKey) 
          {
            this._dpDiv.find(".oj-datepicker-current").focus();
          }
          break;
        case 68: //d character
          if (event.altKey && event.ctrlKey) 
          {
            this._dpDiv.find(".oj-datepicker-close").focus();
          }
          break;
        case kc.TAB:
          this.hide();
          // hide on tab out
          break;
        case kc.ENTER:
          sel = $("td." + this._DAYOVER_CLASS + ":not(." + this._CURRENT_CLASS + ")", this._dpDiv);
          if (sel[0])
          {
            this._selectDay(this._currentMonth, this._currentYear, sel[0]);
          }
          event.preventDefault();
          event.stopPropagation();
          return false;
        case kc.ESCAPE:
          this.hide();
          this.element.focus();
          handled = true;
          break;// hide on escape
        case kc.PAGE_UP:
          if(event.ctrlKey && event.altKey)
          {
            this._adjustDate(- this.options["stepBigMonths"], "M", true);
          }
          else if (event.altKey)
          {
            this._adjustDate( - 1, "Y", true);
          }
          else 
          {
            this._adjustDate(- this._getStepMonths(), "M", true);
          }
          handled = true;
          break;// previous month/year on page up/+ ctrl
        case kc.PAGE_DOWN:
          if(event.ctrlKey && event.altKey)
          {
            this._adjustDate(+ this.options["stepBigMonths"], "M", true);
          }
          else if (event.altKey)
          {
            this._adjustDate(1, "Y", true);
          }
          else 
          {
            this._adjustDate(+ this._getStepMonths(), "M", true);
          }
          handled = true;
          break;// next month/year on page down/+ ctrl
        case kc.END:
          this._currentDay = this._getDaysInMonth(this._currentYear, this._currentMonth);
          this._updateDatepicker(true);
          handled = true;
          break;
        case kc.HOME:
          this._currentDay = 1;
          this._updateDatepicker(true);
          handled = true;
          break;
        case kc.LEFT:
          this._adjustDate((isRTL ?  + 1 :  - 1), "D", true);
          // -1 day on ctrl or command +left
          if (event.originalEvent.altKey)
          {
            this._adjustDate((event.ctrlKey ?  - this.options["stepBigMonths"] :  - this._getStepMonths()), "M", true);
          }
          // next month/year on alt +left on Mac
          handled = true;
          break;
        case kc.UP:
          this._adjustDate( - 7, "D", true);
          handled = true;
          break;// -1 week on ctrl or command +up
        case kc.RIGHT:
          this._adjustDate((isRTL ?  - 1 :  + 1), "D", true);
          // +1 day on ctrl or command +right
          if (event.originalEvent.altKey)
          {
            this._adjustDate((event.ctrlKey ?  + this.options["stepBigMonths"] :  + this._getStepMonths()), "M", true);
          }
          // next month/year on alt +right
          handled = true;
          break;
        case kc.DOWN:
          this._adjustDate( + 7, "D", true);
          handled = true;
          break;// +1 week on ctrl or command +down
        default : ;
      }
    }
    else if (event.keyCode === kc.HOME && event.ctrlKey)
    {
      // display the date picker on ctrl+home
      this.show();
      handled = true;
    }

    if (handled)
    {
      event.preventDefault();
      event.stopPropagation();
    }

  },

  /**
   * Thie function will update the calendar display
   * 
   * @private
   * @param {boolean=} focusOnCalendar
   */
  _updateDatepicker : function __updateDatepicker(focusOnCalendar)
  {
    this._maxRows = 4;//Reset the max number of rows being displayed (see #7043)
    var generatedHtmlContent = this._generateHTML();
    this._dpDiv.empty().append(generatedHtmlContent.html);
    
    var buttons = $("button", this._dpDiv);
    
    if(buttons.length > 0) 
    {
      $.each($("button", this._dpDiv), function (index, ele)
      {
        $(ele).ojButton();
      });
    }
    
    this._attachHandlers();
    
    this._dpDiv.find("." + this._DAYOVER_CLASS + " a").mouseover();
    if (generatedHtmlContent.dayOverId)
    {
      this._dpDiv.find(".oj-datepicker-calendar").attr("aria-activedescendant", generatedHtmlContent.dayOverId);
    }

    var numMonths = this._getNumberOfMonths(), 
        cols = numMonths[1], 
        width = 17;

    this._dpDiv.removeClass("oj-datepicker-multi-2 oj-datepicker-multi-3 oj-datepicker-multi-4").width("");
    if (cols > 1)
    {
      this._dpDiv.addClass("oj-datepicker-multi-" + cols).css("width", (width * cols) + "em");
    }
    this._dpDiv[(numMonths[0] !== 1 || numMonths[1] !== 1 ? "add" : "remove") + "Class"]("oj-datepicker-multi");

    // #6694 - don't focus the input if it's already focused
    // this breaks the change event in IE
    if (this._datepickerShowing && this.element.is(":visible") && !this.element.is(":disabled"))
    {
      if (!focusOnCalendar && !this._isInLine())
      {
        if (this.element[0] !== document.activeElement)
        {
          this.element.focus();
        }
      }
      else 
      {
        var calendar = this._dpDiv.find(".oj-datepicker-calendar");
        if (calendar[0] !== document.activeElement)
        {
          calendar.focus();
        }
      }
    }
    
  },

  /**
   * Adjust one of the date sub-fields.
   * 
   * @private
   * @param {number} offset
   * @param {string} period
   * @param {boolean=} focusOnCalendar
   */
  _adjustDate : function __adjustDate(offset, period, focusOnCalendar)
  {
    if (this.options["disabled"])
    {
      return;
    }
    this._adjustInstDate(offset + (period === "M" ? this.options["currentMonthPos"] : 0), // undo positioning
    period);
    this._updateDatepicker(focusOnCalendar);
  },

  /**
   * Action for current link.
   * 
   * @private
   */
  _gotoToday : function __gotoToday()
  {
    var date = new Date();

    this._currentDay = date.getDate();
    this._drawMonth = this._currentMonth = date.getMonth();
    this._drawYear = this._currentYear = date.getFullYear();

    this._adjustDate();
  },

  /**
   * Action for selecting a new month/year.
   * 
   * @private
   * @param {Object} select
   * @param {string} period
   */
  _selectMonthYear : function __selectMonthYear(select, period)
  {
    var selected = parseInt(select.options[select.selectedIndex].value, 10);

    if (period === "M")
    {
      this._currentMonth = this._drawMonth = selected;
    }
    else 
    {
      this._currentYear = this._drawYear = selected;
    }
    
    //Take care of accessibility
    $("#" + this._GetSubId(this._CALENDAR_DESCRIPTION_ID)).html(this.options["monthWide"][this._drawMonth] + " " + yearDisplay.format(new Date(this._drawYear, this._drawMonth, 1)));

    this._adjustDate();
  },
  
  //Action for selecting a day.
  _selectDay : function __selectDay(month, year, td)
  {
    if ($(td).hasClass(this._UNSELECTABLE_CLASS) || this.options["disabled"])
    {
      return;
    }

    this._currentDay = $("a", td).html();
    this._currentMonth = month;
    this._currentYear = year;

    var value = this.options['value'];
    if (value)
    {
      var temp = new Date(this._currentYear, this._currentMonth, this._currentDay);
      
      this._copyTimeOver(value, temp);

      value = temp;
    }
    else 
    {
      value = new Date(this._currentYear, this._currentMonth, this._currentDay);
    }
    
    this._SetDisplayValue( this._GetConverter()["format"](value) );
    this._SetValue(value, null, 
    {
      validationMode : this._VALIDATION_MODE.VALIDATORS_ONLY
    });
    this.hide();
  },
  
  //A date may be specified as an exact value or a relative one.
  _determineDate : function __determineDate(date, defaultDate)
  {
    var self = this, offsetNumeric = function (offset)
    {
      var todayDate = self._getTodayDate();
      todayDate.setDate(todayDate.getDate() + offset);
      return todayDate;
    },
    newDate = (date == null || date === "" ? defaultDate : (typeof date === "number" ? (isNaN(date) ? defaultDate : offsetNumeric(date)) : new Date(date.getTime())));

    newDate = newDate || defaultDate;
    return newDate;
  },

  /**
   * Set the date(s) directly.
   * 
   * @private
   * @param {Object} date
   */
  _setCurrentDate : function __setCurrentDate(date)
  {
    var newDate = this._determineDate(date, this._getTodayDate());

    this._currentDay = newDate.getDate();
    this._drawMonth = this._currentMonth = newDate.getMonth();
    this._drawYear = this._currentYear = newDate.getFullYear();

    this._adjustInstDate();
  },

  /**
   * Retrieve the date(s) directly.
   * 
   * @private
   * @return {Object} startDate
   */
  _getCurrentDate : function __getCurrentDate()
  {
    var startDate = (!this._currentYear || (this.element.val() === "") ? null : new Date(this._currentYear, this._currentMonth, this._currentDay));
    return startDate;
  },
  
  _getStepMonths : function __getStepMonths()
  {
    var stepMonths = this.options["stepMonths"];
    return $.isNumeric(stepMonths) ? stepMonths : this.options["numberOfMonths"];
  },

  /**
   * Attach the onxxx handlers.  These are declared statically so 
   * they work with static code transformers like Caja.
   * 
   * @private
   */
  _attachHandlers : function __attachHandlers()
  {
    var stepMonths = this._getStepMonths(), self = this;
    this._dpDiv.find("[data-handler]").map(function ()
    {
      var handler = 
      {
        /** @expose */
        prev : function ()
        {
          self._adjustDate( - stepMonths, "M", true);
        },
        /** @expose */
        next : function ()
        {
          self._adjustDate( + stepMonths, "M", true);
        },
        /** @expose */
        hide : function (evt)
        {
          if((evt.type === "keyup" && evt.keyCode === 13) || evt.type === "click")
          {
            self.hide();
            evt.preventDefault();
            evt.stopPropagation();
          }
        },
        /** @expose */
        today : function (evt)
        {
          if((evt.type === "keyup" && evt.keyCode === 13) || evt.type === "click")
          {
            self._gotoToday();
            evt.preventDefault();
            evt.stopPropagation();
          }
        },
        /** @expose */
        selectDay : function ()
        {
          self._selectDay( + this.getAttribute("data-month"),  + this.getAttribute("data-year"), this);
          return false;
        },
        /** @expose */
        selectMonth : function ()
        {
          self._selectMonthYear(this, "M");
          return false;
        },
        /** @expose */
        selectYear : function ()
        {
          self._selectMonthYear(this, "Y");
          return false;
        },
        /** @expose */
        calendarKey : function (evt)
        {
          self._doKeyDown(evt);
        }
      };
      $(this).bind(this.getAttribute("data-event"), handler[this.getAttribute("data-handler")]);
    });
  },

  /**
   * Generate the HTML for the current state of the date picker.
   * 
   * @private
   */
  _generateHTML : function __generateHTML()
  {
    var maxDraw, prevText, prev, nextText, next, currentText, gotoDate, controls, 
        buttonPanel, weekDisplay, dayNames = this.options["dayWide"], dayNamesMin = this.options["dayNarrow"], 
        monthNames = this.options["monthWide"], monthNamesShort = this.options["monthAbbreviated"], 
        firstDay = this.options["firstDayOfWeek"], daysOutsideMonth, html, dow, row, group, col, selected, rowCellId, 
        dayOverClass, dayOverId = "", calender, thead, day, daysInMonth, leadDays, curRows, numRows, 
        printDate, dRow, tbody, daySettings, otherMonth, unselectable, tempDate = new Date(), 
        today = new Date(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate()), // clear time
        isRTL = this._IsRTL(), buttonPanelDisplay = this.options["buttonPanel"], numMonths = this._getNumberOfMonths(), 
        currentMonthPos = this.options["currentMonthPos"], dayMetaData = this.options["dayMetaData"], 
        currMetaData = null, isMultiMonth = (numMonths[0] !== 1 || numMonths[1] !== 1), minDate = this._getMinMaxDate("min"), 
        maxDate = this._getMinMaxDate("max"), drawMonth = this._drawMonth - currentMonthPos, drawYear = this._drawYear, 
        compareDate = new Date(this._currentYear, this._currentMonth, this._currentDay), valueDate = this._getDate(), 
        selectedDay = valueDate.getDate(), selectedMonth = valueDate.getMonth(), selectedYear = valueDate.getFullYear(), 
        wDisabled = this.options["disabled"], calculatedWeek, weekText = this.getTranslatedString("weekText");

    valueDate.setHours(0);
    valueDate.setMinutes(0);
    valueDate.setSeconds(0);
    valueDate.setMilliseconds(0);

    if (drawMonth < 0)
    {
      drawMonth += 12;
      drawYear--;
    }
    if (maxDate)
    {
      maxDraw = new Date(maxDate.getFullYear(), maxDate.getMonth() - (numMonths[0] * numMonths[1]) + 1, maxDate.getDate());
      maxDraw = (minDate && maxDraw < minDate ? minDate : maxDraw);
      while (new Date(drawYear, drawMonth, 1) > maxDraw)
      {
        drawMonth--;
        if (drawMonth < 0)
        {
          drawMonth = 11;
          drawYear--;
        }
      }
    }
    this._drawMonth = drawMonth;
    this._drawYear = drawYear;

    prevText = this.getTranslatedString("prevText");

    prev = (this._canAdjustMonth( - 1, drawYear, drawMonth) && !wDisabled ? "<a href='#' class='oj-datepicker-prev-icon oj-enabled oj-component-icon oj-clickable-icon' data-handler='prev' data-event='click'" + " title='" + prevText + "'></a>" : "<a class='oj-datepicker-prev-icon oj-disabled oj-component-icon oj-clickable-icon' title='" + prevText + "'></a>");

    nextText = this.getTranslatedString("nextText");

    next = (this._canAdjustMonth( + 1, drawYear, drawMonth) && !wDisabled ? "<a href='#' class='oj-datepicker-next-icon oj-enabled oj-component-icon oj-clickable-icon' data-handler='next' data-event='click'" + " title='" + nextText + "'></a>" : "<a class='oj-datepicker-next-icon oj-disabled oj-component-icon oj-clickable-icon' title='" + nextText + "'></a>");

    currentText = this.getTranslatedString("currentText");
    gotoDate = today;

    controls = (!this._isInLine() ? "<button type='button' class='oj-datepicker-close oj-enabled oj-priority-primary' data-handler='hide' data-event='click keyup'>" + this.getTranslatedString("closeText") + "</button>" : "");

    buttonPanel = (buttonPanelDisplay === "default") ? "<div class='oj-datepicker-buttonpane'>" + (isRTL ? controls : "") + (this._isInRange(gotoDate) ? "<button type='button' class='oj-datepicker-current oj-enabled oj-priority-secondary' data-handler='today' data-event='click keyup'" + ">" + currentText + "</button>" : "") + (isRTL ? "" : controls) + "</div>" : "";

    weekDisplay = this.options["weekDisplay"];

    daysOutsideMonth = this.options["daysOutsideMonth"];
    html = "";
    
    var monthControl = "all";
    for (row = 0;row < numMonths[0];row++)
    {
      group = "";
      this._maxRows = 4;
      for (col = 0;col < numMonths[1];col++)
      {
        monthControl = "all";
        calender = "";
        if (isMultiMonth)
        {
          calender += "<div class='oj-datepicker-group";
          if (numMonths[1] > 1)
          {
            switch (col)
            {
              case 0:
                calender += " oj-datepicker-group-first";
                monthControl = (isRTL ? "right" : "left");
                break;
              case numMonths[1] - 1:
                calender += " oj-datepicker-group-last";
                monthControl = (isRTL ? "left" : "right");
                break;
              default :
                calender += " oj-datepicker-group-middle";
                monthControl = "";
                break;
            }
          }
          calender += "'>";
        }
        calender += "<div class='oj-datepicker-header" + (wDisabled ? " oj-disabled " : " oj-enabled ") + "'>" + (/all|left/.test(monthControl) && row === 0 ? (isRTL ? next : prev) : "") + (/all|right/.test(monthControl) && row === 0 ? (isRTL ? prev : next) : "") + this._generateMonthYearHeader(drawMonth, drawYear, minDate, maxDate, row > 0 || col > 0, monthNames, monthNamesShort) + // draw month headers
"</div><table class='oj-datepicker-calendar" + (wDisabled ? " oj-disabled " : " oj-enabled ") + "' tabindex=-1 data-handler='calendarKey' data-event='keydown' aria-readonly='true' role='grid' " + "aria-labelledby='" + this._GetSubId(this._CALENDAR_DESCRIPTION_ID) + "'><thead role='presentation'>" + "<tr role='row'>";
        thead = (weekDisplay === "number" ? "<th class='oj-datepicker-week-col'>" + this.getTranslatedString("weekHeader") + "</th>" : "");
        for (dow = 0;dow < 7;dow++)
        {
          // days of the week
          day = (dow + parseInt(firstDay, 10)) % 7;
          thead += "<th role='columnheader' aria-label='" + dayNames[day] + "'" + ((dow + firstDay + 6) % 7 >= 5 ? " class='oj-datepicker-week-end'" : "") + ">" + "<span title='" + dayNames[day] + "'>" + dayNamesMin[day] + "</span></th>";
        }
        calender += thead + "</tr></thead><tbody role='presentation'>";
        daysInMonth = this._getDaysInMonth(drawYear, drawMonth);
        if (drawYear === selectedYear && drawMonth === selectedMonth)
        {
          selectedDay = Math.min(selectedDay, daysInMonth);
        }
        leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;
        curRows = Math.ceil((leadDays + daysInMonth) / 7);// calculate the number of rows to generate
        numRows = (isMultiMonth ? this._maxRows > curRows ? this._maxRows : curRows : curRows);//If multiple months, use the higher number of rows (see #7043)
        this._maxRows = numRows;
        printDate = new Date(drawYear, drawMonth, 1 - leadDays);
        for (dRow = 0;dRow < numRows;dRow++)
        {
          // create date picker rows
          calender += "<tr role='row'>";
          
          calculatedWeek = this.options["calculateWeek"](printDate);
          tbody = (weekDisplay === "none" ? "" : "<td class='oj-datepicker-week-col' role='rowheader' aria-label='" + weekText + " " + calculatedWeek + "'>" + calculatedWeek + "</td>");
          for (dow = 0;dow < 7;dow++)
          {
            // create date picker days
            otherMonth = (printDate.getMonth() !== drawMonth);
            selected = printDate.getTime() === valueDate.getTime();
            rowCellId = "oj-dp-" + dRow + "-" + dow;
            dayOverClass = (printDate.getTime() === compareDate.getTime() && drawMonth === this._currentMonth);
            if (dayOverClass)
            {
              dayOverId = rowCellId;
            }

            daySettings = [true, ""];
            var pYear = printDate.getFullYear(), pMonth = printDate.getMonth(), pDate = printDate.getDate(), getMetaData = function getMetaData(dayMetaData, position, params)
            {
              if (!dayMetaData || position === params.length)
              {
                return dayMetaData;
              }

              var nextPos = position + 1;
              return getMetaData(dayMetaData[params[position]], nextPos, params) || getMetaData(dayMetaData["*"], nextPos, params);
            };

            if (dayMetaData)
            {
              currMetaData = getMetaData(dayMetaData, 0, [pYear, pMonth+1, pDate]); //request to start from 1 rather than 0
              if (currMetaData)
              {
                //has content
                daySettings = [!currMetaData["disabled"], currMetaData["className"] || ""];
                if (currMetaData["tooltip"])
                {
                  daySettings.push(currMetaData["tooltip"]);
                }
              }
            }
            var selectedDate = printDate.getTime() === valueDate.getTime();

            unselectable = (otherMonth && daysOutsideMonth !== "selectable") || !daySettings[0] || (minDate && printDate < minDate) || (maxDate && printDate > maxDate);
            tbody += "<td role='gridcell' aria-disabled='" + !!unselectable + "' aria-selected='" + selected + "' id='" + rowCellId + "' " + "class='" + ((dow + firstDay + 6) % 7 >= 5 ? " oj-datepicker-week-end" : "") + // highlight weekends
(otherMonth ? " oj-datepicker-other-month" : "") + // highlight days from other months
(dayOverClass ? " " + this._DAYOVER_CLASS : "") + // highlight selected day
(unselectable || wDisabled ? " " + this._UNSELECTABLE_CLASS + " oj-disabled" : " oj-enabled") + // highlight unselectable days
(otherMonth && daysOutsideMonth === "hidden" ? "" : " " + daySettings[1] + // highlight custom dates
(selected ? " " + this._CURRENT_CLASS : "") + // highlight selected day
(printDate.getTime() === today.getTime() ? " oj-datepicker-today" : "")) + "'" + // highlight today (if different)
((!otherMonth || daysOutsideMonth !== "hidden") && daySettings[2] ? " title='" + daySettings[2].replace(/'/g, "&#39;") + "'" : "") + // cell title
(unselectable ? "" : " data-handler='selectDay' data-event='click' data-month='" + printDate.getMonth() + "' data-year='" + printDate.getFullYear() + "'") + ">" + // actions
(otherMonth && daysOutsideMonth === "hidden" ? "&#xa0;" : // display for other months
(unselectable || wDisabled ? "<span class='oj-disabled'>" + printDate.getDate() + "</span>" : "<a class='oj-enabled" + (selectedDate ? " oj-selected" : "") + // highlight selected day
(otherMonth ? " oj-priority-secondary" : "") + // distinguish dates from other months
"' " + (selectedDate || dayOverClass ? "" : "tabindex='-1' ") + " href='#'>" + printDate.getDate() + "</a>")) + "</td>";// display selectable date
            printDate.setDate(printDate.getDate() + 1);
          }
          calender += tbody + "</tr>";
        }
        drawMonth++;
        if (drawMonth > 11)
        {
          drawMonth = 0;
          drawYear++;
        }
        calender += "</tbody></table>" + (isMultiMonth ? "</div>" + ((numMonths[0] > 0 && col === numMonths[1] - 1) ? "<div class='oj-datepicker-row-break'></div>" : "") : "");
        group += calender;
      }
      html += group;
    }
    html += buttonPanel;
    return {html : html, dayOverId : dayOverId};
  },

  /**
   * Generate the month and year header.
   * 
   * @private
   */
  _generateMonthYearHeader : function __generateMonthYearHeader(drawMonth, drawYear, minDate, maxDate, secondary, monthNames, monthNamesShort)
  {

    var inMinYear, inMaxYear, month, years, thisYear, determineYear, year, endYear, 
        changeMonth = this.options["changeMonth"], changeYear = this.options["changeYear"], 
        positionOfMonthToYear = oj.LocaleData.isMonthPriorToYear() ? "before" : "after", 
        html = "<div class='oj-datepicker-title' role='header'>", monthHtml = "", 
        wDisabled = this.options["disabled"];

    // month selection
    if (secondary || changeMonth === "none")
    {
      monthHtml += "<span class='oj-datepicker-month'>" + monthNames[drawMonth] + "</span>";
    }
    else 
    {
      inMinYear = (minDate && minDate.getFullYear() === drawYear);
      inMaxYear = (maxDate && maxDate.getFullYear() === drawYear);
      monthHtml += "<select tabindex='-1' class='oj-datepicker-month " + (wDisabled ? "oj-disabled' disabled" : "oj-enabled'") + " data-handler='selectMonth' data-event='change' role='listbox'>";
      for (month = 0;month < 12;month++)
      {
        if ((!inMinYear || month >= minDate.getMonth()) && (!inMaxYear || month <= maxDate.getMonth()))
        {
          monthHtml += "<option role='option' value='" + month + "' aria-selected='" + (month === drawMonth ? "true' selected='selected'" : "false'") + ">" + monthNamesShort[month] + "</option>";
        }
      }
      monthHtml += "</select>";
    }

    if (positionOfMonthToYear === "before")
    {
      html += monthHtml + (secondary || !((changeMonth === "select") && (changeYear === "select")) ? "&#xa0;" : "");
    }

    // year selection
    if (!this.yearshtml)
    {
      this.yearshtml = "";
      if (secondary || changeYear === "none")
      {
        html += "<span class='oj-datepicker-year'>" + yearDisplay.format(new Date(drawYear, drawMonth, 1)) + "</span>";
      }
      else 
      {
        // determine range of years to display
        years = this.options["yearRange"].split(":");
        thisYear = new Date().getFullYear();
        determineYear = function (value)
        {
          var year = (value.match(/c[+\-].*/) ? drawYear + parseInt(value.substring(1), 10) : (value.match(/[+\-].*/) ? thisYear + parseInt(value, 10) : parseInt(value, 10)));
          return (isNaN(year) ? thisYear : year);
        };
        year = determineYear(years[0]);
        endYear = Math.max(year, determineYear(years[1] || ""));
        year = (minDate ? Math.max(year, minDate.getFullYear()) : year);
        endYear = (maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear);
        this.yearshtml += "<select tabindex='-1' class='oj-datepicker-year " + (wDisabled ? "oj-disabled' disabled" : "oj-enabled'") + " data-handler='selectYear' data-event='change' role='listbox'>";
        for (;year <= endYear;year++)
        {
          this.yearshtml += "<option role='option' value='" + year + "' aria-selected='" + (year === drawYear ? "true' selected='selected'" : "false'") + ">" + yearDisplay.format(new Date(year, drawMonth, 1)) + "</option>";
        }
        this.yearshtml += "</select>";

        html += this.yearshtml;
        this.yearshtml = null;
      }
    }

    if (positionOfMonthToYear === "after")
    {
      html += (secondary || !((changeMonth === "select") && (changeYear === "select")) ? "&#xa0;" : "") + monthHtml;
    }
    html += "<span class='oj-helper-hidden-accessible' id='" + this._GetSubId(this._CALENDAR_DESCRIPTION_ID) + "'>" + monthNames[drawMonth] + " " + yearDisplay.format(new Date(drawYear, drawMonth, 1)) + "</span>";
    html += "<span class='oj-helper-hidden-accessible' id='" + this._GetSubId(this._DATEPICKER_DESCRIPTION_ID) + "'>" + this.getTranslatedString("datePicker") + "</span>";
    html += "</div>";// Close datepicker_header
    return html;
  },

  /**
   * Adjust one of the date sub-fields.
   * 
   * @private
   */
  _adjustInstDate : function __adjustInstDate(offset, period)
  {
    var year = this._drawYear + (period === "Y" ? offset : 0), 
        month = this._drawMonth + (period === "M" ? offset : 0), 
        day = Math.min(this._currentDay, this._getDaysInMonth(year, month)) + (period === "D" ? offset : 0), 
        date = new Date(year, month, day);

    this._currentDay = date.getDate();
    this._drawMonth = this._currentMonth = date.getMonth();
    this._drawYear = this._currentYear = date.getFullYear();
  },

  /**
   * Determine the number of months to show.
   * 
   * @private
   */
  _getNumberOfMonths : function __getNumberOfMonths()
  {
    var numMonths = this.options["numberOfMonths"];
    numMonths = typeof numMonths === "string" ? parseInt(numMonths, 10) : numMonths;
    return (numMonths == null ? [1, 1] : (typeof numMonths === "number" ? [1, numMonths] : numMonths));
  },

  /**
   * Determine the current maximum date - ensure no time components are set.
   * 
   * @private
   */
  _getMinMaxDate : function __getMinMaxDate(minMax)
  {
    return this._determineDate(this.options[minMax], null);
  },

  /**
   * Find the number of days in a given month.
   * 
   * @private
   */
  _getDaysInMonth : function __getDaysInMonth(year, month)
  {
    return 32 - new Date(year, month, 32).getDate();
  },

  /**
   * Find the day of the week of the first of a month.
   * 
   * @private
   */
  _getFirstDayOfMonth : function __getFirstDayOfMonth(year, month)
  {
    return new Date(year, month, 1).getDay();
  },

  /**
   * Determines if we should allow a "next/prev" month display change.
   * 
   * @private
   */
  _canAdjustMonth : function __canAdjustMonth(offset, curYear, curMonth)
  {
    var numMonths = this._getNumberOfMonths(), date = new Date(curYear, curMonth + (offset < 0 ? offset : numMonths[0] * numMonths[1]), 1);

    if (offset < 0)
    {
      date.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()));
    }
    return this._isInRange(date);
  },

  /**
   * Is the given date in the accepted range? 
   * 
   * @private
   */
  _isInRange : function __isInRange(date)
  {
    var yearSplit, currentYear, minDate = this._getMinMaxDate("min"), maxDate = this._getMinMaxDate("max"), minYear = null, maxYear = null, years = this.options["yearRange"];
    if (years)
    {
      yearSplit = years.split(":");
      currentYear = new Date().getFullYear();
      minYear = parseInt(yearSplit[0], 10);
      maxYear = parseInt(yearSplit[1], 10);
      if (yearSplit[0].match(/[+\-].*/))
      {
        minYear += currentYear;
      }
      if (yearSplit[1].match(/[+\-].*/))
      {
        maxYear += currentYear;
      }
    }

    return ((!minDate || date.getTime() >= minDate.getTime()) && (!maxDate || date.getTime() <= maxDate.getTime()) && (!minYear || date.getFullYear() >= minYear) && (!maxYear || date.getFullYear() <= maxYear));
  },

  /* Retrieve the size of left and top borders for an element.
   * @param  elem  (jQuery object) the element of interest
   * @return  (number[2]) the left and top borders
   */
  _getBorders : function __getBorders(elem)
  {
    var convert = function (value)
    {
      return {thin : 1, medium : 2, thick : 3}[value] || value;
    };
    return [parseFloat(convert(elem.css("border-left-width"))), parseFloat(convert(elem.css("border-top-width")))];
  },
  
  /**
   * This function is to hide the datepicker if the user clicks anywhere outside the datepicker 
   * 
   * @private
   * @param {Event} event
   */
  _checkExternalClick : function __checkExternalClick(event)
  {

    var $target = $(event.target);

    if ((($target[0] !== this._dpDiv[0] && $target.parents("#" + this._GetSubId(this._MAIN_DIV_ID)).length === 0 
        && !$target.closest("." + this._TRIGGER_CLASS).length 
        && this._datepickerShowing)))
    {
      this.hide();
    }
  },

  /**
   * To disable or enable the widget
   * 
   * @private
   * @instance
   */
  _disableEnable : function __disableEnable(val)
  {
    if (!this._isInLine() && this._triggerNode)
    {
      var filteredChildren = this._triggerNode.children().filter("span");

      if (val)
      {
        filteredChildren.addClass("oj-disabled").removeClass("oj-enabled");
      }
      else 
      {
        filteredChildren.removeClass("oj-disabled").addClass("oj-enabled");
      }
    }
    
    if(this._datepickerShowing) 
    {
      this._updateDatepicker();
    }
  },
  
  /**
   * Invoke super only if it is not inline
   * 
   * @ignore
   * @protected
   * @override
   * @instance
   * @memberof! oj.ojInputDate
   */
  _AppendInputHelper : function __AppendInputHelper()
  {
    if (!this._isInLine())
    {
      this._superApply(arguments);
    }
  },
  
  /**
   * This handler will set the value from the input text element. 
   * 
   * @ignore
   * @protected
   * @override
   * @param {Event} event
   * @instance
   * @memberof! oj.ojInputDate
   */
  _onBlurHandler : function __onBlurHandler(event)
  {
    if(this._isInLine()) 
    {
      return;
    }
    
    this._superApply(arguments);
    
    if (this._datepickerShowing)
    {
      this._dpDiv.find(".oj-datepicker-calendar").focus();
    }
  },

  /**
   * Updates the datepicker if it's showing in addition to delegating to super.
   * 
   * @ignore
   * @protected
   * @override
   * @instance
   * @memberof! oj.ojInputDate
   */
  _SetDisplayValue : function __setDisplayValue(displayValue)
  {
    this._superApply(arguments);

    if (this._datepickerShowing)
    {
      this._updateDatepicker();
    }

  },

  /**
   * @ignore
   * @protected
   * @override
   * @instance
   * @memberof! oj.ojInputDate
   */
  _SetValue : function (newValue, event, options)
  {
    var valid = this._superApply(arguments);

    if (valid)
    {
      this._setCurrentDate(this._getDate());
    }

    return valid;
  },

  /**
   * @ignore
   * @protected
   * @override
   * @instance
   * @memberof! oj.ojInputDate
   */
  _GetElementValue : function ()
  {
    return this.options['value'] || "";
  },
  
  /**
   * @protected
   * @override
   * @return {string}
   */
  _GetDefaultStyleClass : function ()
  {
    return "oj-inputdate";
  },
  
  /**
   * Sets up the default dateTimeRange and dateRestriction validators.
   * 
   * @ignore
   * @protected
   * @override
   * @instance
   * @memberof! oj.ojInputDate
   */
  _GetDefaultValidators : function ()
  {
    var ret = this._superApply(arguments),
        minDate = this._getMinMaxDate("min"),
        maxDate = this._getMinMaxDate("max"),
        dateTimeRangeOptions = {}, dateRestrictionOptions = {};
    
    if(minDate != null || maxDate != null) 
    {
      //need to alter how the default validators work as validators are now immutable
      dateTimeRangeOptions = {'min': this.options['min'], 
                          'max': this.options['max'],
                          'converter': this._GetConverter()};
      this._datePickerDefaultValidators[oj.ValidatorFactory.VALIDATOR_TYPE_DATETIMERANGE] = 
              oj.Validation.validatorFactory(oj.ValidatorFactory.VALIDATOR_TYPE_DATETIMERANGE).createValidator(dateTimeRangeOptions);
    }
    
    if(this.options["dayMetaData"] != null) 
    {
      dateRestrictionOptions = {'dayMetaData': this.options["dayMetaData"], 
                                'converter': this._GetConverter()};
      this._datePickerDefaultValidators[oj.ValidatorFactory.VALIDATOR_TYPE_DATERESTRICTION] = 
            oj.Validation.validatorFactory(oj.ValidatorFactory.VALIDATOR_TYPE_DATERESTRICTION).createValidator(dateRestrictionOptions);
    }
    
    return $.extend(this._datePickerDefaultValidators, ret);
  },
  
  /**
   * Copies the time portion over from one date to an another
   * 
   * @private
   */
  _copyTimeOver : function __copyTimeOver(from, to)
  {
    to.setHours(from.getHours());
    to.setMinutes(from.getMinutes());
    to.setSeconds(from.getSeconds());
    to.setMilliseconds(from.getMilliseconds());
  },
  
  /**
   * Gets today's date w/o time
   * 
   * @private
   * @return {Object} date
   */
  _getTodayDate : function __getTodayDate()
  {
    var date = new Date();
    date.setHours(0);
    date.setMinutes(0);
    date.setSeconds(0);
    date.setMilliseconds(0);
    return date;
  },

  /**
   * Retrieve the default date shown on opening.
   * 
   * @private
   */
  _getDate : function __getDate()
  {
    return this._determineDate(this.options['value'], this._getTodayDate());
  },

  /**
   * Whether the widget is inline or not
   * 
   * @private
   */
  _isInLine : function __isInLine()
  {
    return this._isInLineVal;
  },
  
  /**
   * Return the subcomponent node represented by the documented locator attribute values.
   * 
   * <table class="props">
   *   <thead>
   *     <tr>
   *       <th>Locator</th>
   *       <th>Description</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td>oj-datepicker-content</td>
   *       <td>Datepicker content div container</td>
   *     </tr>
   *     <tr>
   *       <td>oj-inputdatetime-calendar-icon</td>
   *       <td>Calendar icon that triggers the Datepicker content display</td>
   *     </tr>
   *     <tr>
   *       <td>oj-datepicker-prev-icon</td>
   *       <td>Previous month icon</td>
   *     </tr>
   *     <tr>
   *       <td>oj-datepicker-next-icon</td>
   *       <td>Next month icon</td>
   *     </tr>
   *     <tr>
   *       <td>oj-datepicker-month</td>
   *       <td>Month span or select element</td>
   *     </tr>
   *     <tr>
   *       <td>oj-datepicker-year</td>
   *       <td>Year span or select element</td>
   *     </tr>
   *     <tr>
   *       <td>oj-datepicker-current</td>
   *       <td>Current/Today button for button bar</td>
   *     </tr>
   *     <tr>
   *       <td>oj-datepicker-close</td>
   *       <td>Done/Close button for button bar</td>
   *     </tr>
   * </tbody></table>
   * 
   * @expose
   * @override
   * @memberof! oj.ojInputDate
   * @instance
   * @param {Object} locator An Object containing at minimum a subId property whose value is a string, documented by the component, that allows the component to 
   *                        look up the subcomponent associated with that string.  It contains:<p>
   *                        component: optional - in the future there may be more than one component contained within a page element<p>
   *                        subId: the string, documented by the component, that the component expects in getNodeBySubId to locate a particular subcomponent
   * @returns {Object|null} the subcomponent located by the subId string passed in locator, if found.<p>
   */
  getNodeBySubId: function(locator)
  {
    
    var ret = this._superApply(arguments);
    if(ret) 
    {
      return ret;
    }
    
    var subId = locator['subId'],
        dpDiv = this._dpDiv;
    
    if(subId) 
    {
      switch(subId) 
      {
      case "oj-datepicker-content": return dpDiv;
      case "oj-inputdatetime-calendar-icon": return $(".oj-inputdatetime-calendar-icon", this._triggerNode);
      case "oj-datepicker-prev-icon": return $(".oj-datepicker-prev-icon", dpDiv);
      case "oj-datepicker-next-icon": return $(".oj-datepicker-next-icon", dpDiv);
      case "oj-datepicker-month": return $(".oj-datepicker-month", dpDiv);
      case "oj-datepicker-year": return $(".oj-datepicker-year", dpDiv);
      case "oj-datepicker-current": return $(".oj-datepicker-current", dpDiv);
      case "oj-datepicker-close": return $(".oj-datepicker-close", dpDiv);
      }
    }
    
    return null;
  },
  
  /** 
   * Hides the datepicker
   * 
   * @expose 
   * @memberof! oj.ojInputDate
   * @instance
   */
  hide : function __hide()
  {

    if (this._datepickerShowing && !this._isInLine())
    {
      this._dpDiv.hide();
      this._datepickerShowing = false;
      
      if(this.options["showOn"] === "focus") 
      {
        this._ignoreShow = true;
      }
      this.element.focus();
    }

    return this;
  },
  
  /** 
   * Redraws the calendar 
   * 
   * @expose
   * @memberof! oj.ojInputDate
   * @instance
   */
  refresh : function __refresh()
  {
    this._superApply(arguments);
    this._updateDatepicker();
    return this;
  },

  /**
   * Shows the datepicker
   * 
   * @expose
   * @memberof! oj.ojInputDate
   * @instance
   */
  show : function __show()
  {
    if (this._datepickerShowing || this.options["disabled"])
    {
      return;
    }
    
    if (this._ignoreShow) 
    {
      //set within hide or elsewhere and focus is placed back on this.element
      this._ignoreShow = false;
      return;
    }

    var rtl = this._IsRTL();

    //to avoid flashes on Firefox
    this._dpDiv.empty();
    this._updateDatepicker();

    this._dpDiv.css(
    {
      top : "", left : "", position : "absolute"
    });

    this._dpDiv["position"](
    {
      my : rtl ? "right top" : "left top", at : rtl ? "right bottom" : "left bottom", of : this.element, collision : "fit"
    });

    this._datepickerShowing = true;
    this._dpDiv.show();
    this._dpDiv.find(".oj-datepicker-calendar").focus();

    return this;
  },
  
  /** 
   * Returns the calendar display node
   * 
   * @expose 
   * @memberof! oj.ojInputDate
   * @instance
   */
  calendarDisplay : function __calendarDisplay()
  {
    return this._dpDiv;
  }
  
});
/*!
 * JET Input Time @VERSION
 * http://jqueryui.com
 *
 * Copyright 2013 jQuery Foundertion and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * Depends:
 *  jquery.ui.widget.js
 */
/**
 * @class
 * @name oj.ojInputTime
 * @augments oj.inputBase
 * 
 * @classdesc
 * <h3 id="inputTimeOverview-section">
 *   JET ojInputTime Component
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#inputTimeOverview-section"></a>
 * </h3>
 * 
 * <p>Description: ojInputTime provides a simple time selection drop down.
 * 
 * <h3 id="pseudos-section">
 *   Pseudo-selectors
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#pseudos-section"></a>
 * </h3>
 * 
 * <pre class="prettyprint">
 * <code>$( ":oj-inputTime" )            // selects all JET input on the page
 * </code>
 * </pre>
 * 
 * <h3 id="binding-section">
 *   Declarative Binding
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#binding-section"></a>
 * </h3>
 * 
 * <pre class="prettyprint">
 * <code>
 *    &lt;input id="timeId" data-bind="ojComponent: {component: 'ojInputTime'}" /&gt;
 * </code>
 * </pre>
 * 
 * @desc Creates or re-initializes a JET ojInputTime
 * 
 * @param {Object=} options a map of option-value pairs to set on the component
 * 
 * @example <caption>Initialize the input element with no options specified:</caption>
 * $( ".selector" ).ojInputTime();
 * 
 * * @example <caption>Initialize the input element with some options:</caption>
 * $( ".selector" ).ojInputTime( { "disabled": true } );
 * 
 * @example <caption>Initialize the input element via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;input id="timeId" data-bind="ojComponent: {component: 'ojInputTime'}" /&gt;
 */
oj.__registerWidget("oj.ojInputTime", $['oj']['inputBase'], 
{
  version : "1.0.0", 
  widgetEventPrefix : "oj", 
  
  //-------------------------------------From base---------------------------------------------------//
  _CLASS_NAMES : "oj-inputdatetime-input",
  _WIDGET_CLASS_NAMES : "oj-inputdatetime-time-only oj-component oj-inputdatetime oj-inputdatetime-input-container",
  _INPUT_HELPER_KEY: "inputHelp",
  _ATTR_CHECK : [{"attr": "type", "setMandatory": "text"}],
  //-------------------------------------End from base-----------------------------------------------//
  
  _TIME_PICKER_ID : "ojInputTime", 
  _TRIGGER_CLASS : "oj-inputdatetime-input-trigger",
  _TRIGGER_TIME_CLASS : "oj-inputdatetime-time-icon",
  
  options : 
  {
    /**
     * Default converter for ojInputTime
     *
     * If one wishes to provide a custom converter for the ojInputTime override the factory returned for
     * oj.Validation.converterFactory(oj.ConverterFactory.CONVERTER_TYPE_DATETIME)
     *
     * @expose
     * @memberof! oj.ojInputTime
     * @instance
     * @default <code class="prettyprint">oj.Validation.converterFactory(oj.ConverterFactory.CONVERTER_TYPE_DATETIME).createConverter({"hour": "2-digit", "hour12": true, "minute": "2-digit"})</code>
     */
    converter : oj.Validation.converterFactory(oj.ConverterFactory.CONVERTER_TYPE_DATETIME).createConverter(
    {
      "hour" : "2-digit", "hour12" : true, "minute" : "2-digit"
    }), 

    /**
     * Time increment to be used for ojInputTime, the format is Thh:mm:ss:SS
     *
     * @expose
     * @memberof! oj.ojInputTime
     * @instance
     * @default <code class="prettyprint">"T00:30:00:00"</code>
     */
    timeIncrement : "T00:30:00:00", 
    
    /**
     * JSON data passed when the widget is of ojInputDateTime
     * 
     * {
     *  widget : dateTimePickerInstance, 
     *  converter: parsedTimePickerConverter, 
     *  inline: true|false
     * }
     * 
     * @expose
     * @memberof! oj.ojInputTime
     * @instance
     * @private
     */
    datePicker : null
  },
  
  /**
   * Overridden to set the default value for options.value when it's not set
   * 
   * @ignore
   * @protected
   * @override
   * @memberof! oj.ojInputTime
   * @instance
   */    
  _InitOptions : function ()
  {
    this._super();
    if (!this.options["value"]) 
    {
      // we are doing same as _GetElementValue. 
      this.options["value"] = "";
    }
  },
  
  /**
   * @ignore
   */
  _InitBase : function __InitBase() 
  {
    
    this._timeConverter = null; //set when is of datetimepicker
    this._timepickerShowing = false;
    
    this._datePicker = this.options["datePicker"];
    
    this._timePickerDisplay = $("<div id='" + this._GetSubId(this._TIME_PICKER_ID) + "' class='oj-listbox-drop oj-listbox-display-none'></div>");
    $("body").append(this._timePickerDisplay);
    
    $(document).on("mousedown", $.proxy(this._checkExternalClick, this));
  },
  
  /**
   * @protected
   * @override
   * @instance
   * @memberof! oj.ojInputTime
   */
  _ComponentCreate : function __ComponentCreate()
  {
    this._InitBase();
    
    var ret = this._superApply(arguments);
    
    if (this._isContainedInDateTimePicker() && !this._isDatePickerInline())
    {
      //set to nothing since then of not inline and don't want to place two component classes to 
      //the same input element
      this._CLASS_NAMES = "";
    }
    
    this._attachTrigger();
    
    //only time to have ojInputTime handle the display of timepicker by keyDown is when datePicker reference is null or 
    //when it is not null and is inline
    if (this._isIndependentInput())
    {
      this._inputKeyDownHandler = $.proxy(this._doInputKeyDown, this);
      this.element.on("keydown", this._inputKeyDownHandler);
    }
    
    return ret;
  },
  
  /**
   * @ignore
   * @protected
   * @override
   */
  _setOption : function __setOption(key, value)
  {
    var retVal = null;
    
    if (key === "value")
    {
      //When a null, undefined, or "" value is passed in set to Today's value unless input element has value
      if(!value && this.element.val())
      {
        value = new Date();
      }
      
      retVal = this._super(key, value);
      return retVal;
    }
    
    retVal = this._superApply(arguments);

    if(key === "disabled") 
    {
      var filteredChildren = this._triggerNode.children().filter("span");

      if (value)
      {
        filteredChildren.addClass("oj-disabled").removeClass("oj-enabled");
      }
      else 
      {
        filteredChildren.removeClass("oj-disabled").addClass("oj-enabled");
      }
    }
    else if(key === "timeIncrement") 
    {
      //changing back to original code of invoking _generateTime per discussion
      this._generateTime();
    }
 
    return retVal;
  },
  
  /**
   * @ignore
   * @protected
   * @override
   */
  _destroy : function __destroy()
  {
    var retVal = this._super();
    
    if (this._triggerNode)
    {
      this._triggerNode.remove();
    }

    if (this._inputKeyDownHandler)
    {
      this.element.off("keydown", this._inputKeyDownHandler);
    }
    
    this._timePickerDisplay.remove();
    
    return retVal;
  },
  
  /**
   * Invoke super only if it is standlone or if it is part of ojInputDateTime and ojInputDateTime is inline
   * 
   * @ignore
   * @protected
   * @override
   */
  _AppendInputHelper : function __AppendInputHelper()
  {
    if (this._isIndependentInput())
    {
      this._superApply(arguments);
    }
  },
  
  /**
   * Handle it only when is standlone or is inline.
   * 
   * @ignore
   * @protected
   * @override
   * @param {Event} event
   */
  _onBlurHandler : function __onBlurHandler(event) 
  {
    if(this._isIndependentInput()) 
    {

      this._superApply(arguments);
      
      if (this._timepickerShowing)
      {
        $("ul", this._timePickerDisplay).focus();
      }

    }
  },
  
  /**
   * This function will create the necessary time trigger container [i.e. image to launch the time drop down] 
   * and perform any attachment to events
   * 
   * @private
   */
  _attachTrigger : function __attachTrigger()
  {

    //only time to create one's own span element is when datePicker reference is null or when it is not null and is inline
    var createNewSpan = this._isIndependentInput(), 
        triggerContainer = createNewSpan ? $($("<span>").addClass(this._TRIGGER_CLASS)) : $("+ span", this.element),
        triggerTime = $($("<span/>").addClass(this._TRIGGER_TIME_CLASS + " oj-clickable-icon oj-component-icon"));

    triggerContainer.append(triggerTime);
    
    var self = this;
    triggerTime.on("click", function ()
    {
      if (self._timepickerShowing)
      {
        self.hide();
        return;
      }

      self.show();
    }).on("mouseenter", function() 
    {
      $(this).addClass("oj-hover");
    }).on("mousedown", function() 
    {
      $(this).addClass("oj-active");
    }).on("mouseleave", function() 
    {
      $(this).removeClass("oj-hover oj-active");
    });
    
    this._triggerNode = triggerContainer;
    if (createNewSpan)
    {
      this.element.after(triggerContainer);
    }
  },
  
  //This handler is for the case where an user keys down on the input text element
  _doInputKeyDown : function __doInputKeyDown(event)
  {
    var kc = $.ui.keyCode, 
        handled = false;

    if (this._timepickerShowing)
    {
      switch (event.keyCode)
      {
        case kc.TAB: ;
          this.hide();
          break;
        case kc.ESCAPE:
          this.hide();
          handled = true;
          break;
        case kc.UP: ;
        case kc.DOWN:
          $("ul", this._timePickerDisplay).focus();
          handled = true;
          break;
      }
    }
    else 
    {
      switch (event.keyCode)
      {
        case kc.UP: ;
        case kc.DOWN:
          this.show();
          handled = true;
          break;
      }
    }

    if (handled || event.keyCode === kc.ENTER)
    {
      event.preventDefault();
      event.stopPropagation();
      return false;
    }

  },
  
  /**
   * This function will generate the time drop down 
   * 
   * @private
   */
  _generateTime : function __generateTime()
  {

    var processDate = this._getStubDate(), 
        timeNode = $("<ul class='oj-listbox-results' tabindex='-1' role='listbox'></ul>"), 
        selectedDateFormat = this._getFormattedValue(), source = [], i, j;

    processDate.setHours(0);
    processDate.setMinutes(0);
    processDate.setSeconds(0);
    processDate.setMilliseconds(0);

    source = this._getTimeSource(processDate);
    selectedDateFormat = selectedDateFormat || source[0].value; //either choose the selected date or if it doesn't exist the first value

    this._timePickerDisplay.empty();

    for (i = 0, j = source.length;i < j;i++)
    {
      var value = source[i].value,
          liNode = $("<li class='oj-listbox-result' role='presentation'>"),
          node = $("<div class='oj-listbox-result-label' data-value='" + value + "' role='option' id='" + 
                    this["uuid"] + "_sel" + i + "'>" + source[i].label + "</li>");

      if (selectedDateFormat === value)
      {
        node.attr("aria-selected", "true");
        liNode.addClass("oj-listbox-highlighted"); //TODO When combo box changes it's CSS to Jet specific [i.e. oj-selected or something else] make the same change
      }
      
      liNode.append(node);
      timeNode.append(liNode);
    }

    this._timePickerDisplay.append(timeNode);

    var self = this;
    timeNode.on("click", function (event)
    {
      self.hide();
      self._processTimeSelection(event);
    }).on("keydown", function (event)
    {
      self._timeNodeKeyDown(event);
    });

  },
  
  /**
   * This function will return an array of JSON objects of label + value for the 
   * time drop down
   * 
   * @private
   * @param {Object} date to get timeSource of
   * @return {Array} source
   */
  _getTimeSource : function __getTimeSource(date)
  {
    var source = [], 
        converter = this._getTimeConverter();

    if (date)
    {
      var timeIncrement = this.options["timeIncrement"];
      
      var splitted = timeIncrement.split(":");

      if (splitted.length === 4)
      {
        var increments = this._getTimeIncrement(timeIncrement);

        if (increments)
        {
          var processDate = new Date(date), formatted = "";

          //continue until day differs
          do 
          {
            formatted = converter.format(processDate);
            source.push(
            {
              label : formatted, value : formatted
            });
            processDate.setHours(processDate.getHours() + increments.hourIncr);
            processDate.setMinutes(processDate.getMinutes() + increments.minuteIncr);
            processDate.setSeconds(processDate.getSeconds() + increments.secondIncr);
            processDate.setMilliseconds(processDate.getMilliseconds() + increments.millisecondIncr);
          }
          while (processDate.getDate() === date.getDate());
        }
      }
      else 
      {
        throw new Error("timeIncrement value should be in the format of Thh:mm:ss:SS");
      }
      
    }

    return source;
  },
  
  /**
   * This function will return a JSON object of the increment parsed into 
   * {hourIncr: val, minuteIncr: val, secondIncr: val, millisecondIncr: val }
   * 
   * @private
   * @param {string} timeIncrement
   * @return {Object} increments
   */
  _getTimeIncrement : function __getTimeIncrement(timeIncrement)
  {

    var increments = null, splitted = timeIncrement.split(":");

    if (splitted.length === 4)
    {
      increments = 
      {
        hourIncr : parseInt(splitted[0].substring(1), 10), 
        minuteIncr : parseInt(splitted[1], 10), 
        secondIncr : parseInt(splitted[2], 10), 
        millisecondIncr : parseInt(splitted[3], 10)
      };
    }

    return increments;
  },
  
  //This handler is when an user keys down with the drop down has focus
  _timeNodeKeyDown : function __timeNodeKeyDown(event)
  {

    if (this._timepickerShowing)
    {

      var kc = $.ui.keyCode, 
          handled = false;

      switch (event.keyCode)
      {
        case kc.TAB: ;
          this.hide();
          break;
        case kc.ESCAPE:
          this.hide();
          this.element.focus();
          handled = true;
          break;
        case kc.UP:
          this._processNextPrevSibling(event, "prev");
          handled = true;
          break;
        case kc.DOWN:
          this._processNextPrevSibling(event, "next");
          handled = true;
          break;
        case kc.ENTER:
          this._processTimeSelection(event);
          handled = true;
          break;
      }

      if (handled)
      {
        event.preventDefault();
        event.stopPropagation();
        return false;
      }
    }
  },
  
  /**
   * This function will set the oj-listbox-highlighted to the next or previous sibling due to key down or key up stroke
   * 
   * @private
   * @param {Event} event
   * @param {string} prevOrNext
   */
  _processNextPrevSibling : function __processNextPrevSibling(event, prevOrNext)
  {
    var prevActive = $(".oj-listbox-highlighted", this._timePickerDisplay),
        ulElement = $("ul", this._timePickerDisplay);
    
    if (prevActive.length === 1)
    {
      var node = $(prevActive)[prevOrNext]();
      if (node.length === 1)
      {
        prevActive.removeClass("oj-listbox-highlighted");
        node.addClass("oj-listbox-highlighted");
        ulElement.attr("aria-activedescendant", node.children()[0].id);
        this._checkScrollTop(node);
      }
    }
  },
  
  /**
   * This handler is when an user selects a time entry
   * 
   * @private
   * @param {Event} event
   */
  _processTimeSelection : function __processTimeSelection(event)
  {

    var timePickerDisplay = this._timePickerDisplay, 
        prevSelected = $("[aria-selected]", timePickerDisplay), 
        ulElement = $("ul", timePickerDisplay), 
        selected = $(".oj-listbox-highlighted div", timePickerDisplay);

    if (selected.length !== 1)
    {
      return;
    }
    
    if(prevSelected.length === 1)
    {
      //previous selection can be 0 so remove only when of size 1
      prevSelected.removeAttr("aria-selected");
      prevSelected.parent().removeClass("oj-listbox-highlighted");
    }
    
    selected.attr("aria-selected", "true");
    selected.parent().addClass("oj-listbox-highlighted");
    
    this._SetDisplayValue(selected.attr("data-value")); //requirement to invoke _SetDisplayValue since _SetValue doesn't invoke it
    this._SetValue(selected.attr("data-value"));
    ulElement.attr("aria-activedescendant", selected[0].id); //updated for Jaws accessibilty reader
    
    this.hide();
    
    this.element.focus();
    
    if (this._isContainedInDateTimePicker())
    {
      //when focus is placed on the input, since datepicker w/ showOn of focus can display it
      this._datePicker["widget"].hide();
    }
  },
  
  /** 
   * Shows the timepicker
   * 
   * @expose 
   * @instance
   * @memberof! oj.ojInputTime
   */
  show : function __show()
  {
    if (this.options["disabled"])
    {
      return;
    }

    if (this._isContainedInDateTimePicker())
    {
      //need to hide the datepicker prior to showing timepicker
      this._datePicker["widget"].hide();
    }
    
    //lazily generate
    if (this._timePickerDisplay.children().length === 0)
    {
      this._generateTime();
    }

    this._timePickerDisplay.css(
    {
      top : "", left : ""
    });
    
    //Need to set the width to align with what combobox does
    this._timePickerDisplay.width(this.element.parent().width());

    var rtl = this._IsRTL();

    this._timePickerDisplay["position"](
    {
      my : rtl ? "right top" : "left top", at : rtl ? "right bottom" : "left bottom", of : this.element, collision : "fit"
    });

    this._timepickerShowing = true;
    this._timePickerDisplay.show();

    var selected = $("[aria-selected]", this._timePickerDisplay);
    if (selected.length === 1)
    {
      this._checkScrollTop($(selected));
    }

    $("ul", this._timePickerDisplay).focus();
  },
  
  /** 
   * Hides the timepicker
   * 
   * @expose 
   * @instance
   * @memberof! oj.ojInputTime
   */
  hide : function __hide()
  {
    if (this._timepickerShowing)
    {
      this._timePickerDisplay.hide();
      this._timepickerShowing = false;
      this.element.focus();
    }
  },
  
  /** 
   * Redraws the time drop down
   * 
   * @expose 
   * @instance
   * @memberof! oj.ojInputTime
   */
  refresh : function __refresh()
  {
    this._superApply(arguments);
    this._generateTime();
    return this;
  },
  
  /**
   * @ignore
   * @protected
   * @override
   * @instance
   * @memberof! oj.ojInputTime
   */
  _SetDisplayValue : function __setDisplayValue(displayValue)
  {
    //Only time to set the display value to the this.element is when not of 
    //ojInputDateTime [unless is inline]. Otherwise it will set only the time portion 
    //for the ojInputDateTime
    if (this._isIndependentInput())
    {
      this._superApply(arguments);
    }
    this._generateTime();
  },
  
  /**
   * Whether the this.element should be wrapped. Function so that additional conditions can be placed
   * 
   * @ignore
   * @protected
   * @override
   * @return {boolean}
   */
  _DoWrapElement : function ()
  {
    return this._isIndependentInput();
  },
  
  /**
   * Whether the input element of ojInputTime is shared or not [i.e. not part of ojInputDateTime or if it has 
   * been created by ojInputDateTime that ojInputDateTime
   * 
   * @ignore
   * @return {boolean}
   */
  _isIndependentInput : function __isIndependentInput()
  {
    return !this._isContainedInDateTimePicker() || this._isDatePickerInline();
  },
  
  /**
   * @protected
   * @override
   * @return {string}
   */
  _GetDefaultStyleClass : function ()
  {
    return "oj-inputtime";
  },
  
  /**
   * @ignore
   * @protected
   * @override
   * @instance
   * @memberof! oj.ojInputTime
   */
  _GetElementValue : function ()
  {
    return this.options['value'] || "";
  },
  
  /**
   * Returns a stub date with specific Year, Month, and Day [since only concerned with Time]
   * 
   * @private
   * @return {Object}
   */
  _getStubDate : function __getStubDate()
  {
    var temp = new Date(1950, 0, 1);
    return temp;
  },
  
  /**
   * This helper function will check if the currently selected time entry is within the view and if not will scroll to it
   * 
   * @private
   * @param {Object} node
   */
  _checkScrollTop : function (node)
  {
    var top = node.position().top, 
        height = this._timePickerDisplay.height(), 
        results = $(".oj-listbox-results", this._timePickerDisplay),
        scrollTop = results.scrollTop();

    if ((height + scrollTop) < top || top < scrollTop)
    {
      results.scrollTop(top);
    }
  },
  
  /**
   * This function will return the correct converter for ojInputTime
   * 
   * @private
   * @return {string} increments
   */
  _getTimeConverter : function __getTimeConverter() 
  {
    return this._isContainedInDateTimePicker() ? this._datePicker["converter"] : this._GetConverter();
  },
  
  /**
   * This function will return a formattedValue of the date object
   * 
   * @private
   * @return {string} increments
   */
  _getFormattedValue : function __getFormattedValue()
  {
    var converter = this._getTimeConverter(), 
        date = this.options['value'];

    return date ? converter.format(date) : "";
  },
  
  /**
   * Whether ojInputTime has been created by ojInputDateTime
   * 
   * @private
   */
  _isContainedInDateTimePicker : function __isContainedInDateTimePicker()
  {
    return this._datePicker !== null;
  },
  
  /**
   * Helper function to determine whether the provided datePicker is inline or not
   * 
   * @private
   */
  _isDatePickerInline : function __isDatePickerInline()
  {
    return this._datePicker["inline"];
  },
  
  /**
   * This function is to hide the timepicker if the user clicks anywhere outside the timepicker 
   * 
   * @private
   * @param {Event} event
   */
  _checkExternalClick : function __checkExternalClick(event)
  {

    var $target = $(event.target);

    if ((($target[0] !== this._timePickerDisplay[0] && 
          $target.parents("#" + this._GetSubId(this._TIME_PICKER_ID)).length === 0) && 
          !$target.closest("." + this._TRIGGER_CLASS).length && this._timepickerShowing))
    {
      this.hide();
    }
  },
  
  /**
   * Return the subcomponent node represented by the documented locator attribute values. For Time
   * 
   * <table class="props">
   *   <thead>
   *     <tr>
   *       <th>Locator</th>
   *       <th>Description</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td>oj-listbox-drop</td>
   *       <td>Time drop down div container</td>
   *     </tr>
   *     <tr>
   *       <td>oj-inputdatetime-time-icon</td>
   *       <td>Time icon that triggers the Time drop down display</td>
   *     </tr>
   * </tbody></table>
   * 
   * @expose
   * @override
   * @instance
   * @memberof! oj.ojInputTime
   * @param {Object} locator An Object containing at minimum a subId property whose value is a string, documented by the component, that allows the component to 
   *                        look up the subcomponent associated with that string.  It contains:<p>
   *                        component: optional - in the future there may be more than one component contained within a page element<p>
   *                        subId: the string, documented by the component, that the component expects in getNodeBySubId to locate a particular subcomponent
   * @returns {Object|null} the subcomponent located by the subId string passed in locator, if found.<p>
   */
  getNodeBySubId: function(locator)
  {
    var ret = this._superApply(arguments);
    if(ret) 
    {
      return ret;
    }
    
    var subId = locator['subId'];
    if(subId === "oj-listbox-drop")
    {
      return this._timePickerDisplay;
    }
    else if(subId === "oj-inputdatetime-time-icon")
    {
      return $(".oj-inputdatetime-time-icon", this._triggerNode);
    }
    
    return null;
  },
  
  /** 
   * Returns the time display node
   * 
   * @expose 
   * @instance
   * @memberof! oj.ojInputTime
   */
  timeDisplay : function __timeDisplay()
  {
    return this._timePickerDisplay;
  },
  
  /** 
   * Returns the root node
   * 
   * @expose 
   * @instance
   * @memberof! oj.ojInputTime
   */
  widget : function __widget()
  {
    return this._isIndependentInput() ? this._super() : this._datePicker["widget"].widget();
  }
  
});
/*!
 * JET Input DateTime @VERSION
 * http://jqueryui.com
 *
 * Copyright 2013 jQuery Foundertion and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * Depends:
 *  jquery.ui.widget.js
 */
/**
 * @class
 * @name oj.ojInputDateTime
 * @augments oj.ojInputDate
 * 
 * @classdesc
 * <h3 id="inputDateTimeOverview-section">
 *   JET ojInputDateTime Component
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#inputDateTimeOverview-section"></a>
 * </h3>
 * 
 * <p>Description: ojInputDateTime extends from ojInputDate providing additionally time selection drop down.
 * 
 * <h3 id="keyboard-section">
 *   Keyboard interaction
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
 * </h3>
 * 
 * <p>Asides from basic keyboard interaction of ojInputDate when focus is NOT on the grid and on the input element.
 * 
 * <table class="keyboard-table">
 *   <thead>
 *     <tr>
 *       <th>Key</th>
 *       <th>Use</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td><kbd>Enter</kbd></td>
 *       <td>Select the currently focused day</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>UpArrow</kbd></td>
 *       <td>Move up in the grid.</tr>
 *     <tr>
 *       <td><kbd>DownArrow</kbd></td>
 *       <td>Move down in the grid.</tr>
 *     <tr>
 *       <td><kbd>RightArrow</kbd></td>
 *       <td>Move right in the grid.</tr>
 *     <tr>
 *       <td><kbd>LeftArrow</kbd></td>
 *       <td>Move left in the grid.</tr>
 *     <tr>
 *       <td><kbd>Esc</kbd></td>
 *       <td>Close the grid.</tr>
 *     <tr>
 *       <td><kbd>Home</kbd></td>
 *       <td>Move focus to first day of the month.</tr>
 *     <tr>
 *       <td><kbd>End</kbd></td>
 *       <td>Move focus to last day of the month.</tr>
 *     <tr>
 *       <td><kbd>PageUp</kbd></td>
 *       <td>Switch to previous month.</tr>
 *     <tr>
 *       <td><kbd>PageDown</kbd></td>
 *       <td>Switch to next month.</tr>
 *     <tr>
 *       <td><kbd>Alt + PageUp</kbd></td>
 *       <td>Switch to previous year.</tr>
 *     <tr>
 *       <td><kbd>Alt + PageDown</kbd></td>
 *       <td>Switch to next year.</tr>
 *     <tr>
 *       <td><kbd>Ctrl + Alt + PageUp</kbd></td>
 *       <td>Switch to previous by stepBigMonths.</tr>
 *     <tr>
 *       <td><kbd>Ctrl + Alt + PageDown</kbd></td>
 *       <td>Switch to next by stepBigMonths.</tr>
 *     <tr>
 *       <td><kbd>Ctrl + Alt + T</kbd></td>
 *       <td>Places focus on Today button if it exists.</tr>
 *     <tr>
 *       <td><kbd>Ctrl + Alt + D</kbd></td>
 *       <td>Places focus on Done button if it exists.
 *     </tr>
 *     <tr>
 *       <td><kbd>Shift + DownArrow or UpArrow</kbd></td>
 *       <td>Shows the timepicker and moves the focus into the expanded timepicker list</td>
 *     </tr>
 * </tbody></table>
 * 
 * <h3 id="pseudos-section">
 *   Pseudo-selectors
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#pseudos-section"></a>
 * </h3>
 * 
 * <pre class="prettyprint">
 * <code>$( ":oj-inputDateTime" )            // selects all JET input on the page
 * </code>
 * </pre>
 * 
 * <h3 id="binding-section">
 *   Declarative Binding
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#binding-section"></a>
 * </h3>
 * 
 * <pre class="prettyprint">
 * <code>
 *    &lt;input id="dateTimeId" data-bind="ojComponent: {component: 'ojInputDateTime'}" /&gt;
 * </code>
 * </pre>
 * 
 * @desc Creates or re-initializes a JET ojInputDateTime
 * 
 * @param {Object=} options a map of option-value pairs to set on the component
 * 
 * @example <caption>Initialize the input element with no options specified:</caption>
 * $( ".selector" ).ojInputDateTime();
 * 
 * * @example <caption>Initialize the input element with some options:</caption>
 * $( ".selector" ).ojInputDateTime( { "disabled": true } );
 * 
 * @example <caption>Initialize the input element via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;input id="dateTimeId" data-bind="ojComponent: {component: 'ojInputDateTime'}" /&gt;
 */
oj.__registerWidget("oj.ojInputDateTime", $['oj']['ojInputDate'], 
{
  version : "1.0.0", 
  widgetEventPrefix : "oj",
  
  //-------------------------------------From base---------------------------------------------------//
  _WIDGET_CLASS_NAMES : "oj-inputdatetime-date-time oj-component oj-inputdatetime",
  _INPUT_HELPER_KEY: "inputHelpBoth",
  //-------------------------------------End from base-----------------------------------------------//
  
  options : 
  {

    /**
     * Time increment to be used for ojInputDateTime, the format is Thh:mm:ss:SS
     *
     * @expose
     * @instance
     * @memberof! oj.ojInputDateTime
     * @default <code class="prettyprint">"T00:30:00:00"</code>
     */
    timeIncrement : "T00:30:00:00", 

    /**
     * Default converter for ojInputDateTime
     *
     * If one wishes to provide a custom converter for the ojInputDateTime override the factory returned for
     * oj.Validation.converterFactory(oj.ConverterFactory.CONVERTER_TYPE_DATETIME)
     *
     * @expose
     * @instance
     * @memberof! oj.ojInputDateTime
     * @default <code class="prettyprint">oj.Validation.converterFactory(oj.ConverterFactory.CONVERTER_TYPE_DATETIME).createConverter({"day": "2-digit", "month": "2-digit", "year": "2-digit", "hour": "2-digit", "hour12": true, "minute": "2-digit"})</code>
     */
    converter : oj.Validation.converterFactory(oj.ConverterFactory.CONVERTER_TYPE_DATETIME).createConverter(
    {
      "day" : "2-digit", "month" : "2-digit", "year" : "2-digit", "hour" : "2-digit", "hour12" : true, "minute" : "2-digit"
    })
  },
  
  /**
   * @protected
   * @override
   * @instance
   * @memberof! oj.ojInputDateTime
   */
  _InitBase : function __InitBase() 
  {
    this._super();
    
    this._timePickerElement = this.element; //if the ojInputDateTime is inline, then this ref will change to a NEW input element
    this._timePicker = null;
    this._timeSelectedHandler = null;
    this._timeConverter = null;
  },
  
  /**
   * @protected
   * @override
   * @instance
   * @memberof! oj.ojInputDateTime
   */
  _ComponentCreate : function __ComponentCreate()
  {
    var ret = this._super(), 
        timeConverter = this._getTimePickerConverter(this._GetConverter());
    
    if (timeConverter === null)
    {
      throw new Error("Plase use ojInputDate if you do not have time portion");
    }
    
    if (this._isInLine())
    {
      //Since DatePicker never intended to have timepicker associated to it
      //need to have an input element that is tied to the time selector
      
      var input = $("<input type='text'>");
      input.insertAfter(this.element);
      
      //Now need to reset this._timePickerElement to the newly created input element
      this._timePickerElement = input;
    }
    
    //create time instance for the time portion
    this._timeSelectedHandler = $.proxy(this._timeSelected, this);
    this._timePicker = this._timePickerElement.ojInputTime(
    {
      "converter" : null,
      "optionChange" : this._timeSelectedHandler, 
      "timeIncrement" : this.options["timeIncrement"], 
      "placeholder" : timeConverter.getHint(),
      "datePicker" : {"widget": this, "converter": timeConverter, "inline": this._isInLine()} 
    });
    
    return ret;
  },
  
  /**
   * @protected
   * @override
   * @instance
   * @memberof! oj.ojInputDateTime
   */        
  _AfterCreate : function () 
  {
    var ret = this._superApply(arguments),
        timeConverter = this._getTimePickerConverter(this._GetConverter());
    
    this._timePicker.ojInputTime("option", "disabled", this.options["disabled"]);
    
    if(this._isInLine()) 
    {
      this._timePickerElement.val(timeConverter.format(this._getDate()));
    }
    
    return ret;
  },
  
  _setOption : function __setOption(key, value)
  {
    
    if(this._timePicker) 
    {
      if (key === "timeIncrement" || key === "disabled")
      {
        this._timePicker.ojInputTime("option", key, value);
      }
      else if (key === "converter")
      {
        this._timePicker.ojInputTime("option", key, this._getTimePickerConverter(value));
      }
    }
    
    return this._superApply(arguments);
  },
  
  /**
   * @ignore
   * @protected
   * @override
   */
  _destroy : function __destroy()
  {
    var ret = this._super();

    this._timePicker.ojInputTime("destroy");

    if (this._isInLine())
    {
      //note that this.element below would be of the TimePicker's input element
      this._timePickerElement.remove();
    }
    
    return ret;
  },
  
  /*
   * Will provide the timePicker converter based on the actual converter
   */
  _getTimePickerConverter : function __getTimePickerConverter(converter) 
  {
    var resolvedOptions = converter.resolvedOptions(), options = { },
        params = ["hour", "hour12", "minute", "second", "millisecond", "timeFormat"], i, j;

    for (i = 0, j = params.length;i < j;i++)
    {
      if (params[i] in resolvedOptions)
      {
        if(params[i] === "timeFormat") {
          //special case for timeFormat, formatType of time must be added
          options["formatType"] = "time";
        }
        options[params[i]] = resolvedOptions[params[i]];
      }
    }
    
    if ($.isEmptyObject(options))
    {
      return null;
    }
    
    var timeConverter = oj.Validation.converterFactory(oj.ConverterFactory.CONVERTER_TYPE_DATETIME).createConverter(options);
    this._timeConverter = timeConverter;
    return timeConverter;
  },
  
  /**
   * Handler for when the time is selected
   * 
   * @private
   * @param {Event} event
   * @param {Object} params
   */
  _timeSelected : function __timeSelected(event, params)
  {
    
    if(params["option"] === "value")
    {
      var currDate = new Date(this._getDate()), 
          selectedDate = this._timeConverter.parse(params["value"]);
      
      currDate.setHours(selectedDate.getHours());
      currDate.setMinutes(selectedDate.getMinutes());
      currDate.setSeconds(selectedDate.getSeconds());
      currDate.setMilliseconds(selectedDate.getMilliseconds());
      this.option("value", currDate);
    }
    
  },
  
  //Just for the case of launching timepicker with Alt + Up or Alt + Down
  _doInputKeyDown : function __doInputKeyDown(event)
  {
    var kc = $.ui.keyCode, 
        handled = false;
    
    if (!this._datepickerShowing) 
    {

      switch (event.keyCode)
      {
        case kc.UP: ;
        case kc.DOWN:
          if(event.shiftKey)
          {
            this._timePicker.ojInputTime("show");
            handled = true;
          }
          break;
      }

    }

    if (handled)
    {
      event.preventDefault();
      event.stopPropagation();
      return false;
    }
    
    return this._superApply(arguments);
  },
  
  /**
   * To disable or enable the widget
   * 
   * @private
   */
  _disableEnable : function __disableEnable(val)
  {
    var ret = this._superApply(arguments);

    if (this._isInLine() && this._timePicker)
    {
      this._timePicker.ojInputTime("option", "disabled", val);
    }

    return ret;
  },
  
  /**
   * @ignore
   * @expose
   */
  show : function __show()
  {
    this._timePicker.ojInputTime("hide");

    return this._super();
  },
  
  /** 
   * Redraws the calendar 
   * 
   * @ignore
   * @override
   * @instance
   */
  refresh : function __refresh()
  {
    this._superApply(arguments);
    this._timePicker.ojInputTime("refresh");
    return this;
  },
  
  /**
   * Return the subcomponent node represented by the documented locator attribute values.
   * 
   * @expose
   * @override
   * @instance
   * @memberof! oj.ojInputDateTime
   * @param {Object} locator An Object containing at minimum a subId property whose value is a string, documented by the component, that allows the component to 
   *                        look up the subcomponent associated with that string.  It contains:<p>
   *                        component: optional - in the future there may be more than one component contained within a page element<p>
   *                        subId: the string, documented by the component, that the component expects in getNodeBySubId to locate a particular subcomponent
   * @returns {Object|null} the subcomponent located by the subId string passed in locator, if found.<p>
   */
  getNodeBySubId: function(locator)
  {
    
    var ret = this._superApply(arguments);
    if(ret) 
    {
      return ret;
    }
    
    var subId = locator['subId'];
    if(subId === "oj-datepicker-time" || subId === "oj-datepicker-time-icon")
    {
      return this._timePicker.ojInputTime("getNodeBySubId", locator);
    }
    
    return null;
  },
  
  /**
   * 
   * @return {Object} jquery object 
   * 
   * 
   * @expose
   * @protected
   * @override
   * @instance
   * @memberof! oj.ojInputDateTime
   */
  _GetMessagingLauncherElement : function ()
  {
    return !this._isInLine() ? this._super() : this._timePickerElement.ojInputTime("widget");
  },
  
  /**
   * @protected
   * @override
   * @return {string}
   */
  _GetDefaultStyleClass : function ()
  {
    return "oj-inputdatetime";
  },
  
  /**
   * @protected
   * @override
   * @instance
   */
  _GetTranslationsSectionName: function()
  {
    return "oj-ojInputDate"; 
  }
  
});
/**
 * @export
 * @class oj.FlattenedTreeRowSet
 * @classdesc RowSet wrapper for FlattenedTreeDataSource
 * 
 * @param {oj.FlattenedTreeDataSource} data oj.FlattenedTreeDataSource
 * @param {Object=} options Passed through to the user's initialize routine, if any, upon construction 
 * @constructor
 */
oj.FlattenedTreeRowSet = function(data, options) 
{
  // Initialize
  oj.FlattenedTreeRowSet._init(this, data, options);
};

// Subclass from oj.FlattenedTreeDataSource
oj.Object.createSubclass(oj.FlattenedTreeRowSet, oj.RowSet, "oj.FlattenedTreeRowSet");

/**
 * Initializes the data source.
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeRowSet
 * @instance
 */
oj.FlattenedTreeRowSet.prototype.Init = function()
{
    oj.FlattenedTreeRowSet.superclass.Init.call(this);
};

oj.FlattenedTreeRowSet._init = function(rowSet, data, options) 
{
  rowSet._eventHandlers = [];
  rowSet._startIndex = 0;
  
  rowSet.Init();
  rowSet._data = data;
  
  // override the insert/removeRows function
  rowSet._data.insertRows = function(insertAtIndex, insertAtKey, nodeSet)
  {
    var i, row, rowIdx;
    for (i = 0; i < nodeSet.getCount(); i++)
    {
      rowIdx = insertAtIndex + i;
      row = new oj.ArrayRow(nodeSet.getData(i), {'context': nodeSet.getMetadata(i)});
      oj.FlattenedTreeRowSet.superclass._handleEvent.call(rowSet, oj.RowSet.EventType['ADD'], {'rowIdx': rowIdx, 'row': row});
    }
  };
  rowSet._data.removeRows = function(rowKeys)
  {
    var i, rowIdx;
    for (i = 0; i < rowKeys.length; i++)
    {
      // indices shift down as we remove
      rowIdx = rowKeys[i].index - i;
      oj.FlattenedTreeRowSet.superclass._handleEvent.call(rowSet, oj.RowSet.EventType['REMOVE'], {'rowIdx': rowIdx, 'row': null});
    }
  };
};

/**
 * Add an instance of this RowSet's Row(s) to the end of the RowSet.
 * @param {oj.Row} row Row object
 * @param {Object=} options at: splice the new Row into the RowSet at the value given (at:index) <p>
 *                          deferred: if true, return a promise as though this RowSet were virtual whether it is or not
 * 
 * @returns {Object} if deferred or virtual, return a promise when the set has completed
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeRowSet
 * @instance
 */
oj.FlattenedTreeRowSet.prototype.add = function(row, options)
{
  oj.Assert.failedInAbstractFunction();
  return null;
};

/**
 * Return the Row object found at the given index of the RowSet, or a promise object that will return the Row to a function
 * in the done() call.
 * 
 * @param {number} index Index for which to return the Row object. 
 * @param {Object=} options <p>
 *                  fetchSize: fetch size to use if the call needs to fetch more records from the server, if virtualized.  Overrides the overall fetchSize setting <p>
 *                  deferred: if true, return a deferred/promise object as described below.  If not specified, the return value will
 *                   be determined by whether or not the RowSet is virtual
 * @return {Object} Row object located at index. If index is out of range, returns null.  If this is a paging/virtual RowSet or
 *                  if deferred is specified and true, at will return a jQuery promise object which will call its done function,
 *                  passing the value at(index) 
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeRowSet
 * @instance
 */
oj.FlattenedTreeRowSet.prototype.at = function(index, options)
{
  var nodeSet = this._currentNodeSet;
  var startIndex = nodeSet.getStart();
  index = startIndex + index;
  return new oj.ArrayRow(nodeSet.getData(index), {'context': nodeSet.getMetadata(index)});
};

/**
 * Return a copy of the RowSet
 * @return {Object} copy of the RowSet
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeRowSet
 * @instance
 */
oj.FlattenedTreeRowSet.prototype.clone = function()
{
  oj.Assert.failedInAbstractFunction();
  return null;
};

/**
 * Collapse the specified row.
 * @param {Object} rowKey the key of the row to collapse
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeRowSet
 * @instance
 */
oj.FlattenedTreeRowSet.prototype.collapse = function(rowKey)
{
  this._data.collapse(rowKey);
};

/**
 * Expand the specified row.
 * @param {Object} rowKey the key of the row to expand
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeRowSet
 * @instance
 */
oj.FlattenedTreeRowSet.prototype.expand = function(rowKey)
{
  this._data.expand(rowKey);
};

/**
 * Fetch the RowSet data.
 * @param {Object=} options Options to control fetch<p>
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeRowSet
 * @instance
 */
oj.FlattenedTreeRowSet.prototype.fetch = function(options)
{
  options = options || {};
  if (options['startIndex'] != null)
  {
    this._startIndex = options['startIndex'];
  }
  var rangeOption = {'start': this._startIndex, 'count':  30};
  this._data.fetchRows(rangeOption,
    {
      "success": function(nodeSet)
      {
        this._handleFetchRowsSuccess(nodeSet);
      }.bind(this),
      "error": function(status)
      {
        //this._handleFetchRowsError(status, {'start': rowStart, 'count': rowCount}, callbacks, callbackObjects);
      }.bind(this)
    }
  ); 
};

/**
 * Return the first Row object from the RowSet whose Row id value is the given id
 * Note this method will not function as expected if the id is not set
 * @param {Object|string} id ID for which to return the Row object, if found. 
 * @param {Object=} options <p>
 *                  fetchSize: fetch size to use if the call needs to fetch more records from the server, if virtualized.  Overrides the overall fetchSize setting<p>
 *                  deferred: if true, return a promise as though this RowSet were virtual whether it is or not
 * @return {Object} First Row object in the RowSet where Row.id = id. If none are found, returns null.
 *                  If deferred or virtual, return a promise passing the Row when done
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeRowSet
 * @instance
 */
oj.FlattenedTreeRowSet.prototype.get = function(id, options)
{
  oj.Assert.failedInAbstractFunction();
  return null;
};

/**
 * Return whether there is more data which can be fetched.
 * @return {boolean} whether there is more data
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeRowSet
 * @instance
 */
oj.FlattenedTreeRowSet.prototype.hasMore = function()
{
  oj.Assert.failedInAbstractFunction();
  return false;
};

/**
 * Return the array index location of the given Row object.
 * @param {Object} row Row object to locate 
 * @param {Object=} options deferred: if true, return a promise as though this RowSet were virtual whether it is or not
 
 * @return {number} The index of the given Row object, or a promise that will call with the index when complete.
 *                  If the object is not found, returns -1.
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeRowSet
 * @instance
 */
oj.FlattenedTreeRowSet.prototype.indexOf = function(row, options)
{
  oj.Assert.failedInAbstractFunction();
  return 0;
};

/**
 * Determine if the RowSet has any Rows
 * 
 * @returns {boolean} true if RowSet is empty
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeRowSet
 * @instance
 */
oj.FlattenedTreeRowSet.prototype.isEmpty = function()
{
  oj.Assert.failedInAbstractFunction();
  return true;
};

/**
 * Attach an event handler to the datasource
 * @param {string} eventType eventType supported by the datasource
 * @param {function(Object)} eventHandler event handler function
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeRowSet
 * @instance
 */
oj.FlattenedTreeRowSet.prototype.on = function(eventType, eventHandler)
{
  if (eventType == 'expand' ||
      eventType == 'collapse')
  {
    // expand/collapse listeners should be passed through to the FlattenedTreeDatasource
    this._data.on(eventType, eventHandler);
  }
  else
  {
    oj.FlattenedTreeRowSet.superclass.on.call(this, eventType, eventHandler);
  }
};

/**
 * Detach an event handler from the datasource
 * @param {string} eventType eventType supported by the datasource
 * @param {function(Object)} eventHandler event handler function
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeRowSet
 * @instance
 */
oj.FlattenedTreeRowSet.prototype.off = function(eventType, eventHandler)
{
  if (eventType == 'expand' ||
      eventType == 'collapse')
  {
    // expand/collapse listeners should be passed through to the FlattenedTreeDatasource
    this._data.off(eventType, eventHandler);
  }
  else
  {
    oj.FlattenedTreeRowSet.superclass.off.call(this, eventType, eventHandler);
  }
};

/**
 * Remove a Row from the RowSet, if found.
 * @param {oj.Row} row Row object
 * @param {Object=} options silent: if set, do not fire a remove event
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeRowSet
 * @instance
 */
oj.FlattenedTreeRowSet.prototype.remove = function(row, options)
{
  oj.Assert.failedInAbstractFunction();
};

/**
 * Remove and replace the RowSet's entire list of Rows with a new set of Rows, if provided. Otherwise, empty the RowSet.
 * @param {Object=} data Array of Row objects with which to replace the RowSet's data. 
 * @param {Object=} options user options, passed to event
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeRowSet
 * @instance
 */
oj.FlattenedTreeRowSet.prototype.reset = function(data, options)
{
  oj.Assert.failedInAbstractFunction();
};

/**
 * Return the length of the RowSet
 * @returns {number} length of the RowSet
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeRowSet
 * @instance
 */
oj.FlattenedTreeRowSet.prototype.size = function()
{ 
  return this._currentNodeSet == null ? 0 : this._currentNodeSet.getCount();
};

/**
 * Sort the Rows in the RowSet
 * 
 * @param {Object=} options
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeRowSet
 * @instance
 */
oj.FlattenedTreeRowSet.prototype.sort = function(options)
{
  oj.Assert.failedInAbstractFunction();
};

/**
 * Return current start index.
 * @returns {number} start index
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeRowSet
 * @instance
 */
oj.FlattenedTreeRowSet.prototype.startIndex = function() {
  return 0;
};

/**
 * Return the total length of the RowSet
 * @returns {number} length of the RowSet
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeRowSet
 * @instance
 */
oj.FlattenedTreeRowSet.prototype.totalSize = function()
{
  return -1;
};

oj.FlattenedTreeRowSet.prototype._handleFetchRowsSuccess = function(nodeSet)
{
  this._currentNodeSet = nodeSet;
};



/*jslint browser: true,devel:true*/
/**
 * @export
 * @class oj.TableDataSource
 * @classdesc Abstract object representing data used by table component
 * @param {Object} data data supported by the components
 * @param {Object|null} options Array of options for the TableDataSource
 * @constructor
 */
oj.TableDataSource = function(data, options)
{
  if (this.constructor == oj.TableDataSource)
  {
    // This should only be called by the constructors of the subclasses. If you need
    // to initialize a new TableDataSource then call the constructors of the subclasses such
    // as oj.ArrayTableDataSource or oj.CollectionTableDataSource.
    var errSummary = oj.Translations.getTranslatedString('oj-ojTable.tableDataSourceInstantiated.summary');
    var errDetail = oj.Translations.getTranslatedString('oj-ojTable.tableDataSourceInstantiated.detail');
    throw new oj.Message(errSummary, errDetail, oj.Message.SEVERITY_LEVEL['ERROR']);
  }
  // Initialize
  this.data = data;
  this.options = options;
  this.isFetching = false;
  this._startIndex = 0;
  this.Init();
};

// Subclass from oj.DataSource 
oj.Object.createSubclass(oj.TableDataSource, oj.DataSource, "oj.TableDataSource");

/**
 * Initializes the instance.
 * @export
 * @expose
 * @memberof! oj.TableDataSource
 * @instance
 */
oj.TableDataSource.prototype.Init = function()
{
  oj.TableDataSource.superclass.Init.call(this);
};

/**
 * Return the oj.Row object found at the given index of the RowSet.
 * 
 * @param {number} index Index for which to return the Row object. 
 * @return {Object} oj.Row object located at index. If index is out of range, returns null.
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.TableDataSource
 * @instance
 */
oj.TableDataSource.prototype.at = function(index)
{
  oj.Assert.failedInAbstractFunction();
  return null;
};

/**
 * Fetch the RowSet data.
 * @param {Object=} options Options to control fetch<p>
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.TableDataSource
 * @instance
 */
oj.TableDataSource.prototype.fetch = function(options)
{
  oj.Assert.failedInAbstractFunction();
};

/**
 * Return the first oj.Row object from the RowSet whose Row id value is the given id
 * @param {Object|string} id ID for which to return the Row object, if found. 
 * @return {Object} First Row object in the RowSet where Row.id = id. If none are found, returns null.
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.TableDataSource
 * @instance
 */
oj.TableDataSource.prototype.get = function(id)
{
  oj.Assert.failedInAbstractFunction();
  return null;
};

/**
 * Determines whether this TableDataSource supports certain feature.
 * @param {string} feature the feature in which its capabilities is inquired.  Currently the only valid feature is "sort".
 * @return {string|null} the name of the feature.  For "sort", the valid return values are: "full", "none".  
 *         Returns null if the feature is not recognized.
 * @export
 * @expose
 * @memberof! oj.TableDataSource
 * @instance
 */
oj.TableDataSource.prototype.getCapability = function(feature)
{
    return null;
};

/**
 * Return whether there is more data which can be fetched.
 * @returns {boolean} whether there is more data
 * @export
 * @expose
 * @memberof! oj.TableDataSource
 * @instance
 */
oj.TableDataSource.prototype.hasMore = function()
{
  oj.Assert.failedInAbstractFunction();
  return false;
};

/**
 * Return the array index location of the given Row object.
 * @param {Object} row oj.Row object to locate 
 * @return {number} The index of the given Row object. If the object is not found, returns -1.
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.TableDataSource
 * @instance
 */
oj.TableDataSource.prototype.indexOf = function(row)
{
  oj.Assert.failedInAbstractFunction();
  return 0;
};

/**
 * Get the length of the RowSet.
 * limit it.
 * @returns {number} length of the RowSet
 * @export
 * @expose
 * @memberof! oj.TableDataSource
 * @instance
 */
oj.TableDataSource.prototype.size = function()
{
  oj.Assert.failedInAbstractFunction();
  return 0;
};

/**
 * Performs a sort on the data source.
 * @param {Object} criteria the sort criteria.
 * @param {Object} criteria.key The key that identifies which field to sort
 * @param {string} criteria.direction the sort direction, valid values are "ascending", "descending", "none" (default)
 * @export
 * @expose
 * @memberof! oj.TableDataSource
 * @instance
 */
oj.TableDataSource.prototype.sort = function(criteria)
{
  oj.Assert.failedInAbstractFunction();
};

/**
 * Get or set the current start index.
 * @param {number} startIndex start index
 * @returns {number} start index
 * @export
 * @expose
 * @memberof! oj.TableDataSource
 * @instance
 */
oj.TableDataSource.prototype.startIndex = function(startIndex) 
{
  if (startIndex != null)
  {
    this._startIndex = startIndex;
  }
  return this._startIndex;
};

/**
 * Return the total size of data available, including server side if not local.
 * @returns {number} total size of data
 * @export
 * @expose
 * @memberof! oj.TableDataSource
 * @instance
 */
oj.TableDataSource.prototype.totalSize = function()
{
  oj.Assert.failedInAbstractFunction();
  return 0;
};
/*jslint browser: true,devel:true*/
/**
 * @export
 * @class oj.PagingTableDataSource
 * @classdesc Object representing data used by the paging component
 * @param {Object} dataSource
 * @param {Object|null} options Array of options for the PagingControlDataSource
 * @constructor
 */
oj.PagingTableDataSource = function(dataSource, options)
{
  // Initialize
  options = options || {};
  
  if (!(dataSource instanceof oj.TableDataSource))
  {
    // we only support Array, oj.Collection, or ko.observableArray. To
    // check for observableArray, we can't do instanceof check because it's
    // a function. So we just check if it contains a subscribe function.
    var errSummary = oj.Translations.getTranslatedString('oj-table.dataInvalidType.summary');
    var errDetail = oj.Translations.getTranslatedString('oj-table.dataInvalidType.detail');
    throw new oj.Message(errSummary, errDetail, oj.Message.SEVERITY_LEVEL['ERROR']);
  }
  this.dataSource = dataSource;
  this._startIndex = 0;
  this.Init();
};

// Subclass from oj.DataSource 
oj.Object.createSubclass(oj.PagingTableDataSource, oj.PagingDataSource, "oj.PagingTableDataSource");

/**
 * Initializes the instance.
 * @export
 * @expose
 * @memberof! oj.PagingTableDataSource
 * @instance
 */
oj.PagingTableDataSource.prototype.Init = function()
{
  oj.PagingTableDataSource.superclass.Init.call(this);
};

/**
 * Calls fetch on the datasource with paging options.
 * @param {Object=} options Options to control fetch<p>
 *                  startIndex: The index at which to start fetching records.<p>
 *                  pageSize: The number of records to be fetched.<p>
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.PagingTableDataSource
 * @instance
 */
oj.PagingTableDataSource.prototype.fetch = function(options)
{
  if (options != null)
  {
    this._startIndex = options['startIndex'];
  }
  var pageSize = options['pageSize'] != null ? options['pageSize'] : this._pageSize;
  this.dataSource.fetch({'startIndex': this._startIndex, 'pageSize': pageSize});
};

/**
 * Calls fetch for the next page of data. No-op if no more data.
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.PagingTableDataSource
 * @instance
 */
oj.PagingTableDataSource.prototype.next = function()
{
  if (this.dataSource.totalSize() > this._startIndex)
  {
    this._currentPageSize = this._currentPageSize + this._pageSize;
    this.fetch({'startIndex': this._startIndex, 'pageSize': this._currentPageSize});
  }
};

/**
 * Calls fetch for the previous page of data. No-op if at the beginning.
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.PagingTableDataSource
 * @instance
 */
oj.PagingTableDataSource.prototype.previous = function()
{
  if (this._startIndex != 0 || this._startIndex != -1)
  {
    this._startIndex = this._startIndex - this._pageSize;
    this._startIndex = this._startIndex < 0 ? 0 : this._startIndex;
    this._currentPageSize = this._currentPageSize + this._pageSize;
    this.fetch({'startIndex': this._startIndex, 'pageSize': this._currentPageSize});
  }
};

/**
 * Set or change the number of models in a page
 * 
 * @param {number} n page size
 * @export
 * @expose
 * @memberof! oj.PagingTableDataSource
 * @instance
 */
oj.PagingTableDataSource.prototype.setPageSize = function(n) {
  this._pageSize = n;
  this._currentPageSize = this._startIndex + n;
};

/**
 * Return current start index. -1 if initial fetch has not been done yet.
 * @returns {number} start index
 * @export
 * @expose
 * @memberof! oj.PagingTableDataSource
 * @instance
 */
oj.PagingTableDataSource.prototype.startIndex = function() {
  return this._startIndex;
};


/**** start delegated functions ****/

/**
 * Return the model object found at the given index of the collection.
 * 
 * @param {number} index Index for which to return the model object. 
 * @return {Object} Model object located at index. If index is out of range, returns null.
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.PagingTableDataSource
 * @instance
 */
oj.PagingTableDataSource.prototype.at = function(index)
{
  return this.dataSource.at(index);
};

/**
 * Return the first model object from the collection whose model id value is the given id or cid, or the id or cid from a passed in model
 * @param {Object|string} id ID, cid, or Model (see Model id or cid) for which to return the model object, if found. 
 * @return {Object} First model object in the collection where model.id = id or model.cid = id. If none are found, returns null.
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.PagingTableDataSource
 * @instance
 */
oj.PagingTableDataSource.prototype.get = function(id)
{
  return this.dataSource.get(id);
};

/**
 * Determines whether this TableDataSource supports certain feature.
 * @param {string} feature the feature in which its capabilities is inquired.  Currently the only valid feature is "sort".
 * @return {string|null} the name of the feature.  For "sort", the valid return values are: "full", "none".  
 *         Returns null if the feature is not recognized.
 * @export
 * @expose
 * @memberof! oj.PagingTableDataSource
 * @instance
 */
oj.PagingTableDataSource.prototype.getCapability = function(feature)
{
  return this.dataSource.getCapability(feature);
};

/**
 * Return whether there is more data which can be fetched.
 * @returns {boolean} whether there is more data
 * @export
 * @expose
 * @memberof! oj.PagingTableDataSource
 * @instance
 */
oj.PagingTableDataSource.prototype.hasMore = function()
{
  return this.dataSource.hasMore();
};

/**
 * Return the array index location of the given model object.
 * @param {Object} model Model object to locate 
 * @return {number} The index of the given model object. If the object is not found, returns -1.
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.PagingTableDataSource
 * @instance
 */
oj.PagingTableDataSource.prototype.indexOf = function(model)
{
  return this.dataSource.indexOf(model);
};

/**
 * Attach an event handler to the datasource
 * @param {string} eventType eventType supported by the datasource
 * @param {function(Object)} eventHandler event handler function
 * @export
 * @expose
 * @memberof! oj.PagingTableDataSource
 * @instance
 */
oj.PagingTableDataSource.prototype.on = function(eventType, eventHandler)
{
  var dataSource = (/** @type {{on: Function}} */ (this.dataSource));
  return dataSource.on(eventType, eventHandler);
};

/**
 * Detach an event handler from the datasource
 * @param {string} eventType eventType supported by the datasource
 * @param {function(Object)} eventHandler event handler function
 * @export
 * @expose
 * @memberof! oj.PagingTableDataSource
 * @instance
 */
oj.PagingTableDataSource.prototype.off = function(eventType, eventHandler)
{
  var dataSource = (/** @type {{off: Function}} */ (this.dataSource));
  return dataSource.off(eventType, eventHandler);
};

/**
 * Return the size of the data locally in the dataSource. -1 if an initial fetch has not been
 * done yet.
 * @returns {number} size of data
 * @export
 * @expose
 * @memberof! oj.PagingTableDataSource
 * @instance
 */
oj.PagingTableDataSource.prototype.size = function()
{
  if (this._currentPageSize != null && this._currentPageSize > 0)
  {
    if (this.dataSource.size() > this._currentPageSize)
    {
      return this._currentPageSize;
    }
  }
  return this.dataSource.size();
};

/**
 * Performs a sort on the data source.
 * @param {Object} criteria the sort criteria.
 * @param {Object} criteria.key The key that identifies which field to sort
 * @param {string} criteria.direction the sort direction, valid values are "ascending", "descending", "none" (default)
 * @export
 * @expose
 * @memberof! oj.PagingTableDataSource
 * @instance
 */
oj.PagingTableDataSource.prototype.sort = function(criteria)
{
  this.dataSource.sort(criteria);
};

/**
 * Return the total size of data available, including server side if not local.
 * @returns {number} total size of data
 * @export
 * @expose
 * @memberof! oj.PagingTableDataSource
 * @instance
 */
oj.PagingTableDataSource.prototype.totalSize = function()
{
  return this.dataSource.totalSize();
};

/**** end delegated functions ****/

/*jslint browser: true,devel:true*/
/**
 * @export
 * @class oj.ArrayTableDataSource
 * @classdesc Object representing data used by table component
 * @param {Array|Object|function():Array} data data supported by the components
 * @param {Object|null} options Array of options for the TableDataSource
 * @constructor
 */
oj.ArrayTableDataSource = function(data, options)
{
  // Initialize
  if (!(data instanceof Array) &&
      (typeof (data) != 'function' &&
       typeof (data.subscribe) != 'function'))
  {
    // we only support Array or ko.observableArray. To
    // check for observableArray, we can't do instanceof check because it's
    // a function. So we just check if it contains a subscribe function.
    var errSummary = oj.Translations.getTranslatedString('oj-ojTable.dataInvalidType.summary');
    var errDetail = oj.Translations.getTranslatedString('oj-ojTable.dataInvalidType.detail');
    throw new oj.Message(errSummary, errDetail, oj.Message.SEVERITY_LEVEL['ERROR']);
  }

  oj.ArrayTableDataSource.superclass.constructor.call(this, data, options);

  this._rowSet = new oj.ArrayRowSet(/** @type Array */ (data), this.options);
  this._addRowSetEventListeners();

  if ((options != null && (options['startFetch'] == 'enabled' || options['startFetch'] == null))
    || options == null)
  {
    // do an initial fetch
    var self = this;
    setTimeout(function()
    {
      self.fetch({'startFetch': 'enabled'});
    }, 0);
  }
};

// Subclass from oj.DataSource 
oj.Object.createSubclass(oj.ArrayTableDataSource, oj.TableDataSource, "oj.ArrayTableDataSource");

/**
 * Initializes the instance.
 * @export
 * @expose
 * @memberof! oj.ArrayTableDataSource
 * @instance
 */
oj.ArrayTableDataSource.prototype.Init = function()
{
  oj.ArrayTableDataSource.superclass.Init.call(this);
};

/**
 * Add an instance of oj.Row to the end of the RowSet.
 * @param {Object} m Row object (or array of rows) to add. These can be already-created instance of the oj.Row object, or sets of attribute/values, which will be wrapped by add().
 * @param {Object=} options silent: if set, do not fire an add event<p>
 *                          at: splice the new Row into the RowSet at the value given (at:index) <p>
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.ArrayTableDataSource
 * @instance
 */
oj.ArrayTableDataSource.prototype.add = function(m, options)
{
  this._rowSet.add(m, options);
};

/**
 * Return the oj.Row object found at the given index of the RowSet.
 * 
 * @param {number} index Index for which to return the Row object. 
 * @return {Object} oj.Row object located at index. If index is out of range, returns null.
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.ArrayTableDataSource
 * @instance
 */
oj.ArrayTableDataSource.prototype.at = function(index)
{
  return this._rowSet.at(index);
};

/**
 * Fetch the RowSet data.
 * @param {Object=} options Options to control fetch<p>
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.ArrayTableDataSource
 * @instance
 */
oj.ArrayTableDataSource.prototype.fetch = function(options)
{
  options = options || {};
  if (options['startIndex'] != null)
  {
    oj.ArrayTableDataSource.superclass.startIndex.call(this, options['startIndex']);
  }
  var data = this.data;

  if (options['startFetch'] == 'enabled')
  {
    // only do an initial fetch if collection is empty
    if (this._rowSet.isEmpty() ||
      (typeof this._rowSet.size() === 'undefined'))
    {
      this._rowSet.fetch(options);
    }
  }
  else
  {
    this._rowSet.fetch(options);
  }
};

/**
 * Return the first oj.Row object from the RowSet whose Row id value is the given id
 * @param {string} id ID for which to return the Row object, if found. 
 * @return {Object} First Row object in the RowSet where Row.id = id. If none are found, returns null.
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.ArrayTableDataSource
 * @instance
 */
oj.ArrayTableDataSource.prototype.get = function(id)
{
  return this._rowSet.get(id);
};

/**
 * Determines whether this TableDataSource supports certain feature.
 * @param {string} feature the feature in which its capabilities is inquired.  Currently the only valid feature is "sort".
 * @return {string|null} the name of the feature.  For "sort", the valid return values are: "full", "none".  
 *         Returns null if the feature is not recognized.
 * @export
 */
oj.ArrayTableDataSource.prototype.getCapability = function(feature)
{
    return 'full';
};

/**
 * Return whether there is more data which can be fetched.
 * @returns {boolean} whether there is more data
 * @export
 * @expose
 * @memberof! oj.ArrayTableDataSource
 * @instance
 */
oj.ArrayTableDataSource.prototype.hasMore = function()
{
  if (this._rowSet != null)
  {
    return this._rowSet.hasMore();
  }
  return false;
};

/**
 * Return the array index location of the given Row object.
 * @param {Object} row oj.Row object to locate 
 * @return {number} The index of the given Row object. If the object is not found, returns -1.
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.ArrayTableDataSource
 * @instance
 */
oj.ArrayTableDataSource.prototype.indexOf = function(row)
{
  return this._rowSet.indexOf(row);
};

/**
 * Remove a Row from the RowSet, if found.
 * @param {Object} m oj.Row object or array of Rows to remove. 
 * @param {Object=} options silent: if set, do not fire a remove event 
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.ArrayTableDataSource
 * @instance
 */
oj.ArrayTableDataSource.prototype.remove = function(m, options)
{
  this._rowSet.remove(m, options);
};

/**
 * Remove and replace the RowSet's entire list of Rows with a new set of Rows, if provided. Otherwise, empty the RowSet.
 * @param {Object=} data Array of Row objects or attribute/value pair objects with which to replace the RowSet's data. 
 * @param {Object=} options user options, passed to event
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.ArrayTableDataSource
 * @instance
 */
oj.ArrayTableDataSource.prototype.reset = function(data, options)
{
  this._rowSet.reset(data, options);
};

/**
 * Get the length of the RowSet.
 * limit it.
 * @returns {number} length of the RowSet
 * @export
 * @expose
 * @memberof! oj.ArrayTableDataSource
 * @instance
 */
oj.ArrayTableDataSource.prototype.size = function()
{
  return this._rowSet.size();
};

/**
 * Performs a sort on the data source.
 * @param {Object} criteria the sort criteria.
 * @param {Object} criteria.key The key that identifies which field to sort
 * @param {string} criteria.direction the sort direction, valid values are "ascending", "descending", "none" (default)
 * @export
 * @expose
 * @memberof! oj.ArrayTableDataSource
 * @instance
 */
oj.ArrayTableDataSource.prototype.sort = function(criteria)
{
  var key = criteria['key']; 
  var direction = criteria['direction'];
  var comparator = null;
  
  if (direction == 'ascending')
  {
    comparator = function(row) {
      if ($.isFunction(row.get))
      {
        return row.get(key);
      }
      else
      {
        return row[key]();
      }
    };
  }
  else if (direction == 'descending')
  {
    comparator = function(rowA, rowB) {
      var a, b;
      if ($.isFunction(rowA.get))
      {
        a = rowA.get(key);
        b = rowB.get(key);
      }
      else
      {
        a = rowA[key]();
        b = rowB[key]();
      }
      if (a === b)
      {
        return 0;
      }
      return a > b ? -1 : 1;
    };
  }
  this._rowSet['comparator'] = comparator;
  this._rowSet.sort();
};

/**
 * Return the total size of data available, including server side if not local.
 * @returns {number} total size of data
 * @export
 * @expose
 * @memberof! oj.ArrayTableDataSource
 * @instance
 */
oj.ArrayTableDataSource.prototype.totalSize = function()
{
  return this._rowSet.totalSize();
};

/**
 * Add event listeners to the RowSet
 * @private
 */
oj.ArrayTableDataSource.prototype._addRowSetEventListeners = function()
{
  var self = this;
  (/** @type {{on: Function}} */  (this._rowSet)).on(oj.RowSet.EventType['ADD'], function(event) {
    self.isFetching = false;
    oj.TableDataSource.superclass.handleEvent.call(self, oj.RowSet.EventType['ADD'], event);
  });
  (/** @type {{on: Function}} */  (this._rowSet)).on(oj.RowSet.EventType['REMOVE'], function(event) {
    self.isFetching = false;
    oj.TableDataSource.superclass.handleEvent.call(self, oj.RowSet.EventType['REMOVE'], event);
  });
  (/** @type {{on: Function}} */  (this._rowSet)).on(oj.RowSet.EventType['REQUEST'], function(event) {
    self.isFetching = true;
    oj.TableDataSource.superclass.handleEvent.call(self, oj.RowSet.EventType['REQUEST'], event);
  });
  (/** @type {{on: Function}} */  (this._rowSet)).on(oj.RowSet.EventType['RESET'], function(event) {
    self.isFetching = false;
    oj.TableDataSource.superclass.handleEvent.call(self, oj.RowSet.EventType['RESET'], event);
  });
  (/** @type {{on: Function}} */  (this._rowSet)).on(oj.RowSet.EventType['SORT'], function(event) {
    self.isFetching = false;
    oj.TableDataSource.superclass.handleEvent.call(self, oj.RowSet.EventType['SORT'], event);
  });
  (/** @type {{on: Function}} */  (this._rowSet)).on(oj.RowSet.EventType['CHANGE'], function(event) {
    self.isFetching = false;
    oj.TableDataSource.superclass.handleEvent.call(self, oj.RowSet.EventType['CHANGE'], event);
  });
  (/** @type {{on: Function}} */  (this._rowSet)).on(oj.RowSet.EventType['DESTROY'], function(event) {
    self.isFetching = false;
    oj.TableDataSource.superclass.handleEvent.call(self, oj.RowSet.EventType['DESTROY'], event);
  });
  (/** @type {{on: Function}} */  (this._rowSet)).on(oj.RowSet.EventType['SYNC'], function(event) {
    self.isFetching = false;
    oj.TableDataSource.superclass.handleEvent.call(self, oj.RowSet.EventType['SYNC'], event);
  });
  (/** @type {{on: Function}} */  (this._rowSet)).on(oj.RowSet.EventType['ERROR'], function(event) {
    self.isFetching = false;
    oj.TableDataSource.superclass.handleEvent.call(self, oj.RowSet.EventType['ERROR'], event);
  });
};
/**
 * The ojTable component enhances a HTML table element into one that supports all
 * the features in JET Table.
 * 
 * <h3 id="keyboard-section">
 *   Keyboard interaction
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
 * </h3>
 * When existing focus is on a column header.
 * <table class="keyboard-table">
 *   <thead>
 *     <tr>
 *       <th>Key</th>
 *       <th>Use</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td><kbd>Tab</kbd></td>
 *       <td>Navigate to next focusable element on page (outside table).</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Shift+Tab</kbd></td>
 *       <td>Navigate to previous focusable element on page (outside table).</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>DownArrow</kbd></td>
 *       <td>Move focus to the first row.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>UpArrow</kbd></td>
 *       <td>Do nothing.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>LeftArrow</kbd></td>
 *       <td>Move focus to previous column header.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Shift+LeftArrow</kbd></td>
 *       <td>Select and move focus to previous column header.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>RightArrow</kbd></td>
 *       <td>Move focus to next column header.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Shift+RightArrow</kbd></td>
 *       <td>Select and move focus to next column header.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Home</kbd></td>
 *       <td>Move focus to first column header.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>End</kbd></td>
 *       <td>Move focus to last column header.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Space</kbd></td>
 *       <td>Select column.</td>
 *     </tr>
 * </tbody></table>
 * When existing focus is on a row element.
 * <table class="keyboard-table">
 *   <thead>
 *     <tr>
 *       <th>Key</th>
 *       <th>Use</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td><kbd>Tab</kbd></td>
 *       <td>Move focus to next focusable element in row.
 *           <br>If focus is on the last focusable element in the row, move focus to first focusable element in next row.
 *           <br>If focus is on the last focusable element in the last row, move focus to next focusable element on the page (outside table).
 *       </td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Shift+Tab</kbd></td>
 *       <td>Move focus to previous focusable element in row.
 *           <br>If focus is on the first focusable element in the row, move focus to last focusable element in previous row.
 *           <br>If focus is on the first focusable element in the first row, move focus to previous focusable element on the page (outside table).
 *       </td>
 *     </tr>
 *     <tr>
 *       <td><kbd>DownArrow</kbd></td>
 *       <td>Move focus to the next row.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Shift+DownArrow</kbd></td>
 *       <td>Select and move focus to the next row.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>UpArrow</kbd></td>
 *       <td>Move focus to the previous row. If at the first row then move to the column header.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Shift+UpArrow</kbd></td>
 *       <td>Select and move focus to the previous row.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>LeftArrow</kbd></td>
 *       <td>Do nothing.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>RightArrow</kbd></td>
 *       <td>Do nothing.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Home</kbd></td>
 *       <td>Move focus to first row.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>End</kbd></td>
 *       <td>Move focus to last row.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Space</kbd></td>
 *       <td>Select row.</td>
 *     </tr>
 * </tbody></table>
 * 
 * <h3>Support for knockout templates:</h3>
 * When knockout bindings are used, the following additional options are available to use
 * knockout templates to customize JET Table.
 * <ul>
 *   <li>columnTemplates<p>
 *   An array of column templates. Each entry must contain the following parameters:
 *   <br>columnId: Points to the column specified in the columns option with the referenced Id.
 *   <br>type: Can be either 'cell' or 'header'.
 *   <br>template: The name of the knockout template to use.
 *   </li>
 *   <li>rowTemplate<p>
 *   The name of the knockout template for each row to use.
 *   </li>
 * </ul>
 * 
 * @example  <caption>Initialize the table via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;table id="table" data-bind="ojComponent: {component: 'ojTable', data: datasource, columns:
 *      [{headerText: 'Department Id', field: 'DepartmentId'},
 *      {headerText: 'Department Name', field: 'DepartmentName'},
 *      {headerText: 'Location Id', field: 'LocationId'},
 *      {headerText: 'Manager Id', field: 'ManagerId'}]}"&gt;
 *      
 * @example  <caption>Initialize the table with columnTemplates via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;table id="table" data-bind="ojComponent: {component: 'ojTable', data: datasource, columns:
 *      [{headerText: 'Department Id', field: 'DepartmentId'},
 *      {headerText: 'Department Name', field: 'DepartmentName'},
 *      {headerText: 'Location Id', field: 'LocationId'},
 *      {headerText: 'Manager Id', field: 'ManagerId'}]},
 *      {id: 'column5'}],
 *      columnTemplates: [{columnId: 'column5', type: 'header', template: 'oracle_link_hdr'},
 *                        {columnId: 'column5', type: 'cell', template: 'oracle_link'}]}"&gt;
 * &lt;script type="text/html" id="oracle_link_hdr"&gt;
 *    &lt;th style="padding-left: 5px; padding-right: 5px;"&gt;
 *       Oracle Link
 *    &lt;/th&gt;
 * &lt;/script&gt;
 * &lt;script type="text/html" id="oracle_link"&gt;
 *     &lt;td&gt;
 *         &lt;a href="http://www.oracle.com"&gt;Oracle&lt;/a&gt;
 *     &lt;/td&gt;
 * &lt;/script&gt;
 *
 * @example  <caption>Initialize the table with rowTemplate via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;table id="table" data-bind="ojComponent: {component: 'ojTable', data: datasource, columns:
 *      [{headerText: 'Department Id', field: 'DepartmentId'},
 *      {headerText: 'Department Name', field: 'DepartmentName'},
 *      {headerText: 'Location Id', field: 'LocationId'},
 *      {headerText: 'Manager Id', field: 'ManagerId'}]},,
 *      rowTemplate: {template: 'row_tmpl'}}"&gt;
 * &lt;script type="text/html" id="row_tmpl"&gt;
 *   &lt;tr&gt;
 *       &lt;td data-bind="text: DepartmentId"&gt;
 *       &lt;/td&gt;
 *       &lt;td data-bind="text: DepartmentName"&gt;
 *       &lt;/td&gt;
 *       &lt;td data-bind="text: LocationId"&gt;
 *       &lt;/td&gt;
 *       &lt;td data-bind="text: ManagerId"&gt;
 *       &lt;/td&gt;
 *   &lt;/tr&gt;
 * &lt;/script&gt;
 * 
 * @class
 * @constructor
 * @name oj.ojTable
 * @augments oj.baseComponent
 */
(function() {
  oj.__registerWidget("oj.ojTable", $['oj']['baseComponent'],
    {
      version: '1.0.0',
      defaultElement: '<table>',
      widgetEventPrefix: 'oj',
      options:
        {
          /** 
           * Accessibility options. 
           * <p>
           * The following options are supported:
           * <ul>
           *   <li>rowHeader: columnId</li>
           * </ul>
           * The td cells in the column specified by the rowHeader
           * attribute will be assigned an id and then referenced by the
           * headers attribute in the rest of the cells in the row.
           * This is required by screenReaders. By default the first column
           * will be taken as the rowHeader.
           * @expose 
           * @public 
           * @instance
           * @memberof! oj.ojTable 
           * @default <code class="prettyprint">null</code>
           */
          accessibility: null,
          /** 
           * The data to bind to the component. 
           * <p>
           * Must be of type oj.TableDataSource {@link oj.TableDataSource}
           * @expose 
           * @public 
           * @instance
           * @memberof! oj.ojTable 
           * @default <code class="prettyprint">null</code>
           */
          data: null,
          /**
           * The text to display when there are no data in the Table. If it is not defined, 
           * then a default empty text is extracted from the resource bundle.
           * 
           * @expose 
           * @memberof! oj.ojTable
           * @instance
           * @type {String|null}
           * @default <code class="prettyprint">"No data to display."</code>
           * @example <caption>Initialize the table with the <code class="prettyprint">emptyText</code> option specified:</caption>
           * &lt;table id="table" data-bind="ojComponent: {component: 'ojTable', data: datasource, emptyText: 'No data', columns:
           * [{headerText: 'Department Id', field: 'DepartmentId'},
           * {headerText: 'Department Name', field: 'DepartmentName']}"&gt;
           */
          emptyText: null,
          /** 
           * Whether the horizontal gridlines are to be drawn.
           * @expose 
           * @public 
           * @instance
           * @memberof! oj.ojTable 
           * @default <code class="prettyprint">"enabled"</code>
           */
          horizontalGridVisible: 'enabled',
          /** 
           * The row renderer function to use.
           * <p>
           * The renderer function will be passed in an Object which contains the fields:
           * <ul>
           *   <li>component: Instance of the component</li>
           *   <li>row: Key/value pairs of the row</li>
           *   <li>status: Contains the rowIndex, rowKey, and activeRow</li>
           *   <li>parentElement: Empty rendered TR element</li>
           * </ul>
           * The function returns  either a String or 
           * a DOM element of the content inside the row. If the developer chooses 
           * to manipulate the row element directly, the function should return 
           * nothing.
           * @expose 
           * @public 
           * @instance
           * @memberof! oj.ojTable 
           * @default <code class="prettyprint">null</code>
           */
          rowRenderer: null,
          /** 
           * The row and column selection modes. Both can be either single or multiple.
           * @expose 
           * @public 
           * @instance
           * @memberof! oj.ojTable 
           * @default <code class="prettyprint">null</code>
           * @example <caption>Initialize the table with the <code class="prettyprint">selectionMode</code> option specified:</caption>
           * &lt;table id="table" data-bind="ojComponent: {component: 'ojTable', data: datasource, selectionMode: {row: 'multiple', column: 'multiple'}, columns:
           * [{headerText: 'Department Id', field: 'DepartmentId'},
           * {headerText: 'Department Name', field: 'DepartmentName']}"&gt;
           */
          selectionMode: null,
          /** 
           * Whether the vertical gridlines are to be drawn.
           * @expose 
           * @public 
           * @instance
           * @memberof! oj.ojTable 
           * @default <code class="prettyprint">"enabled"</code>
           */
          verticalGridVisible: 'enabled',
          /** 
           * An array of column definitions.
           * @expose 
           * @public 
           * @instance
           * @memberof! oj.ojTable 
           * @default <code class="prettyprint">null</code>
           * @example <caption>Initialize the table with the <code class="prettyprint">columns</code> option specified:</caption>
           * &lt;table id="table" data-bind="ojComponent: {component: 'ojTable', data: datasource, columns:
           * [{headerText: 'Department Id', field: 'DepartmentId'},
           * {headerText: 'Department Name', field: 'DepartmentName']}"&gt;
           */
          columns: [{
              /** 
               * The renderer function that renders the content of the cell. 
               * The function will be passed a context object which contains 
               * the following objects:
               * <ul>
               *   <li>data: The cell data</li>
               *   <li>column: The column object</li>
               *   <li>component: Instance of the component</li>
               *   <li>datasource: Instance of the datasource used by the table </li>
               *   <li>row: Key/value pairs of the row</li>
               *   <li>status: Contains the rowIndex, rowKey, and activeRow</li>
               *   <li>parentElement: Empty rendered <td> element</li>
               * </ul>
               * The function returns  either a String or 
               * a DOM element of the content inside the header. If the developer chooses 
               * to manipulate the cell element directly, the function should return 
               * nothing. If no renderer is specified, the Table will treat the cell data as a String.
               * @expose 
               * @public 
               * @instance
               * @memberof! oj.ojTable 
               * @default <code class="prettyprint">null</code>
               */
              renderer: null,
              /** 
               * The CSS class to apply to the column cells
               * @expose 
               * @public 
               * @instance
               * @memberof! oj.ojTable 
               * @default <code class="prettyprint">null</code>
               */
              className: null,
              /** 
               * The data field this column refers to. 
               * @expose 
               * @public 
               * @instance
               * @memberof! oj.ojTable 
               * @default <code class="prettyprint">null</code>
               */
              field: null,
              /** 
               * The CSS class to apply to the footer cell.
               * @expose 
               * @public 
               * @instance
               * @memberof! oj.ojTable 
               * @default <code class="prettyprint">null</code>
               */
              footerClassName: null,
              /** 
               * The renderer function that renders the content of the footer. 
               * The function will be passed a context object which contains 
               * the following objects:
               * <ul>
               *   <li>column: The column object</li>
               *   <li>component: Instance of the component</li>
               *   <li>datasource: Instance of the datasource used by the table </li>
               *   <li>status: Contains the rowIndex, rowKey, and activeRow</li>
               *   <li>parentElement: Empty rendered <td> element</li>
               * </ul>
               * The function returns  either a String or 
               * a DOM element of the content inside the footer. If the developer chooses 
               * to manipulate the footer element directly, the function should return 
               * nothing. If no renderer is specified, the Table will treat the footer data as a String.
               * @expose 
               * @public 
               * @instance
               * @memberof! oj.ojTable 
               * @default <code class="prettyprint">null</code>
               */
              footerRenderer: null,       
              /** 
               * The CSS styling to apply to the footer cell.
               * @expose 
               * @public 
               * @instance
               * @memberof! oj.ojTable 
               * @default <code class="prettyprint">null</code>
               */
              footerStyle: null,
              /** 
               * The CSS class to apply to the column header text.
               * @expose 
               * @public 
               * @instance
               * @memberof! oj.ojTable 
               * @default <code class="prettyprint">null</code>
               */
              headerClassName: null,
              /** 
               * The renderer function that renders the content of the header. 
               * The function will be passed a context object which contains 
               * the following objects:
               * <ul>
               *   <li>column: The column object</li>
               *   <li>component: Instance of the component</li>
               *   <li>parentElement: Empty rendered TH element</li>
               * </ul>
               * The function returns either a String or 
               * a DOM element of the content inside the header. If the developer chooses 
               * to manipulate the cell element directly, the function should return 
               * nothing. If no renderer is specified, the Table will treat the header data as a String.
               * @expose 
               * @public 
               * @instance
               * @memberof! oj.ojTable 
               * @default <code class="prettyprint">null</code>
               */
              headerRenderer: null, 
              /** 
               * The CSS styling to apply to the column header text.
               * @expose 
               * @public 
               * @instance
               * @memberof! oj.ojTable 
               * @default <code class="prettyprint">null</code>
               */
              headerStyle: null,
              /** 
               * Text to display in the header of the column.
               * @expose 
               * @public 
               * @instance
               * @memberof! oj.ojTable 
               * @default <code class="prettyprint">null</code>
               */
              headerText: null,
              /** 
               * The identifier for the column
               * @expose 
               * @public 
               * @instance
               * @memberof! oj.ojTable 
               * @default <code class="prettyprint">null</code>
               */
              id: null,
              /** 
               * Whether or not the column is sortable. 
               * <p>
               * A sortable column has a clickable header that (when clicked) 
               * sorts the table by that column's property. Note that 
               * in order for a column to be sortable, this attribute 
               * must be set to "enabled" and the underlying model must 
               * support sorting by this column's property. If this attribute
               * is set to "auto" then the column will be sortable if the
               * underlying model supports sorting. A value of "none" will
               * disable sorting on the column.
               * @expose 
               * @public 
               * @instance
               * @memberof! oj.ojTable 
               * @default <code class="prettyprint">"auto"</code>
               */
              sortable: 'auto',
              /** 
               * This is the property that the framework uses to 
               * sort the Table's data.
               * @expose 
               * @public 
               * @instance
               * @memberof! oj.ojTable 
               * @default <code class="prettyprint">null</code>
               */
              sortProperty: null,
              /** 
               * The CSS styling to apply to the column cells
               * @expose 
               * @public 
               * @instance
               * @memberof! oj.ojTable 
               * @default <code class="prettyprint">null</code>
               */
              style: null
            }],
          /** 
           * Default values to apply to all columns objects.
           * @expose 
           * @public 
           * @instance
           * @memberof! oj.ojTable 
           * @default <code class="prettyprint">null</code>
           * @example <caption>Initialize the table with the <code class="prettyprint">columnsDefault</code> option specified:</caption>
           * &lt;table id="table" data-bind="ojComponent: {component: 'ojTable', data: datasource, columnsDefault: {headerStyle: 'text-align: left; white-space:nowrap;'}, columns:
           * [{headerText: 'Department Id', field: 'DepartmentId'},
           * {headerText: 'Department Name', field: 'DepartmentName']}"&gt;
           */
          columnsDefault: {
              /** 
               * The renderer function that renders the content of the cell. 
               * The function will be passed a context object which contains 
               * the following objects:
               * <ul>
               *   <li>data: The cell data</li>
               *   <li>column: The column object</li>
               *   <li>component: Instance of the component</li>
               *   <li>datasource: Instance of the datasource used by the table </li>
               *   <li>row: Key/value pairs of the row</li>
               *   <li>status: Contains the rowIndex, rowKey, and activeRow</li>
               *   <li>parentElement: Empty rendered <td> element</li>
               * </ul>
               * The function returns  either a String or 
               * a DOM element of the content inside the header. If the developer chooses 
               * to manipulate the cell element directly, the function should return 
               * nothing. If no renderer is specified, the Table will treat the cell data as a String.
               * @expose 
               * @public 
               * @instance
               * @memberof! oj.ojTable 
               * @default <code class="prettyprint">null</code>
               */
              renderer: null,
              /** 
               * The default CSS class for column cells
               * @expose 
               * @public 
               * @instance
               * @memberof! oj.ojTable 
               * @default <code class="prettyprint">null</code>
               */
              className: null,
              /** 
               * The default data field for column. 
               * @expose 
               * @public 
               * @instance
               * @memberof! oj.ojTable 
               * @default <code class="prettyprint">null</code>
               */
              field: null,
              /** 
               * The CSS class to apply to the footer cell.
               * @expose 
               * @public 
               * @instance
               * @memberof! oj.ojTable 
               * @default <code class="prettyprint">null</code>
               */
              footerClassName: null,
              /** 
               * The renderer function that renders the content of the footer. 
               * The function will be passed a context object which contains 
               * the following objects:
               * <ul>
               *   <li>column: The column object</li>
               *   <li>component: Instance of the component</li>
               *   <li>datasource: Instance of the datasource used by the table </li>
               *   <li>status: Contains the rowIndex, rowKey, and activeRow</li>
               *   <li>parentElement: Empty rendered <td> element</li>
               * </ul>
               * The function returns  either a String or 
               * a DOM element of the content inside the footer. If the developer chooses 
               * to manipulate the footer element directly, the function should return 
               * nothing. If no renderer is specified, the Table will treat the footer data as a String.
               * @expose 
               * @public 
               * @instance
               * @memberof! oj.ojTable 
               * @default <code class="prettyprint">null</code>
               */
              footerRenderer: null, 
              /** 
               * The CSS styling to apply to the footer cell.
               * @expose 
               * @public 
               * @instance
               * @memberof! oj.ojTable 
               * @default <code class="prettyprint">null</code>
               */
              footerStyle: null,
              /** 
               * The default CSS class to apply to the column header text.
               * @expose 
               * @public 
               * @instance
               * @memberof! oj.ojTable 
               * @default <code class="prettyprint">null</code>
               */
              headerClassName: null,
              /** 
               * The renderer function that renders the content of the header. 
               * The function will be passed a context object which contains 
               * the following objects:
               * <ul>
               *   <li>column: The column object</li>
               *   <li>component: Instance of the component</li>
               *   <li>parentElement: Empty rendered TH element</li>
               * </ul>
               * The function returns either a String or 
               * a DOM element of the content inside the header. If the developer chooses 
               * to manipulate the cell element directly, the function should return 
               * nothing. If no renderer is specified, the Table will treat the header data as a String.
               * @expose 
               * @public 
               * @instance
               * @memberof! oj.ojTable 
               * @default <code class="prettyprint">null</code>
               */
              headerRenderer: null, 
              /** 
               * The default CSS styling to apply to the column header text.
               * @expose 
               * @public 
               * @instance
               * @memberof! oj.ojTable 
               * @default <code class="prettyprint">null</code>
               */
              headerStyle: null,
              /** 
               * Default text to display in the header of the column.
               * @expose 
               * @public 
               * @instance
               * @memberof! oj.ojTable 
               * @default <code class="prettyprint">null</code>
               */
              headerText: null,
              /** 
               * Whether or not the column is sortable. 
               * <p>
               * A sortable column has a clickable header that (when clicked) 
               * sorts the table by that column's property. Note that 
               * in order for a column to be sortable, this attribute 
               * must be set to "enabled" and the underlying model must 
               * support sorting by this column's property. If this attribute
               * is set to "auto" then the column will be sortable if the
               * underlying model supports sorting. A value of "none" will
               * disable sorting on the column.
               * @expose 
               * @public 
               * @instance
               * @memberof! oj.ojTable 
               * @default <code class="prettyprint">"auto"</code>
               */
              sortable: 'auto',
              /** 
               * Default property that the framework uses to 
               * sort the Table's data.
               * @expose 
               * @public 
               * @instance
               * @memberof! oj.ojTable 
               * @default <code class="prettyprint">null</code>
               */
              sortProperty: null,
              /** 
               * Default CSS styling to apply to the column cells
               * @expose 
               * @public 
               * @instance
               * @memberof! oj.ojTable 
               * @default <code class="prettyprint">null</code>
               */
              style: null
            },
            /**
              * Triggered when the active row is changed via the <code class="prettyprint">activeRow()</code> method or via the UI.
              *
              * @expose 
              * @event 
              * @memberof! oj.ojTable
              * @instance
              * @property {Event} event <code class="prettyprint">jQuery</code> event object
              * @property {Object} ui Parameters
              * @property {number} ui.newRowIndex the new row index of the active row
              * @property {number} ui.oldRowIndex the old row index of the active row
              * 
              * @example <caption>Initialize the table with the <code class="prettyprint">activeRow</code> callback specified:</caption>
              * $( ".selector" ).ojTable({
              *     "activeRow": function( event, data ) {}
              * });
              *
              * @example <caption>Bind an event listener to the <code class="prettyprint">ojactiverow</code> event:</caption>
              * $( ".selector" ).on( "ojactiverow", function( event, data ) {} );
              */
            activeRow: null,
            /**
              * Triggered before the active row is changed via the <code class="prettyprint">activeRow()</code> method or via the UI.
              *
              * @expose 
              * @event 
              * @memberof! oj.ojTable
              * @instance
              * @property {Event} event <code class="prettyprint">jQuery</code> event object
              * @property {Object} ui Parameters
              * @property {number} ui.newRowIndex the new row index of the active row
              * @property {number} ui.oldRowIndex the old row index of the active row
              * 
              * @example <caption>Initialize the table with the <code class="prettyprint">preActiveRow</code> callback specified:</caption>
              * $( ".selector" ).ojTable({
              *     "preActiveRow": function( event, data ) {}
              * });
              *
              * @example <caption>Bind an event listener to the <code class="prettyprint">ojpreactiverow</code> event:</caption>
              * $( ".selector" ).on( "ojpreactiverow", function( event, data ) {} );
              */
            preActiveRow: null,
            /**
              * Triggered when selection is changed via the <code class="prettyprint">selection()</code> method or via the UI.
              *
              * @expose 
              * @event 
              * @memberof! oj.ojTable
              * @instance
              * @property {Event} event <code class="prettyprint">jQuery</code> event object
              * @property {Object} ui Parameters
              * @property {Array} ui.selection the table selection object
              * 
              * @example <caption>Initialize the table with the <code class="prettyprint">select</code> callback specified:</caption>
              * $( ".selector" ).ojTable({
              *     "select": function( event, data ) {}
              * });
              *
              * @example <caption>Bind an event listener to the <code class="prettyprint">ojselect</code> event:</caption>
              * $( ".selector" ).on( "ojselect", function( event, data ) {} );
              */
            select: null,
            /**
              * Triggered when the table scrollbars are scrolled via the <code class="prettyprint">scrollTop()</code> method or via the UI.
              *
              * @expose 
              * @event 
              * @memberof! oj.ojTable
              * @instance
              * @property {Event} event <code class="prettyprint">jQuery</code> event object
              * @property {Object} ui Parameters
              * @property {number} ui.scrollLeft the scrollLeft value in px
              * @property {number} ui.scrollTop the scrollTop value in px
              * 
              * @example <caption>Initialize the table with the <code class="prettyprint">scroll</code> callback specified:</caption>
              * $( ".selector" ).ojTable({
              *     "scroll": function( event, data ) {}
              * });
              *
              * @example <caption>Bind an event listener to the <code class="prettyprint">ojscroll</code> event:</caption>
              * $( ".selector" ).on( "ojscroll", function( event, data ) {} );
              */
            scroll: null
        },
      /**
       * @const
       */
      _BUNDLE_KEY:
        {
          _MSG_FETCHING_DATA:                             'msgFetchingData',
          _MSG_NO_DATA:                                   'msgNoData',
          _LABEL_SELECT_COLUMN:                           'labelSelectColumn',
          _LABEL_SELECT_ROW:                              'labelSelectRow',
          _ERR_COLUMN_RENDERER_COLUMN_NOT_FOUND_SUMMARY:  'columnRendererColumnNotFound.summary',
          _ERR_COLUMN_RENDERER_COLUMN_NOT_FOUND_DETAIL:   'columnRendererColumnNotFound.detail',
          _ERR_COLUMN_RENDERER_OPTION_REQUIRED_SUMMARY:   'columnRendererOptionRequired.summary',
          _ERR_COLUMN_RENDERER_OPTION_REQUIRED_DETAIL:    'columnRendererOptionRequired.detail',
          _ERR_PREACTIVEROW_ERROR_SUMMARY:                'preActiveRowError.summary',
          _ERR_PREACTIVEROW_ERROR_DETAIL:                 'preActiveRowError.detail',
          _ERR_ACTIVEROW_UNAVAILABLE_INDEX_SUMMARY:       'activeRowUnavailableIndex.summary',
          _ERR_ACTIVEROW_UNAVAILABLE_INDEX_DETAIL:        'activeRowUnavailableIndex.detail',
          _ERR_REFRESHROW_INVALID_INDEX_SUMMARY:          'refreshRowInvalidRowIndex.summary',
          _ERR_REFRESHROW_INVALID_INDEX_DETAIL:           'refreshRowInvalidRowIndex.detail',
          _ERR_DATA_INVALID_TYPE_SUMMARY:                 'dataInvalidType.summary',
          _ERR_DATA_INVALID_TYPE_DETAIL:                  'dataInvalidType.detail'
        },
      /**
       * @private
       * @const
       * @type {string}
       */
      _COLUMN_HEADER_ID:                                  '_headerColumn',
      /**
       * @private
       * @const
       * @type {string}
       */
      _COLUMN_HEADER_TEXT_ID:                             '_headerColumnText',
      /**
       * @private
       * @const
       * @type {string}
       */
      _COLUMN_HEADER_ASC_ID:                              '_headerColumnAsc',
      /**
       * @private
       * @const
       * @type {string}
       */
      _COLUMN_HEADER_DSC_ID:                              '_headerColumnDsc',
      /**
       * @private
       * @const
       * @type {string}
       */
      _COLUMN_HEADER_ID_PREFIX:                           '_hdrCol',
      /**
       * @private
       * @const
       * @type {string}
       */
      _OPTION_AUTO:                                       'auto',
      /**
       * @private
       * @const
       * @type {string}
       */
      _OPTION_ENABLED:                                    'enabled',
      /**
       * @private
       * @const
       * @type {string}
       */
      _OPTION_DISABLED:                                   'disabled',
      /**
       * @private
       * @const
       * @type {string}
       */
      _OPTION_NONE:                                       'none',
      /**
       * @private
       * @const
       */
      _OPTION_SELECTION_MODES:
        {
          _SINGLE:                                        'single',
          _MULTIPLE:                                      'multiple'
        },
      /**
       * @private
       * @const
       */
      _COLUMN_SORT_ORDER:
        {
          _ASCENDING:                                     'ascending',
          _DESCENDING:                                    'descending'
        },
      /**
       * @private
       * @const
       */
      _KEYBOARD_CODES:
        {
          _KEYBOARD_CODE_CTRL:                            17,
          _KEYBOARD_CODE_SHIFT:                           16,
          _KEYBOARD_CODE_SPACEBAR:                        32,
          _KEYBOARD_CODE_ENTER:                           13,
          _KEYBOARD_CODE_UP:                              38,
          _KEYBOARD_CODE_DOWN:                            40,
          _KEYBOARD_CODE_LEFT:                            37,
          _KEYBOARD_CODE_RIGHT:                           39,
          _KEYBOARD_CODE_HOME:                            36,
          _KEYBOARD_CODE_END:                             35,
          _KEYBOARD_CODE_TAB:                             9,
          _KEYBOARD_CODE_ESC:                             27,
          _KEYBOARD_MODIFIER_SHIFT:                       'shiftKey'
        },
      /**** start Public APIs ****/

      /**
       * Get or update the active row. If called with no arguments then returns
       * the current active row index. If called iwth -1 then resets the activeRow.
       * If selection argument is specified then sets the active row. A preactiverow 
       * event is fired before the active row is changed,. If that event results in
       * an error then the actove row will not be changed.
       * @expose
       * @memberof! oj.ojTable
       * @instance
       * @param {number} index  Row index. 
       * @return {number} Index of active row or -1 if no active row.
       * @throws {Error}
       * @export
       * @example <caption>Invoke the <code class="prettyprint">activeRow</code> method:</caption>
       * $( ".selector" ).ojTable( "activeRow", 1 );
       */
      'activeRow': function(index)
      {
        var data = this._getData();
        // if no data then bail
        if (!data)
        {
          return -1;
        }

        if (index != null)
        {
          if (this._activeRowIndex != index)
          {
            // if new active row is different from the existing one then trigger
            // an event
            var oldIndex = this._activeRowIndex;
            try
            {
              this._trigger('preactiverow', null, {'newRowIndex': index, 'oldRowIndex': oldIndex});
            }
            catch (err)
            {
              // caught an error. Do not change active row
              var errSummary = this.getTranslatedString(this._BUNDLE_KEY._ERR_PREACTIVEROW_ERROR_SUMMARY);
              var errDetail = this.getTranslatedString(this._BUNDLE_KEY._ERR_PREACTIVEROW_ERROR_DETAIL, {'error': err.toString()});
              throw new oj.Message(errSummary, errDetail, oj.Message.SEVERITY_LEVEL['ERROR']);
            }
            this._activeRowIndex = index;
            this._trigger('activerow', null, {'newRowIndex': index, 'oldRowIndex': oldIndex});
            this._setRowFocus(index, true, null);
          }
          return index;
        }
        else if (this._activeRowIndex != null)
        {
          return this._activeRowIndex;
        }

        return -1;
      },
      /**
       * Get the column metadata
       * @expose
       * @memberof! oj.ojTable
       * @instance
       * @param {number} columnIdx  Column index of the column. Null returns all columns
       * @return {Object|null} Column metadata or null if not found
       * @export
       * @example <caption>Invoke the <code class="prettyprint">columnMetaData</code> method:</caption>
       * $( ".selector" ).ojTable( "columnMetaData", "columnId1" );
       */
      'columnMetaData': function(columnIdx)
      {
        var columns = this._getColumnDefs();

        if (columnIdx === null || arguments.length == 0)
        {
          return columns;
        }
        else
        {
          return columns[columnIdx];
        }
      },
      /**
       * Refresh the table.
       * @expose
       * @memberof! oj.ojTable
       * @instance
       * @export
       * @example <caption>Invoke the <code class="prettyprint">refresh</code> method:</caption>
       * $( ".selector" ).ojTable( "refresh" );
       */
      'refresh': function()
      {
        this._super();
        // When a programmatic refresh is called, clear any cached
        // table dimenions because they may have been re-specified
        this._clearCachedTableDimensions();
        this._refresh();
      },
      /**
       * Refresh a row in the table.
       * @expose
       * @memberof! oj.ojTable
       * @instance
       * @param {number} rowIdx  Index of the row to refresh.
       * @return {boolean} true if refreshed, false if not
       * @throws {Error}
       * @export
       * @example <caption>Invoke the <code class="prettyprint">refreshRow</code> method:</caption>
       * $( ".selector" ).ojTable( "refreshRow", 1 );
       */
      'refreshRow': function(rowIdx)
      {
        var data = this._getData();
        // if no data then bail
        if (!data)
        {
          return false;
        }

        if (isNaN(rowIdx) || rowIdx < 0 || rowIdx > data.size() - 1)
        {
          // validate rowIdx value
          var errSummary = this.getTranslatedString(this._BUNDLE_KEY._ERR_REFRESHROW_INVALID_INDEX_SUMMARY);
          var errDetail = this.getTranslatedString(this._BUNDLE_KEY._ERR_REFRESHROW_INVALID_INDEX_DETAIL, {'rowIdx': rowIdx.toString()});
          throw new oj.Message(errSummary, errDetail, oj.Message.SEVERITY_LEVEL['ERROR']);
        }

        // get row at rowIdx
        var row = data.at(rowIdx);
        if (row == null)
        {
          return false;
        }
        // refresh table row DOM with row
        try
        {
          this._refreshTableBodyRow(rowIdx, row);
        }
        catch (e)
        {
          throw e;
        }
        return true;
      },
      /**
       * Get or update the table selection. If called with no arguments then returns
       * the current selection which is an Array of ranges. Ranges consist of start and end
       * objects which contain row and column indexes.
       * If selection argument is specified then sets the selection.
       * @expose
       * @memberof! oj.ojTable
       * @instance
       * @param {Array} selection  Array of range objects. 
       * @return {Array|null} array of Range objects or null if no selection
       * @export
       * @example <caption>Invoke the <code class="prettyprint">selection</code> method:</caption>
       * $( ".selector" ).ojTable( "selection", mySelection );
       */
      'selection': function(selection)
      {
        if (selection != null)
        {
          // first clear currently selected rows
          this._clearSelectedRows();
          // we need to set the selection
          var i, j, rangeObj, startRowIdx, endRowIdx, startColumnIdx, endColumnIdx;
          for (i = 0; i < selection.length; i++)
          {
            rangeObj = selection[i];

            if (rangeObj['start'] == null || rangeObj['end'] == null)
            {
              console.log('Error: Invalid range object in selection. Both start and end objects must be specified');
              return null;
            }

            startRowIdx = rangeObj['start']['row'];
            endRowIdx = rangeObj['end']['row'];
            startColumnIdx = rangeObj['start']['column'];
            endColumnIdx = rangeObj['end']['column'];

            if (startRowIdx != null && endRowIdx != null && startColumnIdx != null && endColumnIdx != null)
            {
              console.log('Error: Invalid range object in selection - Can only support row or column selection. Not both');
              return null;
            }
            if (startRowIdx != null && endRowIdx != null)
            {
              // this is a row based selection
              for (j = startRowIdx; j <= endRowIdx; j++)
              {
                try
                {
                  this._setRowSelection(j, true, null);
                }
                catch (e)
                {
                  console.log('Error: ' + e);
                }
              }
            }
            else if (startColumnIdx != null && endColumnIdx != null)
            {
              // this is a column based selection
              for (j = startColumnIdx; j <= endColumnIdx; j++)
              {
                try
                {
                  this._setHeaderColumnSelection(j, true, null);
                }
                catch (e)
                {
                  console.log('Error: ' + e);
                }
              }
            }
            else
            {
              console.log('Error: Invalid range object in selection - \n\
                                  start row: ' + startRowIdx + '\n\
                                  end row: ' + endRowIdx + '\n\
                                  start column: ' + startColumnIdx + '\n\
                                  end column: ' + endColumnIdx);
              return null;
            }
          }
          return this['selection']();
        }
        else
        {
          var selectedRowIdxs = this._getSelectedRowIdxs();
          var selectedColumnIdxs = this._getSelectedHeaderColumnIdxs();
          var selectionIdxs = null;
          var rowSelection = true;
          if (selectedRowIdxs != null && selectedRowIdxs.length > 0)
          {
            selectionIdxs = selectedRowIdxs;
          }
          else if (selectedColumnIdxs != null && selectedColumnIdxs.length > 0)
          {
            selectionIdxs = selectedColumnIdxs;
            rowSelection = false;
          }
          else
          {
            return null;
          }

          var rangeArray = [];

          // first count the number of ranges we have by seeing how many
          // non-continguous selections we have
          var rangeCount = 0;
          var previousIdx = null;
          var rangeObj, selectionIdx;
          var i;
          for (i = 0; i < selectionIdxs.length; i++)
          {
            selectionIdx = selectionIdxs[i];
            if (i == 0)
            {
              rangeObj = [];
              rangeObj['start'] = [];
              rangeObj['end'] = [];
              if (rowSelection)
              {
                rangeObj['start']['row'] = selectionIdx;
                rangeObj['end']['row'] = selectionIdx;
              }
              else
              {
                rangeObj['start']['column'] = selectionIdx;
                rangeObj['end']['column'] = selectionIdx;
              }
              rangeArray[0] = rangeObj;
            }
            else
            {
              rangeObj = rangeArray[rangeCount];
              if (rowSelection)
              {
                rangeObj['end']['row'] = selectionIdx;
              }
              else
              {
                rangeObj['end']['column'] = selectionIdx;
              }
              if (selectionIdx != previousIdx + 1)
              {
                if (rowSelection)
                {
                  rangeObj['end']['row'] = previousIdx;
                  rangeObj = [];
                  rangeObj['start'] = [];
                  rangeObj['end'] = [];
                  rangeObj['start']['row'] = selectionIdx;
                  rangeObj['end']['row'] = selectionIdx;
                }
                else
                {
                  rangeObj['end']['column'] = previousIdx;
                  rangeObj = [];
                  rangeObj['start'] = [];
                  rangeObj['end'] = [];
                  rangeObj['start']['column'] = selectionIdx;
                  rangeObj['end']['column'] = selectionIdx;
                }
                rangeCount++;
                rangeArray[rangeCount] = rangeObj;
              }
            }
            previousIdx = selectionIdx;
          }
          return rangeArray;
        }
      },
      /**
       * Get or update scroll left position.
       * @expose
       * @memberof! oj.ojTable
       * @instance
       * @param {number} value  ScrollLeft value. 
       * @return {number|null} ScrollLeft value. 
       * @export
       * @example <caption>Invoke the <code class="prettyprint">scrollLeft</code> method:</caption>
       * $( ".selector" ).ojTable( "scrollLeft", 100 );
       */
      'scrollLeft': function(value)
      {
        if (value != null)
        {
          if (isNaN(value) || value < 0)
          {
            // validate value
            console.log('Error: Invalid scrollLeft value: ' + value);
            return null;
          }
          this._getTableDomUtils().getScroller().scrollLeft(value);
        }
        return this._getTableDomUtils().getScroller().scrollLeft();
      },
      /**
       * Get or update scroll top position.
       * @expose
       * @memberof! oj.ojTable
       * @instance
       * @param {number} value  ScrollTop value. 
       * @return {number|null} ScrollTop value. 
       * @export
       * @example <caption>Invoke the <code class="prettyprint">scrollTop</code> method:</caption>
       * $( ".selector" ).ojTable( "scrollTop", 100 );
       */
      'scrollTop': function(value)
      {
        if (value != null)
        {
          if (isNaN(value) || value < 0)
          {
            // validate value
            console.log('Error: Invalid scrollTop value: ' + value);
            return null;
          }
          this._getTableDomUtils().getScroller().scrollTop(value);
        }
        return this._getTableDomUtils().getScroller().scrollTop();
      },
      /**** end Public APIs ****/

      /**** start internal widget functions ****/

      /**
       * @override
       * @protected
       * @instance
       * @memberof! oj.ojTable
       */
      _ComponentCreate : function ()
      {
        this._super();
        this._draw();
        this._registerCustomEvents();
        this._on(this._events);
        // register event listeners for table on the datasource so that the table
        // component is notified when rows are added, deleted, etc from the datasource.
        this._registerDomEventListeners();
        this._registerDataSourceEventListeners();
      },
      /**
       * @override
       * @private
       */
      _destroy: function()
      {
        var data = this._getData();
        // unregister the listeners on the datasource
        if (this._dataSourceEventHandlers != null && data != null)
        {
          var i;
          for (i = 0; i < this._dataSourceEventHandlers.length; i++)
            data.off(this._dataSourceEventHandlers[i].eventType, this._dataSourceEventHandlers[i].eventHandler);
        }
        
        this._getTableDomUtils().getTableBody().removeAttr(oj.Components._OJ_CONTAINER_ATTR);

        this.element.children().remove('.' + oj.TableDomUtils.CSS_CLASSES._TABLE_HEADER_CLASS);
        this.element.children().remove('.' + oj.TableDomUtils.CSS_CLASSES._TABLE_BODY_CLASS);
        this.element.children().remove('.' + oj.TableDomUtils.CSS_CLASSES._TABLE_STATUS_MESSAGE_CLASS);

        var tableContainer = this._getTableDomUtils().getTableContainer();
        if (tableContainer != null)
        {
          // add the table back tgo the parent element and remove the 
          // tableContainer div
          tableContainer[0].parentNode.appendChild(this.element);
          tableContainer[0].parentNode.removeChild(tableContainer[0]);
        }
        this.element.removeClass(oj.TableDomUtils.CSS_CLASSES._TABLE_CLASS);
      },
      /**
       * @override
       * @private
       */
      _draw: function()
      {
        var options = this.options;

        this._tableHeight = this.element.height();
        this._tableWidth = this.element.width();
        // add main css class to element
        this.element.addClass(oj.TableDomUtils.CSS_CLASSES._TABLE_CLASS);

        // create the initial table structure
        this._getTableDomUtils().createInitialTable(this._isTableHeaderless(), 
                                                    this._isTableFooterless(), 
                                                    this._handleContextMenuBeforeShow.bind(this), 
                                                    this._handleContextMenuSelect.bind(this));
        // style the initial table structure
        this._getTableDomUtils().styleInitialTable();

        // populate the table header DOM with header content
        this._refreshTableHeader();

        // populate the table footer DOM with footer content
        this._refreshTableFooter();

        // resize the table dimensions to accomodate the completed tableheader
        this._getTableDomUtils().refreshTableDimensions();

        if (this.options.disabled)
        {
          this.disable();
        }
        
        this._registerResizeListener(this._getTableDomUtils().getTableContainer());
      },
      /**
       * @override
       * @private
       */
      _events:
        {
          /**
           * Reset the keyboard state on blur and set the inactive
           * selected rows
           */
          'blur': function(event)
          {
            // make sure the blur isn't for a focus to an element within
            // the table
            var table = this._getTableDomUtils().getTable();
            if (table.has(event.relatedTarget).length > 0)
            {
              return;
            }
            // In FF we check explicitOriginalTarget
            else if (event.originalEvent != null && event.originalEvent.explicitOriginalTarget == table[0])
            {
              return;
            }

            this._clearKeyboardKeys();
            this._setTableNavigationMode(false);
          },
          /**
           * Capture acc selected column event
           */
          'click .oj-table-checkbox-acc-select-column': function(event)
          {
            var columnIdx = this._getTableDomUtils().getElementColumnIdx($(event.currentTarget));
            var selected = $(event.currentTarget).is(':checked');
            // if selected then focus on the column
            if (selected)
            {
              this._setHeaderColumnFocus(columnIdx, true, null);
            }
            this._setHeaderColumnSelection(columnIdx, selected, event.currentTarget, event);
            event.stopPropagation();
          },
          /**
           * Capture acc selected row event
           */
          'click .oj-table-checkbox-acc-select-row': function(event)
          {
            var rowIdx = this._getTableDomUtils().getElementRowIdx($(event.currentTarget));
            var selected = $(event.currentTarget).is(':checked');
            // if selected then focus on the row
            if (selected)
            {
              this._setRowFocus(rowIdx, true, null);
            }
            this._setRowSelection(rowIdx, selected, event.currentTarget, event);
            event.stopPropagation();
          },
          /**
           * Capture keyboard down events
           */
          'keydown': function(event)
          {
            // ignore key event on the footer
            if (this._getTableDomUtils().getTableFooter() != null && 
                this._getTableDomUtils().getTableFooter().has(event.target).length > 0)
            {
              return;
            }
            this._addKeyboardKey(event.keyCode);
            // process single or two key events
            if (this._getKeyboardKeys().length == 1 ||
              this._getKeyboardKeys().length == 2)
            {
              if (this._isKeyboardKeyPressed(this._KEYBOARD_CODES._KEYBOARD_CODE_UP) ||
                this._isKeyboardKeyPressed(this._KEYBOARD_CODES._KEYBOARD_CODE_DOWN) ||
                this._isKeyboardKeyPressed(this._KEYBOARD_CODES._KEYBOARD_CODE_SPACEBAR) ||
                this._isKeyboardKeyPressed(this._KEYBOARD_CODES._KEYBOARD_CODE_HOME) ||
                this._isKeyboardKeyPressed(this._KEYBOARD_CODES._KEYBOARD_CODE_END))
              {
                event.preventDefault();
                event.stopPropagation();
              }

              if (this._isKeyboardKeyPressed(this._KEYBOARD_CODES._KEYBOARD_CODE_UP) ||
                this._isKeyboardKeyPressed(this._KEYBOARD_CODES._KEYBOARD_CODE_DOWN))
              {
                this._handleKeydownUpDown(event);
              }
              else if (this._isKeyboardKeyPressed(this._KEYBOARD_CODES._KEYBOARD_CODE_LEFT) ||
                this._isKeyboardKeyPressed(this._KEYBOARD_CODES._KEYBOARD_CODE_RIGHT))
              {
                this._handleKeydownLeftRight(event);
              }
              else if (this._isKeyboardKeyPressed(this._KEYBOARD_CODES._KEYBOARD_CODE_TAB))
              {
                this._handleKeydownTab(event);
              }
            }
          },
          /**
           * Capture keyboard up events
           */
          'keyup': function(event)
          {
            // ignore key event on the footer
            if (this._getTableDomUtils().getTableFooter() != null && 
                this._getTableDomUtils().getTableFooter().has(event.target).length > 0)
            {
              return;
            }
            // process single or 2 key events
            if (this._getKeyboardKeys().length == 1)
            {
              var keyboardCode1 = this._getKeyboardKeys()[0];

              if (keyboardCode1 == this._KEYBOARD_CODES._KEYBOARD_CODE_SPACEBAR)
              {
                this._handleKeyupSpacebar(event);
              }
              else if (keyboardCode1 == this._KEYBOARD_CODES._KEYBOARD_CODE_ENTER)
              {
                this._handleKeyupEnter(event);
              }
              else if (keyboardCode1 == this._KEYBOARD_CODES._KEYBOARD_CODE_HOME)
              {
                this._handleKeyupHome(event);
              }
              else if (keyboardCode1 == this._KEYBOARD_CODES._KEYBOARD_CODE_END)
              {
                this._handleKeyupEnd(event);
              }
              else if (keyboardCode1 == this._KEYBOARD_CODES._KEYBOARD_CODE_ESC)
              {
                this._handleKeyupEsc(event);
              }
            }
            // remove the keycode from our internal list of pressed keys.
            this._removeKeyboardKey(event.keyCode);
          },
          /**
           * show the ascending/descending links when the mouse 
           * enters a column header
           */
          'mouseenter .oj-table-column-header': function(event)
          {
            // get the column index of the header element
            var columnIdx = this._getTableDomUtils().getElementColumnIdx($(event.currentTarget));
            // show the asc/dsc links for the header
            this._showTableHeaderColumnSortLink(columnIdx, true);
            this._showTableHeaderColumnSortLink(columnIdx, false);
          },
          /**
           * hide the ascending/descending links when the mouse 
           * leaves a column header
           */
          'mouseleave .oj-table-column-header': function(event)
          {
            // get the column index of the header element
            var columnIdx = this._getTableDomUtils().getElementColumnIdx($(event.currentTarget));
            // hide the asc/dsc links for the header
            this._hideTableHeaderColumnSortLink(columnIdx, true);
            this._hideTableHeaderColumnSortLink(columnIdx, false);
          },
          /**
           * show the row hover when the mouse enters a table cell
           */
          'mouseenter .oj-table-data-cell': function(event)
          {
            // get the row index of the cell element
            var rowIdx = this._getTableDomUtils().getElementRowIdx($(event.currentTarget));
            // set row hover
            this._updateRowCellsClass(rowIdx, {hover: true});
          },
          /**
           * hide the row hover when the mouse leaves a table cell
           */
          'mouseleave .oj-table-data-cell': function(event)
          {
            // get the row index of the cell element
            var rowIdx = this._getTableDomUtils().getElementRowIdx($(event.currentTarget));
            // unset row hover
            this._updateRowCellsClass(rowIdx, {hover: false});
          },
          /**
           * invoke a sort on the column data when the mouse clicks the ascending link
           */
          'click .oj-table-column-header-asc-link': function(event)
          {
            this._checkFocus();
            var columnIdx = this._getTableDomUtils().getElementColumnIdx($(event.target));
            this._handleSortTableHeaderColumn(columnIdx, true);
            event.preventDefault();
            event.stopPropagation();
          },
          'click .oj-table-column-header-acc-asc-link': function(event)
          {
            this._checkFocus();
            var columnIdx = this._getTableDomUtils().getElementColumnIdx($(event.target));
            this._handleSortTableHeaderColumn(columnIdx, true);
            event.preventDefault();
            event.stopPropagation();
          },
          /**
           * invoke a sort on the column data when the mouse clicks the descending link
           */
          'click .oj-table-column-header-dsc-link': function(event)
          {
            this._checkFocus();
            var columnIdx = this._getTableDomUtils().getElementColumnIdx($(event.target));
            this._handleSortTableHeaderColumn(columnIdx, false);
            event.preventDefault();
            event.stopPropagation();
          },
          'click .oj-table-column-header-acc-dsc-link': function(event)
          {
            this._checkFocus();
            var columnIdx = this._getTableDomUtils().getElementColumnIdx($(event.target));
            this._handleSortTableHeaderColumn(columnIdx, false);
            event.preventDefault();
            event.stopPropagation();
          },
          /**
           * set the row focus or selection when the mouse clicks on a cell.
           * Ctrl + click results in selection and focus. Plain click results in focus.
           * Plain click on a selected row removes the selection.
           */
          'click .oj-table-data-cell': function(event)
          {
            this._checkFocus();
            // get the row index of the cell element
            var rowIdx = this._getTableDomUtils().getElementRowIdx($(event.currentTarget));
            // set the row focus
            this._setRowFocus(rowIdx, true, event.currentTarget);
            // check if we are selecting
            if (this._getKeyboardKeys().length == 1)
            {
              if (this._getKeyboardKeys()[0] == this._KEYBOARD_CODES._KEYBOARD_CODE_SHIFT)
              {
                var lastSelectedRowIdx = this._getLastRowSelection();
                if (lastSelectedRowIdx != null)
                {
                  // shift selection is always from the last selected row
                  if (rowIdx < lastSelectedRowIdx)
                  {
                    var i;
                    for (i = rowIdx; i <= lastSelectedRowIdx; i++)
                    {
                      this._setRowSelection(i, true, event.currentTarget, event);
                    }
                  }
                  else
                  {
                    var i;
                    for (i = lastSelectedRowIdx; i <= rowIdx; i++)
                      this._setRowSelection(i, true, event.currentTarget, event);
                  }
                }
              }
              else if (this._getKeyboardKeys()[0] == this._KEYBOARD_CODES._KEYBOARD_CODE_CTRL)
              {
                this._setRowSelection(rowIdx, !this._getRowSelection(rowIdx), event.currentTarget, event);
              }
            }
            else if (this._getKeyboardKeys().length == 0)
            {
              this._setRowSelection(rowIdx, !this._getRowSelection(rowIdx), event.currentTarget, event);
            }
          },
          /**
           * set the column header selection and focus. Plain click results in
           * focus and selection. If Ctrl is not pressed then we have single column selection.
           */
          'click .oj-table-column-header': function(event)
          {
            this._checkFocus();
            // get the column index
            var columnIdx = this._getTableDomUtils().getElementColumnIdx($(event.currentTarget));
            // set the column focus
            this._setHeaderColumnFocus(columnIdx, true, event.currentTarget);
            // check if we are selecting
            if (this._getKeyboardKeys().length == 1)
            {
              if (this._getKeyboardKeys()[0] == this._KEYBOARD_CODES._KEYBOARD_CODE_SHIFT)
              {
                var lastSelectedColumnIdx = this._getLastHeaderColumnSelection();
                if (lastSelectedColumnIdx != null)
                {
                  // shift selection is always from the last selected column
                  if (columnIdx < lastSelectedColumnIdx)
                  {
                    var i;
                    for (i = columnIdx; i <= lastSelectedColumnIdx; i++)
                    {
                      this._setHeaderColumnSelection(i, true, event.currentTarget, event);
                    }
                  }
                  else
                  {
                    var i;
                    for (i = lastSelectedColumnIdx; i <= columnIdx; i++)
                      this._setHeaderColumnSelection(i, true, event.currentTarget, event);
                  }
                }
              }
              else if (this._getKeyboardKeys()[0] == this._KEYBOARD_CODES._KEYBOARD_CODE_CTRL)
              {
                this._setHeaderColumnSelection(columnIdx, !this._getHeaderColumnSelection(columnIdx), event.currentTarget, event);
              }
            }
            else if (this._getKeyboardKeys().length == 0)
            {
              this._setHeaderColumnSelection(columnIdx, !this._getHeaderColumnSelection(columnIdx), event.currentTarget, event);
            }
            event.preventDefault();
          }
        },
      /**
       * @override
       * @private
       */
      _refresh: function()
      {
        this._clearCachedMetadata();
        this._clearCachedDataMetadata();
        var self = this;
        setTimeout(function()
        {
          self._refreshAll()
        }, 0);
      },
      /**
       * @override
       * @private
       */
      _setOption: function(key, value)
      {
        this._super(key, value);
        this._refresh();
      },
      /**** end internal widget functions ****/

      /**** start internal functions ****/

      /**
       * Add a keyCode to internally track pressed keys. keyCodes should be added on 
       * mouse down and then later removed on mouse up.
       * @param {number} keyCode  KeyCode of the keyboard key.
       * @private
       */
      _addKeyboardKey: function(keyCode)
      {
        var foundCode = false;
        for (var prop in this._KEYBOARD_CODES)
        {
          if (this._KEYBOARD_CODES.hasOwnProperty(prop))
          {
            if (this._KEYBOARD_CODES[prop] == keyCode)
            {
              foundCode = true;
            }
          }
        }

        if (!foundCode)
        {
          // only add keys we are interested in
          return;
        }

        var keyboardKeys = this._getKeyboardKeys();
        var found = false;
        var i;
        for (i = 0; i < keyboardKeys.length; i++)
        {
          if (keyboardKeys[i] == keyCode)
          {
            found = true;
            break;
          }
        }
        if (!found)
        {
          keyboardKeys.push(keyCode);
        }
      },
      /**
       * Check the focus is on the table or descendent focusable element
       * @private
       */
      _checkFocus: function()
      {
        // set focus on the table
        if (!this._isFocused())
        {
          // only focus if focus is not on some child element of table
          this._getTableDomUtils().getTable().focus();
        }
      },
      /**
       * Clear any cached metadata
       * @private
       */
      _clearCachedMetadata: function()
      {
        this._columnDefArray = null;
        this._setTableNavigationMode(false);
      },
      /**
       * Clear any cached data metadata
       * @private
       */
      _clearCachedDataMetadata: function()
      {
        this._data = null;
      },
      /**
       * Clear any cached table dimensions
       * @private
       */
      _clearCachedTableDimensions: function()
      {
        this._tableHeight = null;
        this._tableWidth = null;
      },
      /**
       * Clear any keyboard keys
       * @private
       */
      _clearKeyboardKeys: function()
      {
        this._keyboardKeys = [];
      },
      /**
       * Clear the focused column header
       * @private
       */
      _clearFocusedHeaderColumn: function()
      {
        var focusedHeaderColumnIdx = this._getFocusedHeaderColumnIdx();
        if (focusedHeaderColumnIdx != null)
        {
          this._setHeaderColumnFocus(focusedHeaderColumnIdx, false, null);
        }
      },
      /**
       * Clear the focused row
       * @private
       */
      _clearFocusedRow: function()
      {
        var focusedRowIdx = this._getFocusedRowIdx();
        if (focusedRowIdx != null)
        {
          this._setRowFocus(focusedRowIdx, false, null);
        }
      },
      /**
       * Clear the selected column headers
       * @private
       */
      _clearSelectedHeaderColumns: function()
      {
        var selectedHeaderColumnIdxs = this._getSelectedHeaderColumnIdxs();

        var i;
        for (i = 0; i < selectedHeaderColumnIdxs.length; i++)
        {
          this._setHeaderColumnSelection(selectedHeaderColumnIdxs[i], false, null);
        }
      },
      /**
       * Clear the selected rows
       * @private
       */
      _clearSelectedRows: function()
      {
        var selectedRowIdxs = this._getSelectedRowIdxs();

        var i;
        for (i = 0; i < selectedRowIdxs.length; i++)
          this._setRowSelection(selectedRowIdxs[i], false, null);
      },
      /**
       * Clear the sorted column header indicator. Note this does not affect the order
       * of the data. This is just to clear the UI indication.
       * @param {number} columnIdx  column index
       * @private
       */
      _clearSortedHeaderColumn: function(columnIdx)
      {
        var sortedTableHeaderColumnIdx = this._getSortedTableHeaderColumnIdx();
        if (sortedTableHeaderColumnIdx != null)
        {
          var sortedTableHeaderColumn = this._getTableDomUtils().getTableHeaderColumn(sortedTableHeaderColumnIdx);
          var sorted = sortedTableHeaderColumn.data('sorted');
          sortedTableHeaderColumn.data('sorted', null);
          
          if (sortedTableHeaderColumnIdx != columnIdx)
          {
            if (sorted == this._COLUMN_SORT_ORDER._ASCENDING)
            {
              this._hideTableHeaderColumnSortLink(sortedTableHeaderColumnIdx, true);
            }
            else
            {
              this._hideTableHeaderColumnSortLink(sortedTableHeaderColumnIdx, false);
            }
          }
          else
          {
            var sortedTableHeaderColumnAscLink = sortedTableHeaderColumn.find('.' + oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_ASC_LINK_CLASS);
            sortedTableHeaderColumnAscLink.removeClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._SELECTED);
            var sortedTableHeaderColumnDscLink = sortedTableHeaderColumn.find('.' + oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_DSC_LINK_CLASS);
            sortedTableHeaderColumnDscLink.removeClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._SELECTED);
          }
        }
      },
      /**
       * Return the column definitions
       * @return {Array} array of column metadata Objects.
       * @private
       */
      _getColumnDefs: function()
      {
        // cache the columns array in this._columnDefArray
        if (!this._columnDefArray)
        {
          this._columnDefArray = this._getColumnMetadata();
        }
        return this._columnDefArray;
      },
      /**
       * Return the column metadata in sorted oder.
       * @return {Array} array of column metadata Objects.
       * @private
       */
      _getColumnMetadata: function()
      {
        // get the columns metadata
        var columns = this.options['columns'];
        var columnsDefault = this.options['columnsDefault'];

        if ((columns.length == 0 ||
            (columns.length == 1 &&
            columns[0].id == null &&
            columns[0].headerText == null &&
            columns[0].field == null)) &&
            (columnsDefault.headerText == null &&
            columnsDefault.field == null))
        {
          return [];
        }
        
        var defaultedColumns = [];
        var i;
        for (i = 0; i < columns.length; i++)
        {
          defaultedColumns[i] = $.extend({}, columnsDefault, columns[i]);
        }

        var columnsSortedArray = [];
        // add the rest of the columns in the array
        for (i = 0; i < defaultedColumns.length; i++)
        {
          columnsSortedArray.push(defaultedColumns[i]);
        }
        
        var data = this._getData();
        var sortSupportedData = false;
        if (data != null && data.getCapability('sort') == 'full')
        {
          sortSupportedData = true;
        }

        for (i = 0; i < defaultedColumns.length; i++)
        {
          // generate ids for columns which don't have it specified
          if (columnsSortedArray[i].id == null)
          {
            columnsSortedArray[i].id = this._COLUMN_HEADER_ID_PREFIX + i;
          }
          // for the columns which have sortable = 'auto' check the datasource
          // and enable or disable
          if ((columnsSortedArray[i].sortable == null || 
               columnsSortedArray[i].sortable == this._OPTION_AUTO)
               && sortSupportedData)
          {
            columnsSortedArray[i].sortable = this._OPTION_ENABLED;
          }
        }
        return columnsSortedArray;
      },
      /**
       * Return all the column indexes for elements with a particular style class
       * @param {string} styleClass  style class
       * @return {Array} Array of column indexes
       * @private
       */
      _getColumnIdxsForElementsWithStyleClass: function(styleClass)
      {
        var elements = this._getTableDomUtils().getTable().find(styleClass);
        var columnIdxs = [];
        if (elements && elements.length > 0)
        {
          var i, j, alreadyAdded, columnIdx;
          for (i = 0; i < elements.length; i++)
          {
            columnIdx = this._getTableDomUtils().getElementColumnIdx($(elements.get(i)));

            alreadyAdded = false;
            for (j = 0; j < columnIdxs.length; j++)
            {
              if (columnIdxs[j] == columnIdx)
              {
                alreadyAdded = true;
              }
            }
            if (!alreadyAdded)
            {
              columnIdxs.push(columnIdx);
            }
          }
        }

        return columnIdxs;
      },
      /**
       * Return the column renderer
       * @param {number} columnIdx  column index
       * @param {String} type  renderer type
       * @return {Object} renderer
       * @private
       */
      _getColumnRenderer: function(columnIdx, type)
      {
        var columns = this._getColumnDefs();
        var column = columns[columnIdx];
        
        if (type == 'cell')
        {
          return column['renderer'];
        }
        else if (type == 'footer')
        {
          return column['footerRenderer'];
        }
        else if (type == 'header')
        {
          return column['headerRenderer'];
        }

        return null;
      },
      /**
       * Return the datasource object defined for this table
       * @return {Object} Datasource object.
       * @throws {Error}
       * @private
       */
      _getData: function()
      {
        if (!this._data && this.options.data != null)
        {
          var data = this.options.data;
          if (data instanceof oj.TableDataSource ||
              data instanceof oj.PagingTableDataSource)
          {
            this._data = data;
          }
          else
          {
            // we only support TableDataSource
            var errSummary = oj.Translations.getTranslatedString('oj-table.dataInvalidType.summary');
            var errDetail = oj.Translations.getTranslatedString('oj-table.dataInvalidType.detail');
            throw new oj.Message(errSummary, errDetail, oj.Message.SEVERITY_LEVEL['ERROR']);
          }
          this._dataMetadata = this.options.data;
          this._registerDataSourceEventListeners();
        }
        return this._data;
      },
      /**
       * Get the focused column header index
       * @return {number|null} the column index
       * @private
       */
      _getFocusedHeaderColumnIdx: function()
      {
        // focused column headers have the focused style class. There should only be one focused header
        return this._getColumnIdxsForElementsWithStyleClass('.' + oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_CLASS + '.' + oj.TableDomUtils.MARKER_STYLE_CLASSES._FOCUS)[0];
      },
      /**
       * Get the focused row index
       * @return {number|null} the row index
       * @private
       */
      _getFocusedRowIdx: function()
      {
        // focused rows have cells with focused style class. There should only be one focused row
        return this._getRowIdxsForElementsWithStyleClass('.' + oj.TableDomUtils.CSS_CLASSES._TABLE_DATA_ROW_CLASS + '.' + oj.TableDomUtils.MARKER_STYLE_CLASSES._FOCUS)[0];
      },
      /**
       * Return whether the column header at the index is focused
       * @param {number} columnIdx  column index
       * @return {boolean} whether it's focused
       * @private
       */
      _getHeaderColumnFocus: function(columnIdx)
      {
        return this._getHeaderColumnState(columnIdx).focused;
      },
      /**
       * Return whether the column header at the index is selected
       * @param {number} columnIdx  column index
       * @return {boolean} whether it's selected
       * @private
       */
      _getHeaderColumnSelection: function(columnIdx)
      {
        return this._getHeaderColumnState(columnIdx).selected;
      },
      /**
       * Return the column selection mode
       * @return {string|null} single, multiple, or null
       * @private
       */
      _getColumnSelectionMode: function()
      {
        var columnSelectionMode = this.options.selectionMode == null ? null : this.options.selectionMode['column'];
        return columnSelectionMode;
      },
      /**
       * Return the state of the column header at a partiocular index
       * @param {number} columnIdx  column index
       * @return {Object} Object which contains booleans focused and selected
       * @private
       */
      _getHeaderColumnState: function(columnIdx)
      {
        var headerColumn = this._getTableDomUtils().getTableHeaderColumn(columnIdx);

        return {focused: headerColumn.hasClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._FOCUS),
          selected: headerColumn.hasClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._SELECTED)};
      },
      /**
       * Return the currently pressed keyboard keys
       * @return {Array} Array of keyCodes
       * @private
       */
      _getKeyboardKeys: function()
      {
        if (!this._keyboardKeys)
        {
          this._keyboardKeys = [];
        }

        // reverse the array since we want the keybaord keys to be a LIFO stack
        return this._keyboardKeys.reverse();
      },
      /**
       * Return the last column which was selected (chronologically)
       * @return {number|null} last selected column
       * @private
       */
      _getLastHeaderColumnSelection: function()
      {
        if (this._lastSelectedColumnIdxArray != null &&
          this._lastSelectedColumnIdxArray.length > 0)
        {
          return this._lastSelectedColumnIdxArray[0];
        }
        return null;
      },
      /**
       * Return the last row which was selected (chronologically)
       * @return {number|null} last selected row
       * @private
       */
      _getLastRowSelection: function()
      {
        if (this._lastSelectedRowIdxArray != null &&
          this._lastSelectedRowIdxArray.length > 0)
        {
          return this._lastSelectedRowIdxArray[0];
        }
        return null;
      },
      /**
       * Get the element from an array of elements according to type
       * @param {Object} elements  Array of jquery elements
       * @param {string} type  DOM type
       * @return {Object|null} element
       * @private
       */
      _getJQueryElement: function(elements, type)
      {
        var i;
        for (i = 0; i < $(elements).length; i++)
        {
          if ($($(elements)[i]).is(type))
          {
            return $(elements)[i];
          }
        }
        return null;
      },
      /**
       * Return whether the row is focused
       * @param {number} rowIdx  row index
       * @return {boolean} whether the row is focused
       * @private
       */
      _getRowFocus: function(rowIdx)
      {
        return this._getTableDomUtils().getTableBodyRow(rowIdx).hasClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._FOCUS);
      },
      /**
       * Return whether the row is hovered
       * @param {number} rowIdx  row index
       * @return {boolean} whether the row is hovered
       * @private
       */
      _getRowHover: function(rowIdx)
      {
        return this._getTableDomUtils().getTableBodyRow(rowIdx).hasClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._HOVER);
      },
      /**
       * Return all the row indexes for elements with a particular style class
       * @param {string} styleClass  style class
       * @return {Array} Array of row indexes
       * @private
       */
      _getRowIdxsForElementsWithStyleClass: function(styleClass)
      {
        var elements = this._getTableDomUtils().getTable().find(styleClass);
        var rowIdxs = [];
        if (elements && elements.length > 0)
        {
          var i, j, rowIdx, alreadyAdded;
          for (i = 0; i < elements.length; i++)
          {
            rowIdx = this._getTableDomUtils().getElementRowIdx($(elements.get(i)));

            alreadyAdded = false;
            for (j = 0; j < rowIdxs.length; j++)
            {
              if (rowIdxs[j] == rowIdx)
              {
                alreadyAdded = true;
              }
            }
            if (!alreadyAdded)
            {
              rowIdxs.push(rowIdx);
            }
          }
        }

        return rowIdxs;
      },
      /**
       * Return the row renderer
       * @return {Object} renderer
       * @private
       */
      _getRowRenderer: function()
      {
        return this.options['rowRenderer'];
      },
      /**
       * Return whether the row is selected
       * @param {number} rowIdx  row index
       * @return {boolean} whether the row is selected
       * @private
       */
      _getRowSelection: function(rowIdx)
      {
        return this._getTableDomUtils().getTableBodyRow(rowIdx).hasClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._SELECTED);
      },
      /**
       * Return the row selection mode
       * @return {string|null} single, multiple, or null
       * @private
       */
      _getRowSelectionMode: function()
      {
        var rowSelectionMode = this.options['selectionMode'] == null ? null : this.options['selectionMode']['row'];
        return rowSelectionMode;
      },
      /**
       * Return the selected column header indexes
       * @return {Array} array of column header indexes
       * @private
       */
      _getSelectedHeaderColumnIdxs: function()
      {
        // selected column headers have the selected css class
        return this._getColumnIdxsForElementsWithStyleClass('.' + oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_CLASS + '.' + oj.TableDomUtils.MARKER_STYLE_CLASSES._SELECTED);
      },
      /**
       * Return the selected row indexes
       * @return {Array} array of row indexes
       * @private
       */
      _getSelectedRowIdxs: function()
      {
        // selected rows have the selected css class
        return this._getRowIdxsForElementsWithStyleClass('.' + oj.TableDomUtils.CSS_CLASSES._TABLE_DATA_ROW_CLASS + '.' + oj.TableDomUtils.MARKER_STYLE_CLASSES._SELECTED);
      },
      /**
       * Return the currnetly sorted column index
       * @return {number|null} column index
       * @private
       */
      _getSortedTableHeaderColumnIdx: function()
      {
        var tableHeaderColumns = this._getTableDomUtils().getTableHeaderColumns();

        var i, sorted;
        for (i = 0; i < tableHeaderColumns.length; i++)
        {
          // sorted column will have the sorted data attr
          sorted = $(tableHeaderColumns[i]).data('sorted');

          if (sorted != null)
          {
            return i;
          }
        }
        return null;
      },
      /**
       * Get tabbable elements within the element
       * @param {jQuery} element  DOM element
       * @return {jQuery|null} jQuery array of DOM elements
       * @private
       */
      _getTabbableElements: function(element)
      {
        var tabbableElements = element.find(':tabbable');

        if (tabbableElements != null && tabbableElements.length > 0)
        {
          return tabbableElements;
        }
        return null;
      },
      /**
       * Return table DOM utils instance
       * @return {Object} instance of table DOM utils
       * @private
       */
      _getTableDomUtils: function()
      {
        if (!this._tableDomUtils)
        {
          this._tableDomUtils = new oj.TableDomUtils(this);
        }
        return this._tableDomUtils;
      },
      /**
       * Return the number of DOM rows in the table
       * @return {number} row count.
       * @private
       */
      _getTableRowCount: function()
      {
        var rows = this._getTableDomUtils().getTableBodyRows();

        if (rows != null)
        {
          return rows.length;
        }
        return 0;
      },
      /**
       * Handle an ojbeforeshow event on the context menu. Set the position correctly for keyboard events and store the Keyboard/Mouse event that called the context menu
       * @private	 
       */
      _handleContextMenuBeforeShow: function(event, ui)
      {
        var contextMenu = this._getTableDomUtils().getContextMenu();

        this._contextMenuEvent = event['originalEvent']['originalEvent'];
        if (this._contextMenuEvent['type'] === 'keydown')
        {
          contextMenu.ojMenu("option", "menuPosition", {"my": "left top", "at": "left bottom", "of": this.contextMenuEvent['target']});
        }
        else
        {
          contextMenu.ojMenu("option", "menuPosition", {"my": "left top", "at": "left bottom"});
        }
        
        var headerColumn = this._getTableDomUtils().getFirstAncestor($(this._contextMenuEvent['target']), 'oj-table-column-header');
        var tableBodyCell = this._getTableDomUtils().getFirstAncestor($(this._contextMenuEvent['target']), 'oj-table-data-cell');
        
        if (tableBodyCell != null)
        {
          var columnIdx = this._getTableDomUtils().getElementColumnIdx(tableBodyCell);
          headerColumn = this._getTableDomUtils().getTableHeaderColumn(columnIdx);
        }

        if (headerColumn.attr('data-oj-sortable') == this._OPTION_ENABLED)
        {
          this._getTableDomUtils().getContextMenu().find('[data-oj-command=oj-table-sortAsc]').removeClass('oj-disabled');
          this._getTableDomUtils().getContextMenu().find('[data-oj-command=oj-table-sortDsc]').removeClass('oj-disabled');
        }
        else
        {
          this._getTableDomUtils().getContextMenu().find('[data-oj-command=oj-table-sortAsc]').addClass('oj-disabled');
          this._getTableDomUtils().getContextMenu().find('[data-oj-command=oj-table-sortDsc]').addClass('oj-disabled');
        }
      },
      /**
       * Handle an ojselect event on a menu item, if sort call the handler on the core.
       * If resize prompt the user with a dialog box
       * @private	 
       */
      _handleContextMenuSelect: function(event, ui)
      {
        var menuItemCommand = ui.item.attr('data-oj-command');
        var headerColumn = this._getTableDomUtils().getFirstAncestor($(this._contextMenuEvent['target']), 'oj-table-column-header');
        var tableBodyCell = this._getTableDomUtils().getFirstAncestor($(this._contextMenuEvent['target']), 'oj-table-data-cell');
        var columnIdx = null;
        
        if (headerColumn != null)
        {
          columnIdx = this._getTableDomUtils().getElementColumnIdx(headerColumn);
        }
        if (tableBodyCell != null)
        {
          columnIdx = this._getTableDomUtils().getElementColumnIdx(tableBodyCell);
        }
        if (menuItemCommand == 'oj-table-sortAsc')
        {
          this._handleSortTableHeaderColumn(columnIdx, true);
        }
        else if (menuItemCommand == 'oj-table-sortDsc')
        {
          this._handleSortTableHeaderColumn(columnIdx, false);
        }
      },
      /**
       * Callback handler for data error.
       * @param {Object} error 
       * @private
       */
      _handleDataError: function(error)
      {
        this._hideStatusMessage();
        throw error;
      },
      /**
       * Callback handler for fetch start in the datasource.
       * @param {Object} event 
       * @private
       */
      _handleDataFetchStart: function(event)
      {
        this._showStatusMessage();
      },
      /**
       * Callback handler for fetch completed in the datasource. Refresh entire
       * table body DOM and refresh the table dimensions if refresh == true. Hide the Fetching Data... 
       * status message.
       * @param {boolean} refresh
       * @private
       */
      _handleDataFetchEnd: function(refresh)
      {
        if (refresh)
        {
          this._refreshTableBody();
          this._getTableDomUtils().refreshTableDimensions();
        }
        this._hideStatusMessage();
      },
      /**
       * Callback handler for reset in the datasource. Refresh entire
       * table body DOM and refresh the table dimensions.
       * @param {Object} event 
       * @private
       */
      _handleDataReset: function(event)
      {
        this._hideStatusMessage();
        this._refreshTableBody();
        this._getTableDomUtils().refreshTableDimensions();
        this['activeRow'](-1);
      },
      /**
       * Callback handler for rows added into the datasource. Add a new tr and refresh the DOM
       * at the row index and refresh the table dimensions to accomodate the new
       * row
       * @param {Object} event
       * @private
       */
      _handleDataRowAdd: function(event)
      {
        var rowIdx = event['rowIdx'];
        var row = event['row'];
        
        if (rowIdx == null || rowIdx < 0)
        {
          rowIdx = this._getData().indexOf(row);
        }
        this._hideStatusMessage();
        var tableBodyRow = this._getTableDomUtils().createTableBodyRow(this._getRowSelectionMode());
        this._getTableDomUtils().styleTableBodyRow(tableBodyRow, this._getRowSelectionMode());
        // insert the <tr> element in to the table body DOM
        this._getTableDomUtils().insertTableBodyRow(rowIdx, tableBodyRow, row, null);
        this._refreshTableBodyRow(rowIdx, row);
        this._getTableDomUtils().refreshTableDimensions();
        this._setRowFocus(rowIdx, true, null);
      },
      /**
       * Callback handler for row change in the datasource. Refresh the changed
       * row.
       * @param {Object} event
       * @private
       */
      _handleDataRowChange: function(event)
      {
        var rowIdx = event['rowIdx'];
        var row = event['row'];
        
        if (rowIdx == null || rowIdx < 0)
        {
          rowIdx = this._getData().indexOf(row);
        }
        this._hideStatusMessage();
        this._refreshTableBodyRow(rowIdx, row);
        this._getTableDomUtils().refreshTableDimensions();
      },
      /**
       * Callback handler for row removed in the datasource. Remove the row DOM from the
       * table body by searching for the matching rowKey. New rows will have null rowKey.
       * After removing the row, refresh all the remaining row indexes since
       * they will have shifted. Lastly, refresh the table dimensions
       * @param {Object} event
       * @private
       */
      _handleDataRowRemove: function(event)
      {
        var rowIdx = event['rowIdx'];
        var row = event['row'];
        
        if (rowIdx == null || rowIdx < 0)
        {
          rowIdx = row.index;
        }
        
        this._hideStatusMessage();

        var tableBodyRows = this._getTableDomUtils().getTableBodyRows();

        if (!tableBodyRows)
        {
          return;
        }

        var i, j, tableBodyRow, deletedRow;
        for (i = 0; i < tableBodyRows.length; i++)
        {
          tableBodyRow = $(tableBodyRows[i]);
          deletedRow = null;
          if (this._getTableDomUtils().getElementRowIdx(tableBodyRow) == rowIdx)
          {
            deletedRow = tableBodyRow;
          }
          if (deletedRow != null)
          {
            deletedRow[0].parentNode.removeChild(deletedRow[0]);
            break;
          }
        }
        this._getTableDomUtils().clearCachedDomRowData();
        this._getTableDomUtils().refreshTableDimensions();
      },
      /**
       * Callback handler for sort completed in the datasource. Refresh entire
       * table body DOM and refresh the table dimensions. Set row focus to the
       * active row.
       * @param {Object} event 
       * @private
       */
      _handleDataSort: function(event)
      {
        this._hideStatusMessage();
        this._refreshTableBody();
        this._getTableDomUtils().refreshTableDimensions();
        var activeRowIdx = this['activeRow']();
        if (activeRowIdx != null)
        {
          this._setRowFocus(activeRowIdx, true, null);
        }
      },
      /**
       * Handler for Left/Right keydown.
       * @param {Object} event
       * @private
       */
      _handleKeydownLeftRight: function(event)
      {
        // pressing left/right navigates the column headers
        var focusedHeaderColumnIdx = this._getFocusedHeaderColumnIdx();
        var columns = this._getColumnDefs();

        if (focusedHeaderColumnIdx != null)
        {
          var newFocusedHeaderColumnIdx = focusedHeaderColumnIdx;

          if (this._isKeyboardKeyPressed(this._KEYBOARD_CODES._KEYBOARD_CODE_LEFT))
          {
            newFocusedHeaderColumnIdx = focusedHeaderColumnIdx > 0 ? focusedHeaderColumnIdx - 1 : focusedHeaderColumnIdx;
          }
          else if (this._isKeyboardKeyPressed(this._KEYBOARD_CODES._KEYBOARD_CODE_RIGHT))
          {
            newFocusedHeaderColumnIdx = focusedHeaderColumnIdx < columns.length - 1 ? focusedHeaderColumnIdx + 1 : focusedHeaderColumnIdx;
          }

          if (newFocusedHeaderColumnIdx != focusedHeaderColumnIdx)
          {
            this._setHeaderColumnFocus(newFocusedHeaderColumnIdx, true, null);

            if (event[this._KEYBOARD_CODES._KEYBOARD_MODIFIER_SHIFT])
            {
              // if shift is also pressed then we need to select too
              var newFocusedHeaderColumnSelection = this._getHeaderColumnSelection(newFocusedHeaderColumnIdx);
              // we may be clearing or setting the selection
              this._setHeaderColumnSelection(newFocusedHeaderColumnIdx, !newFocusedHeaderColumnSelection, null, event);
              // if we are clearing the selection, then clear the previous column too.
              if (newFocusedHeaderColumnSelection)
              {
                if (this._getHeaderColumnSelection(focusedHeaderColumnIdx))
                {
                  this._setHeaderColumnSelection(focusedHeaderColumnIdx, false, null, event);
                }
              }
            }
          }
        }
      },
      /**
       * Handler for Tab keydown.
       * @param {Object} event
       * @private
       */
      _handleKeydownTab: function(event)
      {
        // if Tab is pressed while a row has focus then we 
        // want to Tab within that row and then go to the 
        // next row until Esc is pressed
        var focusedRowIdx = this._getFocusedRowIdx();

        if (focusedRowIdx != null && this._isTableNavigationMode())
        {

          var tableBody = this._getTableDomUtils().getTableBody();
          var tabbableElementsInBody = this._getTabbableElements(tableBody);
          // only bother if there are any tabbable elements
          if (tabbableElementsInBody != null)
          {
            var currentFocusElement = document.activeElement;

            var isCurrentlyFocused = false;
            var i, tableBodyRow, tabbableElementsInRow;
            for (i = 0; i < tabbableElementsInBody.length; i++)
            {
              if (currentFocusElement == tabbableElementsInBody[i])
              {
                isCurrentlyFocused = true;
                break;
              }
            }
            // if already focused on an element in the body, then
            // don't do anything
            if (isCurrentlyFocused)
            {
              return;
            }
            else if (!event[this._KEYBOARD_CODES._KEYBOARD_MODIFIER_SHIFT])
            {
              tableBodyRow = this._getTableDomUtils().getTableBodyRow(focusedRowIdx);
              tabbableElementsInRow = this._getTabbableElements(tableBodyRow);

              if (tabbableElementsInRow != null)
              {
                $(tabbableElementsInRow[0]).focus();
              }
              else
              {
                // if there are no tabbable elements
                // in the row then focus on the first 
                // tabbable element in the body
                $(tabbableElementsInBody[0]).focus();
              }
              event.preventDefault();
              event.stopPropagation();
            }
          }
        }
        else
        {
          // tab out of the component to the next tabbable
          // element on the page
          var table = this._getTableDomUtils().getTable();
          var tabbableElementsInDocument = this._getTabbableElements($(document));
          var tabbableElementsInTable = this._getTabbableElements(table);
          var tableTabIndex = tabbableElementsInDocument.index(this._getTableDomUtils().getTable());
          $(tabbableElementsInDocument[tableTabIndex + tabbableElementsInTable.length + 1]).focus();
          event.preventDefault();
          event.stopPropagation();
        }
        // we need to remove Tab on keydown because we may not
        // get a keyup for it if focus moves
        // outside of table
        this._removeKeyboardKey(event.keyCode);
      },
      /**
       * Handler for Up/Down keydown.
       * @param {Object} event
       * @private
       */
      _handleKeydownUpDown: function(event)
      {
        var focusedRowIdx = this._getFocusedRowIdx();
        var focusedHeaderColumnIdx = this._getFocusedHeaderColumnIdx();

        if (focusedRowIdx != null)
        {
          // if row is focused then up/down navigates the rows
          var data = this._getData();
          var newFocusedRowIdx = focusedRowIdx;

          if (this._isKeyboardKeyPressed(this._KEYBOARD_CODES._KEYBOARD_CODE_UP))
          {
            if (focusedRowIdx > 0)
            {
              newFocusedRowIdx = focusedRowIdx - 1;
            }
            else
            {
              newFocusedRowIdx = focusedRowIdx;
            }
          }
          else if (this._isKeyboardKeyPressed(this._KEYBOARD_CODES._KEYBOARD_CODE_DOWN))
          {
            newFocusedRowIdx = focusedRowIdx < data.size() - 1 ? focusedRowIdx + 1 : focusedRowIdx;
          }

          if (newFocusedRowIdx != focusedRowIdx)
          {
            this._setRowFocus(newFocusedRowIdx, true, null);

            if (event[this._KEYBOARD_CODES._KEYBOARD_MODIFIER_SHIFT])
            {
              // if shift is also pressed then we need to select too
              var newFocusedRowSelection = this._getRowSelection(newFocusedRowIdx);
              // we may be clearing or setting the selection
              this._setRowSelection(newFocusedRowIdx, !newFocusedRowSelection, null, event);
              // if we are clearing the selection, then clear the previous row too.
              if (newFocusedRowSelection)
              {
                if (this._getRowSelection(focusedRowIdx))
                {
                  this._setRowSelection(focusedRowIdx, false, null, event);
                }
              }
            }
          }
          // if user is on the first row and presses up the focus on the first column header
          else if (newFocusedRowIdx == focusedRowIdx &&
            focusedRowIdx == 0 &&
            this._isKeyboardKeyPressed(this._KEYBOARD_CODES._KEYBOARD_CODE_UP))
          {
            this._setHeaderColumnFocus(0, true, null);
          }
        }
        // if user is on a column header and pressed down then focus on the first row
        else if (focusedHeaderColumnIdx != null &&
          this._isKeyboardKeyPressed(this._KEYBOARD_CODES._KEYBOARD_CODE_DOWN))
        {
          this._setRowFocus(0, true, null);
        }
      },
      /**
       * Handler for End keyup.
       * @param {Object} event
       * @private
       */
      _handleKeyupEnd: function(event)
      {
        // pressing End focuses on last column
        var focusedColumnIdx = this._getFocusedHeaderColumnIdx();

        if (focusedColumnIdx != null &&
          focusedColumnIdx != this._getColumnDefs().length - 1)
        {
          this._setHeaderColumnFocus(this._getColumnDefs().length - 1, true, null);
        }
      },
      /**
       * Handler for Enter keyup.
       * @param {Object} event
       * @private
       */
      _handleKeyupEnter: function(event)
      {
        // pressing enter does sort on the focused column header
        var focusedColumnIdx = this._getFocusedHeaderColumnIdx();

        if (focusedColumnIdx != null && this._getColumnDefs()[focusedColumnIdx].sortable == this._OPTION_ENABLED)
        {
          var tableHeaderColumn = this._getTableDomUtils().getTableHeaderColumn(focusedColumnIdx);
          var sorted = tableHeaderColumn.data('sorted');
          // if not already sorted then sort ascending. If already sorted
          // ascending then do descending sort and vice versa.
          if (sorted == null || sorted == this._COLUMN_SORT_ORDER._DESCENDING)
          {
            this._handleSortTableHeaderColumn(focusedColumnIdx, true);
          }
          else
          {
            this._handleSortTableHeaderColumn(focusedColumnIdx, false);
          }
        }
      },
      /**
       * Handler for Esc keyup.
       * @param {Object} event
       * @private
       */
      _handleKeyupEsc: function(event)
      {
        // pressing Esc always returns focus back to the table.
        // This is for when users are tabbing through focuable
        // elements and need to get back to general table nav
        event.preventDefault();
        event.stopPropagation();
        this._getTableDomUtils().getTable().focus();
        this._setTableNavigationMode(false);
      },
      /**
       * Handler for Home keyup.
       * @param {Object} event
       * @private
       */
      _handleKeyupHome: function(event)
      {
        // pressing Home focuses on first column
        var focusedColumnIdx = this._getFocusedHeaderColumnIdx();

        if (focusedColumnIdx != null && focusedColumnIdx != 0)
        {
          this._setHeaderColumnFocus(0, true, null);
        }
      },
      /**
       * Handler for Spacebar keyup.
       * @param {Object} event
       * @private
       */
      _handleKeyupSpacebar: function(event)
      {
        // pressing spacebar selects the focused row/column
        var focusedRowIdx = this._getFocusedRowIdx();

        if (focusedRowIdx != null)
        {
          this._setRowSelection(focusedRowIdx, !this._getRowSelection(focusedRowIdx), null, event);
        }
        else
        {
          var focusedHeaderColumnIdx = this._getFocusedHeaderColumnIdx();
          if (focusedHeaderColumnIdx != null)
          {
            this._setHeaderColumnSelection(focusedHeaderColumnIdx, !this._getHeaderColumnSelection(focusedHeaderColumnIdx), null, event);
          }
        }
      },
      /**
       * Handler for column sort
       * @param {number} columnIdx  column index
       * @param {boolean} ascending  sort order ascending
       * @private
       */
      _handleSortTableHeaderColumn: function(columnIdx, ascending)
      {
        // clear the sorted indicator on any other column
        this._clearSortedHeaderColumn(columnIdx);
        // get the column metadata
        var column = this._getColumnDefs()[columnIdx];
        // get which field to sort on
        var sortField = column.sortProperty == null ? column.field : column.sortProperty;
        // get the column header DOM element
        var tableHeaderColumn = this._getTableDomUtils().getTableHeaderColumn(columnIdx);
        // invoke sort on the data
        this._invokeDataSort(sortField, ascending, null);

        if (ascending)
        {
          // store sort order on the DOM element
          tableHeaderColumn.data('sorted', this._COLUMN_SORT_ORDER._ASCENDING);
          var headerColumnAscLink = tableHeaderColumn.find('.' + oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_ASC_LINK_CLASS);
          headerColumnAscLink.addClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._SELECTED);
          this._showTableHeaderColumnSortLink(columnIdx, true);
        }
        else
        {
          // store sort order on the DOM element
          tableHeaderColumn.data('sorted', this._COLUMN_SORT_ORDER._DESCENDING);
          var headerColumnDscLink = tableHeaderColumn.find('.' + oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_DSC_LINK_CLASS);
          headerColumnDscLink.addClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._SELECTED);
          this._showTableHeaderColumnSortLink(columnIdx, false);
        }
      },
      /**
       * Hide the 'No data to display.' message.
       * @private
       */
      _hideNoDataMessage: function()
      {
        var noDataMessage = this._getTableDomUtils().getTableNoDataMessage();
        noDataMessage.css('display', 'none');
      },
      /**
       * Hide the Fetching Data... status message.
       * @private
       */
      _hideStatusMessage: function()
      {
        var statusMessage = this._getTableDomUtils().getTableStatusMessage();
        statusMessage.css('display', 'none');
      },
      /**
       * Hide the column header sort link
       * @param {number} columnIdx  column index
       * @param {boolean} ascending  sort order ascending
       * @private
       */
      _hideTableHeaderColumnSortLink: function(columnIdx, ascending)
      {
        // check if the column is sortable. If not, then there won't be any sort links
        if (this._getColumnDefs()[columnIdx].sortable == this._OPTION_ENABLED)
        {
          var tableHeaderColumn = this._getTableDomUtils().getTableHeaderColumn(columnIdx);
          // check if the column is currently sorted
          var sorted = tableHeaderColumn.data('sorted');

          // we should only hide the ascending sort link if the column is not sorted or
          // is sorted by descending order
          if (ascending && (sorted == null || sorted == this._COLUMN_SORT_ORDER._DESCENDING))
          {
            var headerColumnAscLink = tableHeaderColumn.find('.' + oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_ASC_LINK_CLASS);
            headerColumnAscLink.addClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._DISABLED);
            headerColumnAscLink.removeClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._ENABLED);
            headerColumnAscLink.removeClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._SELECTED);
          }
          // we should only hide the descending sort link if the column is not sorted or
          // is sorted by ascending order
          else if (!ascending && (sorted == null || sorted == this._COLUMN_SORT_ORDER._ASCENDING))
          {
            var headerColumnDscLink = tableHeaderColumn.find('.' + oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_DSC_LINK_CLASS);
            headerColumnDscLink.addClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._DISABLED);
            headerColumnDscLink.removeClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._ENABLED);
            headerColumnDscLink.removeClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._SELECTED);
          }
        }
      },
      /**
       * Invoke sort on a field. This function is called when a user clicks the 
       * column header sort links
       * @param {string} sortField  field name
       * @param {boolean} ascending  sort order ascending
       * @param {jQuery} element  DOM element which triggered the sort
       * @private
       */
      _invokeDataSort: function(sortField, ascending, element)
      {
        var data = this._getData();
        // if no data then bail
        if (!data)
        {
          return null;
        }

        // show the Fetching Data... message
        this._showStatusMessage();
        
        var sortCriteria = {};
        sortCriteria['key'] = sortField;

        // the sort function on the datasource takes comparators
        if (ascending)
        {
          sortCriteria['direction'] = this._COLUMN_SORT_ORDER._ASCENDING;
          data.sort(sortCriteria);
        }
        else
        {
          sortCriteria['direction'] = this._COLUMN_SORT_ORDER._DESCENDING;
          data.sort(sortCriteria);
        }
      },
      /**
       * Whether the columns have been updated
       * @return {boolean} true or false
       * @private
       */
      _isColumnMetadataUpdated: function()
      {
        if (this._columnDefArray != null)
        {
          var columnsMetadata = this._getColumnMetadata();
          if (this._columnDefArray.length != columnsMetadata.length)
          {
            return true;
          }
          else
          {
            var i, prop;
            for (i = 0; i < columnsMetadata.length; i++)
            {
              for (prop in columnsMetadata[i]) {
                if (columnsMetadata[i].hasOwnProperty(prop)) {
                  if (columnsMetadata[i][prop] != this._columnDefArray[i][prop])
                  {
                    return true;
                  }
                }
              }
            }
          }
          return false;
        }
        return true;
      },
      /**
       * Whether the focus is on the table or descendent focusable element
       * @return {boolean} true or false
       * @private
       */
      _isFocused: function()
      {
        // set focus on the table
        var currentFocusElement = $(document.activeElement);
        var table = this._getTableDomUtils().getTable();
        if (table[0] != currentFocusElement[0] &&
          table.has(currentFocusElement).length == 0)
        {
          return false;
        }
        return true;
      },
      /**
       * Is keybaord key pressed
       * @param {number} keyCode  KeyCode of the keyboard key.
       * @return {boolean} true or false
       * @private
       */
      _isKeyboardKeyPressed: function(keyCode)
      {
        var keyboardKeys = this._getKeyboardKeys();
        var i;
        for (i = 0; i < keyboardKeys.length; i++)
        {
          if (keyboardKeys[i] == keyCode)
          {
            return true;
          }
        }
        return false;
      },
      /**
       * Returns whether the table is footerless
       * @return {boolean} true or false
       * @private
       */
      _isTableFooterless: function()
      {
        var columns = this._getColumnDefs();
        var i, footerRenderer;
        
        for (i = 0; i < columns.length; i++)
        {
          footerRenderer = this._getColumnRenderer(i, 'footer');
          if (footerRenderer != null)
          {
            return false
          }
        }
        return true;
      },
      /**
       * Returns whether the table is headerless
       * @return {boolean} true or false
       * @private
       */
      _isTableHeaderless: function()
      {
        var columns = this._getColumnDefs();

        var i, j;
        for (i = 0; i < columns.length; i++)
        {
          if (columns[i]['headerText'] != null ||
            columns[i]['headerStyle'] != null ||
            (columns[i]['sortable'] != null &&
              columns[i]['sortable'] != this._OPTION_NONE) ||
            columns[i]['sortProperty'] != null ||
            columns[i]['headerRenderer'] != null)
          {
            return false;
          }
        }
        
        return true;
      },
      /**
       * Returns whether the table header columns were rendered
       * @return {boolean} true or false
       * @private
       */
      _isTableHeaderColumnsRendered: function()
      {
        return this._renderedTableHeaderColumns == true;
      },
      /**
       * Return whether the component is in table navigation mode
       * @return {boolean} true or false
       * @private
       */
      _isTableNavigationMode: function()
      {
        return this._tableNavMode;
      },
      /**
       * @override
       * @private
       */
      _refreshAll: function()
      {
        if (this._isColumnMetadataUpdated() ||
            (!this._isTableHeaderColumnsRendered() &&
            !this._isTableHeaderless()))
        {
          this._clearCachedMetadata();
          this._refreshTableHeader();
        }
        this._refreshTableFooter();
        this._refreshTableBody();
        // if the datasource is already doing a fetch then show the message
        if (this._getData() != null && this._getData().isFetching)
        {
          this._showStatusMessage();
        }
        this._getTableDomUtils().refreshTableDimensions();
      },
      
      /**
       * Refresh the entire table body with data from the datasource
       * @private
       */
      _refreshTableBody: function()
      {
        var self = this;
        var tableBody = this._getTableDomUtils().getTableBody();
        var data = this._getData();
        tableBody.empty();
         this._getTableDomUtils().clearCachedDomRowData();
        
        // if no data then bail
        if (!data || data.size() == 0 || this._getColumnDefs().length == 0)
        {
          this._showNoDataMessage();
        }
        else
        {
          this._hideNoDataMessage();
          var tableBodyDocFrag = $(document.createDocumentFragment());
          var startIndex = data.startIndex();
          var endIndex = startIndex + data.size();
          var i, row;
          for (i = startIndex; i < endIndex; i++)
          {
            row = data.at(i);
            if (row != null)
            {
              if (row instanceof oj.Row)
              {
                this._refreshTableBodyRow(i, row, tableBodyDocFrag);
              }
              else
              {
                $.when(row).done(function(resolvedModel)
                                 {
                                   self._refreshTableBodyRow(i, resolvedModel, null)
                                 }); 
              }
            }
          }
          tableBody.append(tableBodyDocFrag);
        }
      },
      /**
       * Refresh the row at a particular index with the row data
       * @param {number} rowIdx  row index
       * @param {Object} row  oj.Row
       * @param {Object} docFrag  document fragment
       * @private
       */
      _refreshTableBodyRow: function(rowIdx, row, docFrag)
      {
        var options = this.options;
        var rowRenderer = this._getRowRenderer();
        var columns = this._getColumnDefs();

        if (isNaN(rowIdx) || rowIdx < 0)
        {
          // validate rowIdx value
          throw 'Error: Invalid rowIdx value: ' + rowIdx;
        }

        this._hideNoDataMessage();

        // check if a row renderer was defined
        if (rowRenderer)
        {
          // check if we already have a <tr> element at that index
          var tableBodyRow = this._getTableDomUtils().getTableBodyRow(rowIdx);
          if (!tableBodyRow)
          {
            // if not then create one
            tableBodyRow = this._getTableDomUtils().createTableBodyRow(this._getRowSelectionMode());
            this._getTableDomUtils().styleTableBodyRow(tableBodyRow, this._getRowSelectionMode());
            // insert the <tr> element in to the table body DOM
            this._getTableDomUtils().insertTableBodyRow(rowIdx, tableBodyRow, row, docFrag);
          }
          else
          {
            tableBodyRow.empty();
          }
          var tableBody = tableBodyRow.parent();

          var rowContent = rowRenderer({'rowContext': this._getTableDomUtils().getRendererContextObject(row, tableBodyRow[0]), 
                                        'row': row.pairs()});

          if (rowContent != null)
          {
            // if the renderer returned a value then we set it as the content
            // for the row
            tableBodyRow.append(rowContent);
          }
          else
          {
            // if the renderer didn't return a value then the existing
            // row was manipulated. So get it and set the required
            // attributes just in case it was replaced or the attributes
            // got removed
            if (docFrag == null)
            {
              tableBodyRow = $(tableBody.children()[rowIdx]);
            }
            else
            {
              tableBodyRow = $(docFrag.children()[rowIdx]);
            }
            this._getTableDomUtils().clearCachedDomRowData();
            this._getTableDomUtils().setTableBodyRowAttributes(rowIdx, row, tableBodyRow);
            this._getTableDomUtils().styleTableBodyRow(tableBodyRow);
          }
          this._getTableDomUtils().createTableBodyCellAccSelect(rowIdx, tableBodyRow);

          // set the cell attributes and styling. Skip the 1st one
          // because it's the acc row select td
          var tableBodyCells = tableBodyRow.children('td');
          var i;
          for (i = 1; i < tableBodyCells.length; i++)
          {
            var tableBodyCell = $(tableBodyCells[i]);
            this._getTableDomUtils().setTableBodyCellAttributes(rowIdx, i - 1, tableBodyCell);
            this._getTableDomUtils().styleTableBodyCell(i - 1, tableBodyCell);
          }
        }
        else
        {
          var tableBodyRow = null;
          if (docFrag == null)
          {
            // check if we already have a <tr> element at that index
            tableBodyRow = this._getTableDomUtils().getTableBodyRow(rowIdx);
            if (!tableBodyRow)
            {
              // if not then create one
              tableBodyRow = this._getTableDomUtils().createTableBodyRow(this._getRowSelectionMode());
              this._getTableDomUtils().styleTableBodyRow(tableBodyRow, this._getRowSelectionMode());
            }
          }
          else
          {
            // if we have a documentFragment then always create a new <tr>
            tableBodyRow = this._getTableDomUtils().createTableBodyRow(this._getRowSelectionMode());
            this._getTableDomUtils().styleTableBodyRow(tableBodyRow, this._getRowSelectionMode());
          }
          // insert the empty <tr> element into the table body DOM
          this._getTableDomUtils().replaceTableBodyRow(rowIdx, tableBodyRow, row, docFrag);
          var j, column, cellContext, cellRenderer;
          for (j = 0; j < columns.length; j++)
          {
            column = columns[j];
            cellRenderer = this._getColumnRenderer(j, 'cell');
            // set the cells in the inserted row with values from the row
            this._getTableDomUtils().setTableBodyCell(rowIdx, j, tableBodyRow, row, cellRenderer);
          }
        }
      },
      /**
       * Refresh the table footer
       * @private
       */
      _refreshTableFooter: function()
      {
        var columns = this._getColumnDefs();
        var tableFooter = this._getTableDomUtils().getTableFooter();

        if (!tableFooter)
        {
          if (this._isTableFooterless())
          {
            return;
          }
          else
          {
            // metadata could have been updated to add column headers
            tableFooter = this._getTableDomUtils().createTableFooter();
            this._getTableDomUtils().styleTableFooter(tableFooter);
          }
        }

        var tableFooterRow = this._getTableDomUtils().getTableFooterRow();
        // remove all the existing footer cells
        tableFooterRow.empty();

        if (columns && columns.length > 0)
        {
          this._getTableDomUtils().createTableFooterAccSelect(tableFooterRow);
          
          var i, column, footerRenderer, footerCell, footerCellContent;
          for (i = 0; i < columns.length; i++)
          {
            column = columns[i];
            footerRenderer = this._getColumnRenderer(i, 'footer');
            footerCell = this._getTableDomUtils().createTableFooterCell(i, this._getColumnSelectionMode());
            this._getTableDomUtils().styleTableFooterCell(i, footerCell);
            this._getTableDomUtils().insertTableFooterCell(i, footerCell);

            if (footerRenderer)
            {
              // if footerRenderer is defined then call that
              footerCellContent = footerRenderer({'footerContext': this._getTableDomUtils().getRendererContextObject(null, footerCell[0]),
                                                  'column': column});
              
              if (footerCellContent != null)
              {
                // if the renderer returned a value then we set it as the content
                // for the footer cell
                footerCell.empty();
                footerCell.append(footerCellContent);
              }
              else
              {
                // if the renderer didn't return a value then the existing
                // footer cell was manipulated. So get it and set the required
                // attributes just in case it was replaced or the attributes
                // got removed
                footerCell = $(tableFooterRow.children(':not(.' + oj.TableDomUtils.CSS_CLASSES._HIDDEN_CONTENT_ACC_CLASS + ')')[i]);
                this._getTableDomUtils().styleTableFooterCell(i, footerCell, this._getColumnSelectionMode());
              }
            }
          }
        }
      },
      /**
       * Refresh the table header
       * @private
       */
      _refreshTableHeader: function()
      {
        var columns = this._getColumnDefs();
        var tableHeader = this._getTableDomUtils().getTableHeader();

        if (!tableHeader)
        {
          if (this._isTableHeaderless())
          {
            return;
          }
          else
          {
            // metadata could have been updated to add column headers
            tableHeader = this._getTableDomUtils().createTableHeader();
            this._getTableDomUtils().styleTableHeader(tableHeader);
          }
        }

        var tableHeaderRow = this._getTableDomUtils().getTableHeaderRow();
        // remove all the existing column headers
        tableHeaderRow.empty();

        if (columns && columns.length > 0)
        {
          var tableHeaderAccSelectRowColumn = this._getTableDomUtils().createTableHeaderAccSelectRowColumn();
          tableHeaderRow.append(tableHeaderAccSelectRowColumn);

          var i, j, column, headerRenderer, headerColumn, headerColumnContent;
          for (i = 0; i < columns.length; i++)
          {
            column = columns[i];
            headerRenderer = this._getColumnRenderer(i, 'header');
            headerColumn = this._getTableDomUtils().createTableHeaderColumn(i, this._getColumnSelectionMode());
            this._getTableDomUtils().insertTableHeaderColumn(i, headerColumn);

            if (headerRenderer)
            {
              // if headerRenderer is defined then call that
              headerColumnContent = headerRenderer({'headerContext': this._getTableDomUtils().getRendererContextObject(null, headerColumn[0]),
                                                    'column': column});
              
              if (headerColumnContent != null)
              {
                // if the renderer returned a value then we set it as the content
                // for the headerColumn
                headerColumn.empty();
                headerColumn.append(headerColumnContent);
              }
              else
              {
                // if the renderer didn't return a value then the existing
                // headerColumn was manipulated. So get it and set the required
                // attributes just in case it was replaced or the attributes
                // got removed
                headerColumn = $(tableHeaderRow.children(':not(' + '.' + oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_ACC_SELECT_ROW_CLASS + ')')[i]);
                this._getTableDomUtils().setTableHeaderColumnAttributes(i, headerColumn);
                this._getTableDomUtils().styleTableHeaderColumn(i, headerColumn, this._getColumnSelectionMode());
              }
            }
            // set the acc column selection checkbox
            this._getTableDomUtils().createTableHeaderColumnAccSelect(i, this._getColumnSelectionMode());
          }
          this._renderedTableHeaderColumns = true;
        }
      },
      /**
       * Register the events which will be published by the table component.
       * @private
       */
      _registerCustomEvents: function()
      {
        // ojtableactiverow handlers will be passed an object which contains the
        // old and new active row
        var jqEvent = (/** @type {{special: Object}} */($.event));
        var jqEventSpecial = jqEvent['special'];
        jqEventSpecial['ojtableactiverow'] = {
          /**
           * Handle event
           * @param {{handleObj: {handler: {apply: Function}}}} event
           * @private
           */
          handle: function(event) {
            var handleObj = event['handleObj'];
            return handleObj['handler'].apply(this, [event, arguments[1]]);
          }
        };
        // ojtablepreactiverow handlers will be passed an object which contains the
        // old and new active row
        jqEventSpecial['ojtablepreactiverow'] = {
          /**
           * Handle event
           * @param {{handleObj: {handler: {apply: Function}}}} event
           * @private
           */
          handle: function(event) {
            var handleObj = event['handleObj'];
            return handleObj['handler'].apply(this, [event, arguments[1]]);
          }
        };
        // ojtablescroll handlers will be passed an object which contains
        // the scrollTop and scrollLeft
        jqEventSpecial['ojtablescroll'] = {
          /**
           * Handle event
           * @param {{handleObj: {handler: {apply: Function}}}} event
           * @private
           */
          handle: function(event) {
            var handleObj = event['handleObj'];
            return handleObj['handler'].apply(this, [event, arguments[1]]);
          }
        };
        // ojtableselect handlers will be passed an object which contains
        // either the row or column index and the selectionAdded boolean which indicates whether
        // the selection was added or removed.
        jqEventSpecial['ojtableselect'] = {
          /**
           * Handle event
           * @param {{handleObj: {handler: {apply: Function}}}} event
           * @private
           */
          handle: function(event) {
            var handleObj = event['handleObj'];
            return handleObj['handler'].apply(this, [event, arguments[1]]);
          }
        };
      },
      /**
       * Register event listeners which need to be registered datasource. 
       * @private
       */
      _registerDataSourceEventListeners: function()
      {
        // register the listeners on the datasource
        var data = this._getData();
        if (data != null)
        {
          this._dataSourceEventHandlers = [];
          this._dataSourceEventHandlers.push({'eventType': oj.RowSet.EventType['REQUEST'], 'eventHandler': this._handleDataFetchStart.bind(this)});
          this._dataSourceEventHandlers.push({'eventType': oj.RowSet.EventType['SYNC'], 'eventHandler': this._handleDataFetchEnd.bind(this)});
          this._dataSourceEventHandlers.push({'eventType': oj.RowSet.EventType['SORT'], 'eventHandler': this._handleDataSort.bind(this)});
          this._dataSourceEventHandlers.push({'eventType': oj.RowSet.EventType['ADD'], 'eventHandler': this._handleDataRowAdd.bind(this)});
          this._dataSourceEventHandlers.push({'eventType': oj.RowSet.EventType['REMOVE'], 'eventHandler': this._handleDataRowRemove.bind(this)});
          this._dataSourceEventHandlers.push({'eventType': oj.RowSet.EventType['CHANGE'], 'eventHandler': this._handleDataRowChange.bind(this)});
          this._dataSourceEventHandlers.push({'eventType': oj.RowSet.EventType['RESET'], 'eventHandler': this._handleDataReset.bind(this)});
          this._dataSourceEventHandlers.push({'eventType': oj.RowSet.EventType['ERROR'], 'eventHandler': this._handleDataError.bind(this)});

          var i;
          for (i = 0; i < this._dataSourceEventHandlers.length; i++)
            data.on(this._dataSourceEventHandlers[i]['eventType'], this._dataSourceEventHandlers[i]['eventHandler']);
        }
      },
      /**
       * Register event listeners which need to be registered directly on
       * the DOM element.
       * @private
       */
      _registerDomEventListeners: function()
      {
        if (this._getTableDomUtils().getScroller() != null)
        {
          // if width or height is defined then we can have scrollbars so register scroll event listeners
          this._getTableDomUtils().getScroller().scroll((function(event) {
            var scrollLeft = $(event.target).scrollLeft();
            var maxScrollLeft = $(event.target)[0].scrollWidth - $(event.target)[0].clientWidth;

            if (this._GetReadingDirection() === "rtl")
            {
              scrollLeft = maxScrollLeft - scrollLeft;
            }

            var scrollTop = $(event.target).scrollTop();
            var tableHeader = this._getTableDomUtils().getTableHeader();

            if (!tableHeader)
            {
              return;
            }

            if (!this._getTableDomUtils().isDivScroller())
            {
              var tableHeaderRow = this._getTableDomUtils().getTableHeaderRow();
              if (tableHeaderRow)
              {
                if (this._GetReadingDirection() === "rtl")
                {
                  tableHeaderRow.css('right', '-' + scrollLeft + 'px');
                }
                else
                {
                  tableHeaderRow.css('left', '-' + scrollLeft + 'px');
                }
              }
            }
            else
            {
              if (this._GetReadingDirection() === "rtl")
              {
                tableHeader.css('right', '-' + scrollLeft + 'px');
              }
              else
              {
                tableHeader.css('left', '-' + scrollLeft + 'px');
              }
              tableHeader.css('width', this._tableHeaderWidth + scrollLeft + 'px');
            }
            // trigger the ojtablescroll event so that listeners on the table
            // // component will be notified that the table was scrolled.
            this._trigger('scroll', event, {'scrollLeft': $(event.target).scrollLeft(), 'scrollTop': scrollTop});
          }).bind(this));
        }
      },
      /**
       * Register event listeners for resize the container DOM element.
       * @param {jQuery} element  DOM element
       * @private
       */
      _registerResizeListener: function(element)
      {         
        if (!this._isResizeListenerAdded)
        {
          var self = this;
          oj.DomUtils.addResizeListener(element[0], function(width, height)
                                                    {
                                                      // only reset the table dimensions if table dimension styling was set
                                                      self._clearCachedTableDimensions();
                                                      self._getTableDomUtils().refreshTableDimensions();
                                                    });
          this._isResizeListenerAdded = true;
        }
      },
      /**
       * Remove a keyCode from our internal list of pressed keys. This is done on keyup.
       * @private
       */
      _removeKeyboardKey: function(keyCode)
      {
        var keyboardKeys = this._getKeyboardKeys();
        var i;
        for (i = 0; i < keyboardKeys.length; i++)
        {
          if (keyboardKeys[i] == keyCode)
          {
            keyboardKeys.splice(i, 1);
          }
        }
      },
      /**
       * Scroll column into viewport
       * @param {number} columnIdx  row index
       * @private
       */
      _scrollColumnIntoViewport: function(columnIdx)
      {
        var tableBody = this._getTableDomUtils().getTableBody();
        var tableHeaderColumn = this._getTableDomUtils().getTableHeaderColumn(columnIdx);

        if (!tableHeaderColumn)
        {
          return;
        }

        var scrollbarWidth = this._getTableDomUtils().getScrollbarWidth();
        var headerColumnRect = tableHeaderColumn.get(0).getBoundingClientRect();
        var tableBodyRect = tableBody.get(0).getBoundingClientRect();

        var scrolledLeft = false;
        if (headerColumnRect.left < tableBodyRect.left)
        {
          var scrollLeftDiff = tableBodyRect.left - headerColumnRect.left;
          tableBody.scrollLeft(tableBody.scrollLeft() - scrollLeftDiff);
          scrolledLeft = true;
        }

        if (headerColumnRect.right > tableBodyRect.right - scrollbarWidth && !scrolledLeft)
        {
          var scrollLeftDiff = headerColumnRect.right - tableBodyRect.right + scrollbarWidth;
          tableBody.scrollLeft(tableBody.scrollLeft() + scrollLeftDiff);
        }
      },
      /**
       * Scroll row into viewport
       * @param {number} rowIdx  row index
       * @private
       */
      _scrollRowIntoViewport: function(rowIdx)
      {

        var tableBodyRow = this._getTableDomUtils().getTableBodyRow(rowIdx);
        var scrollbarHeight = this._getTableDomUtils().getScrollbarHeight();
        var rowRect = tableBodyRow.get(0).getBoundingClientRect();
        var scrollingElement = this._getTableDomUtils().getScroller();
        var scrollingElementRect = scrollingElement.get(0).getBoundingClientRect();

        var scrolledDown = false;
        if (rowRect.bottom > scrollingElementRect.bottom - scrollbarHeight)
        {
          var scrollTopDiff = rowRect.bottom - scrollingElementRect.bottom + scrollbarHeight;
          scrollingElement.scrollTop(scrollingElement.scrollTop() + scrollTopDiff);
          scrolledDown = true;
        }

        if (rowRect.top < scrollingElementRect.top && !scrolledDown)
        {
          var scrollTopDiff = scrollingElementRect.top - rowRect.top;
          scrollingElement.scrollTop(scrollingElement.scrollTop() - scrollTopDiff);
        }

      },
      /**
       * Set focus on column header
       * @param {number} columnIdx  column index
       * @param {boolean} focused  whether it's focused
       * @param {jQuery} element  DOM element which triggered the column header focus
       * @private
       */
      _setHeaderColumnFocus: function(columnIdx, focused, element)
      {
        if (focused)
        {
          var focusedHeaderColumnIdx = this._getFocusedHeaderColumnIdx();
          if (focusedHeaderColumnIdx != null && focusedHeaderColumnIdx != columnIdx)
          {
            this._setHeaderColumnFocus(focusedHeaderColumnIdx, false, element);
          }
          // clear focused row
          this._clearFocusedRow();
          // clear selected rows
          this._clearSelectedRows();
          // scroll column into view
          this._scrollColumnIntoViewport(columnIdx);
        }
        this._setHeaderColumnState(columnIdx, {focused: focused}, element);
      },
      /**
       * Set selection on column header
       * @param {number} columnIdx  column index
       * @param {boolean} selected  whether it's focused
       * @param {jQuery} element  DOM element which triggered the column header selection
       * @param {Object} event
       * @private
       */
      _setHeaderColumnSelection: function(columnIdx, selected, element, event)
      {
        if (this._getColumnSelectionMode() == this._OPTION_SELECTION_MODES._SINGLE ||
          this._getColumnSelectionMode() == this._OPTION_SELECTION_MODES._MULTIPLE)
        {
          if (isNaN(columnIdx) || columnIdx < 0)
          {
            // validate value
            throw 'Error: Invalid column selection value: ' + columnIdx;
          }

          // if we have single selection then clear any existing selections
          if (this._getColumnSelectionMode() == this._OPTION_SELECTION_MODES._SINGLE && selected)
          {
            this._clearSelectedHeaderColumns();
          }
          this._setHeaderColumnState(columnIdx, {selected: selected}, element, event);
          // save it
          this._setLastHeaderColumnSelection(columnIdx, selected);
          
          // update the acc checkbox
          var accSelectionColumn = this._getTableDomUtils().getTableHeaderColumnAccSelect(columnIdx);
          var accSelectCheckbox = $(accSelectionColumn.children('.' + oj.TableDomUtils.CSS_CLASSES._CHECKBOX_ACC_SELECT_COLUMN_CLASS)[0]);
          accSelectCheckbox.prop('checked', selected);
        }
      },
      /**
       * Set the state of the column header. e.g., focused, selected, etc.
       * @param {number} columnIdx  column index
       * @param {Object} state  Object which contains whether it's focused or selected
       * @param {jQuery} element  DOM element which triggered the column header state
       * @param {Object} event
       * @private
       */
      _setHeaderColumnState: function(columnIdx, state, element, event)
      {
        var headerColumn = this._getTableDomUtils().getTableHeaderColumn(columnIdx);

        if (!headerColumn)
        {
          return;
        }

        var focused = state.focused;
        var selected = state.selected;

        if (selected != null)
        {
          var headerColumnSelected = headerColumn.hasClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._SELECTED);

          var selectionChanged = false;
          if (headerColumnSelected != selected)
          {
            if (!selected)
            {
              headerColumn.removeClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._SELECTED);
            }
            else
            {
              headerColumn.addClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._SELECTED);
            }
            selectionChanged = true;
          }

          if (selectionChanged)
          {
            this._trigger('select', event, {'column': columnIdx, 'selectionAdded': selected});
          }
        }
        if (focused != null)
        {
          if (!focused)
          {
            headerColumn.removeClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._FOCUS);
            this._hideTableHeaderColumnSortLink(columnIdx, true);
            this._hideTableHeaderColumnSortLink(columnIdx, false);
          }
          else
          {
            headerColumn.addClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._FOCUS);
            this._showTableHeaderColumnSortLink(columnIdx, true);
            this._showTableHeaderColumnSortLink(columnIdx, false);
          }
        }
        this._updateHeaderColumnCellsClass(columnIdx);
      },
      /**
       * Set the last column which was selected (chronologically)
       * @param {number} columnIdx  column index
       * @param {boolean} selected  whether it's selected
       * @private
       */
      _setLastHeaderColumnSelection: function(columnIdx, selected)
      {
        if (!this._lastSelectedColumnIdxArray)
        {
          this._lastSelectedColumnIdxArray = [];
        }

        var i;
        for (i = 0; i < this._lastSelectedColumnIdxArray.length; i++)
        {
          if (this._lastSelectedColumnIdxArray[i] == columnIdx)
          {
            this._lastSelectedColumnIdxArray.splice(i, 1);
            break;
          }
        }

        if (selected)
        {
          this._lastSelectedColumnIdxArray.push(columnIdx);
        }
      },
      /**
       * Set the last row which was selected (chronologically)
       * @param {number} rowIdx  row index
       * @param {boolean} selected  whether it's selected
       * @private
       */
      _setLastRowSelection: function(rowIdx, selected)
      {
        if (!this._lastSelectedRowIdxArray)
        {
          this._lastSelectedRowIdxArray = [];
        }

        for (var i = 0; i < this._lastSelectedRowIdxArray.length; i++)
        {
          if (this._lastSelectedRowIdxArray[i] == rowIdx)
          {
            this._lastSelectedRowIdxArray.splice(i, 1);
            break;
          }
        }

        if (selected)
        {
          this._lastSelectedRowIdxArray.push(rowIdx);
        }
      },
      /**
       * Set focus on row
       * @param {number} rowIdx  row index
       * @param {boolean} focused  whether it's focused
       * @param {jQuery} element  DOM element which triggered the row focus
       * @private
       */
      _setRowFocus: function(rowIdx, focused, element)
      {
        if (rowIdx == -1)
        {
          this._clearFocusedRow();
          return;
        }
        var tableBodyRow = this._getTableDomUtils().getTableBodyRow(rowIdx);
        
        if (!tableBodyRow)
        {
          return;
        }

        if (focused)
        {
          var focusedRowIdx = this._getFocusedRowIdx();
          if (focusedRowIdx != null && focusedRowIdx != rowIdx)
          {
            this._setRowFocus(focusedRowIdx, false, element);
          }
          var activeRowIdx = this['activeRow'](rowIdx);
          if (activeRowIdx == rowIdx)
          {
            tableBodyRow.addClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._FOCUS);
            // only change focus if the active row assignment was successful
            this._scrollRowIntoViewport(rowIdx);
            // clear any hover on the row
            this._updateRowCellsClass(rowIdx, {focused: true, hover: false});
            // clear any focused column header
            this._clearFocusedHeaderColumn();
            // clear any selected column header
            this._clearSelectedHeaderColumns();
            // set to table navigation mode
            this._setTableNavigationMode(true);
          }
        }
        else
        {
          tableBodyRow.removeClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._FOCUS);
        }
        // update focus style for the cells
        this._updateRowCellsClass(rowIdx, {focused: focused});
      },
      /**
       * Set selection on row
       * @param {number} rowIdx  column index
       * @param {boolean} selected  whether it's selected
       * @param {jQuery} element  DOM element which triggered the row selection
       * @param {Object} event
       * @private
       */
      _setRowSelection: function(rowIdx, selected, element, event)
      {
        if (this._getRowSelectionMode() == this._OPTION_SELECTION_MODES._SINGLE ||
          this._getRowSelectionMode() == this._OPTION_SELECTION_MODES._MULTIPLE)
        {
          if (isNaN(rowIdx) || rowIdx < 0)
          {
            // validate value
            throw 'Error: Invalid row selection value: ' + rowIdx;
          }

          // if we have single selection then clear any existing selections
          if (this._getRowSelectionMode() == this._OPTION_SELECTION_MODES._SINGLE && selected)
          {
            this._clearSelectedRows();
          }
          var tableBodyRow = this._getTableDomUtils().getTableBodyRow(rowIdx);
          var selectionChanged = false;

          var rowSelected = tableBodyRow.hasClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._SELECTED);

          if (rowSelected != selected)
          {
            if (!selected)
            {
              tableBodyRow.removeClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._SELECTED);
            }
            else
            {
              tableBodyRow.addClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._SELECTED);
            }
            selectionChanged = true;
          }

          if (selectionChanged)
          {
            this._trigger('select', event, {'row': rowIdx, 'selectionAdded': selected});
          }

          if (selectionChanged)
          {
            // if selection was set then we want to override
            // the default style precedence
            if (selected)
            {
              this._updateRowCellsClass(rowIdx, {hover: false, focused: false, selected: true});
            }
            else
            {
              this._updateRowCellsClass(rowIdx, {selected: false});
            }
          }
          // save it
          this._setLastRowSelection(rowIdx, selected);

          // update the acc checkbox
          var accSelectionCell = this._getTableDomUtils().getTableBodyCellAccSelect(tableBodyRow);
          var accSelectCheckbox = $(accSelectionCell.children('.' + oj.TableDomUtils.CSS_CLASSES._CHECKBOX_ACC_SELECT_ROW_CLASS)[0]);
          accSelectCheckbox.prop('checked', selected);
        }
      },
      /**
       * Set whether the component is in table navigation mode
       * @param {boolean} value true or false
       * @private
       */
      _setTableNavigationMode: function(value)
      {
        this._tableNavMode = value;
      },
      /**
       * Show the 'No data to display.'
       * @private
       */
      _showNoDataMessage: function()
      {
        var noDataMessage = this._getTableDomUtils().getTableNoDataMessage();
        noDataMessage.css('display', 'inline');
      },
      /**
       * Show the Fetching Data... status message.
       * @private
       */
      _showStatusMessage: function()
      {
        var statusMessage = this._getTableDomUtils().getTableStatusMessage();
        statusMessage.css('display', 'inline');
      },
      /**
       * Show the column header sort link
       * @param {number} columnIdx  column index
       * @param {boolean} ascending  sort order ascending
       * @private
       */
      _showTableHeaderColumnSortLink: function(columnIdx, ascending)
      {
        if (this._getColumnDefs()[columnIdx].sortable == this._OPTION_ENABLED)
        {
          var tableHeaderColumn = this._getTableDomUtils().getTableHeaderColumn(columnIdx);

          if (!tableHeaderColumn)
          {
            return;
          }

          if (ascending)
          {
            var headerColumnAscLink = tableHeaderColumn.find('.' + oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_ASC_LINK_CLASS);
            headerColumnAscLink.addClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._ENABLED);
            headerColumnAscLink.removeClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._DISABLED);
          }
          else
          {
            var headerColumnDscLink = tableHeaderColumn.find('.' + oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_DSC_LINK_CLASS);
            headerColumnDscLink.addClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._ENABLED);
            headerColumnDscLink.removeClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._DISABLED);
          }
        }
      },
      /**
       * Update the css class from all the cells in a column according to column state
       * @param {number} columnIdx  column index
       * @param {boolean} blur  true or false
       * @private
       */
      _updateHeaderColumnCellsClass: function(columnIdx, blur)
      {
        var state = this._getHeaderColumnState(columnIdx);
        var selected = state.selected;
        var data = this._getData();
        var i, tableBodyCell;
        for (i = 0; i < data.size(); i++)
        {
          tableBodyCell = this._getTableDomUtils().getTableBodyCell(i, columnIdx);
          if (!selected)
          {
            $(tableBodyCell).removeClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._SELECTED);
          }
          else
          {
            $(tableBodyCell).addClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._SELECTED);
          }
        }
      },
      /**
       * Update the css class from all the cells in a row according to row state
       * @param {number} rowIdx  row index
       * @param {Object} state  row state
       * @param {boolean} blur  true or false
       * @private
       */
      _updateRowCellsClass: function(rowIdx, state, blur)
      {
        var tableBodyCells = this._getTableDomUtils().getTableBodyCells(rowIdx);
        var focused = state.focused;
        var selected = state.selected;
        var hover = state.hover;

        if (!tableBodyCells)
        {
          return;
        }

        if (hover != null)
        {
          var i;
          for (i = 0; i < tableBodyCells.length; i++)
          {
            if (!hover)
            {
              $(tableBodyCells[i]).removeClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._HOVER);
            }
            else
            {
              $(tableBodyCells[i]).addClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._HOVER);
            }
          }
        }
        if (focused != null)
        {
          var i;
          for (i = 0; i < tableBodyCells.length; i++)
          {
            if (!focused)
            {
              $(tableBodyCells[i]).removeClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._FOCUS);
            }
            else
            {
              $(tableBodyCells[i]).addClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._FOCUS);
            }
          }
        }
        if (selected != null)
        {
          var i;
          for (i = 0; i < tableBodyCells.length; i++)
          {
            if (!selected)
            {
              $(tableBodyCells[i]).removeClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._SELECTED);
            }
            else
            {
              $(tableBodyCells[i]).addClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._SELECTED);
            }
          }
        }
      }
      /**** end internal functions ****/
    })
}());
/*jslint browser: true,devel:true*/
/**
 * @export
 * @class oj.FlattenedTreeTableDataSource
 * @classdesc Object representing data used by the rowexpander component
 * @param {Object} data
 * @param {Object|null} options Array of options for the TreeTableDataSource
 * @constructor
 */
oj.FlattenedTreeTableDataSource = function(data, options)
{
  // Initialize
  options = options || {};

  if (!(data instanceof oj.FlattenedTreeDataSource))
  {
    var errSummary = oj.Translations.getTranslatedString('oj-table.dataInvalidType.summary');
    var errDetail = oj.Translations.getTranslatedString('oj-table.dataInvalidType.detail');
    throw new oj.Message(errSummary, errDetail, oj.Message.SEVERITY_LEVEL['ERROR']);
  }

  this._rowSet = new oj.FlattenedTreeRowSet(data, options);
  this._addRowSetEventListeners();
  this.Init();
  
  if ((options != null && (options['startFetch'] == 'enabled' || options['startFetch'] == null))
    || options == null)
  {
    // do an initial fetch
    var self = this;
    setTimeout(function()
    {
      self.fetch({'startFetch': 'enabled'});
    }, 0);
  }
};

// Subclass from oj.DataSource 
oj.Object.createSubclass(oj.FlattenedTreeTableDataSource, oj.TableDataSource, "oj.FlattenedTreeTableDataSource");

/**
 * Initializes the instance.
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeTableDataSource
 * @instance
 */
oj.FlattenedTreeTableDataSource.prototype.Init = function()
{
  oj.FlattenedTreeTableDataSource.superclass.Init.call(this);
};

/**
 * Calls fetch on the datasource.
 * @param {Object=} options Options to control fetch<p>
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeTableDataSource
 * @instance
 */
oj.FlattenedTreeTableDataSource.prototype.fetch = function(options)
{
  this._rowSet.fetch(options);
};




/**** start delegated functions ****/

/**
 * Return the model object found at the given index of the collection.
 * 
 * @param {number} index Index for which to return the model object. 
 * @return {Object} Model object located at index. If index is out of range, returns null.
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeTableDataSource
 * @instance
 */
oj.FlattenedTreeTableDataSource.prototype.at = function(index)
{
  return this._rowSet.at(index);
};

/**
 * Collapse the specified row.
 * @param {Object} rowKey the key of the row to collapse
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeTableDataSource
 * @instance
 */
oj.FlattenedTreeTableDataSource.prototype.collapse = function(rowKey)
{
  this._rowSet.collapse(rowKey);
};

/**
 * Expand the specified row.
 * @param {Object} rowKey the key of the row to expand
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeTableDataSource
 * @instance
 */
oj.FlattenedTreeTableDataSource.prototype.expand = function(rowKey)
{
  this._rowSet.expand(rowKey);
};

/**
 * Return the first model object from the collection whose model id value is the given id or cid, or the id or cid from a passed in model
 * @param {Object|string} id ID, cid, or Model (see Model id or cid) for which to return the model object, if found. 
 * @return {Object} First model object in the collection where model.id = id or model.cid = id. If none are found, returns null.
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeTableDataSource
 * @instance
 */
oj.FlattenedTreeTableDataSource.prototype.get = function(id)
{
  return this._rowSet.get(id);
};

/**
 * Return whether there is more data which can be fetched.
 * @returns {boolean} whether there is more data
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeTableDataSource
 * @instance
 */
oj.FlattenedTreeTableDataSource.prototype.hasMore = function()
{
  return this._rowSet.hasMore();
};

/**
 * Return the array index location of the given model object.
 * @param {Object} model Model object to locate 
 * @return {number} The index of the given model object. If the object is not found, returns -1.
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeTableDataSource
 * @instance
 */
oj.FlattenedTreeTableDataSource.prototype.indexOf = function(model)
{
  return this._rowSet.indexOf(model);
};

/**
 * Attach an event handler to the datasource
 * @param {string} eventType eventType supported by the datasource
 * @param {function(Object)} eventHandler event handler function
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeTableDataSource
 * @instance
 */
oj.FlattenedTreeTableDataSource.prototype.on = function(eventType, eventHandler)
{
  if (eventType == 'expand' ||
      eventType == 'collapse')
  {
    // expand/collapse listeners should be passed through to the FlattenedTreeDatasource
    this._rowSet.on(eventType, eventHandler);
  }
  else
  {
    oj.FlattenedTreeTableDataSource.superclass.on.call(this, eventType, eventHandler);
  }
};

/**
 * Detach an event handler from the datasource
 * @param {string} eventType eventType supported by the datasource
 * @param {function(Object)} eventHandler event handler function
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeTableDataSource
 * @instance
 */
oj.FlattenedTreeTableDataSource.prototype.off = function(eventType, eventHandler)
{
  if (eventType == 'expand' ||
      eventType == 'collapse')
  {
    // expand/collapse listeners should be passed through to the FlattenedTreeDatasource
    this._rowSet.off(eventType, eventHandler);
  }
  else
  {
    oj.FlattenedTreeTableDataSource.superclass.off.call(this, eventType, eventHandler);
  }
};

/**
 * Return the size of the data locally in the dataSource. -1 if an initial fetch has not been
 * done yet.
 * @returns {number} size of data
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeTableDataSource
 * @instance
 */
oj.FlattenedTreeTableDataSource.prototype.size = function()
{
  return this._rowSet.size();
};

/**
 * Sort the models in the collection
 * @param {Object=} comparator
 * @param {Object=} options silent: if true, do not fire the sort event
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeTableDataSource
 * @instance
 */
oj.FlattenedTreeTableDataSource.prototype.sort = function(comparator, options)
{
  this._rowSet.sort(options);
};

/**
 * Return current start index.
 * @returns {number} start index
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeTableDataSource
 * @instance
 */
oj.FlattenedTreeTableDataSource.prototype.startIndex = function() {
  return this._rowSet.startIndex();
};

/**
 * Return the total size of data available, including server side if not local.
 * @returns {number} total size of data
 * @export
 * @expose
 * @memberof! oj.FlattenedTreeTableDataSource
 * @instance
 */
oj.FlattenedTreeTableDataSource.prototype.totalSize = function()
{
  return this._rowSet.totalSize();
};

/**** end delegated functions ****/

/**
 * Add event listeners to the RowSet
 * @private
 */
oj.FlattenedTreeTableDataSource.prototype._addRowSetEventListeners = function()
{
  var self = this;
  (/** @type {{on: Function}} */  (this._rowSet)).on(oj.RowSet.EventType['ADD'], function(event) {
    oj.TableDataSource.superclass.handleEvent.call(self, oj.RowSet.EventType['ADD'], event);
  });
  (/** @type {{on: Function}} */  (this._rowSet)).on(oj.RowSet.EventType['REMOVE'], function(event) {
    oj.TableDataSource.superclass.handleEvent.call(self, oj.RowSet.EventType['REMOVE'], event);
  });
  (/** @type {{on: Function}} */  (this._rowSet)).on(oj.RowSet.EventType['REQUEST'], function(event) {
    oj.TableDataSource.superclass.handleEvent.call(self, oj.RowSet.EventType['REQUEST'], event);
  });
  (/** @type {{on: Function}} */  (this._rowSet)).on(oj.RowSet.EventType['RESET'], function(event) {
    oj.TableDataSource.superclass.handleEvent.call(self, oj.RowSet.EventType['RESET'], event);
  });
  (/** @type {{on: Function}} */  (this._rowSet)).on(oj.RowSet.EventType['SORT'], function(event) {
    oj.TableDataSource.superclass.handleEvent.call(self, oj.RowSet.EventType['SORT'], event);
  });
  (/** @type {{on: Function}} */  (this._rowSet)).on(oj.RowSet.EventType['CHANGE'], function(event) {
    oj.TableDataSource.superclass.handleEvent.call(self, oj.RowSet.EventType['CHANGE'], event);
  });
  (/** @type {{on: Function}} */  (this._rowSet)).on(oj.RowSet.EventType['DESTROY'], function(event) {
    oj.TableDataSource.superclass.handleEvent.call(self, oj.RowSet.EventType['DESTROY'], event);
  });
  (/** @type {{on: Function}} */  (this._rowSet)).on(oj.RowSet.EventType['SYNC'], function(event) {
    oj.TableDataSource.superclass.handleEvent.call(self, oj.RowSet.EventType['SYNC'], event);
  });
  (/** @type {{on: Function}} */  (this._rowSet)).on(oj.RowSet.EventType['ERROR'], function(event) {
    oj.TableDataSource.superclass.handleEvent.call(self, oj.RowSet.EventType['ERROR'], event);
  });
};
/*jslint browser: true,devel:true*/
/**
 * @export
 * @class oj.TableDomUtils
 * @classdesc DOM Utils for ojTable
 * @param {Object} component ojTable instance
 * @constructor
 */
oj.TableDomUtils = function(component)
{
  this.component = component;
  this.options = component['options'];
  this.element = component['element'];
  this.Init();
};

// Subclass from oj.Object 
oj.Object.createSubclass(oj.TableDomUtils, oj.Object, "oj.TableDomUtils");

/**
 * Initializes the instance.
 * @export
 */
oj.TableDomUtils.prototype.Init = function()
{
  oj.TableDomUtils.superclass.Init.call(this);
};

/**
 * Clear any cached DOM rows
 * @private
 */
oj.TableDomUtils.prototype.clearCachedDomRowData = function()
{
  this._cachedDomTableBodyRows = null;
}

/**
 * Create a span element for acc purposes
 * @param {string} text span text
 * @param {string|null} className css class
 * @return {jQuery} jQuery span DOM element
 */
oj.TableDomUtils.prototype.createAccLabelSpan = function(text, className)
{
  var accLabel = $(document.createElement('span'));
  if (className != null)
  {
    accLabel.addClass(className);
  }
  accLabel.addClass(oj.TableDomUtils.CSS_CLASSES._HIDDEN_CONTENT_ACC_CLASS);
  accLabel.append(text);

  return accLabel;
};

/**
 * Add a default context menu to the table container if there is none. If there is
 * a context menu set on the table options we use that one. Add listeners
 * for context menu before show and select.
 * @param {function(Object)} handleContextMenuBeforeShow function called before menu show
 * @param {function(Object)} handleContextMenuSelect function called for menu select
 * @return {jQuery} jQuery ul DOM element
 */
oj.TableDomUtils.prototype.createContextMenu = function(handleContextMenuBeforeShow, handleContextMenuSelect)
{
  var menuContainer = null;
  var menuContainerId = null;
  var sortMenu = null, listItems;
  var self = this;

  if (this.options['data'] != null)
  {
    if (this.options["contextMenu"] == null && this.getTable().attr("contextmenu") == null)
    {
      menuContainer = $(document.createElement('ul'));
      menuContainer.css('display', 'none');
      menuContainer.attr('id', this.getTable().id + 'contextmenu');
      this.getTableContainer().append(menuContainer);
      sortMenu = this.createContextMenuItem('sort');
      menuContainer.append(sortMenu);
      menuContainer.ojMenu();
      this.component._setOption("contextMenu", '#' + menuContainer.attr('id'));
    }
    else
    {
      menuContainerId = this.options["contextMenu"] == null ? this.getTable().attr("contextmenu") : this.options["contextMenu"];
      menuContainer = $('#' + menuContainerId);
      listItems = menuContainer.find('[data-oj-command]');
      listItems.each(function() {
        var command;
        if ($(this).children('a').length === 0)
        {
          command = $(this).attr('data-oj-command').split("-");
          $(this).replaceWith(self.createContextMenuItem(command[command.length - 1]));
        }
      });
      menuContainer.ojMenu('refresh');
    }
    menuContainer.on("ojbeforeshow", handleContextMenuBeforeShow);
    menuContainer.on("ojselect", handleContextMenuSelect);
    this._menuContainer = menuContainer;
  }
  return menuContainer;
};

/**
 * Builds a menu for a command, takes care of submenus where appropriate
 * @return {jQuery} jQuery li DOM element
 */
oj.TableDomUtils.prototype.createContextMenuItem = function(command)
{
  if (command === 'sort')
  {
    return $(this.createContextMenuListItem(command)).append($('<ul></ul>').append($(this.createContextMenuListItem('sortAsc'))).append($(this.createContextMenuListItem('sortDsc'))));
  }
  return null;
};

/**
 * Builds a context menu list item from a command
 * @param {string} command the string to look up command value for as well as translation
 * @return {jQuery} jQuery li DOM element 
 */
oj.TableDomUtils.prototype.createContextMenuListItem = function(command)
{
  var contextMenuListItem = $(document.createElement('li'));
  contextMenuListItem.attr('data-oj-command', 'oj-table-' + command);
  contextMenuListItem.append(this.createContextMenuLabel(command));

  return contextMenuListItem;
};

/**
 * Builds a context menu label by looking up command translation
 * @param {string} command the string to look up translation for
 * @return {jQuery} jQuery a DOM element
 */
oj.TableDomUtils.prototype.createContextMenuLabel = function(command)
{
  var contextMenuLabel = $(document.createElement('a'));
  contextMenuLabel.attr('href', '#');
  var commandString = null;
  if (command == 'sort')
  {
    commandString = this.component.getTranslatedString('labelSort');
  }
  else if (command == 'sortAsc')
  {
    commandString = this.component.getTranslatedString('labelSortAsc');
  }
  else if (command == 'sortDsc')
  {
    commandString = this.component.getTranslatedString('labelSortDsc');
  }
  contextMenuLabel.append(commandString);

  return contextMenuLabel;
};

/**
 * Create the initial empty table
 * @param {boolean} isTableHeaderless is table headerless
 * @param {boolean} isTableFooterless is table footerless
 * @param {function(Object)} handleContextMenuBeforeShow function called before menu show
 * @param {function(Object)} handleContextMenuSelect function called for menu select
 * @return {jQuery} jQuery table DOM element
 */
oj.TableDomUtils.prototype.createInitialTable = function(isTableHeaderless, isTableFooterless, handleContextMenuBeforeShow, handleContextMenuSelect)
{
  var table = this.getTable();
  this.createTableContainer();
  // create the context menu
  this.createContextMenu(handleContextMenuBeforeShow, handleContextMenuSelect);
  // we only need a scroller div if we are using fallback scrolling
  if (this.isDivScroller())
  {
    this.createTableDivScroller();
  }

  if (!isTableHeaderless)
  {
    this.createTableHeader();
  }
  if (!isTableFooterless)
  {
    this.createTableFooter();
  }
  this.createTableBody();
  this.createTableNoDataMessage();
  this.createTableStatusMessage();

  return table;
};

/**
 * Create an empty tbody element with appropriate styling
 * @return {jQuery} jQuery tbody DOM element
 */
oj.TableDomUtils.prototype.createTableBody = function()
{
  var table = this.getTable();
  var tableBody = $(document.createElement('tbody'));
  table.append(tableBody);

  return tableBody;
};

/**
 * Create an empty td element with appropriate styling
 * @param {number} rowIdx  row index
 * @param {number} columnIdx  column index
 * @return {jQuery} jQuery td DOM element
 */
oj.TableDomUtils.prototype.createTableBodyCell = function(rowIdx, columnIdx)
{
  var tableBodyCell = $(document.createElement('td'));

  return tableBodyCell;
};

/**
 * Create a checkbox for accessibility row selection
 * @param {number} rowIdx  row index
 * @param {jQuery} tableBodyRow  tr DOM element
 * @return {jQuery} jQuery td DOM element
 */
oj.TableDomUtils.prototype.createTableBodyCellAccSelect = function(rowIdx, tableBodyRow)
{
  var accSelectionCell = this.getTableBodyCellAccSelect(tableBodyRow);
  var isTableHeaderless = this.getTableHeader() == null ? true : false;

  if (accSelectionCell != null)
  {
    return accSelectionCell;
  }

  accSelectionCell = $(document.createElement('td'));
  accSelectionCell.addClass(oj.TableDomUtils.CSS_CLASSES._TABLE_DATA_CELL_ACC_SELECT_CLASS);
  accSelectionCell.addClass(oj.TableDomUtils.CSS_CLASSES._HIDDEN_CONTENT_ACC_CLASS);
  if (!isTableHeaderless)
  {
    accSelectionCell.attr('headers', oj.TableDomUtils._COLUMN_HEADER_ROW_SELECT_ID);
  }
  var accSelectCheckbox = $(document.createElement('input'));
  accSelectCheckbox.attr('id', 'acc_sel_row' + rowIdx);
  accSelectCheckbox.attr('type', 'checkbox');
  accSelectCheckbox.attr('tabindex', '-1');
  var selectRowTitle = this.component.getTranslatedString(this.component._BUNDLE_KEY._LABEL_SELECT_ROW);
  accSelectCheckbox.attr('title', selectRowTitle);
  accSelectCheckbox.addClass(oj.TableDomUtils.CSS_CLASSES._CHECKBOX_ACC_SELECT_ROW_CLASS);
  accSelectionCell.append(accSelectCheckbox);
  tableBodyRow.prepend(accSelectionCell);

  return accSelectionCell;
};

/**
 * Create an empty tr element with appropriate styling
 * @param {string} rowSelectionMode  row selection mode
 * @return {jQuery} jQuery tr DOM element
 */
oj.TableDomUtils.prototype.createTableBodyRow = function(rowSelectionMode)
{
  var tableBodyRow = $(document.createElement('tr'));

  return tableBodyRow;
};

/**
 * Create an empty div element with appropriate styling
 * @return {jQuery} jQuery div DOM element
 */
oj.TableDomUtils.prototype.createTableContainer = function()
{
  var options = this.options;
  // need to enclose the table in a div to provide horizontal scrolling
  var tableContainer = $(document.createElement('div'));
  this.element.parent()[0].replaceChild(tableContainer[0], this.element[0]);
  tableContainer.prepend(this.element);

  return tableContainer;
};

/**
 * Create an empty tfoot with appropriate styling
 * @return {jQuery} jQuery tfoot DOM element
 */
oj.TableDomUtils.prototype.createTableFooter = function()
{
  var table = this.getTable();
  var tableFooter = $(document.createElement('tfoot'));
  var tableFooterRow = $(document.createElement('tr'));
  this.createTableFooterAccSelect(tableFooterRow);

  tableFooter.append(tableFooterRow);
  table.append(tableFooter);

  return tableFooter;
};

/**
 * Create a checkbox for accessibility row selection
 * @param {jQuery} tableFooterRow  tr DOM element
 * @return {jQuery} jQuery td DOM element
 */
oj.TableDomUtils.prototype.createTableFooterAccSelect = function(tableFooterRow)
{
  var accFooterCell = tableFooterRow.find('.' + oj.TableDomUtils.CSS_CLASSES._HIDDEN_CONTENT_ACC_CLASS);

  if (accFooterCell != null && accFooterCell.length > 0)
  {
    return $(accFooterCell[0]);
  }
  accFooterCell = $(document.createElement('td'));
  accFooterCell.addClass(oj.TableDomUtils.CSS_CLASSES._HIDDEN_CONTENT_ACC_CLASS);
  accFooterCell.attr('tabindex', '-1');
  tableFooterRow.prepend(accFooterCell);

  return accFooterCell;
};

/**
 * Create an empty td element with appropriate styling
 * @param {number} columnIdx  column index
 * @return {jQuery} jQuery td DOM element
 */
oj.TableDomUtils.prototype.createTableFooterCell = function(columnIdx)
{
  var tableFooterCell = $(document.createElement('td'));

  return tableFooterCell;
};

/**
 * Create an empty thead & tr element with appropriate styling
 * @return {jQuery} jQuery thead DOM element
 */
oj.TableDomUtils.prototype.createTableHeader = function()
{
  var table = this.getTable();
  var tableHeader = $(document.createElement('thead'));
  var tableHeaderRow = $(document.createElement('tr'));
  tableHeader.append(tableHeaderRow);
  table.prepend(tableHeader);

  return tableHeader;
};

/**
 * Create a th element for accessibility row selection
 * @return {jQuery} jQuery th DOM element
 */
oj.TableDomUtils.prototype.createTableHeaderAccSelectRowColumn = function()
{
  var headerColumn = $(document.createElement('th'));
  headerColumn.addClass(oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_ACC_SELECT_ROW_CLASS);
  headerColumn.addClass(oj.TableDomUtils.CSS_CLASSES._HIDDEN_CONTENT_ACC_CLASS);
  headerColumn.attr('id', oj.TableDomUtils._COLUMN_HEADER_ROW_SELECT_ID);
  var selectRowTitle = this.component.getTranslatedString(this.component._BUNDLE_KEY._LABEL_SELECT_ROW);
  headerColumn.attr('title', selectRowTitle);
  headerColumn.css('visibility', 'hidden');
  headerColumn.append(selectRowTitle);

  return headerColumn;
};

/**
 * Create a th element with appropriate styling and column content
 * @param {number} columnIdx  column index
 * @param {string} columnSelectionMode  column selection mode
 * @return {jQuery} jQuery th DOM element
 */
oj.TableDomUtils.prototype.createTableHeaderColumn = function(columnIdx, columnSelectionMode)
{
  var column = this.component['columnMetaData'](columnIdx);
  var headerColumn = $(document.createElement('th'));
  this.styleTableHeaderColumn(columnIdx, headerColumn, columnSelectionMode);
  var headerColumnRowDiv = $(document.createElement('div'));
  headerColumnRowDiv.addClass(oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_ROW_CLASS);
  headerColumnRowDiv.css('float', 'none');
  headerColumn.append(headerColumnRowDiv);
  
  // add abbr for acc
  headerColumn.attr('abbr', column.headerText);
  
  // the text div contains the column header text
  var headerColumnTextDiv = $(document.createElement('div'));
  headerColumnTextDiv.addClass(oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_TEXT_CLASS);
  headerColumnRowDiv.append(headerColumnTextDiv);
  var headerColumnTextCellDiv = $(document.createElement('div'));
  headerColumnTextCellDiv.attr('style', column.headerStyle);
  if (column.headerClassName)
  {
    headerColumnTextCellDiv.addClass(column.headerClassName);
  }
  headerColumnTextCellDiv.css('display', 'table-cell');
  headerColumnTextCellDiv.css('vertical-align', 'middle');
  headerColumnTextCellDiv.append(column.headerText);
  headerColumnTextDiv.append(headerColumnTextCellDiv);
  // sort ascending link
  var headerColumnAscDiv = $(document.createElement('div'));
  headerColumnAscDiv.addClass(oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_ASC_CLASS);
  headerColumnRowDiv.append(headerColumnAscDiv);
  if (column.sortable == oj.TableDomUtils._OPTION_ENABLED)
  {
    var headerColumnAscLink = $(document.createElement('a'));
    headerColumnAscLink.addClass(oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_ASC_LINK_CLASS);
    headerColumnAscLink.addClass(oj.TableDomUtils.CSS_CLASSES._WIDGET_ICON_CLASS);
    headerColumnAscLink.addClass(oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_ASC_ICON_CLASS);
    headerColumnAscLink.addClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._DISABLED);
    headerColumnAscLink.addClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._CLICKABLE_ICON);
    this.component._hoverable(headerColumnAscLink);
    headerColumnAscDiv.append(headerColumnAscLink);
    
    // separate link for acc
    var headerColumnAccAscLink = $(document.createElement('a'));
    headerColumnAccAscLink.attr('tabindex', '0');
    headerColumnAccAscLink.attr('href', '#');
    headerColumnAccAscLink.addClass(oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_ACC_ASC_LINK_CLASS);
    headerColumnAccAscLink.addClass(oj.TableDomUtils.CSS_CLASSES._HIDDEN_CONTENT_ACC_CLASS);
    headerColumnAccAscLink.append(this.component.getTranslatedString('labelSortAsc'));
    headerColumnAscDiv.append(headerColumnAccAscLink);
    
    headerColumn.attr('data-oj-sortable', oj.TableDomUtils._OPTION_ENABLED);
  }
  //sort descending link
  var headerColumnDscDiv = $(document.createElement('div'));
  headerColumnDscDiv.addClass(oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_DSC_CLASS);
  headerColumnRowDiv.append(headerColumnDscDiv);
  if (column.sortable == oj.TableDomUtils._OPTION_ENABLED)
  {
    var headerColumnDscLink = $(document.createElement('a'));
    headerColumnDscLink.addClass(oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_DSC_LINK_CLASS);
    headerColumnDscLink.addClass(oj.TableDomUtils.CSS_CLASSES._WIDGET_ICON_CLASS);
    headerColumnDscLink.addClass(oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_DSC_ICON_CLASS);
    headerColumnDscLink.addClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._DISABLED);
    headerColumnDscLink.addClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._CLICKABLE_ICON);
    this.component._hoverable(headerColumnDscLink);
    headerColumnDscDiv.append(headerColumnDscLink);
    
    // separate link for acc
    var headerColumnAccDscLink = $(document.createElement('a'));
    headerColumnAccDscLink.attr('tabindex', '0');
    headerColumnAccDscLink.attr('href', '#');
    headerColumnAccDscLink.addClass(oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_ACC_DSC_LINK_CLASS);
    headerColumnAccDscLink.addClass(oj.TableDomUtils.CSS_CLASSES._HIDDEN_CONTENT_ACC_CLASS);
    headerColumnAccDscLink.append(this.component.getTranslatedString('labelSortDsc'));
    headerColumnDscDiv.append(headerColumnAccDscLink);
  }

  return headerColumn;
};

/**
 * Create a checkbox for accessibility column selection
 * @param {number} columnIdx  column index
 * @param {string} columnSelectionMode  column selection mode
 * @return {jQuery} jQuery div DOM element
 */
oj.TableDomUtils.prototype.createTableHeaderColumnAccSelect = function(columnIdx, columnSelectionMode)
{
  if (columnSelectionMode != oj.TableDomUtils._OPTION_SELECTION_MODES._SINGLE &&
    columnSelectionMode != oj.TableDomUtils._OPTION_SELECTION_MODES._MULTIPLE)
  {
    return null;
  }
  var headerColumn = this.getTableHeaderColumn(columnIdx);
  var accSelectionHeaderColumn = this.getTableHeaderColumnAccSelect(columnIdx);

  if (accSelectionHeaderColumn != null)
  {
    return accSelectionHeaderColumn;
  }

  accSelectionHeaderColumn = $(document.createElement('div'));
  accSelectionHeaderColumn.addClass(oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_ACC_SELECT_COLUMN_CLASS);
  accSelectionHeaderColumn.addClass(oj.TableDomUtils.CSS_CLASSES._HIDDEN_CONTENT_ACC_CLASS);
  var accSelectCheckbox = $(document.createElement('input'));
  accSelectCheckbox.attr('id', 'acc_sel_col' + columnIdx);
  accSelectCheckbox.attr('type', 'checkbox');
  accSelectCheckbox.attr('tabindex', '-1');
  var selectColumnTitle = this.component.getTranslatedString(this.component._BUNDLE_KEY._LABEL_SELECT_COLUMN);
  accSelectCheckbox.attr('title', selectColumnTitle);
  accSelectCheckbox.addClass(oj.TableDomUtils.CSS_CLASSES._CHECKBOX_ACC_SELECT_COLUMN_CLASS);
  accSelectionHeaderColumn.append(accSelectCheckbox);
  headerColumn.prepend(accSelectionHeaderColumn);

  return accSelectionHeaderColumn;
};

/**
 * Create a div element for table scrolling. Used in scrolling fallback mode.
 * @return {jQuery} jQuery div DOM element
 */
oj.TableDomUtils.prototype.createTableDivScroller = function()
{
  var table = this.getTable();
  var tableDivScroller = $(document.createElement('div'));
  tableDivScroller.addClass(oj.TableDomUtils.CSS_CLASSES._TABLE_SCROLLER_CLASS);
  var tableContainer = table.parent();
  tableContainer.remove('.' + oj.TableDomUtils.CSS_CLASSES._TABLE_CLASS);
  tableContainer.append(tableDivScroller);
  tableDivScroller.append(table);

  return tableDivScroller;
};

/**
 * Create a div element for the 'No data to display' message
 * @return {jQuery} jQuery div DOM element
 */
oj.TableDomUtils.prototype.createTableNoDataMessage = function()
{
  var tableContainer = this.getTableContainer();
  var noDataMessage = $(document.createElement('div'));
  noDataMessage.addClass(oj.TableDomUtils.CSS_CLASSES._TABLE_NO_DATA_MESSAGE_CLASS);
  noDataMessage.css('display', 'none');
  noDataMessage.css('position', 'absolute');
  noDataMessage.css('z-index', 5000);
  var emptyTextMsg = null;
  if (this.options['emptyText'] != null)
  {
    emptyTextMsg = this.options['emptyText'];
  }
  else
  {
    emptyTextMsg = this.component.getTranslatedString(this.component._BUNDLE_KEY._MSG_NO_DATA);
  }
  noDataMessage.append(emptyTextMsg);
  tableContainer.append(noDataMessage);

  return noDataMessage;
};

/**
 * Create a div element for the Fetching Data... status message
 * @return {jQuery} jQuery div DOM element
 */
oj.TableDomUtils.prototype.createTableStatusMessage = function()
{
  var tableContainer = this.getTableContainer();
  var statusMessage = $(document.createElement('div'));
  statusMessage.addClass(oj.TableDomUtils.CSS_CLASSES._TABLE_STATUS_MESSAGE_CLASS);
  statusMessage.css('display', 'none');
  statusMessage.css('position', 'absolute');
  statusMessage.css('z-index', 5000);
  statusMessage.append(this.component.getTranslatedString(this.component._BUNDLE_KEY._MSG_FETCHING_DATA));
  tableContainer.append(statusMessage);

  return statusMessage;
};

/**
 * Get the context menu
 * @return  {jQuery} jQuery table DOM element
 */
oj.TableDomUtils.prototype.getContextMenu = function()
{
  return this._menuContainer;
};

/**
 * Get the column index of the DOM element. e.g. pass in the table cell to
 * see which column it's in.
 * @param {jQuery} element  DOM element
 * @return {number|null} the column index
 * @private
 */
oj.TableDomUtils.prototype.getElementColumnIdx = function(element)
{
  var tableBodyCell = this.getFirstAncestor(element, oj.TableDomUtils.CSS_CLASSES._TABLE_DATA_CELL_CLASS);
  if (tableBodyCell != null)
  {
    return tableBodyCell.parent().children('.' + oj.TableDomUtils.CSS_CLASSES._TABLE_DATA_CELL_CLASS).index(tableBodyCell);
  }
  
  var tableHeaderColumn = this.getFirstAncestor(element, oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_CLASS);
  if (tableHeaderColumn != null)
  {
    return tableHeaderColumn.parent().children('.' + oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_CLASS).index(tableHeaderColumn);
  }
  
  var tableFooterCell = this.getFirstAncestor(element, oj.TableDomUtils.CSS_CLASSES._TABLE_FOOTER_CELL_CLASS);
  if (tableFooterCell != null)
  {
    return tableFooterCell.parent().children('.' + oj.TableDomUtils.CSS_CLASSES._TABLE_FOOTER_CELL_CLASS).index(tableFooterCell);
  }
  return null;
};

/**
 * Get the row index of the DOM element. e.g. pass in the table cell to
 * see which row it's in.
 * @param {jQuery} element  DOM element
 * @return {number|null} the row index
 * @private
 */
oj.TableDomUtils.prototype.getElementRowIdx = function(element)
{
  var tableBodyRow = this.getFirstAncestor(element, oj.TableDomUtils.CSS_CLASSES._TABLE_DATA_ROW_CLASS);
  
  if (tableBodyRow != null)
  {
    return tableBodyRow.index();
  }
  return null;
};

/**
 * Return table dimensions without any data
 * @return {Object} the height and width of the table
 */
oj.TableDomUtils.prototype.getEmptyTableDimensions = function()
{
  var table = this.getTable();
  var tableBody = this.getTableBody();
  var tableHeader = this.getTableHeader();
  var tableFooter = this.getTableFooter();
  var tableHeaderDisplay = '';
  var tableBodyDisplay = '';
  var tableFooterDisplay = '';

  if (tableHeader != null)
  {
    tableHeaderDisplay = tableHeader.css('display').toString();
    tableHeader.css('display', 'none');
  }

  if (tableBody != null)
  {
    tableBodyDisplay = tableBody.css('display').toString();
    tableBody.css('display', 'none');
  }
  if (tableFooter != null)
  {
    tableFooterDisplay = tableFooter.css('display').toString();
    tableFooter.css('display', 'none');
  }
  table.removeClass(oj.TableDomUtils.CSS_CLASSES._TABLE_CLASS);

  var dimensions = {height: table.height(), width: table.width()};

  table.addClass(oj.TableDomUtils.CSS_CLASSES._TABLE_CLASS);
  if (tableBody != null)
  {
    tableBody.css('display', tableBodyDisplay);
  }
  if (tableHeader != null)
  {
    tableHeader.css('display', tableHeaderDisplay);
  }
  if (tableFooter != null)
  {
    tableFooter.css('display', tableFooterDisplay);
  }

  return dimensions;
};

/**
  * Find the first ancestor of an element with a specific class name
  * @param {jQuery} element the element to find the nearest class name to
  * @param {string} className the class name to look for
  * @return {jQuery|null} the element with the className, if there is none returns null 
  */
oj.TableDomUtils.prototype.getFirstAncestor = function(element, className) 
{
  var parents;
  
  if (element == null)
  {
    return null;
  }
  element = $(element);

  if (element.hasClass(className))
  {
    return element;
  }
  parents = element.parents('.' + className);
  if (parents.length != 0)
  {
    return parents.eq(0);
  }
  return null;
};

/**
  * Get the context object to pass into the renderer
  * @param {Object} row  oj.Row instance
  * @param {Object} parentElement element
  * @private
  */
oj.TableDomUtils.prototype.getRendererContextObject = function(row, parentElement)
{
  var context = [];
  context['component'] = this.component;
  context['datasource'] = this.options['data'];
  context['parentElement'] = parentElement;

  if (row != null)
  {
    context['status'] = this.getRendererStatusObject(row);
    var rowContext = row.context;
    var i;
    for (i in rowContext)
    {
      if (rowContext.hasOwnProperty(i))
      {
        context[i] = rowContext[i];
      }
    }
  }

  return context;
};

/**
 * Get the status object to pass into the renderer
 * @param {Object} row  oj.Row instance
 * @return {Object} status object
 * @private
 */
oj.TableDomUtils.prototype.getRendererStatusObject = function(row)
{
  return {'rowIndex': this.options['data'].indexOf(row),
    'rowKey': row['id'],
    'activeRow': this.component['activeRow']()};
};

/**
 * Return the scrollbar height
 * @return {number} scrolbar height
 * @private
 */
oj.TableDomUtils.prototype.getScrollbarHeight = function()
{
  var scroller = this.getScroller();
  var scrollbarHeight = scroller.get(0).offsetHeight - scroller.get(0).clientHeight;

  return scrollbarHeight;
};

/**
 * Return the scrollbar width
 * @return {number} scrolbar width
 * @private
 */
oj.TableDomUtils.prototype.getScrollbarWidth = function()
{
  var scroller = this.getScroller();
  var scrollbarWidth = scroller.get(0).offsetWidth - scroller.get(0).clientWidth;

  return scrollbarWidth;
};

/**
 * Return the table scroller
 * @return {jQuery} scrolbar
 */
oj.TableDomUtils.prototype.getScroller = function()
{
  if (!this.isDivScroller())
  {
    return this.getTableBody();
  }
  else
  {
    return this.getTableDivScroller();
  }
};
        
/**
 * Return the table element
 * @return {jQuery} jQuery table DOM element
 */
oj.TableDomUtils.prototype.getTable = function()
{
  return $(this.element);
};

/**
 * Return the table body element
 * @return {jQuery|null} jQuery tbody DOM element
 */
oj.TableDomUtils.prototype.getTableBody = function()
{
  if (!this._cachedDomTableBody)
  {
    var table = this.getTable();
    var tableBody = null;
    if (table)
    {
      tableBody = table.find('.' + oj.TableDomUtils.CSS_CLASSES._TABLE_BODY_CLASS);
      if (tableBody && tableBody.length > 0)
      {
        this._cachedDomTableBody = $(tableBody.get(0));
      }
    }
  }

  return this._cachedDomTableBody;
};

/**
 * Return the cell element
 * param {number} rowIdx  row index
 * param {number} columnIdx  column index
 * @return {jQuery|null} jQuery td DOM element
 */
oj.TableDomUtils.prototype.getTableBodyCell = function(rowIdx, columnIdx)
{
  var tableBodyCells = this.getTableBodyCells(rowIdx);
  if (!tableBodyCells)
  {
    return null;
  }

  // this should return the correct cell
  if (tableBodyCells.length > columnIdx)
  {
    var tableBodyCellColumnIdx = this.getElementColumnIdx(tableBodyCells[columnIdx]);
    if (tableBodyCellColumnIdx == columnIdx)
    {
      return $(tableBodyCells[columnIdx]);
    }
  }

  // if not, search through all the cells
  var i;
  for (i = 0; i < tableBodyCells.length; i++)
  {
    if (this.getElementColumnIdx(tableBodyCells[i]) == columnIdx)
    {
      return $(tableBodyCells[i]);
    }
  }

  return null;
};

/**
 * Get checkbox cell for accessibility row selection
 * @param {jQuery} tableBodyRow  tr DOM element
 * @return {jQuery|null} jQuery td DOM element
 */
oj.TableDomUtils.prototype.getTableBodyCellAccSelect = function(tableBodyRow)
{
  if (tableBodyRow != null)
  {
    var accSelectionCell = tableBodyRow.find('.' + oj.TableDomUtils.CSS_CLASSES._TABLE_DATA_CELL_ACC_SELECT_CLASS);

    if (accSelectionCell != null && accSelectionCell.length > 0)
    {
      return $(accSelectionCell[0]);
    }
  }
  return null;
};

/**
 * Return all the cell elements in a row
 * @param {number} rowIdx  row index
 * @return {jQuery|null} jQuery array of td DOM elements
 */
oj.TableDomUtils.prototype.getTableBodyCells = function(rowIdx)
{
  var tableBodyRow = this.getTableBodyRow(rowIdx);

  if (!tableBodyRow)
  {
    return null;
  }

  var tableBodyCellElements = tableBodyRow.children('.' + oj.TableDomUtils.CSS_CLASSES._TABLE_DATA_CELL_CLASS);

  if (tableBodyCellElements != null && tableBodyCellElements.length > 0)
  {
    return tableBodyCellElements;
  }

  return null;
};

/**
 * Return table row
 * @param {number|null} rowIdx  row index
 * @return {jQuery|null} jQuery tr DOM element
 */
oj.TableDomUtils.prototype.getTableBodyRow = function(rowIdx)
{
  var tableBodyRows = this.getTableBodyRows();

  if (!tableBodyRows)
  {
    return null;
  }
  
  if (rowIdx == null)
  {
    return null;
  }

  // this should return the correct row
  if (tableBodyRows.length > rowIdx)
  {
    var tableBodyRowIdx = this.getElementRowIdx(tableBodyRows[rowIdx]);
    if (tableBodyRowIdx == rowIdx)
    {
      return $(tableBodyRows[rowIdx]);
    }
  }

  // if not, search through all the rows
  var i;
  for (i = 0; i < tableBodyRows.length; i++)
  {
    if (this.getElementRowIdx(tableBodyRows[i]) == rowIdx)
    {
      return $(tableBodyRows[i]);
    }
  }

  return null;
};

/**
 * Return all the table rows
 * @return {jQuery|null} jQuery array of tr DOM elements
 */
oj.TableDomUtils.prototype.getTableBodyRows = function()
{
  if (!this._cachedDomTableBodyRows)
  {
    var tableBody = this.getTableBody();
    var tableBodyRowElements = tableBody.children('.' + oj.TableDomUtils.CSS_CLASSES._TABLE_DATA_ROW_CLASS);

    if (tableBodyRowElements != null && tableBodyRowElements.length > 0)
    {
      this._cachedDomTableBodyRows = tableBodyRowElements;
    }
  }

  return this._cachedDomTableBodyRows;
};

/**
 * Return the table container
 * @return {jQuery|null} jQuery div DOM element
 */
oj.TableDomUtils.prototype.getTableContainer = function()
{
  if (!this._cachedDomTableContainer)
  {
    if (!this.isDivScroller())
    {
      this._cachedDomTableContainer = $(this.element.get(0).parentNode);
    }
    else
    {
      this._cachedDomTableContainer = $(this.element.get(0).parentNode.parentNode);
    }
  }

  return this._cachedDomTableContainer;
};

/**
 * Return the table footer
 * @return {jQuery|null} jQuery tfoot DOM element
 */
oj.TableDomUtils.prototype.getTableFooter = function()
{
  var table = this.getTable();
  var tableFooter = null;
  if (table)
  {
    tableFooter = table.find('.' + oj.TableDomUtils.CSS_CLASSES._TABLE_FOOTER_CLASS);
    if (tableFooter && tableFooter.length > 0)
    {
      return $(tableFooter.get(0));
    }
  }

  return null;
};

/**
 * Return table footer row
 * @return {jQuery|null} jQuery tr DOM element
 */
oj.TableDomUtils.prototype.getTableFooterRow = function()
{
  if (!this._cachedDomTableFooterRow)
  {
    var tableFooter = this.getTableFooter();

    if (!tableFooter)
    {
      return null;
    }

    this._cachedDomTableFooterRow = $(tableFooter.children('.' + oj.TableDomUtils.CSS_CLASSES._TABLE_FOOTER_ROW_CLASS).get(0));
  }

  return this._cachedDomTableFooterRow;
};

/**
 * Return the table header
 * @return {jQuery|null} jQuery thead DOM element
 */
oj.TableDomUtils.prototype.getTableHeader = function()
{
  if (!this._cachedDomTableHeader)
  {
    var table = this.getTable();
    var tableHeader = null;
    if (table)
    {
      tableHeader = table.find('.' + oj.TableDomUtils.CSS_CLASSES._TABLE_HEADER_CLASS);
      if (tableHeader && tableHeader.length > 0)
      {
        this._cachedDomTableHeader = $(tableHeader.get(0));
      }
    }
  }

  return this._cachedDomTableHeader;
};

/**
 * Return table column header
 * @param {number} columnIdx  column index
 * @return {jQuery|null} jQuery th DOM element
 */
oj.TableDomUtils.prototype.getTableHeaderColumn = function(columnIdx)
{
  var headerColumns = this.getTableHeaderColumns();

  if (!headerColumns)
  {
    return null;
  }

  // this should return the correct header column
  if (headerColumns.length > columnIdx)
  {
    var headerColumnIdx = this.getElementColumnIdx(headerColumns[columnIdx]);
    if (headerColumnIdx == columnIdx)
    {
      return $(headerColumns[columnIdx]);
    }
  }

  // if not, search through all the headdesre columns
  var i;
  for (i = 0; i < headerColumns.length; i++)
  {
    if (this.getElementColumnIdx(headerColumns[i]) == columnIdx)
    {
      return $(headerColumns[i]);
    }
  }

  return null;
};

/**
 * Get checkbox cell for accessibility column selection
 * @param {number} columnIdx  column index
 * @return {jQuery|null} jQuery td DOM element
 */
oj.TableDomUtils.prototype.getTableHeaderColumnAccSelect = function(columnIdx)
{
  var headerColumn = this.getTableHeaderColumn(columnIdx);

  if (headerColumn != null)
  {
    var accSelectionCell = headerColumn.find('.' + oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_ACC_SELECT_COLUMN_CLASS);

    if (accSelectionCell != null && accSelectionCell.length > 0)
    {
      return $(accSelectionCell[0]);
    }
  }
  return null;
};

/**
 * Return all table column headers
 * @return {jQuery|null} jQuery array of th DOM elements
 */
oj.TableDomUtils.prototype.getTableHeaderColumns = function()
{
  var tableHeaderRow = this.getTableHeaderRow();

  if (tableHeaderRow != null)
  {
    var headerColumnElements = tableHeaderRow.children('.' + oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_CLASS);

    if (headerColumnElements != null && headerColumnElements.length > 0)
    {
      return headerColumnElements;
    }
  }

  return null;
};

/**
 * Return table header row
 * @return {jQuery|null} jQuery th DOM element
 */
oj.TableDomUtils.prototype.getTableHeaderRow = function()
{
  if (!this._cachedDomTableHeaderRow)
  {
    var tableHeader = this.getTableHeader();

    if (!tableHeader)
    {
      return null;
    }

    this._cachedDomTableHeaderRow = $(tableHeader.children('.' + oj.TableDomUtils.CSS_CLASSES._TABLE_HEADER_ROW_CLASS).get(0));
  }

  return this._cachedDomTableHeaderRow;
};

/**
 * Return the table div scroller
 * @return {jQuery|null} jQuery div DOM element
 */
oj.TableDomUtils.prototype.getTableDivScroller = function()
{
  if (!this._cachedDomTableDivScroller)
  {
    var tableContainer = this.getTableContainer();
    if (tableContainer)
    {
      var tableDivScroller = tableContainer.find('.' + oj.TableDomUtils.CSS_CLASSES._TABLE_SCROLLER_CLASS);
      if (tableDivScroller && tableDivScroller.length > 0)
      {
        this._cachedDomTableDivScroller = $(tableDivScroller.get(0));
      }
    }
  }
  return this._cachedDomTableDivScroller;
};

/**
 * Return the table no data message element
 * @return {jQuery|null} jQuery div DOM element
 */
oj.TableDomUtils.prototype.getTableNoDataMessage = function()
{
  if (!this._cachedDomTableNoDataMessage)
  {
    var tableContainer = this.getTableContainer();
    if (tableContainer)
    {
      var noDataMessage = tableContainer.find('.' + oj.TableDomUtils.CSS_CLASSES._TABLE_NO_DATA_MESSAGE_CLASS);
      if (noDataMessage && noDataMessage.length > 0)
      {
        this._cachedDomTableNoDataMessage = $(noDataMessage.get(0));
      }
    }
  }
  return this._cachedDomTableNoDataMessage;
};

/**
 * Return the table status message element
 * @return {jQuery|null} jQuery div DOM element
 */
oj.TableDomUtils.prototype.getTableStatusMessage = function()
{
  if (!this._cachedDomTableStatusMessage)
  {
    var tableContainer = this.getTableContainer();
    if (tableContainer)
    {
      var statusMessage = tableContainer.find('.' + oj.TableDomUtils.CSS_CLASSES._TABLE_STATUS_MESSAGE_CLASS);
      if (statusMessage && statusMessage.length > 0)
      {
        this._cachedDomTableStatusMessage = $(statusMessage.get(0));
      }
    }
  }

  return this._cachedDomTableStatusMessage;
};

/**
 * Insert a td element in the appropriate place in the DOM
 * @param {number} rowIdx  row index
 * @param {number} columnIdx  column index
 * @param {jQuery} tableBodyCell  DOM element
 * @param {jQuery} tableBodyRow  tr DOM element
 */
oj.TableDomUtils.prototype.insertTableBodyCell = function(rowIdx, columnIdx, tableBodyCell, tableBodyRow)
{
  this.setTableBodyCellAttributes(rowIdx, columnIdx, tableBodyCell);

  var tableBodyCells = $(tableBodyRow).children('.' + oj.TableDomUtils.CSS_CLASSES._TABLE_DATA_CELL_CLASS);

  if (columnIdx == 0)
  {
    // insert right after the acc cell
    var accSelectionCell = tableBodyRow.find('.' + oj.TableDomUtils.CSS_CLASSES._TABLE_DATA_CELL_ACC_SELECT_CLASS);

    if (accSelectionCell != null && accSelectionCell.length > 0)
    {
      $(accSelectionCell[0]).after(tableBodyCell);
    }
    else
    {
      // just prepend it
      tableBodyRow.prepend(tableBodyCell)
    }
  }
  else if (tableBodyCells.length >= columnIdx)
  {
    var previousCell = $(tableBodyCells.get(columnIdx - 1));
    previousCell.after(tableBodyCell);
  }
  else
  {
    $(tableBodyRow).append(tableBodyCell);
  }

  return tableBodyCell;
};

/**
 * Insert a tr element in the appropriate place in the DOM
 * @param {number} rowIdx  row index
 * @param {jQuery} tableBodyRow  DOM element
 * @param {Object} row  oj.Row
 * @param {Object} docFrag  document fragment
 */
oj.TableDomUtils.prototype.insertTableBodyRow = function(rowIdx, tableBodyRow, row, docFrag)
{
  var tableBodyRows = null;

  if (docFrag == null)
  {
    // if docFragm is null then get from the DOM nodes
    var tableBody = this.getTableBody();
    tableBodyRows = tableBody.children('.' + oj.TableDomUtils.CSS_CLASSES._TABLE_DATA_ROW_CLASS);
  }
  else
  {
    tableBodyRows = docFrag.children('.' + oj.TableDomUtils.CSS_CLASSES._TABLE_DATA_ROW_CLASS);
  }
  this.setTableBodyRowAttributes(rowIdx, row, tableBodyRow);
  this.createTableBodyCellAccSelect(rowIdx, tableBodyRow);

  if (docFrag == null)
  {
    if (rowIdx == 0)
    {
      // just prepend it
      tableBody.prepend(tableBodyRow);
    }
    else if (tableBodyRows.length >= rowIdx)
    {
      var previousRow = $(tableBodyRows.get(rowIdx - 1));
      previousRow.after(tableBodyRow);
    }
    else
    {
      tableBody.append(tableBodyRow);
    }
  }
  else
  {
    docFrag.append(tableBodyRow);
  }
  this.clearCachedDomRowData();
};

/**
 * Insert a td element in the appropriate place in the DOM
 * @param {number} columnIdx  column index
 * @param {jQuery} tableFooterCell  DOM element
 */
oj.TableDomUtils.prototype.insertTableFooterCell = function(columnIdx, tableFooterCell)
{
  var tableFooterRow = this.getTableFooterRow();
  var tableFooterCells = $(tableFooterRow).children('.' + oj.TableDomUtils.CSS_CLASSES._TABLE_FOOTER_CELL_CLASS);

  if (columnIdx == 0)
  {
    // insert right after the acc cell
    var accFooterCell = tableFooterRow.find('.' + oj.TableDomUtils.CSS_CLASSES._HIDDEN_CONTENT_ACC_CLASS);

    if (accFooterCell != null && accFooterCell.length > 0)
    {
      $(accFooterCell[0]).after(tableFooterCell);
    }
    else
    {
      // just prepend it
      tableFooterRow.prepend(tableFooterCell)
    }
  }
  else if (tableFooterRow.length >= columnIdx)
  {
    var previousCell = $(tableFooterCells.get(columnIdx - 1));
    previousCell.after(tableFooterCell);
  }
  else
  {
    tableFooterRow.append(tableFooterCell);
  }

  return tableFooterCell;
};

/**
 * Insert a th element in the appropriate place in the DOM
 * @param {number} columnIdx  column index
 * @param {jQuery} tableHeaderColumn  DOM element
 */
oj.TableDomUtils.prototype.insertTableHeaderColumn = function(columnIdx, tableHeaderColumn)
{
  var tableHeaderRow = this.getTableHeaderRow();
  var tableHeaderColumns = this.getTableHeaderColumns();
  // save the column index on the element
  this.setTableHeaderColumnAttributes(columnIdx, tableHeaderColumn);

  // if there is an existing th at the index then replace it
  var oldTableHeaderColumn = this.getTableHeaderColumn(columnIdx);
  if (oldTableHeaderColumn)
    oldTableHeaderColumn.replaceWith(tableHeaderColumn);
  else
  {
    if (columnIdx == 0)
    {
      // insert right after the acc column
      var accSelectionColumn = tableHeaderRow.find('.' + oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_ACC_SELECT_ROW_CLASS);

      if (accSelectionColumn != null && accSelectionColumn.length > 0)
      {
        $(accSelectionColumn[0]).after(tableHeaderColumn);
      }
      else
      {
        // just prepend it
        tableHeaderRow.prepend(tableHeaderColumn)
      }
    }
    else if (tableHeaderColumns.length >= columnIdx)
    {
      var previousColumn = $(tableHeaderColumns.get(columnIdx - 1));
      previousColumn.after(tableHeaderColumn);
    }
    else
    {
      tableHeaderRow.append(tableHeaderColumn);
    }
  }
};

/**
  * Returns true if a div scroller is used. False if tbody scrolling is used.
  * @return {boolean} Whether div scroller is used
  */
oj.TableDomUtils.prototype.isDivScroller = function()
{
  return this._isIE() && this._isIE() < 10 ? true : false;
}

/**
  * Refresh the table dimensions
  */
 oj.TableDomUtils.prototype.refreshTableDimensions = function()
 {
   var options = this.options;
   var table = this.getTable();
   var tableHeader = this.getTableHeader();
   var tableFooter = this.getTableFooter();
   var tableHeaderRow = this.getTableHeaderRow();
   var tableContainer = this.getTableContainer();
   var tableBody = this.getTableBody();
   var data = options['data'];

   // fix up the table header padding to accommodate the sort links
   this._refreshColumnHeaderPadding();

   // first remove any styling so that the browser sizes the table
   this._removeTableDimenionsStyling();
   
   // apply table container styling just in case rootAttributes changed
   this.styleTableContainer(tableContainer, 0, 0);
   
   var emptyTableDimensions = this.getEmptyTableDimensions();
   
   // style the table container to the same dimensions as table and
   this.styleTableContainer(tableContainer, emptyTableDimensions['height'], emptyTableDimensions['width']);
   
   var isTableHeightScrolled = tableContainer[0].scrollHeight > tableContainer[0].clientHeight ? true: false;
   var isTableWidthScrolled = tableContainer[0].scrollHeight > tableContainer[0].clientHeight ? true: false;

   if (!isTableHeightScrolled && !isTableWidthScrolled)
   {
     // remove dimensions on the container
     this.styleTableContainer(tableContainer, 0, 0);
     
     if (data != null && data.size() > 0)
     {
       // if we have data and height and width are not specified then
       // we want the databody to be the same size as the row data
       tableBody.css('display', 'table-row-group');
     }
     else
     {
       tableBody.css('display', 'block');
     }

     if (!this._isIE())
     {
       // size the tableBody so it's at least min size
       var minHeight = parseInt(table.css('minHeight'), 10);
       if (minHeight > 0)
       {
         var tableHeaderHeight = 0;
         if (tableHeader != null)
         {
           tableHeaderHeight = tableHeader.height();
         }
         var tableFooterHeight = 0;
         if (tableFooter != null)
         {
           tableFooterHeight = tableFooter.height();
         }
         tableBody.css('min-height', minHeight - tableHeaderHeight - tableFooterHeight + 'px');
       }
     }

     this._refreshTableMessagingPosition();

     // we don't need to set any other table dimensions if height or width are not specified
     // just let the browser do everything
     return;
   }

   this._setHeaderColumnAndCellColumnWidths();

   // apply the styling which sets the fixed column headers, etc
   var tableHeaderHeight = 0;
   if (tableHeader != null)
   {
     if (isTableHeightScrolled || isTableWidthScrolled)
     {
       tableHeader.css('position', 'absolute');
       tableHeaderRow.css('display', 'block');
     }

     if (this.isDivScroller())
     {
       tableHeader.css('position', 'absolute');
       tableHeader.css('top', '0px');
       // if we use fallback scrolling then the padding top of the container is used to 
       // position the table scroller to below the table header.
       tableContainer.css('padding-top', tableHeader.height() + 'px');
     }
     tableHeaderHeight = tableHeader.height();
     tableBody.css('top', tableHeaderHeight + 'px');
   }
   var tableFooterHeight = 0;
   if (tableFooter != null)
   {
     if (isTableHeightScrolled || isTableWidthScrolled)
     {
       tableFooter.css('position', 'absolute');
       tableFooter.css('display', 'block');
     }
     tableFooterHeight = tableFooter.height();
   }

   tableBody.css('display', 'block');

   if (isTableHeightScrolled || isTableWidthScrolled)
   {
     table.css('display', 'block');
     tableBody.css('position', 'relative');

     if (!this.isDivScroller())
     {
       tableBody.css('overflow-y', 'auto');

       if (isTableWidthScrolled)
       {
         tableBody.css('overflow-x', 'auto');
         tableBody.css('width', emptyTableDimensions['width']);
         if (tableHeader != null)
         {
           tableHeader.css('width', emptyTableDimensions['width']);
         }
       }
       else
       {
         tableBody.css('overflow-x', 'hidden');
       }

       if (isTableHeightScrolled)
       {
         // if we don't use fallbacks crolling then size the table body
         // to fit in the height
         var tableBodyHeight = emptyTableDimensions['height'] - tableHeaderHeight - tableFooterHeight;
         if (tableBodyHeight > 0)
         {
           tableBody.css('height', tableBodyHeight + 'px');
           tableBody.css('min-height', tableBodyHeight + 'px');
         }
       }
     }
     else
     {
       if (isTableHeightScrolled)
       {
         // if we use fallback scrolling then we don't size the table body 
         // because the table scroller div is used to size the data body
         // and provide scrolling
         tableContainer.css('padding-top', tableHeaderHeight + 'px');
       }
     }

     if (tableFooter != null)
     {
       // position the footer at the bottom
       tableFooter.css('top', tableHeaderHeight + tableBody.height() + 'px');
     }
   }

   var scrollbarWidth = this.getScrollbarWidth();
   var scrollbarHeight = this.getScrollbarHeight();

   if (!isTableWidthScrolled)
   {
     if ((data == null || data.size() == 0) && tableHeader != null)
     {
       // if width is not set and we don't currently have any data. We should
       // set the tableBody width to the tableHeader width to prevent 
       // a zero width table.
       tableBody.css('width', tableHeader.width() + 'px');
     }
     else
     {
       if (scrollbarWidth > 0)
       {
         // size the databody so it's full width
         var tableBodyRow = this.getTableBodyRow(0);
         tableBody.css('width', tableBodyRow.width() + scrollbarWidth + 'px');
       }
       else
       {
         tableBody.css('width', '');
       }
     }
   }

   var tableBodyWidth = tableBody.width();

   if (tableHeader != null)
   {
     if (scrollbarWidth > 0)
     {
       // if we have scrollbars then size the tableheader 
       // to align with the scrollbars
       tableHeader.css('overflow', 'hidden');
       tableHeader.css('width', tableBodyWidth - scrollbarWidth + 'px');
     }
     else
     {
       // else table header should be the same width as the table body
       tableHeader.css('width', tableBodyWidth + 'px');
     }
   }

   if (!isTableHeightScrolled &&
     isTableWidthScrolled &&
     tableHeader != null && !this.isDivScroller())
   {
     // if only table width is set then we need to size the 
     // tableContainer div so that it includes the tbody and thead.
     // We need to manually do this because the thead has absolute positioning
     // and hence does not get included in the container div sizing
     var totalHeight = tableHeaderHeight + tableFooterHeight + tableBody.height();
     table.css('height', totalHeight + 'px');
   }

   if (this.isDivScroller())
   {
     var tableDivScroller = this.getTableDivScroller();
     tableDivScroller.css('overflow', 'auto');

     if (isTableWidthScrolled)
     {
       tableDivScroller.css('width', emptyTableDimensions['width']);
     }

     if (isTableHeightScrolled)
     {
       tableDivScroller.css('height', emptyTableDimensions['height']);
     }

     if (tableHeader != null)
     {
       // save the tableHeader width for use later
       this._tableHeaderWidth = tableHeader.width();
     }
   }
   this._refreshTableMessagingPosition();
 };

/**
 * Remove a tr element from the DOM
 * @param {number} rowIdx  row index
 */
oj.TableDomUtils.prototype.removeTableBodyRow = function(rowIdx)
{
  var tableBodyRow = this.getTableBodyRow(rowIdx);
  if (tableBodyRow != null)
  {
    tableBodyRow[0].parentNode.removeChild(tableBodyRow[0]);
    this.clearCachedDomRowData();
  }
};

/**
 * Replace a tr element in the appropriate place in the DOM
 * @param {number} rowIdx  row index
 * @param {jQuery} tableBodyRow  DOM element
 * @param {Object} row  oj.Row
 * @param {Object} docFrag  document fragment
 */
oj.TableDomUtils.prototype.replaceTableBodyRow = function(rowIdx, tableBodyRow, row, docFrag)
{
  var oldTableBodyRow = this.getTableBodyRow(rowIdx);
  if (oldTableBodyRow)
  {
    oldTableBodyRow.replaceWith(tableBodyRow);
    this.clearCachedDomRowData();
  }
  else
  {
    this.insertTableBodyRow(rowIdx, tableBodyRow, row, docFrag);
  }
};

/**
 * Set the td cell. Calls the cell renderer or populates the value.
 * @param {number} rowIdx  row index
 * @param {number} columnIdx  column index
 * @param {jQuery} tableBodyRow  tr DOM element
 * @param {Object} row  oj.Row
 * @param {function(Object)} cellRenderer cell renderer
 * 
 */
oj.TableDomUtils.prototype.setTableBodyCell = function(rowIdx, columnIdx, tableBodyRow, row, cellRenderer)
{
  var columns = this.component['columnMetaData']();
  var column = columns[columnIdx];

  var tableBodyCell = this.getTableBodyCell(rowIdx, columnIdx);

  if (!tableBodyCell)
  {
    tableBodyCell = this.createTableBodyCell(rowIdx, columnIdx);
    this.styleTableBodyCell(columnIdx, tableBodyCell);
    this.insertTableBodyCell(rowIdx, columnIdx, tableBodyCell, tableBodyRow);
  }
  else
  {
    tableBodyCell.empty();
  }
  var data = null;

  if (column.field != null)
  {
    data = row.get(column.field);
  }

  if (cellRenderer)
  {
    var cellContext = this.getRendererContextObject(row, tableBodyCell[0]);
    var cellColumnContent = cellRenderer({'cellContext': cellContext,
      'column': column,
      'data': data,
      'row': row.pairs()});

    if (cellColumnContent != null)
    {
      // if the renderer returned a value then we set it as the content
      // for the cell
      tableBodyCell.append(cellColumnContent);
    }
    else
    {
      // if the renderer didn't return a value then the existing
      // cell was manipulated. So get it and set the required
      // attributes just in case it was replaced or the attributes
      // got removed
      tableBodyCell = $(tableBodyRow.children(':not(' + '.' + oj.TableDomUtils.CSS_CLASSES._TABLE_DATA_CELL_ACC_SELECT_CLASS + ')')[columnIdx]);
      this.setTableBodyCellAttributes(rowIdx, columnIdx, tableBodyCell);
      this.styleTableBodyCell(columnIdx, tableBodyCell);
    }
  }
  else
  {
    tableBodyCell.append(data);
  }
};

/**
 * Set the attributes on the cell like rowIdx, columnIdx, etc
 * @param {number} rowIdx  row index
 * @param {number} columnIdx  column index
 * @param {jQuery} tableBodyCell  td DOM element
 */
oj.TableDomUtils.prototype.setTableBodyCellAttributes = function(rowIdx, columnIdx, tableBodyCell)
{
  var accessibility = this.options['accessibility'];
  var column = this.component['columnMetaData'](columnIdx);
  var rowHeaderColumnId = null;
  var isTableHeaderless = this.getTableHeader() == null ? true : false;

  if (accessibility != null && accessibility['rowHeader'] != null)
  {
    rowHeaderColumnId = accessibility['rowHeader'];
  }
  else
  {
    rowHeaderColumnId = this.component['columnMetaData'](0).id;
  }

  var cellRowHeaderId = rowHeaderColumnId + '_' + rowIdx;

  var headers = column.id;
  if (rowHeaderColumnId == column.id)
  {
    tableBodyCell.attr('id', cellRowHeaderId);

    if (isTableHeaderless)
    {
      headers = '';
    }
  }
  else
  {
    if (!isTableHeaderless)
    {
      headers = headers + ' ' + cellRowHeaderId;
    }
    else
    {
      headers = cellRowHeaderId;
    }
  }

  if (!tableBodyCell.attr('headers'))
  {
    tableBodyCell.attr('headers', headers);
  }
};

/**
 * Set the attributes on the row like rowIdx, etc
 * @param {number} rowIdx  row index
 * @param {Object} row  oj.Row
 * @param {jQuery} tableBodyRow  tr DOM element
 */
oj.TableDomUtils.prototype.setTableBodyRowAttributes = function(rowIdx, row, tableBodyRow)
{
};

/**
 * Set the attributes on the header like columndx, etc
 * @param {number} columnIdx  column index
 * @param {jQuery} tableHeaderColumn  th DOM element
 * @private
 */
oj.TableDomUtils.prototype.setTableHeaderColumnAttributes = function(columnIdx, tableHeaderColumn)
{
  var column = this.component['columnMetaData'](columnIdx);

  if (!tableHeaderColumn.attr('id'))
  {
    tableHeaderColumn.attr('id', column.id);
  }
};

/**
 * Style the initial table
 */
oj.TableDomUtils.prototype.styleInitialTable = function()
{
  var table = this.getTable();
  var tableContainer = this.getTableContainer();
  var tableHeader = table.children('thead');
  tableHeader = tableHeader.length > 0 ? $(tableHeader[0]) : null;
  var tableFooter = table.children('tfoot');
  tableFooter = tableFooter.length > 0 ? $(tableFooter[0]) : null;
  var tableBody = table.children('tbody');
  tableBody = tableBody.length > 0 ? $(tableBody[0]) : null;
  // set the tabindex
  table.attr('tabindex', '0');
  // set focusable
  this.component._focusable(table);
  // set focusable
  this.component._hoverable(table);
        
  this.styleTableContainer(tableContainer, 0, 0);
  this.styleTableHeader(tableHeader);
  this.styleTableFooter(tableFooter);
  this.styleTableBody(tableBody);
};

/**
 * Style the tbody element
 * @param {jQuery} tableBody thead DOM element
 */
oj.TableDomUtils.prototype.styleTableBody = function(tableBody)
{
  tableBody.addClass(oj.TableDomUtils.CSS_CLASSES._TABLE_BODY_CLASS);
  // Add a special marker attribute to tell child components that they are container within table
  tableBody.attr(oj.Components._OJ_CONTAINER_ATTR, this.component['widgetName']);
};

/**
 * Style the td element
 * @param {number} columnIdx  column index
 * @param {jQuery} tableBodyCell  td DOM element
 */
oj.TableDomUtils.prototype.styleTableBodyCell = function(columnIdx, tableBodyCell)
{
  var options = this.options;
  var lastColumn = columnIdx == this.component['columnMetaData']().length - 1 ? true : false;
  var column = this.component['columnMetaData'](columnIdx);

  tableBodyCell.attr('style', column.style);
  if (!tableBodyCell.hasClass(oj.TableDomUtils.CSS_CLASSES._TABLE_DATA_CELL_CLASS))
  {
    tableBodyCell.addClass(oj.TableDomUtils.CSS_CLASSES._TABLE_DATA_CELL_CLASS);
  }
  tableBodyCell.css('float', 'none');
  // needed to prevent the cell outline from showing in FF 
  // when user Ctrl + click on the cell.
  tableBodyCell.css('-moz-user-select', 'none');
  if (options.verticalGridVisible == oj.TableDomUtils._OPTION_ENABLED && !lastColumn)
  {
    tableBodyCell.addClass(oj.TableDomUtils.CSS_CLASSES._TABLE_DATA_CELL_VGRID_LINES_CLASS);
  }
  if (options.horizontalGridVisible == oj.TableDomUtils._OPTION_ENABLED)
  {
    tableBodyCell.addClass(oj.TableDomUtils.CSS_CLASSES._TABLE_DATA_CELL_HGRID_LINES_CLASS);
  }
  if (column.className)
  {
    tableBodyCell.addClass(column.className);
  }
};

/**
 * Style the tr element
 * @param {jQuery} tableBodyRow  tr DOM element
 * @param {string} rowSelectionMode  row selection mode
 */
oj.TableDomUtils.prototype.styleTableBodyRow = function(tableBodyRow, rowSelectionMode)
{
  if (!tableBodyRow.hasClass(oj.TableDomUtils.CSS_CLASSES._TABLE_DATA_ROW_CLASS))
  {
    tableBodyRow.addClass(oj.TableDomUtils.CSS_CLASSES._TABLE_DATA_ROW_CLASS);
  }

  this.component._hoverable(tableBodyRow);

  if (rowSelectionMode == oj.TableDomUtils._OPTION_SELECTION_MODES._SINGLE ||
    rowSelectionMode == oj.TableDomUtils._OPTION_SELECTION_MODES._MULTIPLE)
  {
    tableBodyRow.addClass(oj.TableDomUtils.CSS_CLASSES._TABLE_DATA_ROW_SELECTOR_CLASS);
  }
};

/**
 * Style the table container
 * @param {jQuery} tableContainer  div DOM element
 * @param {number} height  table height
 * @param {number} width  table width
 */
oj.TableDomUtils.prototype.styleTableContainer = function(tableContainer, height, width)
{
  var options = this.options;
  
  if (height > 0)
  {
    tableContainer.css('height', height);
  }
  else
  {
    tableContainer.css('height', '');
  }
  if (width > 0)
  {
    tableContainer.css('width', width);
  }
  else
  {
    tableContainer.css('width', '');
  }
  
  // add rootAttributes
  var rootAttributes = this.options['rootAttributes'];
  tableContainer.attr('class', '');
  var attr, value;
  for (attr in rootAttributes)
  {
    if (rootAttributes.hasOwnProperty(attr))
    {
      value = rootAttributes[attr];
      tableContainer.attr(attr, value);
    }
  }
  tableContainer.addClass(oj.TableDomUtils.CSS_CLASSES._TABLE_CONTAINER_CLASS);
  tableContainer.addClass(oj.TableDomUtils.MARKER_STYLE_CLASSES._WIDGET);
  tableContainer.css('overflow', 'hidden');
};

/**
 * Style the tfoot element
 * @param {jQuery} tableFooter tfoot DOM element
 */
oj.TableDomUtils.prototype.styleTableFooter = function(tableFooter)
{
  if (!tableFooter)
  {
    return;
  }
  tableFooter.addClass(oj.TableDomUtils.CSS_CLASSES._TABLE_FOOTER_CLASS);
  var tableFooterRow = $(tableFooter.children('tr')[0]);
  tableFooterRow.addClass(oj.TableDomUtils.CSS_CLASSES._TABLE_FOOTER_ROW_CLASS);
  tableFooterRow.css('position', 'relative');
};

/**
 * Style the td element
 * @param {number} columnIdx  column index
 * @param {jQuery} tableFooterCell  td DOM element
 */
oj.TableDomUtils.prototype.styleTableFooterCell = function(columnIdx, tableFooterCell)
{
  var options = this.options;
  var lastColumn = columnIdx == this.component['columnMetaData']().length - 1 ? true : false;
  var column = this.component['columnMetaData'](columnIdx);

  tableFooterCell.attr('style', column.footerStyle);
  if (!tableFooterCell.hasClass(oj.TableDomUtils.CSS_CLASSES._TABLE_FOOTER_CELL_CLASS))
  {
    tableFooterCell.addClass(oj.TableDomUtils.CSS_CLASSES._TABLE_FOOTER_CELL_CLASS);
  }
  tableFooterCell.css('float', 'none');
  // needed to prevent the cell outline from showing in FF 
  // when user Ctrl + click on the cell.
  tableFooterCell.css('-moz-user-select', 'none');
  if (options.verticalGridVisible == oj.TableDomUtils._OPTION_ENABLED && !lastColumn)
  {
    tableFooterCell.addClass(oj.TableDomUtils.CSS_CLASSES._TABLE_FOOTER_CELL_VGRID_LINES_CLASS);
  }
  if (column.footerClassName)
  {
    tableFooterCell.addClass(column.footerClassName);
  }
};

/**
 * Style the thead element
 * @param {jQuery} tableHeader thead DOM element
 */
oj.TableDomUtils.prototype.styleTableHeader = function(tableHeader)
{
  if (!tableHeader)
  {
    return;
  }
  tableHeader.addClass(oj.TableDomUtils.CSS_CLASSES._TABLE_HEADER_CLASS);
  tableHeader.css('display', 'table-header-group');
  var tableHeaderRow = $(tableHeader.children('tr')[0]);
  tableHeaderRow.addClass(oj.TableDomUtils.CSS_CLASSES._TABLE_HEADER_ROW_CLASS);
  tableHeaderRow.css('position', 'relative');
};

/**
 * Style the th element
 * @param {number} columnIdx  column index
 * @param {jQuery} tableHeaderColumn  th DOM element
 * @param {string} columnSelectionMode  column selection mode
 */
oj.TableDomUtils.prototype.styleTableHeaderColumn = function(columnIdx, tableHeaderColumn, columnSelectionMode)
{
  var lastColumn = columnIdx == this.component['columnMetaData']().length - 1 ? true : false;
  var column = this.component['columnMetaData'](columnIdx);
  tableHeaderColumn.addClass(oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_CLASS);
  tableHeaderColumn.attr('style', column.headerStyle);
  tableHeaderColumn.css('float', 'none');

  if (lastColumn)
  {
    tableHeaderColumn.css('borderRight', 'none');
  }

  if (columnSelectionMode == oj.TableDomUtils._OPTION_SELECTION_MODES._SINGLE ||
    columnSelectionMode == oj.TableDomUtils._OPTION_SELECTION_MODES._MULTIPLE)
  {
    tableHeaderColumn.addClass(oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_SELECTOR_CLASS);
  }
};

/**
  * Helper function which returns if the browser is IE and if so the version.
  * @private
  * @return {number|null} IE version. null if not IE.
  */
oj.TableDomUtils.prototype._isIE = function()
{
 if (navigator.appName == 'Microsoft Internet Explorer')
 {
   var userAgent = navigator.userAgent;
   var resultArray = (new RegExp('MSIE ([0-9]{1,}[\.0-9]{0,})')).exec(userAgent);
   if (resultArray != null)
   {
     return parseFloat(resultArray[1]);
   }
 }
 return null;
};

/**
  * Fix up the table header padding to accommodate the sort links
  * @private
  */
oj.TableDomUtils.prototype._refreshColumnHeaderPadding = function()
{
  var options = this.options;
  var columns = this.component['columnMetaData']();
  var isTableHeaderless = this.getTableHeader() == null ? true : false;

  var i, headerColumn, headerColumnRowDiv;
  if (!isTableHeaderless)
  {
    var isRTL = this.component._GetReadingDirection() === "rtl";
    var headerColumnAscDiv, headerColumnDscDiv, newHeaderColumnRowDivPadding;
    for (i = 0; i < columns.length; i++)
    {
      headerColumn = this.getTableHeaderColumn(i);
      if (headerColumn != null)
      {
        // add extra headerColumnRow padding to have enough space for the
        // sort link icons
        headerColumnAscDiv = headerColumn.find('.' + oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_ASC_CLASS);
        headerColumnDscDiv = headerColumn.find('.' + oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_DSC_CLASS);
        headerColumnRowDiv = headerColumn.find('.' + oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_ROW_CLASS);
        var totalSortLinkWidth = headerColumnAscDiv.width() + headerColumnDscDiv.width();
        if (!this._headerColumnRowDivPadding)
        {
          this._headerColumnRowDivPadding = isRTL ? headerColumnRowDiv.css("padding-left") : headerColumnRowDiv.css("padding-right");
        }
        newHeaderColumnRowDivPadding = parseInt(this._headerColumnRowDivPadding, 10) + totalSortLinkWidth + 'px';
        if (isRTL)
        {
          headerColumnRowDiv.css("padding-left", newHeaderColumnRowDivPadding);
        }
        else
        {
          headerColumnRowDiv.css("padding-right", newHeaderColumnRowDivPadding);
        }
        isRTL ? headerColumnAscDiv.css('left', headerColumnDscDiv.width() + 'px') : headerColumnAscDiv.css('right', headerColumnDscDiv.width() + 'px')
      }
    }
  }
};

/**
  * Refresh the table messaging position
  * @private
  */
oj.TableDomUtils.prototype._refreshTableMessagingPosition = function()
{
  var tableContainer = this.getTableContainer();
  var tableHeader = this.getTableHeader();
  var tableStatusMessage = this.getTableStatusMessage();
  var tableNoDataMessage = this.getTableNoDataMessage();
  // refresh the status message position
  tableStatusMessage.css('top', tableContainer.height() / 2 + 'px');
  tableStatusMessage.css('left', (tableContainer.width() - tableStatusMessage.width()) / 2 + 'px');

  // refresh the no data message position
  if (tableHeader != null)
  {
    var tableHeaderHeight = tableHeader.height();
    tableNoDataMessage.css('top', tableHeaderHeight + 'px');
  }
  else
  {
    tableNoDataMessage.css('top', '0px');
  }
};

/**
  * Iterate through the columns and remove the widths
  * @private
  */
oj.TableDomUtils.prototype._removeHeaderColumnAndCellColumnWidths = function()
{
  var data = this.options['data'];
  var columns = this.component['columnMetaData']();

  var columnWidths = [];
  var columnPaddingWidths = [];
  var i, headerColumn, headerColumnRowDiv, headerColumnTextDivHeight, headerColumnTextDiv;
  for (i = 0; i < columns.length; i++)
  {
    headerColumn = this.getTableHeaderColumn(i);
    if (headerColumn != null)
    {
      headerColumn.css('min-width', '');
    }
  }

  if (data != null && data.size() > 0)
  {
    var tableBodyRows = this.getTableBodyRows();
    if (tableBodyRows != null && tableBodyRows.length > 0)
    {
      var firstRowIdx = this.getElementRowIdx(tableBodyRows[0]);
      var tableBodyCell, tableBodyCellPaddingWidth, adjustedColumnWidth;
      for (i = 0; i < columns.length; i++)
      {

        tableBodyCell = this.getTableBodyCell(firstRowIdx, i);
        tableBodyCell.css('min-width', '');
      }
    }
  }
};
 
/**
 * Remove table dimensions styling
 * @private
 */
oj.TableDomUtils.prototype._removeTableDimenionsStyling = function()
{
  var table = this.getTable();
  var tableHeader = this.getTableHeader();        
  var tableHeaderRow = this.getTableHeaderRow();
  var tableBody = this.getTableBody();

  // first remove any styling so that the browser sizes the table
  if (tableHeader != null)
  {
    tableHeader.css('position', '');
    if (this.isDivScroller())
    {
      tableHeader.css('top', '');
    }
    tableHeaderRow.css('display', '');
  }
  table.css('display', '');
  tableBody.css('display', '');
  tableBody.css('position', '');
  tableBody.css('overflow-y', '');
  tableBody.css('overflow-x', '');
  tableBody.css('width', '');

  this._removeHeaderColumnAndCellColumnWidths();
};

/**
 * Iterate through the columns and get and then set the widths
 * for the columns and first row this is so that when we re-apply the styling
 * the headers will align with the cells
 * @private
 */
oj.TableDomUtils.prototype._setHeaderColumnAndCellColumnWidths = function()
{
 var data = this.options['data'];
 var columns = this.component['columnMetaData']();

 var columnWidths = [];
 var columnPaddingWidths = [];
 var i, headerColumn, headerColumnRowDiv, headerColumnTextDivHeight, headerColumnTextDiv;
 for (i = 0; i < columns.length; i++)
 {
   headerColumn = this.getTableHeaderColumn(i);
   if (headerColumn != null)
   {
     // read in the widths first. Set the widths in a separate loop so setting
     // the widths of early columns does not affect the widths of the rest
     columnWidths[i] = headerColumn.width();
     columnPaddingWidths[i] = parseInt(headerColumn.css('padding-right'), 10) + parseInt(headerColumn.css('padding-left'), 10);

     // also set the header heights
     headerColumnTextDivHeight = null;
     headerColumnTextDiv = headerColumn.find('.' + oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_TEXT_CLASS);
     if (headerColumnTextDiv && headerColumnTextDiv.length > 0)
     {
       headerColumnTextDivHeight = headerColumnTextDiv.get(0).clientHeight;
     }
     if (headerColumnTextDivHeight != null)
     {
       headerColumnRowDiv = headerColumn.find('.' + oj.TableDomUtils.CSS_CLASSES._COLUMN_HEADER_ROW_CLASS);
       headerColumnRowDiv.css('min-height', headerColumnTextDivHeight + 'px');
     }
   }
 }
 for (i = 0; i < columns.length; i++)
 {
   headerColumn = this.getTableHeaderColumn(i);
   if (headerColumn != null)
   {
     headerColumn.css('min-width', columnWidths[i] + 'px');
   }
 }

 if (data != null && data.size() > 0)
 {
   var tableBodyRows = this.getTableBodyRows();
   if (tableBodyRows != null && tableBodyRows.length > 0)
   {
     var firstRowIdx = this.getElementRowIdx(tableBodyRows[0]);
     var tableBodyCell, tableBodyCellPaddingWidth, adjustedColumnWidth;
     for (i = 0; i < columns.length; i++)
     {

       tableBodyCell = this.getTableBodyCell(firstRowIdx, i);
       tableBodyCellPaddingWidth = parseInt(tableBodyCell.css('padding-right'), 10) + parseInt(tableBodyCell.css('padding-left'), 10);
       adjustedColumnWidth = null;
       if (tableBodyCellPaddingWidth > columnPaddingWidths[i])
       {
         adjustedColumnWidth = columnWidths[i] - tableBodyCellPaddingWidth + columnPaddingWidths[i];
       }
       else
       {
         adjustedColumnWidth = columnWidths[i] + columnPaddingWidths[i] - tableBodyCellPaddingWidth;
       }
       tableBodyCell.css('min-width', adjustedColumnWidth + 'px');
     }
   }
 }
};

/**
 * @const
 */
oj.TableDomUtils.CSS_CLASSES =
  {
    _CHECKBOX_ACC_SELECT_COLUMN_CLASS: 'oj-table-checkbox-acc-select-column',
    _CHECKBOX_ACC_SELECT_ROW_CLASS: 'oj-table-checkbox-acc-select-row',
    _TABLE_CONTAINER_CLASS: 'oj-table-container',
    _TABLE_SCROLLER_CLASS: 'oj-table-scroller',
    _TABLE_CLASS: 'oj-table',
    _TABLE_FOOTER_CLASS: 'oj-table-footer',
    _TABLE_FOOTER_ROW_CLASS: 'oj-table-footer-row',
    _TABLE_HEADER_CLASS: 'oj-table-header',
    _TABLE_HEADER_ROW_CLASS: 'oj-table-header-row',
    _COLUMN_HEADER_CLASS: 'oj-table-column-header',
    _COLUMN_HEADER_SELECTOR_CLASS: 'oj-table-column-header-selector',
    _COLUMN_HEADER_ACC_SELECT_COLUMN_CLASS: 'oj-table-column-header-acc-select-column',
    _COLUMN_HEADER_ACC_SELECT_ROW_CLASS: 'oj-table-column-header-acc-select-row',
    _COLUMN_HEADER_ROW_CLASS: 'oj-table-column-header-row',
    _COLUMN_HEADER_TEXT_CLASS: 'oj-table-column-header-text',
    _COLUMN_HEADER_ASC_CLASS: 'oj-table-column-header-asc',
    _COLUMN_HEADER_DSC_CLASS: 'oj-table-column-header-dsc',
    _COLUMN_HEADER_ACC_ASC_LINK_CLASS: 'oj-table-column-header-acc-asc-link',
    _COLUMN_HEADER_ACC_DSC_LINK_CLASS: 'oj-table-column-header-acc-dsc-link',
    _COLUMN_HEADER_ASC_LINK_CLASS: 'oj-table-column-header-asc-link',
    _COLUMN_HEADER_DSC_LINK_CLASS: 'oj-table-column-header-dsc-link',
    _COLUMN_HEADER_ASC_ICON_CLASS: 'oj-table-column-header-asc-icon',
    _COLUMN_HEADER_DSC_ICON_CLASS: 'oj-table-column-header-dsc-icon',
    _TABLE_BODY_CLASS: 'oj-table-body',
    _TABLE_DATA_ROW_CLASS: 'oj-table-body-row',
    _TABLE_DATA_ROW_SELECTOR_CLASS: 'oj-table-body-row-selector',
    _TABLE_DATA_CELL_CLASS: 'oj-table-data-cell',
    _TABLE_DATA_CELL_ACC_SELECT_CLASS: 'oj-table-data-cell-acc-select',
    _TABLE_DATA_CELL_VGRID_LINES_CLASS: 'oj-table-data-cell-vgrid-lines',
    _TABLE_DATA_CELL_HGRID_LINES_CLASS: 'oj-table-data-cell-hgrid-lines',
    _TABLE_FOOTER_CELL_CLASS: 'oj-table-footer-cell',
    _TABLE_FOOTER_CELL_VGRID_LINES_CLASS: 'oj-table-footer-cell-vgrid-lines',
    _TABLE_STATUS_MESSAGE_CLASS: 'oj-table-status-message',
    _TABLE_NO_DATA_MESSAGE_CLASS: 'oj-table-no-data-message',
    _WIDGET_ICON_CLASS: 'oj-component-icon',
    _HIDDEN_CONTENT_ACC_CLASS: 'oj-helper-hidden-accessible'
  };

/**
 * @const
 */
oj.TableDomUtils.MARKER_STYLE_CLASSES =
  {
    _WIDGET: 'oj-component',
    _ACTIVE: 'oj-active',
    _CLICKABLE_ICON: 'oj-clickable-icon',
    _DISABLED: 'oj-disabled',
    _ENABLED: 'oj-enabled',
    _FOCUS: 'oj-focus',
    _HOVER: 'oj-hover',
    _SELECTED: 'oj-selected'
  };
  
/**
 * @private
 * @const
 * @type {string}
 */
oj.TableDomUtils._COLUMN_HEADER_ROW_SELECT_ID =   '_hdrColRowSel';

/**
 * @private
 * @const
 * @type {string}
 */
oj.TableDomUtils._OPTION_ENABLED = 'enabled';
/**
 * @private
 * @const
 * @type {string}
 */
oj.TableDomUtils._OPTION_DISABLED = 'disabled';
/**
 * @private
 * @const
 */
oj.TableDomUtils._OPTION_SELECTION_MODES =
  {
    _SINGLE: 'single',
    _MULTIPLE: 'multiple'
  };
/*jslint browser: true*/

/**
 * @export
 * @class oj.ModelRow
 * @classdesc Object representing name/value pairs for a row of data
 *
 * @param {oj.Model} model oj.Model object 
 * @param {Object=} options 
 *                  rowSet: rowSet for this row
 * @constructor
 */
oj.ModelRow = function(model, options)
{
  oj.ModelRow._init(this, model, options, null);
};


// Subclass from oj.Object 
oj.Object.createSubclass(oj.ModelRow, oj.Row, "ModelRow.ModelRow");

oj.ModelRow.prototype.Init = function()
{
  oj.Row.superclass.Init.call(this);
};

/**
 * 
 * @export
 * @desc Attribute/value pairs held by the Row.
 * 
 * @type Object
 */
oj.ModelRow.prototype.attributes = {};

/**
 * @export
 * @desc The Row's unique ID. 
 * 
 * @type String
 */
oj.ModelRow.prototype.id = null;

/**
 * @export
 * @desc The name of the row property to be used as the unique ID. See property id. This defaults to a value of "id".
 *  
 * @type String
 */
oj.ModelRow.prototype.idAttribute = null;

oj.ModelRow._init = function(row, model, options, properties)
{
  var prop = null, attrCopy;

  row.Init();

  row._model = model;
  row.id = model.id;
  row.idAttribute = model.idAttribute;
  row.attributes = model.attributes;
  row.index = model.index;

  options = options || {};

  // First, copy all properties passed in
  for (prop in properties)
  {
    if (properties.hasOwnProperty(prop))
    {
      row[prop] = properties[prop];
    }
  }
  row['context'] = options['context'];
};

/**
 * @export
 * Return a copy of the Row with identical attributes and settings
 */
oj.ModelRow.prototype.clone = function()
{
  return this._model.clone();
};

/**
 * Returns the value of the property from the Row.
 * @param {string} property Property to get from row
 * @return {Object} value of property
 * @export
 */
oj.ModelRow.prototype.get = function(property)
{
  return this._model.get(property);
};

/**
 * Return the oj.Model object which was wrapped
 * @return {oj.Model} oj.Model object
 * 
 * @export
 */
oj.ModelRow.prototype.getModel = function()
{
  return this._model;
};

/**
 * Set the value(s) of one or more attributes of the row
 * @param {string||Object} property Property attribute name to set, or an Object containing attribute/value pairs
 * @param {Object=} value Value for property if property is not an Object containing attribute/value pairs
 * @param {Object=} options Options may be passed in
 * @returns {Object||boolean} the row itself, false if failed
 * @export
 */
oj.ModelRow.prototype.set = function(property, value, options)
{
  return this._model.set(property, value, options);
};

/**
 * @export
 * Return all of the Row's attributes as an array
 * 
 * @returns {Array} array of all the Row's attributes
 */
oj.ModelRow.prototype.keys = function()
{
  return this._model.keys();
};

/**
 * @export
 * Return all of the Row's attributes values as an array
 * 
 * @returns {Array} array of all the Row's attributes values
 */
oj.ModelRow.prototype.values = function()
{
  return this._model.values();
};

/**
 * @export
 * Return an array of attributes/value pairs found in the Row 
 * 
 * @returns {Object} returns the Row's attribute/value pairs as an object property bag
 */
oj.ModelRow.prototype.pairs = function()
{
  return this._model.pairs();
};

/*jslint browser: true*/

/**
 * @export
 * @class oj.CollectionRowSet
 * @classdesc RowSet wrapper for oj.Collection 
 * 
 * @param {oj.Collection} collection oj.Collection object 
 * @param {Object=} options Passed through to the user's initialize routine, if any, upon construction 
 * @constructor
 */
oj.CollectionRowSet = function(collection, options) 
{
  // Initialize
  oj.CollectionRowSet._init(this, collection, options, null);
};

/**
 * @export
 * @desc If set, sort the rowSet using the given attribute of a row (if string); function(Row) returning a string attribute
 * by which the sort should take place; function(Row1, Row2) if a user-defined function comparing Row1 and Row2 (see the
 * JavaScript array.sort() for details)
 * 
 * @type {String|function(Object)|function(Object,Object)}
 */
oj.CollectionRowSet.prototype.comparator = null;

/**
 * @export
 * @desc Set to true if sort is supported.
 * 
 * @type boolean
 */
oj.CollectionRowSet.prototype.sortSupported = true;


// Subclass from oj.Object 
oj.Object.createSubclass(oj.CollectionRowSet, oj.RowSet, "CollectionRowSet.CollectionRowSet");

oj.CollectionRowSet.prototype.Init = function()
{
  oj.CollectionRowSet.superclass.Init.call(this);
};

oj.CollectionRowSet._init = function(rowSet, collection, options, properties) 
{
  var prop;
  rowSet._eventHandlers = [];
  rowSet._startIndex = 0;
  
  rowSet.Init();

  // First, copy all properties passed in
  if (properties) 
  {
    for (prop in properties) 
    {
      if (properties.hasOwnProperty(prop)) 
      {
        rowSet[prop] = properties[prop];
      }
    }
  }
  rowSet._collection = collection;
  rowSet._addCollectionEventListeners();
};

/**
 * Return the row object found at the given index of the collection, or a promise object that will return the row to a function
 * in the done() call.
 * 
 * @param {number} index Index for which to return the row object. 
 * @param {Object=} options <p>
 *                  fetchSize: fetch size to use if the call needs to fetch more records from the server, if virtualized.  Overrides the overall fetchSize setting <p>
 *                  deferred: if true, return a deferred/promise object as described below.  If not specified, the return value will
 *                   be determined by whether or not the collection is virtual
 * @return {Object} Row object located at index. If index is out of range, returns null.  If this is a paging/virtual collection or
 *                  if deferred is specified and true, at will return a jQuery promise object which will call its done function,
 *                  passing the value at(index) 
 * @export
 * @expose
 * @memberof! oj.CollectionRowSet
 * @instance
 */
oj.CollectionRowSet.prototype.at = function(index, options)
{
  var model = this._collection.at(index, options);
  if (model != null)
  {
    if (model instanceof oj.Model)
    {
      return new oj.ModelRow(model);
    }
    else
    {
      var deferredModel = $.Deferred();
      $.when(model).done(function(resolvedModel)
                         {
                           deferredModel.resolve(new oj.ModelRow(resolvedModel));
                         });
      return deferredModel;
    }
  }
  return null;
};

/**
 * Loads the data into the RowSet
 * @param {Object=} options Options to control fetch<p>
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.CollectionRowSet
 * @instance
 */
oj.CollectionRowSet.prototype.fetch = function(options)
{
  if (this._canFetch.call(this))
  {
    this._startFetch.call(this);

    options = options || {};
    var self = this;
    var isPaged =  options.startIndex != null ? true : false;
    this._startIndex = isPaged ? options.startIndex : 0;
    var pageSize = options['pageSize'] > 0 ? options['pageSize'] : -1;
    
    if (isPaged)
    {
      this._collection.setRangeLocal(this._startIndex, pageSize).done(function() 
        {
          self._endFetch.call(self, true);
        });
    }
    else
    {
      this._collection.fetch({
        success: function(collection, response, options) 
        {
          self._collection = collection;
          self._endFetch.call(self, true);
        }
      });
    }
  }
}

/**
 * Return the first row object from the collection whose row id value is the given id
 * Note this method will not function as expected if the id is not set
 * @param {Object|string} id ID for which to return the row object, if found. 
 * @param {Object=} options <p>
 *                  fetchSize: fetch size to use if the call needs to fetch more records from the server, if virtualized.  Overrides the overall fetchSize setting<p>
 *                  deferred: if true, return a promise as though this collection were virtual whether it is or not
 * @return {Object} First row object in the collection where row.id = id. If none are found, returns null.
 *                  If deferred or virtual, return a promise passing the row when done
 * @export
 * @expose
 * @memberof! oj.CollectionRowSet
 * @instance
 */
oj.CollectionRowSet.prototype.get = function(id, options)
{
  return new oj.ModelRow(this._collection.get(id, options));
};

/**
 * Return the oj.Collection object which was wrapped
 * @return {oj.Collection} oj.Collection object
 * @export
 * @expose
 * @memberof! oj.CollectionRowSet
 * @instance
 */
oj.CollectionRowSet.prototype.getCollection = function()
{
  return this._collection;
};

/**
 * Return whether there is more data which can be fetched.
 * @return {boolean} whether there is more data
 * @export
 * @expose
 * @memberof! oj.CollectionRowSet
 * @instance
 */
oj.CollectionRowSet.prototype.hasMore = function()
{
  return this._collection['hasMore'];
};

/**
 * Return the array index location of the given row object.
 * @param {Object} row Row object to locate 
 * @param {Object=} options deferred: if true, return a promise as though this collection were virtual whether it is or not
 
 * @return {number} The index of the given row object, or a promise that will call with the index when complete.
 *                  If the object is not found, returns -1.
 * @export
 * @expose
 * @memberof! oj.CollectionRowSet
 * @instance
 */
oj.CollectionRowSet.prototype.indexOf = function(row, options) 
{
  return this._collection.indexOf(row.getModel(), options);
};

/**
 * Determine if the rowset has any rows
 * 
 * @returns {boolean} true if collection is empty
 * @export
 * @expose
 * @memberof! oj.CollectionRowSet
 * @instance
 */
oj.CollectionRowSet.prototype.isEmpty = function() 
{
  return this._collection.isEmpty();
};

/**
 * Return the length of the collection
 * @returns {number} length of the collection
 * @export
 * @expose
 * @memberof! oj.CollectionRowSet
 * @instance
 */
oj.CollectionRowSet.prototype.size = function() 
{
  return this._collection.size();
};

/**
 * Sort the rows in the rowSet
 * @export
 * @expose
 * @memberof! oj.CollectionRowSet
 * @instance
 */
oj.CollectionRowSet.prototype.sort = function() 
{
  this._collection['comparator'] = this['comparator'];
  return this._collection.sort(null);
};

/**
 * Return the total size of data available, including server side if not local.
 * @returns {number} total size of data
 * @export
 * @expose
 * @memberof! oj.CollectionRowSet
 * @instance
 */
oj.CollectionRowSet.prototype.totalSize = function()
{
  return this._collection.totalResults;
};

/**
 * Add event listeners to the collection
 * @private
 */
oj.CollectionRowSet.prototype._addCollectionEventListeners = function()
{
  var self = this;
  this._collection.on(oj.Events.EventType['ADD'], function(event) {
    oj.CollectionRowSet.superclass._handleEvent.call(self, oj.RowSet.EventType['ADD'], {'rowIdx': self._collection.indexOf(event), 'row': new oj.ModelRow(event)});
  });
  this._collection.on(oj.Events.EventType['REMOVE'], function(event) {
    oj.CollectionRowSet.superclass._handleEvent.call(self, oj.RowSet.EventType['REMOVE'], {'rowIdx': self._collection.indexOf(event), 'row': new oj.ModelRow(event)});
  });
  this._collection.on(oj.Events.EventType['RESET'], function(event) {
    oj.CollectionRowSet.superclass._handleEvent.call(self, oj.RowSet.EventType['RESET'], event);
  });
  this._collection.on(oj.Events.EventType['SORT'], function(event, eventOpts) {
    if (!eventOpts['add'])
    {
      oj.CollectionRowSet.superclass._handleEvent.call(self, oj.RowSet.EventType['SORT'], event);
    }
  });
  this._collection.on(oj.Events.EventType['CHANGE'], function(event) {
    oj.CollectionRowSet.superclass._handleEvent.call(self, oj.RowSet.EventType['CHANGE'], {'rowIdx': self._collection.indexOf(event), 'row': new oj.ModelRow(event)});
  });
  this._collection.on(oj.Events.EventType['DESTROY'], function(event) {
    oj.CollectionRowSet.superclass._handleEvent.call(self, oj.RowSet.EventType['DESTROY'], event);
  });
  this._collection.on(oj.Events.EventType['SYNC'], function(event) {
    oj.CollectionRowSet.superclass._handleEvent.call(self, oj.RowSet.EventType['SYNC'], event);
  });
  this._collection.on(oj.Events.EventType['ERROR'], function(event) {
    oj.CollectionRowSet.superclass._handleEvent.call(self, oj.RowSet.EventType['ERROR'], event);
    // call endfetch in case a fetch caused the error
    self._endFetch.call(self, false);
  });
};

/**
 * Indicate whether we can start a fetch
 * @private
 */
oj.CollectionRowSet.prototype._canFetch = function()
{
  return !this._isFetching;
};

/**
 * Indicate starting fetch
 * @private
 */
oj.CollectionRowSet.prototype._startFetch = function()
{
  this._isFetching = true;
  oj.CollectionRowSet.superclass._handleEvent.call(this, oj.RowSet.EventType['REQUEST'], null);
};

/**
 * Indicate ending fetch
 * @param {boolean} refresh whether the listener should refresh based on the fetched data
 * @private
 */
oj.CollectionRowSet.prototype._endFetch = function(refresh)
{
  this._isFetching = false;
  oj.CollectionRowSet.superclass._handleEvent.call(this, oj.RowSet.EventType['SYNC'], refresh);
};
/*jslint browser: true,devel:true*/
/**
 * @export
 * @class oj.CollectionTableDataSource
 * @classdesc Object representing data used by table component
 * @param {Object} data data supported by the components
 * @param {Object|null} options Array of options for the TableDataSource
 * @constructor
 */
oj.CollectionTableDataSource = function(data, options)
{
  // Initialize
  if (!(data instanceof oj.Collection))
  {
    // we only support Array, oj.Collection, oj.RowSet, or ko.observableArray. To
    // check for observableArray, we can't do instanceof check because it's
    // a function. So we just check if it contains a subscribe function.
    var errSummary = oj.Translations.getTranslatedString('oj-ojTable.dataInvalidType.summary');
    var errDetail = oj.Translations.getTranslatedString('oj-ojTable.dataInvalidType.detail');
    throw new oj.Message(errSummary, errDetail, oj.Message.SEVERITY_LEVEL['ERROR']);
  }
  
  oj.CollectionTableDataSource.superclass.constructor.call(this, data, options);

  this._rowSet = new oj.CollectionRowSet(data, this.options);
  this._addRowSetEventListeners();
  
  this.Init();

  if ((options != null && (options['startFetch'] == 'enabled' || options['startFetch'] == null))
    || options == null)
  {
    // do an initial fetch
    var self = this;
    setTimeout(function()
    {
      self.fetch({'startFetch': 'enabled'});
    }, 0);
  }
};

// Subclass from oj.DataSource 
oj.Object.createSubclass(oj.CollectionTableDataSource, oj.TableDataSource, "oj.CollectionTableDataSource");

/**
 * Initializes the instance.
 * @export
 * @expose
 * @memberof! oj.CollectionTableDataSource
 * @instance
 */
oj.CollectionTableDataSource.prototype.Init = function()
{
  oj.CollectionTableDataSource.superclass.Init.call(this);
};

/**
 * Return the oj.Row object found at the given index of the RowSet.
 * 
 * @param {number} index Index for which to return the Row object. 
 * @return {Object} oj.Row object located at index. If index is out of range, returns null.
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.CollectionTableDataSource
 * @instance
 */
oj.CollectionTableDataSource.prototype.at = function(index)
{
  return this._rowSet.at(index);
};

/**
 * Fetch the RowSet data.
 * @param {Object=} options Options to control fetch<p>
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.CollectionTableDataSource
 * @instance
 */
oj.CollectionTableDataSource.prototype.fetch = function(options)
{
  options = options || {};
  if (options['startIndex'] != null)
  {
    oj.CollectionTableDataSource.superclass.startIndex.call(this, options['startIndex']);
  }
  var data = this.data;

  if (options['startFetch'] == 'enabled')
  {
    // only do an initial fetch if collection is empty
    if (this._rowSet.isEmpty() ||
      (typeof this._rowSet.size() === 'undefined'))
    {
      this._rowSet.fetch(options);
    }
  }
  else
  {
    this._rowSet.fetch(options);
  }
};

/**
 * Return the first oj.Row object from the RowSet whose Row id value is the given id
 * @param {Object|string} id ID for which to return the Row object, if found. 
 * @return {Object} First Row object in the RowSet where Row.id = id. If none are found, returns null.
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.CollectionTableDataSource
 * @instance
 */
oj.CollectionTableDataSource.prototype.get = function(id)
{
  return this._rowSet.get(id);
};

/**
 * Return whether there is more data which can be fetched.
 * @returns {boolean} whether there is more data
 * @export
 * @expose
 * @memberof! oj.CollectionTableDataSource
 * @instance
 */
oj.CollectionTableDataSource.prototype.hasMore = function()
{
  if (this._rowSet != null)
  {
    return this._rowSet.hasMore();
  }
  return false;
};

/**
 * Return the array index location of the given Row object.
 * @param {Object} row oj.Row object to locate 
 * @return {number} The index of the given Row object. If the object is not found, returns -1.
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.CollectionTableDataSource
 * @instance
 */
oj.CollectionTableDataSource.prototype.indexOf = function(row)
{
  return this._rowSet.indexOf(row);
};

/**
 * Get the length of the RowSet.
 * limit it.
 * @returns {number} length of the RowSet
 * @export
 * @expose
 * @memberof! oj.CollectionTableDataSource
 * @instance
 */
oj.CollectionTableDataSource.prototype.size = function()
{
  return this._rowSet.size();
};

/**
 * Performs a sort on the data source.
 * @param {Object} criteria the sort criteria.
 * @param {Object} criteria.key The key that identifies which field to sort
 * @param {string} criteria.direction the sort direction, valid values are "ascending", "descending", "none" (default)
 * @export
 * @expose
 * @memberof! oj.CollectionTableDataSource
 * @instance
 */
oj.CollectionTableDataSource.prototype.sort = function(criteria)
{
  var key = criteria['key']; 
  var direction = criteria['direction'];
  var comparator = null;
  
  if (direction == 'ascending')
  {
    comparator = function(row) {
      if ($.isFunction(row.get))
      {
        return row.get(key);
      }
      else
      {
        return row[key]();
      }
    };
  }
  else if (direction == 'descending')
  {
    comparator = function(rowA, rowB) {
      var a, b;
      if ($.isFunction(rowA.get))
      {
        a = rowA.get(key);
        b = rowB.get(key);
      }
      else
      {
        a = rowA[key]();
        b = rowB[key]();
      }
      if (a === b)
      {
        return 0;
      }
      return a > b ? -1 : 1;
    };
  }
  this._rowSet['comparator'] = comparator;
  this._rowSet.sort();
};

/**
 * Return the total size of data available, including server side if not local.
 * @returns {number} total size of data
 * @export
 * @expose
 * @memberof! oj.CollectionTableDataSource
 * @instance
 */
oj.CollectionTableDataSource.prototype.totalSize = function()
{
  return this._rowSet.totalSize();
};

/**
 * Add event listeners to the RowSet
 * @private
 */
oj.CollectionTableDataSource.prototype._addRowSetEventListeners = function()
{
  var self = this;
  (/** @type {{on: Function}} */  (this._rowSet)).on(oj.RowSet.EventType['ADD'], function(event) {
    self.isFetching = false;
    oj.TableDataSource.superclass.handleEvent.call(self, oj.RowSet.EventType['ADD'], event);
  });
  (/** @type {{on: Function}} */  (this._rowSet)).on(oj.RowSet.EventType['REMOVE'], function(event) {
    self.isFetching = false;
    oj.TableDataSource.superclass.handleEvent.call(self, oj.RowSet.EventType['REMOVE'], event);
  });
  (/** @type {{on: Function}} */  (this._rowSet)).on(oj.RowSet.EventType['REQUEST'], function(event) {
    self.isFetching = true;
    oj.TableDataSource.superclass.handleEvent.call(self, oj.RowSet.EventType['REQUEST'], event);
  });
  (/** @type {{on: Function}} */  (this._rowSet)).on(oj.RowSet.EventType['RESET'], function(event) {
    self.isFetching = false;
    oj.TableDataSource.superclass.handleEvent.call(self, oj.RowSet.EventType['RESET'], event);
  });
  (/** @type {{on: Function}} */  (this._rowSet)).on(oj.RowSet.EventType['SORT'], function(event) {
    self.isFetching = false;
    oj.TableDataSource.superclass.handleEvent.call(self, oj.RowSet.EventType['SORT'], event);
  });
  (/** @type {{on: Function}} */  (this._rowSet)).on(oj.RowSet.EventType['CHANGE'], function(event) {
    self.isFetching = false;
    oj.TableDataSource.superclass.handleEvent.call(self, oj.RowSet.EventType['CHANGE'], event);
  });
  (/** @type {{on: Function}} */  (this._rowSet)).on(oj.RowSet.EventType['DESTROY'], function(event) {
    self.isFetching = false;
    oj.TableDataSource.superclass.handleEvent.call(self, oj.RowSet.EventType['DESTROY'], event);
  });
  (/** @type {{on: Function}} */  (this._rowSet)).on(oj.RowSet.EventType['SYNC'], function(event) {
    self.isFetching = false;
    oj.TableDataSource.superclass.handleEvent.call(self, oj.RowSet.EventType['SYNC'], event);
  });
  (/** @type {{on: Function}} */  (this._rowSet)).on(oj.RowSet.EventType['ERROR'], function(event) {
    self.isFetching = false;
    oj.TableDataSource.superclass.handleEvent.call(self, oj.RowSet.EventType['ERROR'], event);
  });
};
/**
 * Creates an attribute group handler that will generate stylistic attribute values such as colors or shapes based on data set categories.
 * @param {Object} matchRules A map of key value pairs for categories and the matching attribute value e.g. {"soda" : "square", "water" : "circle", "iced tea" : "triangleUp"}.
 *                            Attribute values listed in the matchRules object will be reserved only for the matching categories when getAttributeValue is called.
 * @export
 * @constructor
 */
oj.AttributeGroupHandler = function(matchRules) {
  this.Init(matchRules);
};

oj.Object.createSubclass(oj.AttributeGroupHandler, oj.Object, "oj.AttributeGroupHandler");

oj.AttributeGroupHandler.prototype.Init = function(matchRules) {
  oj.AttributeGroupHandler.superclass.Init.call(this);
  this._matchRules = matchRules ? matchRules : {};
  this._assignments = {};
  this._valueIndex = 0;
  this.Values = this.getValueRamp();
  for (var key in this._matchRules) {
    // remove match rule value from attribute group values
    var idx = this.Values.indexOf(this._matchRules[key]);
    if (idx !== -1)
      this.Values.splice(idx, 1);
  }
}

/**
 * Returns the array of possible attribute values for this attribute group handler.
 * This array can be modified so subclasses should return a copy of its internal value ramp.
 * @returns {Array} The array of attribute values
 * @export
 */
oj.AttributeGroupHandler.prototype.getValueRamp = function() {
  return [];
}

/**
 * Assigns the given category an attribute value.  Will consistently return the same attribute value for equal categories.
 * @param {Object} category The category to assign
 * @returns {Object} The attribute value for the category
 * @export
 */
oj.AttributeGroupHandler.prototype.getValue = function(category) {
  if (this._matchRules[category])
    return this._matchRules[category];
  else if (this._assignments[category])
    return this._assignments[category];
  else {
    this._assignments[category] = this.Values[this._valueIndex];
    if (this._valueIndex == this.Values.length - 1)
      this._valueIndex = 0;
    else
      this._valueIndex++;
    return this._assignments[category];
  } 
}

/**
 * Returns the current map of key value pairs for categories and the assigned attribute values
 * @return {Array} The current list of category and value pairing
 * @export
 */
oj.AttributeGroupHandler.prototype.geCategoryAssignments  = function() {
  var assignments = [];
  for (var i in this._assignments)
    assignments.push({"category": i, "value": this._assignments[i]});
  return assignments;
}

/**
 * Reserves an attribute value for the given category
 * @param {String} category Used for checking inputs to getAttributeValue against when assigning an attribute value
 * @param {String} attributeValue The attribute value to assign for inputs matching the given category e.g. "square" or "circle"
 * @export
 */
oj.AttributeGroupHandler.prototype.addMatchRule = function(category, attributeValue) {
  this._matchRules[category] = attributeValue;
}
var DvtStyleProcessor = {
	'CSS_TEXT_PROPERTIES':
		function(node, styleString) {
			var ignoreProperties = {};
			if (node) {
				if (node.hasClass("oj-gaugeMetricLabel") && node.hasClass(node.parentNode, "oj-ledGauge")) {
					ignoreProperties ['font-size'] = true;
					ignoreProperties ['color'] = true;
				}
				if (node.hasClass(node, "oj-chartSliceLabel")) {
					ignoreProperties ['color'] = true;
				}
			}
			return DvtStyleProcessor._mergeOptionsAndDivStyle(node, styleString, false, ignoreProperties);
		},
	'CSS_BACKGROUND_PROPERTIES':
		function(node, styleString) {
			return DvtStyleProcessor._mergeOptionsAndDivStyle(node, styleString, true, {});
		},
	'CSS_URL':
		function(node, styleString) {
			return DvtStyleProcessor._parseUrl(node);
		}
	}
        
DvtStyleProcessor._INHERITED_FONT_COLOR = "rgb(254, 0, 254)";
DvtStyleProcessor._INHERITED_FONT_FAMILY = "Times";
DvtStyleProcessor._INHERITED_FONT_SIZE = "1px";
DvtStyleProcessor._INHERITED_FONT_WEIGHT = "1";
DvtStyleProcessor._INHERITED_FONT_STYLE = "normal";

DvtStyleProcessor.defaultStyleProcessor = function(cssDiv, property) {
	return cssDiv.css(property);
}

/**
 * @param {Object} cssDiv The element with style class or with some default style
 */
DvtStyleProcessor._parseUrl = function(cssDiv) {
  var url = cssDiv.css('content');
  if (url && url.indexOf('url(') !== -1)
    return url.slice(url.indexOf('url(')+4, url.length-1).replace(/"/g,"");
  else
    return url;
}

/**
 * @param {Object} cssDiv The element with style class or with some default style
 * @return {string} The merged CSS background properties string including border-color, border-width, and background-color
 */
DvtStyleProcessor._buildCssBackgroundPropertiesString = function(cssDiv) {
  var styleString = "";
  if (cssDiv.css('border-top-color'))
  {
    styleString += "border-color: " + cssDiv.css('border-top-color') + ";";
  }
  // border without border-style is always nonsense (with width 0px)
  if (cssDiv.css('border-width') && (cssDiv.css('border-style') && cssDiv.css('border-style') != 'none'))
  {
    styleString += "border-width: " + cssDiv.css('border-width') + ";";
  }
  if (cssDiv.css('background-color'))
  {
    styleString += "background-color: " + cssDiv.css('background-color') + ";";
  }

  return styleString;
}

/**
 * build css style string
 * @param {Object} cssDiv The element with style class or with some default style
 * @param {Object} ignoreProperties The css properties to ignore
 * @return {string} The merged CSS text properties string including font-family, font-size, font-weight, color, and font-style
 */
DvtStyleProcessor._buildTextCssPropertiesString = function(cssDiv, ignoreProperties)
{
  var styleString = "";
  var value = cssDiv.css('font-family');
  if (value && value !== DvtStyleProcessor._INHERITED_FONT_FAMILY)
  {
    styleString += "font-family: " + value.replace(/"/g,"'") + ";";
  }
  value = cssDiv.css('font-size');
  if (value && value !== DvtStyleProcessor._INHERITED_FONT_SIZE && !ignoreProperties ['font-size'])
  {
    styleString += "font-size: " + value + ";";
  }
  value = cssDiv.css('font-weight');
  if (value && value !== DvtStyleProcessor._INHERITED_FONT_WEIGHT)
  {
    styleString += "font-weight: " + value + ";";
  }
  value = cssDiv.css('color');
  if (value && value !== DvtStyleProcessor._INHERITED_FONT_COLOR && !ignoreProperties ['color'])
  {
    styleString += "color: " + value + ";";
  }
  value = cssDiv.css('font-style');
  if (value && value !== DvtStyleProcessor._INHERITED_FONT_STYLE)
  {
    styleString += "font-style: " + value + ";";
  }
  return styleString;
}

/**
 * Merges style on div with css text in optionsStyle.
 * 
 * @param {Object} cssDiv The element with style class or with some default style
 * @param {string} optionsStyle The extending CSS text style
 * @param {Object} ignoreProperties The css properties to ignore
 * @param {boolean} bIncludeBackgroundProps Whether to merge background properties in addition to text properties. Default is to merge only text properties.
 * @return {string} The merged CSS properties string
 */
DvtStyleProcessor._mergeOptionsAndDivStyle = function(cssDiv, optionsStyle, bIncludeBackgroundProps, ignoreProperties)
{
  if (!ignoreProperties)
    ignoreProperties = {};

  if (!cssDiv)
  {
    return optionsStyle;
  }

  var oldStyle;
  if (optionsStyle)
  {
    oldStyle = cssDiv.attr("style");
    if (oldStyle)
      cssDiv.attr("style", oldStyle + optionsStyle);
    else
      cssDiv.attr("style", optionsStyle);
  }

  var styleString = '';

  if (bIncludeBackgroundProps !== true)
  {
    styleString += this._buildTextCssPropertiesString(cssDiv, ignoreProperties);
  }

  if (bIncludeBackgroundProps !== false)
  {
    styleString += this._buildCssBackgroundPropertiesString(cssDiv);
  }
  if (oldStyle)
  {
    cssDiv.attr("style", oldStyle);
  }
  return styleString;
}

/**
 * Creates dummy divs for each component style class and merges their values with the component options object.
 * @param {Object} element DOM node to add CSS styles to for processing
 * @param {Object} options The options object to merge CSS properties with
 * @param {Array} componentClasses The style classes associated with the component
 * @param {Object} childClasses Style classes associated with a component's children
 * @private
 */ 
DvtStyleProcessor.processStyles = function(element, options, componentClasses, childClasses)
{
  // Add the common css properties
  var oldClasses = element.attr("class");
  var newClasses = '';
  for (var i=0; i<componentClasses.length; i++)
    newClasses = newClasses + componentClasses[i] + " ";
  if (oldClasses)
    newClasses += oldClasses;
  element.attr("class", newClasses);

  var outerDummyDiv = $(document.createElement("div"));
  outerDummyDiv.attr("style", "display:none;");
  element.append(outerDummyDiv);
  // overwrite inherited values to prevent populating options object with them
  outerDummyDiv.css("font-family", DvtStyleProcessor._INHERITED_FONT_FAMILY);
  outerDummyDiv.css("font-size", DvtStyleProcessor._INHERITED_FONT_SIZE);
  outerDummyDiv.css("color", DvtStyleProcessor._INHERITED_FONT_COLOR);
  outerDummyDiv.css("font-weight", DvtStyleProcessor._INHERITED_FONT_WEIGHT);
  outerDummyDiv.css("font-style", DvtStyleProcessor._INHERITED_FONT_STYLE);
  for (var styleClass in childClasses) {
    var dummyDiv = $(document.createElement("div"));
    dummyDiv.addClass(styleClass);
    outerDummyDiv.append(dummyDiv);
    DvtStyleProcessor._processStyle(options, dummyDiv, childClasses[styleClass]);
  }
}

/**
 * Resolves the css properties within a dummy div
 * @param {Object} options The options object to merge CSS properties with
 * @param {Object} cssDiv The div to use for processing CSS style
 * @param {Object} definition Map of CSS style attribute and values to process
 * @private
 */ 
DvtStyleProcessor._processStyle = function(options, cssDiv, definition)
{
  if (definition instanceof Array) {
    for (var i=0;i<definition.length; i++) 
      DvtStyleProcessor._resolveStyle(options, cssDiv, definition[i]);
  } else {
    DvtStyleProcessor._resolveStyle(options, cssDiv, definition);
  }
}
      
/**
 * Helper function to resolve the css properties within a dummy div.
 * @param {Object} options The options object to merge CSS properties with
 * @param {Object} cssDiv The div to use for processing CSS style
 * @param {Object} definition Map of CSS style attribute and values to process
 * @private
 */ 
DvtStyleProcessor._resolveStyle = function(options, cssDiv, definition)
{
  var path = new DvtJsonPath(options, definition['path']);
  var value;
  if(definition['property']) {
    var handler = DvtStyleProcessor[definition['property']];
    if (!handler)
      value = DvtStyleProcessor.defaultStyleProcessor(cssDiv, definition['property']);
    else
      value = handler(cssDiv, path.getValue());
  }
  if(value != null
     && !(typeof value == 'string' && value.replace(/^\s+/g, '') == '')) {
    path.setValue(value);
  }
}
oj.__registerWidget('oj.dvtBaseComponent', $['oj']['baseComponent'], {
 
  /** 
   * @override
   * @protected
   */
  _create : function() {
    this._super();
  
    // Create the DvtContext, which creates the svg element and adds it to the DOM.
    this._context = new DvtContext(this.element[0]);
    
    // Set the reading direction on the context
    this._context.setReadingDirection(this._GetReadingDirection());
    
    // Set the tabindex on the element to enable keyboard handling
    this.element.attr("tabIndex", 0);
    
    // Create and cache the component instance
    this._component = this._CreateComponent(this._context, this._HandleEvent, this);

    // Add the component to the display tree of the rendering context.
    this._context.getStage().addChild(this._component);  
    
    // Create dummy divs for style classes and merge style class values with json options object
    DvtStyleProcessor.processStyles(this.element, this.options, 
                                    this._GetComponentStyleClasses(), 
                                    this._GetChildStyleClasses());
    
    // Retrieve and apply the translated strings onto the component bundle
    this._processTranslations();

    // Load component resources
    this._LoadResources();
    
    // Add options object to hidden div
    this._addOptionsDiv();

    // Render the component
    this._Render();
    
    // Add resize listener
    oj.DomUtils.addResizeListener(this.element[0], $.proxy(this._handleResize, this));
  },
  
  /** 
   * @override
   */
  refresh : function() {
    this._super();
  
    // Update the reading direction on the context
    this._context.setReadingDirection(this._GetReadingDirection());
    
    // Retrieve and apply the translated strings onto the component bundle
    this._processTranslations();
  
    // Render the component with any changes
    this._Render();
  },
  
  /** 
   * @override
   */
  getNodeBySubId : function(locator) {
    // subcomponents should override for jsDoc to list subId values
    var automation;
    if (this._component && this._component.getAutomation)
      automation = this._component.getAutomation();
    if (automation)
      return automation.getDomElementForSubId(locator['subId']);
    return null;
  },
  
  /** 
   * @override
   */
  getSubIdByNode : function(node) {
    // subcomponents should override for jsDoc to list subId values
    var automation;
    if (this._component && this._component.getAutomation)
      automation = this._component.getAutomation();
    if (automation)
      return automation.getSubIdForDomElement(node);
    return null;
  },
  
  /**
   * Add options object to a hidden div for debugging.
   * @private
   */
  _addOptionsDiv : function() {
    var optionsDiv = $(document.createElement("div"));
    optionsDiv.attr("style", "display:none;");
    optionsDiv.text(JSON.stringify(this.options));
    this.element.append(optionsDiv);
  },
  
  /**
   * Returns the style classes associated with the component.
   * @return {Array}
   * @protected
   */
  _GetComponentStyleClasses : function() {
    return ['oj-dvtbase'];
  },
  
  /**
   * Returns a map of the style classes associated with a component's children.
   * @return {Object}
   * @protected
   */
  _GetChildStyleClasses : function() {
    return {};
  },
  
  /**
   * Returns a map containing keys corresponding to the string ids in ojtranslations.js and values corresponding to the 
   * toolkit constants for the DvtBundle objects.  This map must be guaranteed to be a new instance so that subclasses can
   * add their translations to it.
   * @return {Object}
   * @protected
   */
  _GetTranslationMap: function() {
    // TODO This function is a mess and we shouldn't define our own months.  
    // Will fix once the inheritance of resources is fixed via 18545592.
    var map = {
      'oj-ojDvtCommon.labelClearSelection': 'DvtUtilBundle.CLEAR_SELECTION',
      
      // TODO: Should try to get all of these from common translations not specific to DVT
      'oj-dvtBaseComponent.labelMonthShortJanuary': 'DvtUtilBundle.MONTH_SHORT_JANUARY',
      'oj-dvtBaseComponent.labelMonthShortFebruary': 'DvtUtilBundle.MONTH_SHORT_FEBRUARY',
      'oj-dvtBaseComponent.labelMonthShortMarch': 'DvtUtilBundle.MONTH_SHORT_MARCH',
      'oj-dvtBaseComponent.labelMonthShortApril': 'DvtUtilBundle.MONTH_SHORT_APRIL',
      'oj-dvtBaseComponent.labelMonthShortMay': 'DvtUtilBundle.MONTH_SHORT_MAY',
      'oj-dvtBaseComponent.labelMonthShortJune': 'DvtUtilBundle.MONTH_SHORT_JUNE',
      'oj-dvtBaseComponent.labelMonthShortJuly': 'DvtUtilBundle.MONTH_SHORT_JULY',
      'oj-dvtBaseComponent.labelMonthShortAugust': 'DvtUtilBundle.MONTH_SHORT_AUGUST',
      'oj-dvtBaseComponent.labelMonthShortSeptember': 'DvtUtilBundle.MONTH_SHORT_SEPTEMBER',
      'oj-dvtBaseComponent.labelMonthShortOctober': 'DvtUtilBundle.MONTH_SHORT_OCTOBER',
      'oj-dvtBaseComponent.labelMonthShortNovember': 'DvtUtilBundle.MONTH_SHORT_NOVEMBER',
      'oj-dvtBaseComponent.labelMonthShortDecember': 'DvtUtilBundle.MONTH_SHORT_DECEMBER',
      'oj-dvtBaseComponent.labelScalingSuffixThousand': 'DvtUtilBundle.SCALING_SUFFIX_THOUSAND',
      'oj-dvtBaseComponent.labelScalingSuffixMillion': 'DvtUtilBundle.SCALING_SUFFIX_MILLION',
      'oj-dvtBaseComponent.labelScalingSuffixBillion': 'DvtUtilBundle.SCALING_SUFFIX_BILLION',
      'oj-dvtBaseComponent.labelScalingSuffixTrillion': 'DvtUtilBundle.SCALING_SUFFIX_TRILLION',
      'oj-dvtBaseComponent.labelScalingSuffixQuadrillion': 'DvtUtilBundle.SCALING_SUFFIX_QUADRILLION',
      
      'oj-dvtBaseComponent.stateSelected': 'DvtUtilBundle.STATE_SELECTED',
      'oj-dvtBaseComponent.stateUnselected': 'DvtUtilBundle.STATE_UNSELECTED',
      'oj-dvtBaseComponent.stateMaximized': 'DvtUtilBundle.STATE_MAXIMIZED',
      'oj-dvtBaseComponent.stateMinimized': 'DvtUtilBundle.STATE_MINIMIZED',
      'oj-dvtBaseComponent.stateExpanded': 'DvtUtilBundle.STATE_EXPANDED',
      'oj-dvtBaseComponent.stateCollapsed': 'DvtUtilBundle.STATE_COLLAPSED',
      'oj-dvtBaseComponent.stateIsolated': 'DvtUtilBundle.STATE_ISOLATED',
      'oj-dvtBaseComponent.stateHidden': 'DvtUtilBundle.STATE_HIDDEN',
      'oj-dvtBaseComponent.stateVisible': 'DvtUtilBundle.STATE_VISIBLE'
    };
    
    // Retrieve the resources and map to the DvtBundle identifiers
    var ret = {};
    for(var key in map) {
      var bundleKey = map[key];
      var resource = oj.Translations.getResource(key);
      ret[bundleKey] = resource;
    }
    return ret;
  },
  
  /**
   * Retrieves the translated resource with the specified 
   * @param {string} key The key used to retrieve the translated resource.
   * @param {Array.<string>} params The array of named parameters that need to be converted into index based parameters.
   * @protected
   */
  _GetTranslatedResource: function(key, params) {
    var translatedResource = this.options[key];
    
    // If named parameters are defined, replace with index based params
    if(params) {
      var paramMap = {};
      for(var i=0; i<params.length; i++) {
        paramMap[params[i]] = '{' + i + '}';
      }
      translatedResource = oj.Translations.applyParameters(translatedResource, paramMap);
    }

    return translatedResource;
  },
   
  /**
   * Called to process the translated strings for this widget.  
   * @private
   */
  _processTranslations: function() {
    // Retrieve the map of translation keys + DvtBundle identifiers
    var translationMap = this._GetTranslationMap();
    
    // Register with the DvtBundle
    DvtBundle.addLocalizedStrings(translationMap);
  },
  
  /**
   * @override
   * @protected
   */
  _destroy : function() {
    this.element.children().remove();
    
    // Call super last for destroy
    this._super();
  },

  /**
   * @override
   * @protected
   */
  _setOptions : function(options) {
    // Call the super to update the property values
    this._superApply(arguments);
    
    // Render the component with the changes
    this._Render();
  },
  
  /**
   * Called by _create to instantiate the specific component instance.  Subclasses must override.
   * @param {DvtContext} context
   * @param {Function} callback
   * @param {Object} callbackObj
   * @protected
   */
  _CreateComponent : function(context, callback, callbackObj) {
    return null; // subclasses must override
  },
  
  /**
   * Called by the component to process events.  Subclasses should override to delegate DVT component events to their 
   * JQuery listeners.
   * @param {Object} event
   * @protected
   */
  _HandleEvent : function(event) {
    // subclasses should override to delegate component events to their listeners
  },
  
  /**
   * Called when the component is resized.
   * @param {number} width
   * @param {number} height
   * @private
   */
  _handleResize : function(width, height) {
    // Render the component at the new size if it changed enough
    var newWidth = this.element.width();
    var newHeight = this.element.height();
    if(Math.abs(newWidth - this._width) + Math.abs(newHeight - this._height) >= 5) {    
      this._component.render(null, newWidth, newHeight);
      
      // Update the rendered size
      this._width = newWidth;
      this._height = newHeight;
    }
  },
  
  /**
   * Called by our implementation to load component resources like images, resource bundles, or basemaps.
   * @protected
   */
  _LoadResources : function() {
    // subcomponents should override
  }, 
          
  /**
   * Called to render the component at the current size.
   * @protected
   */
  _Render : function() {
    // Fix 18498656: If the component is not attached to a visible subtree of the DOM, rendering will fail because 
    // getBBox calls will not return the correct values.  Log an error message in this case and avoid rendering.
    if(!this._context.isReadyToRender())
      // TODO This resource should be retrieved off of the options object
      oj.Logger.error(oj.Translations.getResource('oj-dvtBaseComponent.notReadyToRender')['summary']);
    else {
      // Render the component
      this._width = this.element.width();
      this._height = this.element.height();
      this._component.render(this.options, this._width, this._height);
    }
  }
});
/**
 * Creates a shape attribute group handler that will generate shape attribute values.
 * @param {Object} matchRules A map of key value pairs for categories and the matching attribute value e.g. {"soda" : "square", "water" : "circle", "iced tea" : "triangleUp"}.
 *                            Attribute values listed in the matchRules object will be reserved only for the matching categories when getAttributeValue is called.
 * @export
 * @constructor
 * @extends {oj.AttributeGroupHandler}
 */
oj.ShapeAttributeGroupHandler = function(matchRules) {
  this.Init(matchRules);
}

oj.Object.createSubclass(oj.ShapeAttributeGroupHandler, oj.AttributeGroupHandler, "oj.ShapeAttributeGroupHandler");

oj.ShapeAttributeGroupHandler._attributeValues = ['square', 'circle', 'diamond', 'plus', 'triangleDown', 'triangleUp', 'human'];

/**
 * @override
 */
oj.ShapeAttributeGroupHandler.prototype.getValueRamp = function() {
  return oj.ShapeAttributeGroupHandler._attributeValues.slice();
}
/**
 * Creates a color attribute group handler that will generate color attribute values.
 * @param {Object} matchRules A map of key value pairs for categories and the matching attribute value e.g. {"soda" : "#336699", "water" : "#CC3300", "iced tea" : "#F7C808"}.
 *                            Attribute values listed in the matchRules object will be reserved only for the matching categories when getAttributeValue is called.
 * @export
 * @constructor
 * @extends {oj.AttributeGroupHandler}
 */
oj.ColorAttributeGroupHandler = function(matchRules) {
  this._attributeValues = [];
  var attrGpsDiv = $(document.createElement("div"));
  attrGpsDiv.attr("style", "display:none;");
  attrGpsDiv.attr("id", "attrGps");
  $(document.body).append(attrGpsDiv);
  for (var i=0; i<oj.ColorAttributeGroupHandler._styleClasses.length; i++) {
    var childDiv = $(document.createElement("div"));
    childDiv.addClass(oj.ColorAttributeGroupHandler._styleClasses[i]);
    attrGpsDiv.append(childDiv);
    this._attributeValues.push(childDiv.css('color'));
  }
  attrGpsDiv.remove();
  this.Init(matchRules);
}

oj.Object.createSubclass(oj.ColorAttributeGroupHandler, oj.AttributeGroupHandler, "oj.ColorAttributeGroupHandler");

oj.ColorAttributeGroupHandler._styleClasses = ['oj-dvt-category-index1', 
  'oj-dvt-category-index2', 'oj-dvt-category-index3', 'oj-dvt-category-index4', 
  'oj-dvt-category-index5', 'oj-dvt-category-index6', 'oj-dvt-category-index7', 
  'oj-dvt-category-index8', 'oj-dvt-category-index9', 'oj-dvt-category-index10', 
  'oj-dvt-category-index11', 'oj-dvt-category-index12'];

/**
 * @override
 */
oj.ColorAttributeGroupHandler.prototype.getValueRamp = function() {
  return this._attributeValues.slice();
}
/**
 * Class to help set css properties on the component root options object
 * @param {Object} object The root options object from which this path should be resolved
 * @param {string} path The string path within the options object to resolve
 * @constructor
 */
var DvtJsonPath = function(object, path)
{
  this._path = path;
  this._root = object;
  this._delimiter = '/';
}

/**
 * Resolves the parameter of the leaf object and the leaf object itself
 * @param {Object} root The root object to update
 * @param {string} path The string path within the root object to resolve
 * @param {string} delimiter The string delimiter for the path string
 * @param {boolean} createIfMissing Flag to create the hierarchy of the namespaces if they do not exist
 * @return {Object} The resolved parameter
 * @private
 */
DvtJsonPath.prototype._resolveLeafObjectAndProperty = function(root, path, delimiter, createIfMissing)
{
  var result = {};
  while (root && path.indexOf(delimiter) > -1)
  {
    var subProperty = path.substring(0, path.indexOf(delimiter));
    if (createIfMissing && root[subProperty] === undefined)
    {
      root[subProperty] = {};
    }
    root = root[subProperty];
    path = path.substring(path.indexOf(delimiter) + 1, path.length);
  }

  if (root)
  {
    result['object'] = root;
    result['parameter'] = path;
  }

  return result;
}

/**
 * Resolves path to the leaf object and parameter of this object
 * @param {boolean} createIfMissing Flag to create the hierarchy of the namespaces if they do not exist
 * @private
 */
DvtJsonPath.prototype._resolvePath = function(createIfMissing)
{
  if (this._leaf === undefined)
  {
    var result = this._resolveLeafObjectAndProperty(this._root, this._path, this._delimiter, createIfMissing);

    this._leaf = result['object'];
    this._param = result['parameter'];
  }
}

/**
 * Returns value of the leaf element of the path.
 * @return {string} value The value of the leaf element or undefined if path structure is not yet created
 */
DvtJsonPath.prototype.getValue = function()
{
  this._resolvePath(false);
  return this._leaf === undefined ? undefined : this._leaf[this._param];
}

/**
 * Sets value of the leaf element of the path.
 * @param {String} value The value of the leaf element
 */
DvtJsonPath.prototype.setValue = function(value)
{
  this._resolvePath(true);

  if (this._leaf[this._param] !== value)
  {
    this._leaf[this._param] = value;
  }
}
// Base class for all gauge components
oj.__registerWidget('oj.dvtBaseGauge', $['oj']['dvtBaseComponent'], 
{
  /**
   * Reacts to changes to the 'value' option by triggering a 'optionChange' event if the value changes from its previous 
   * value. Refer to the optionChange event for details.
   * 
   * @param {String|Object|string=} key a single string representing a key or an object representing a group 
   * of options
   * @param {Object=} value of the key
   * @fires oj.editableValue#optionChange
   */
  option : function (key, value)
  {    
    // If this contains an update of the value property, retrieve the previous value
    var previousValue, valueOptionSet = false;
    if (typeof key === "string" && value !== undefined)
    {
      // Explicit key or key/value is passed in.
      if(key === "value") {
        valueOptionSet = true;
        previousValue = this.options['value'];
      }
    }
    else if (typeof key === "object" && key)
    {
      // Object literal of key...values is passed in - ('option', {key: value, key2: value2})
      if (key['value'] !== undefined)
      {
        valueOptionSet = true;
        previousValue = this.options['value'];
      }
    }
    
    // Step 2: call the super to set the option 
    var ret = this._superApply(arguments);
    
    // Step 3: trigger events if needed
    if (valueOptionSet)
    {
      var newValue = this.options['value'];
      
      // trigger a optionChange event only when the newValue is different from the previousValue to 
      // avoid recursion. E.g., setOption() triggers optionChange, which calls ko binding callback, 
      // which then writes to observable. Which then causes binding update to call set option again
      if (!oj.Object.innerEquals(previousValue, newValue))
      {
        this._trigger('optionChange', null, {'option': 'value', 'previousValue': previousValue, 'value': newValue});
      }
    }
    
    return ret;
  },

  /**
   * @override
   */
  _GetChildStyleClasses : function() {
    var styleClasses = this._super();
    styleClasses['oj-gauge-metric-label'] = {'path' : 'metricLabel/style', 'property' : 'CSS_TEXT_PROPERTIES'};
    styleClasses['oj-gauge-tick-label'] = {'path' : 'tickLabel/style', 'property' : 'CSS_TEXT_PROPERTIES'};
// TODO HZHANG threshold colors needs bug fix 17334522
//    styleClasses['oj-gauge-threshold-index1'] = {'path' : '', 'type' : 'color'};
//    styleClasses['oj-gauge-threshold-index2'] = {'path' : '', 'type' : 'color'};
//    styleClasses['oj-gauge-threshold-index3'] = {'path' : '', 'type' : 'color'};
    return styleClasses;
  },
  
  /**
   * @override
   */
  _GetTranslationMap: function() {
    var superMap = this._super();
    var selfMap = {
      'DvtGaugeBundle.EMPTY_TEXT': this._GetTranslatedResource('msgNoData')
    };
    
    // TODO Workaround for inheritance of resource from parent not working
    selfMap['DvtGaugeBundle.EMPTY_TEXT'] = oj.Translations.getResource('oj-dvtBaseComponent.msgNoData');
    
    // Combine with the map from the superclass
    var ret = {};
    for(var key in superMap) { ret[key] = superMap[key]; }
    for(var key in selfMap) { ret[key] = selfMap[key]; }
    
    return ret;
  },
  
  /**
   * @override
   */
  _HandleEvent : function(event) {
    var type = event && event.getType ? event.getType() : null;
    if(type === DvtValueChangeEvent.TYPE) {
      // Fired after the value change interaction is complete
      this.option('value', event.getNewValue());
    }
    else if(type === DvtValueChangeEvent.TYPE_INPUT) {
      // Fired during the value change interaction for each change
      this._trigger('input', null, {'value': event.getNewValue()});
    }
    else {
      this._super(event);
    }
  }
});
/**
 * @class 
 * @name oj.ojStatusMeterGauge
 * @augments oj.baseComponent
 * 
 * @classdesc
 * <h3 id="statusMeterGaugeOverview-section">
 *   JET Status Meter Gauge Component
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#statusMeterGaugeOverview-section"></a>
 * </h3>
 * 
 * <p>Status meter gauge component for JET, supporting horizontal and circular status meters.</p>
 * 
 * <p>This component should be bound to an HTML div element, and the SVG DOM that it generates should be treated as a 
 * black box, as it is subject to change.  This component should not be extended.</p>
 * 
 * <pre class="prettyprint">
 * <code>
 * &lt;div data-bind="ojComponent: {
 *   component: 'ojStatusMeterGauge',
 *   value: 63, min: 0, max: 100, 
 *   thresholds: [{max: 33}, {max: 67}, {}]
 * }"/>
 * </code>
 * </pre>
 * 
 * <h3 id="statusMeterGaugeOptions-section">
 *   Options
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#statusMeterGaugeOptions-section"></a>
 * </h3>
 * 
 * <p>Full documentation for the options method, including APIs for data, style properties, and interactivity, is 
 * available <a title="Options Documentation" href="dvt/statusMeterGauge.xml">here</a>.</p>
 * 
 * @desc Creates a JET Status Meter Gauge.
 * @example <caption>Initialize the Status Meter Gauge with no options specified:</caption>
 * $(".selector").ojStatusMeterGauge();
 * 
 * @example <caption>Initialize the Status Meter Gauge with some options:</caption>
 * $(".selector").ojStatusMeterGauge({value: 63, min: 0, max: 100, thresholds: [{max: 33}, {max: 67}, {}]});
 * 
 * @example <caption>Initialize the Status Meter Gauge via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;div data-bind="ojComponent: {component: 'ojStatusMeterGauge'}">
 */
oj.__registerWidget('oj.ojStatusMeterGauge', $['oj']['dvtBaseGauge'], 
{
  version : "1.0.0", 
  widgetEventPrefix : "oj", 
  options: {
    /**
     * Triggered during a value change gesture on mouse or touch move.
     * 
     * @property {Object} ui event payload
     * @property {number} ui.value the value of the gauge
     * 
     * @example <caption>Initialize the component with the <code class="prettyprint">input</code> callback specified:</caption>
     * $(".selector").ojStatusMeterGauge({
     *   "input": function(event, ui){}
     * });
     *
     * @example <caption>Bind an event listener to the <code class="prettyprint">ojinput</code> event:</caption>
     * $(".selector").on("ojinput", function(event, ui){});
     * 
     * @expose 
     * @event 
     * @memberof! oj.ojStatusMeterGauge
     * @instance
     */
    input : null,
    
    /**
     * Triggered when the following component options change. 
     * <ul>
     * <li><strong>value</strong>: when the component's value changes. </li>
     * </ul>
     * 
     * @property {Object} data event payload
     * @property {string} data.option the name of the option that changed, i.e. "value"
     * @property {Object} data.previousValue an Object holding the previous value of the option
     * @property {Object} data.value an Object holding the current value of the option
     * 
     * @example <caption>Initialize the component with the <code class="prettyprint">optionChange</code> callback:</caption>
     * $(".selector").ojStatusMeterGauge({
     *   'optionChange': function (event, data) {} 
     * });
     * 
     * @example <caption>Bind an event listener to the <code class="prettyprint">ojoptionchange</code> event:</caption>
     * $(".selector").on({
     *   'ojoptionchange': function (event, data) {
     *       window.console.log("option changing is: " + data['option']);
     *   };
     * });
     * 
     * @expose 
     * @event 
     * @memberof! oj.ojStatusMeterGauge
     * @instance
     */
    optionChange: null
  },
  
  /**
   * @override
   */
  _CreateComponent : function(context, callback, callbackObj) {
    return DvtStatusMeterGauge.newInstance(context, callback, callbackObj);
  },
  
  /**
   * @override
   */
  _GetComponentStyleClasses : function() {
    var styleClasses = this._super();
    styleClasses.push('oj-statusmetergauge');
    return styleClasses;
  },
  
  /**
   * @override
   */
  _Render : function() {
    // Display the title of the surrounding div as the tooltip
    this.options['shortDesc'] = this.element.attr('title');
  
    // Call the super to render
    this._super();
  }
});
/**
 * @class 
 * @name oj.ojLedGauge
 * @augments oj.baseComponent
 * 
 * @classdesc
 * <h3 id="ledGaugeOverview-section">
 *   JET LED Gauge Component
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#ledGaugeOverview-section"></a>
 * </h3>
 * 
 * <p>LED gauge component for JET.  LED gauges are used to highlight a specific metric value in relation to its 
 * thresholds.<p>
 * 
 * <p>This component should be bound to an HTML div element, and the SVG DOM that it generates should be treated as a 
 * black box, as it is subject to change.  This component should not be extended.</p>
 * 
 * <pre class="prettyprint">
 * <code>
 * &lt;div data-bind="ojComponent: {
 *   component: 'ojLedGauge',
 *   value: 63, min: 0, max: 100, 
 *   thresholds: [{max: 33}, {max: 67}, {}]
 * }"/>
 * </code>
 * </pre>
 * 
 * <h3 id="ledGaugeOptions-section">
 *   Options
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#ledGaugeOptions-section"></a>
 * </h3>
 * 
 * <p>Full documentation for the options method, including APIs for data, style properties, and interactivity, is 
 * available <a title="Options Documentation" href="dvt/ledGauge.xml">here</a>.</p>
 * 
 * @desc Creates a JET LED Gauge.
 * @example <caption>Initialize the LED Gauge with no options specified:</caption>
 * $(".selector").ojLedGauge();
 * 
 * @example <caption>Initialize the LED Gauge with some options:</caption>
 * $(".selector").ojLedGauge({value: 63, min: 0, max: 100, thresholds: [{max: 33}, {max: 67}, {}]});
 * 
 * @example <caption>Initialize the LED Gauge via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;div data-bind="ojComponent: {component: 'ojLedGauge'}">
 */
oj.__registerWidget('oj.ojLedGauge', $['oj']['dvtBaseGauge'], 
{
  version : "1.0.0", 
  widgetEventPrefix : "oj", 
  options: {
    /**
     * Triggered when the following component options change. 
     * <ul>
     * <li><strong>value</strong>: when the component's value changes. </li>
     * </ul>
     * 
     * @property {Object} data event payload
     * @property {string} data.option the name of the option that changed, i.e. "value"
     * @property {Object} data.previousValue an Object holding the previous value of the option
     * @property {Object} data.value an Object holding the current value of the option
     * 
     * @example <caption>Initialize the component with the <code class="prettyprint">optionChange</code> callback:</caption>
     * $(".selector").ojLedGauge({
     *   'optionChange': function (event, data) {} 
     * });
     * 
     * @example <caption>Bind an event listener to the <code class="prettyprint">ojoptionchange</code> event:</caption>
     * $(".selector").on({
     *   'ojoptionchange': function (event, data) {
     *       window.console.log("option changing is: " + data['option']);
     *   };
     * });
     * 
     * @expose 
     * @event 
     * @memberof! oj.ojLedGauge
     * @instance
     */
    optionChange: null
  },
  
  /**
   * @override
   */
  _CreateComponent : function(context, callback, callbackObj) {
    return DvtLedGauge.newInstance(context, callback, callbackObj);
  },
  
  /**
   * @override
   */
  _GetComponentStyleClasses : function() {
    var styleClasses = this._super();
    styleClasses.push('oj-ledgauge');
    return styleClasses;
  },
  
  /**
   * @override
   */
  _Render : function() {
    // Display the title of the surrounding div as the tooltip
    this.options['shortDesc'] = this.element.attr('title');
  
    // Call the super to render
    this._super();
  }
});
/**
 * @class 
 * @name oj.ojRatingGauge
 * @augments oj.baseComponent
 * 
 * @classdesc
 * <h3 id="ratingGaugeOverview-section">
 *   JET Rating Gauge Component
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#ratingGaugeOverview-section"></a>
 * </h3>
 * 
 * <p>Rating gauge component for JET.  Rating gauges are typically used to display or accept user feedback on a product
 * or service.</p>
 * 
 * <p>This component should be bound to an HTML div element, and the SVG DOM that it generates should be treated as a 
 * black box, as it is subject to change.  This component should not be extended.</p>
 * 
 * <pre class="prettyprint">
 * <code>
 * &lt;div data-bind="ojComponent: {component: 'ojRatingGauge', value: 4}"/>
 * </code>
 * </pre>
 * 
 * <h3 id="ratingGaugeOptions-section">
 *   Options
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#ratingGaugeOptions-section"></a>
 * </h3>
 * 
 * <p>Full documentation for the options method, including APIs for data, style properties, and interactivity, is 
 * available <a title="Options Documentation" href="dvt/ratingGauge.xml">here</a>.</p>
 * 
 * @desc Creates a JET Rating Gauge.
 * @example <caption>Initialize the Rating Gauge with no options specified:</caption>
 * $(".selector").ojRatingGauge();
 * 
 * @example <caption>Initialize the Rating Gauge with some options:</caption>
 * $(".selector").ojRatingGauge({value: 4});
 * 
 * @example <caption>Initialize the Rating Gauge via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;div data-bind="ojComponent: {component: 'ojRatingGauge'}">
 */
oj.__registerWidget('oj.ojRatingGauge', $['oj']['dvtBaseGauge'], 
{
  version : "1.0.0", 
  widgetEventPrefix : "oj", 
  options: {
    /**
     * Triggered during a value change gesture on mouse or touch move.
     * 
     * @property {Object} ui event payload
     * @property {number} ui.value the value of the gauge
     * 
     * @example <caption>Initialize the component with the <code class="prettyprint">input</code> callback specified:</caption>
     * $(".selector").ojRatingGauge({
     *   "input": function(event, ui){}
     * });
     *
     * @example <caption>Bind an event listener to the <code class="prettyprint">ojinput</code> event:</caption>
     * $(".selector").on("ojinput", function(event, ui){});
     * 
     * @expose 
     * @event 
     * @memberof! oj.ojRatingGauge
     * @instance
     */
    input : null,
    
    /**
     * Triggered when the following component options change. 
     * <ul>
     * <li><strong>value</strong>: when the component's value changes. </li>
     * </ul>
     * 
     * @property {Object} data event payload
     * @property {string} data.option the name of the option that changed, i.e. "value"
     * @property {Object} data.previousValue an Object holding the previous value of the option
     * @property {Object} data.value an Object holding the current value of the option
     * 
     * @example <caption>Initialize the component with the <code class="prettyprint">optionChange</code> callback:</caption>
     * $(".selector").ojRatingGauge({
     *   'optionChange': function (event, data) {} 
     * });
     * 
     * @example <caption>Bind an event listener to the <code class="prettyprint">ojoptionchange</code> event:</caption>
     * $(".selector").on({
     *   'ojoptionchange': function (event, data) {
     *       window.console.log("option changing is: " + data['option']);
     *   };
     * });
     * 
     * @expose 
     * @event 
     * @memberof! oj.ojRatingGauge
     * @instance
     */
    optionChange: null
  },
  
  /**
   * @override
   */
  _CreateComponent : function(context, callback, callbackObj) {
    return DvtRatingGauge.newInstance(context, callback, callbackObj);
  },
  
  /**
   * @override
   */
  _GetComponentStyleClasses : function() {
    var styleClasses = this._super();
    styleClasses.push('oj-ratinggauge');
    //TODO HZHANG Add style classes for rating gauge selected/hover/unselected/changed
    return styleClasses;
  },
  
  /**
   * @override
   */
  _Render : function() {
    // Display the title of the surrounding div as the tooltip
    this.options['shortDesc'] = this.element.attr('title');
  
    // Call the super to render
    this._super();
  }
});
/**
 * @class 
 * @name oj.ojDialGauge
 * @augments oj.baseComponent
 * 
 * @classdesc
 * <h3 id="dialGaugeOverview-section">
 *   JET Dial Gauge Component
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#dialGaugeOverview-section"></a>
 * </h3>
 * 
 * <p>Dial gauge component for JET.  Dial gauges are used to display a metric value in relation to the minimum and 
 * maximum possible values for that metric.</p>
 * 
 * <p>This component should be bound to an HTML div element, and the SVG DOM that it generates should be treated as a 
 * black box, as it is subject to change.  This component should not be extended.</p>
 * 
 * <pre class="prettyprint">
 * <code>
 * &lt;div data-bind="ojComponent: {
 *   component: 'ojDialGauge',
 *   value: 63, min: 0, max: 100, 
 *   metricLabel: {rendered: 'on'}
 * }"/>
 * </code>
 * </pre>
 * 
 * <h3 id="dialGaugeOptions-section">
 *   Options
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#dialGaugeOptions-section"></a>
 * </h3>
 * 
 * <p>Full documentation for the options method, including APIs for data, style properties, and interactivity, is 
 * available <a title="Options Documentation" href="dvt/dialGauge.xml">here</a>.</p>
 * 
 * @desc Creates a JET Dial Gauge.
 * @example <caption>Initialize the Dial Gauge with no options specified:</caption>
 * $(".selector").ojDialGauge();
 * 
 * @example <caption>Initialize the Dial Gauge with some options:</caption>
 * $(".selector").ojDialGauge({value: 63, min: 0, max: 100, metricLabel: {rendered: 'on'}});
 * 
 * @example <caption>Initialize the Dial Gauge via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;div data-bind="ojComponent: {component: 'ojDialGauge'}">
 */
oj.__registerWidget('oj.ojDialGauge', $['oj']['dvtBaseGauge'], 
{
  version : "1.0.0", 
  widgetEventPrefix : "oj", 
  options: {
    /**
     * Triggered during a value change gesture on mouse or touch move.
     * 
     * @property {Object} ui event payload
     * @property {number} ui.value the value of the gauge
     * 
     * @example <caption>Initialize the component with the <code class="prettyprint">input</code> callback specified:</caption>
     * $(".selector").ojDialGauge({
     *   "input": function(event, ui){}
     * });
     *
     * @example <caption>Bind an event listener to the <code class="prettyprint">ojinput</code> event:</caption>
     * $(".selector").on("ojinput", function(event, ui){});
     * 
     * @expose 
     * @event 
     * @memberof! oj.ojDialGauge
     * @instance
     */
    input : null,
    
    /**
     * Triggered when the following component options change. 
     * <ul>
     * <li><strong>value</strong>: when the component's value changes. </li>
     * </ul>
     * 
     * @property {Object} data event payload
     * @property {string} data.option the name of the option that changed, i.e. "value"
     * @property {Object} data.previousValue an Object holding the previous value of the option
     * @property {Object} data.value an Object holding the current value of the option
     * 
     * @example <caption>Initialize the component with the <code class="prettyprint">optionChange</code> callback:</caption>
     * $(".selector").ojDialGauge({
     *   'optionChange': function (event, data) {} 
     * });
     * 
     * @example <caption>Bind an event listener to the <code class="prettyprint">ojoptionchange</code> event:</caption>
     * $(".selector").on({
     *   'ojoptionchange': function (event, data) {
     *       window.console.log("option changing is: " + data['option']);
     *   };
     * });
     * 
     * @expose 
     * @event 
     * @memberof! oj.ojDialGauge
     * @instance
     */
    optionChange: null
  },
  
  /**
   * @override
   */
  _CreateComponent : function(context, callback, callbackObj) {
    return DvtDialGauge.newInstance(context, callback, callbackObj);
  },

  /**
   * @override
   */
  _GetComponentStyleClasses : function() {
    var styleClasses = this._super();
    styleClasses.push('oj-dialgauge');
    return styleClasses;
  },
  
  /**
   * @override
   */
  _Render : function() {
    // Display the title of the surrounding div as the tooltip
    this.options['shortDesc'] = this.element.attr('title');
  
    // Call the super to render
    this._super();
  }
});
/**
 * @class 
 * @name oj.ojSunburst
 * @augments oj.baseComponent
 * 
 * @classdesc
 * <h3 id="sunburstOverview-section">
 *   JET Sunburst Component
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#sunburstOverview-section"></a>
 * </h3>
 * 
 * <p>Sunburst component for JET. Sunbursts are used to display hierarchical data across two dimensions, represented by 
 * the size and color of the sunburst nodes.</p>
 * 
 * <p>This component should be bound to an HTML div element, and the SVG DOM that it generates should be treated as a 
 * black box, as it is subject to change.  This component should not be extended.</p>
 * 
 * <pre class="prettyprint">
 * <code>
 * &lt;div data-bind="ojComponent: {
 *   component: 'ojSunburst',
 *   nodes: [{value: 100, color: "#FFFF00", label: "Total Sales", 
 *            nodes: [{value: 75, color: "#00FF00", label: "Candy"},
 *                    {value: 20, color: "#FFFF00", label: "Fruit"},
 *                    {value: 15, color: "#FF0000", label: "Vegetables"}]}]
 * }"/>
 * </code>
 * </pre>
 * 
 * <h3 id="sunburstOptions-section">
 *   Options
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#sunburstOptions-section"></a>
 * </h3>
 * 
 * <p>Full documentation for the options method, including APIs for data, style properties, and interactivity, is 
 * available <a title="Options Documentation" href="dvt/sunburst.xml">here</a>.</p>
 * 
 * @desc Creates a JET Sunburst.
 * @example <caption>Initialize the Sunburst with no options specified:</caption>
 * $(".selector").ojSunburst();
 * 
 * @example <caption>Initialize the Sunburst with some options:</caption>
 * $(".selector").ojSunburst({nodes: [{value: 75, color: "#00FF00", label: "Candy"}, {value: 20, color: "#FFFF00", label: "Fruit"}, {value: 15, color: "#FF0000", label: "Vegetables"}]});
 * 
 * @example <caption>Initialize the Sunburst via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;div data-bind="ojComponent: {component: 'ojSunburst'}">
 */
oj.__registerWidget('oj.ojSunburst', $['oj']['dvtBaseComponent'], 
{
  version : "1.0.0", 
  widgetEventPrefix : "oj", 
  options: {
    /**
     * Triggered after user rotation is completed.
     * 
     * @property {Object} ui event payload
     * @property {number} ui.value the start angle of the sunburst, in degrees
     * 
     * @example <caption>Initialize the component with the <code class="prettyprint">rotate</code> callback specified:</caption>
     * $(".selector").ojSunburst({
     *   "rotate": function(event, ui){}
     * });
     *
     * @example <caption>Bind an event listener to the <code class="prettyprint">ojrotate</code> event:</caption>
     * $(".selector").on("ojrotate", function(event, ui){});
     * 
     * @expose 
     * @event 
     * @memberof! oj.ojSunburst
     * @instance
     */
    rotate : null,
    
    /**
     * Triggered during user rotation of the sunburst.
     * 
     * @property {Object} ui event payload
     * @property {number} ui.value the start angle of the sunburst, in degrees
     * 
     * @example <caption>Initialize the component with the <code class="prettyprint">rotateInput</code> callback specified:</caption>
     * $(".selector").ojSunburst({
     *   "rotateInput": function(event, ui){}
     * });
     *
     * @example <caption>Bind an event listener to the <code class="prettyprint">ojrotateinput</code> event:</caption>
     * $(".selector").on("ojrotateinput", function(event, ui){});
     * 
     * @expose 
     * @event 
     * @memberof! oj.ojSunburst
     * @instance
     */
    rotateInput : null,
    
    /**
     * Triggered after data items are selected or de-selected.
     * 
     * @property {Object} ui event payload
     * @property {Array} ui.items an array containing objects describing the selected nodes
     * @property {string} ui.items.id the id of the node
     * 
     * @example <caption>Initialize the component with the <code class="prettyprint">select</code> callback specified:</caption>
     * $(".selector").ojSunburst({
     *   "select": function(event, ui){}
     * });
     *
     * @example <caption>Bind an event listener to the <code class="prettyprint">ojselect</code> event:</caption>
     * $(".selector").on("ojselect", function(event, ui){});
     * 
     * @expose 
     * @event 
     * @memberof! oj.ojSunburst
     * @instance
     */
    select : null
  },
  
  /**
   * @override
   */
  _CreateComponent : function(context, callback, callbackObj) {
    return DvtSunburst.newInstance(context, callback, callbackObj);
  },
  
  /**
   * @override
   */
  _GetComponentStyleClasses : function() {
    var styleClasses = this._super();
    styleClasses.push('oj-sunburst');
    return styleClasses;
  },
  
  /**
   * @override
   */
  _GetChildStyleClasses : function() {
    var styleClasses = this._super();
    // TODO HZHANG fill in the urls after expand/collapse are supported
// 		styleClasses['oj-sunburst-expand-icon'] = {'path' : '', 'property' : 'CSS_URL'};
// 		styleClasses['oj-sunburst-expand-icon oj-hover'] = {'path' : '', 'property' : 'CSS_URL'};
// 		styleClasses['oj-sunburst-expand-icon oj-active'] = {'path' : '', 'property' : 'CSS_URL'};
// 		styleClasses['oj-sunburst-collapse-icon'] = {'path' : '', 'property' : 'CSS_URL'};
// 		styleClasses['oj-sunburst-collapse-icon oj-hover'] = {'path' : '', 'property' : 'CSS_URL'};
// 		styleClasses['oj-sunburst-collapse-icon oj-active'] = {'path' : '', 'property' : 'CSS_URL'};
    styleClasses['oj-sunburst-attribute-type-text'] = {'path' : 'styleDefaults/_attributeTypeTextStyle', 'property' : 'CSS_TEXT_PROPERTIES'};
    styleClasses['oj-sunburst-attribute-value-text'] = {'path' : 'styleDefaults/_attributeValueTextStyle', 'property' : 'CSS_TEXT_PROPERTIES'};
    // TODO HZHANG add this once drilling is supported
//    styleClasses['oj-sunburst-current-text'] = {'path' : '', 'property' : 'CSS_TEXT_PROPERTIES'};
    styleClasses['oj-sunburst-node'] = {'path' : 'nodeDefaults/labelStyle', 'property' : 'CSS_TEXT_PROPERTIES'};
    styleClasses['oj-sunburst-node oj-hover'] = {'path' : 'nodeDefaults/hoverColor', 'property' : 'border-top-color'};
    styleClasses['oj-sunburst-node oj-selected'] = [
      {'path' : 'nodeDefaults/selectedOuterColor', 'property' : 'border-top-color'},
      {'path' : 'nodeDefaults/selectedInnerColor', 'property' : 'border-bottom-color'}
    ];
    return styleClasses;
  },
  
  /**
   * @override
   */
  _GetTranslationMap: function() {
    var superMap = this._super();
    var selfMap = {
      'DvtSunburstBundle.COLOR': this._GetTranslatedResource('labelColor'),
      'DvtSunburstBundle.SIZE': this._GetTranslatedResource('labelSize')
    };
    
    // Combine with the map from the superclass
    var ret = {};
    for(var key in superMap) { ret[key] = superMap[key]; }
    for(var key in selfMap) { ret[key] = selfMap[key]; }
    
    return ret;
  },
  
  /**
   * @override
   */
  _HandleEvent : function(event) {
    var type = event && event.getType ? event.getType() : null, selectedItems, selection, selectedItem, i;
    if(type === DvtSelectionEvent.TYPE) {
      selectedItems = [];
      selection = event.getSelection();
      for(i=0; i<selection.length; i++) {
        selectedItem = {'id': selection[i]};
        selectedItems.push(selectedItem);  
      }
      this._trigger('select', null, {'items': selectedItems});
    }
    else if(type === DvtSunburstRotationEvent.TYPE) {
      // Fired after the rotate interaction is complete
      this._trigger('rotate', null, {'value': event.getStartAngle()});
    }
    else if(type === DvtSunburstRotationEvent.TYPE_INPUT) {
      // Fired during the rotate interaction for each change
      this._trigger('rotateInput', null, {'value': event.getStartAngle()});
    }
    else {
      this._super(event);
    }
  },
   
  /**
   * @override
   */
  _LoadResources : function() {
    // Ensure the resources object exists
    if(this.options['_resources'] == null)
      this.options['_resources'] = {};
      
    var resources = this.options['_resources'];
      
    // Add cursors
    resources['rotateCursor'] = oj.Config.getResourceUrl('resources/internal-deps/dvt/sunburst/rotate.cur');
  }
});
// -------------------------------------------------------------------------------------------------------
// This file contains both the Button and Buttonset components,
// so that they can share the same wrapper function / closure containing shared "private static members".
// -------------------------------------------------------------------------------------------------------

// jim retrieved from https://raw.github.com/jquery/jquery-ui/1-10-stable/ui/jquery.ui.button.js on 6/29/2013, and then modified

/*!
 * TODO: how should the copyright (and rest of header) change in our fork?  Is the above Provenance comment OK?
 * Should we use Google's at-licence or at-preserve annotations?  At-copyright?  At-version (in addition to or instead of version field in components)?  
 * Put answers in forking wiki, and update menu.js and other existing componenents too.
 * 
 * jQuery UI Button @VERSION
 * http://jqueryui.com
 *
 * Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/button/
 *
 * Depends:
 *    jquery.ui.core.js
 *    jquery.ui.widget.js
 */
(function() // Button / Buttonset wrapper function, to keep "private static members" private
{

/**
 * @class
 * @name oj.ojButton
 * @augments oj.baseComponent
 * 
 * @classdesc
 * <h3 id="buttonOverview-section">
 *   JET Button Component
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#buttonOverview-section"></a>
 * </h3>
 * 
 * <p>Description: Themeable, WAI-ARIA-compliant push buttons and toggle buttons, with appropriate styles for hover, active, checked, and disabled.
 * 
 * <p>There are two types of JET Buttons: push buttons and toggle buttons.
 * 
 * 
 * <h3 id="pushButtons-section">
 *   Push Buttons
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#pushButtons-section"></a>
 * </h3>
 * 
 * <p>Push buttons are ordinary buttons that do not stay pressed in when clicked.  
 * Push buttons are created from buttons, anchors, and inputs of type button, submit, and reset.  Button elements are typically a good general-purpose choice.
 * 
 * 
 * <h3 id="toggleButtons-section">
 *   Toggle Buttons
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#toggleButtons-section"></a>
 * </h3>
 * 
 * <p>Toggle buttons are buttons that toggle between a selected state and an unselected state when clicked.  
 * Toggle buttons are created from radio buttons and checkboxes (inputs of type radio and checkbox).
 * 
 * <p>For toggle buttons, the input must have a label, which must be a sibling of the input that precedes the input.
 * The label's <code class="prettyprint">for</code> attribute must refer to the input's <code class="prettyprint">id</code> attribute. 
 * 
 * <p>A new wrapper element is created around the label and input, so that the component has a single root, while avoiding the accessibility problems
 * caused by nesting the input inside the label.  
 * 
 * <p>The label-precedes-input requirement ensures compatibility with the JET <code class="prettyprint">ojComponent</code> binding on the input element, 
 * which expects all relevant DOM elements, including label, to be already available with all their attributes resolved.
 * 
 * <p>The wrapper and label are styled to appear as the button, while the underlying input is updated on click. 
 * 
 * <p> Note that a given radio button must not be both checked and disabled, unless all radios in the group are disabled, since this removes 
 * the entire radio group from the tab order in mainstream browsers.  This issue applies to native radios and is not unique to JET.
 * 
 * 
 * <h3 id="buttonsetToolbar-section">
 *   Buttonsets and Toolbars
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#buttonsetToolbar-section"></a>
 * </h3>
 * 
 * <p>The [JET Buttonset]{@link oj.ojButtonset} component can be used to group related buttons, such as a group of radios or checkboxes.  Buttonset provides
 * visual and semantic grouping and WAI-ARIA-compliant focus management.  See the Buttonset API doc for more information.
 * 
 * <p>Also, buttons and buttonsets can be placed in a [JET Toolbar]{@link oj.ojToolbar}.  Like Buttonset, Toolbar is themable and provides WAI-ARIA-compliant 
 * focus management.  See the Toolbar API doc for more information.
 * 
 * 
 * <h3 id="keyboard-section">
 *   Keyboard interaction
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
 * </h3>
 * 
 * <p>Per WAI-ARIA requirements for role="button", all flavors of JET Button support invocation via both <kbd>Enter</kbd> and <kbd>Spacebar</kbd>, even when the 
 * underlying DOM element does not.
 * 
 * 
 * <h3 id="eventHandling-section">
 *   Event Handling
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#eventHandling-section"></a>
 * </h3>
 * 
 * <p>It's most reliable to register click handlers directly on the button, rather than on an ancestor.  For example, if any of the button's DOM is swapped out in a click 
 * handler (e.g. alternating the text and icon between "Play" and "Pause"), the bubbling will stop if the click target was part of the content that was removed in the swap.
 * 
 * <p>In lieu of a shared listener on an ancestor, syntax like <code class="prettyprint">$( "#ancestor :oj-button" ).click( myFunc );</code> can be used to set a handler on many 
 * buttons at once. 
 * 
 * 
 * <h3 id="pseudos-section">
 *   Pseudo-selectors
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#pseudos-section"></a>
 * </h3>
 * 
 * <p>The <code class="prettyprint">:oj-button</code> pseudo-selector can be used in jQuery expressions to select JET Buttons.  For example:
 * 
 * <pre class="prettyprint">
 * <code>$( ":oj-button" ) // selects all JET Buttons on the page
 * $myEventTarget.closest( ":oj-button" ) // selects the closest ancestor that is a JET Button
 * </code></pre>
 * 
 * 
 * <h3 id="state-section">
 *   Setting Component State
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#state-section"></a>
 * </h3>
 * 
 * <p>In JET, when setting component state after create time, the correct approach depends on whether the component has a JS API for that state.
 * 
 * <p>State with a JS API, such as Button's disabled state, checked state, and label, should be set after creation via that API (which in those examples is 
 * <code class="prettyprint">option()</code>), not by directly manipulating the DOM after creation.  This can be done by calling that JS API directly, or by binding 
 * a component option like <code class="prettyprint">disabled</code> to an observable using the <code class="prettyprint">ojComponent</code> binding.  
 * 
 * <p>Built-in KO bindings, like KO's <code class="prettyprint">disable</code> binding, should not be used in this case, since that is tatamount to 
 * updating the DOM directly.  The component option should be bound instead, via JET's <code class="prettyprint">ojComponent</code> binding.
 * 
 * <p>If a button's checked state needs to be set programmatically, then it should be wrapped in a Buttonset so that its <code class="prettyprint">checked</code> 
 * option can be used.
 * 
 * <p>State with no JS API should be set by manipulating the DOM directly in an allowable way, and then calling <code class="prettyprint">refresh()</code> 
 * on the affected component(s).  E.g. the reading direction (LTR / RTL) is changed by by setting the <code class="prettyprint">"dir"</code> attribute on the 
 * <code class="prettyprint">&lt;html></code> node and calling <code class="prettyprint">refresh()</code>.  
 * 
 * <p>When using a built-in Knockout binding (as opposed to the <code class="prettyprint">ojComponent</code> binding), keep in mind that those bindings do not 
 * execute the necessary <code class="prettyprint">refresh()</code> call after updating the DOM.  Updates that flow from the component to the observable, 
 * as a result of user interaction, are not problematic.  But updates in the other direction, that programmatically update the DOM because the observable changed, 
 * will not be picked up until the next <code class="prettyprint">refresh()</code>.
 * 
 * 
 * <h3 id="jqui2jet-section">
 *   JET for jQuery UI developers
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#jqui2jet-section"></a>
 * </h3>
 * 
 * <!-- TODO: discuss component state, refresh(), etc. -->
 * <ol>
 *   <li>All JQUI and JET components inherit <code class="prettyprint">disable()</code> and <code class="prettyprint">enable()</code> methods from the base class.  This API 
 *       duplicates the functionality of the <code class="prettyprint">disabled</code> option.  In JET, to keep the API as lean as possible, we 
 *       have chosen not to document these methods outside of this section.</li>
 *   <li>JQUI Button has a Boolean <code class="prettyprint">text</code> option indicating whether to hide the label when icons are present.
 *       In JET, we prefer to avoid Booleans for future flexibility, so JET Button instead has an expandable <code class="prettyprint">display</code> option accepting 
 *       the values <code class="prettyprint">"all"</code> and <code class="prettyprint">"icons"</code>.</li>
 *   <li>In JQUI Button, the <code class="prettyprint">icons</code> option accepts keys named <code class="prettyprint">"primary"</code> and 
 *       <code class="prettyprint">"secondary"</code>.  For clarity, these options have been renamed in JET Button to <code class="prettyprint">"start"</code> and 
 *       <code class="prettyprint">"end"</code>, our standard directionality-neutral terms for (in LTR) "left" and "right".</li>
 * </ol>
 * 
 * 
 * <p>Also, event names for all JET components are prefixed with "oj", instead of component-specific prefixes like "button" or "menu".  
 * E.g. the JQUI <code class="prettyprint">buttoncreate</code> event is <code class="prettyprint">ojcreate</code> in JET, as shown in the doc for that event.
 * Reason:  This makes the API more powerful.  It allows apps to listen to "foo" events from <em>all</em> JET components via:
 * 
 * <pre class="prettyprint">
 * <code>$( ".selector" ).on( "ojfoo", myFunc);
 * </code></pre>
 * 
 * or to "foo" events only from JET Buttons (the JQUI functionality) via:
 * 
 * <pre class="prettyprint">
 * <code>$( ".selector" ).on( "ojfoo", ":oj-button", myFunc);
 * </code></pre>
 * 
 * 
 * <!-- - - - - Above this point, the tags are for the class.
 *              Below this point, the tags are for the constructor (initializer). - - - - - - -->
 * 
 * 
 * @desc Creates a JET Button.  If called after the button is already created, it is equivalent to the 
 * "set many options" overload of <code class="prettyprint">option()</code>.  
 * 
 * @param {Object=} options a map of option-value pairs to set on the component
 * 
 * @example <caption>Initialize the button with no options specified:</caption>
 * $( ".selector" ).ojButton();
 * 
 * @example <caption>Initialize the button with some options and callbacks specified:</caption>
 * $( ".selector" ).ojButton( { "label": "Copy", "create": function( event, ui ) {} } );
 * 
 * @example <caption>Initialize a push button via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;button id="paste" data-bind="ojComponent: { component: 'ojButton', 
 *                                              label: 'Paste', 
 *                                              create: setupButton }">
 * 
 * @example <caption>Initialize a toggle button via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;label for="check">Toggle&lt;/label>
 * &lt;input type="checkbox" id="check" data-bind="ojComponent: {component: 'ojButton'}"/>
 */
oj.__registerWidget("oj.ojButton", $['oj']['baseComponent'], 
{
    version: "1.0.0", // doesn't get renamed even when unquoted and not in (our) externs.js file, so I'm leaving it unquoted for now.  TODO: Is it used anywhere, e.g. build tool?  If so, should prob quote or extern or something.  If not, should it get moved to @version (if that exists) or similar, or just remove, or...?
    defaultElement: "<button>", // added to externs.js, since this is an override of a superclass member.  (That's the rule for public methods, what about protected fields?)  Would @override do the job and be better than externing?
    widgetEventPrefix : "oj", 
    options: // options is in externs.js, so no need for quotes
    { 
        /**
         * Disables the button if set to <code class="prettyprint">true</code>.
         * 
         * <p>After create time, the <code class="prettyprint">disabled</code> state should be set via this API, not by setting the underlying DOM attribute.
         * 
         * <p>The 2-way <code class="prettyprint">disabled</code> binding offered by the <code class="prettyprint">ojComponent</code> binding 
         * should be used instead of Knockout's built-in <code class="prettyprint">disable</code> and <code class="prettyprint">enable</code> bindings, 
         * as the former sets the API, while the latter sets the underlying DOM attribute.
         * 
         * @expose
         * @memberof! oj.ojButton
         * @instance
         * @type {?boolean}
         * @default <code class="prettyprint">false</code>
         * 
         * @example <caption>Initialize the button with the <code class="prettyprint">disabled</code> option specified:</caption>
         * $( ".selector" ).ojButton( { "disabled": true } );
         * 
         * @example <caption>Get or set the <code class="prettyprint">disabled</code> option, after initialization:</caption>
         * // getter
         * var disabled = $( ".selector" ).ojButton( "option", "disabled" );
         * 
         * // setter
         * $( ".selector" ).ojButton( "option", "disabled", true );
         */
        disabled: null,
        
        /**
         * Whether to display both the label and icons (<code class="prettyprint">"all"</code>) or just the icons (<code class="prettyprint">"icons"</code>).
         * In the latter case, the label is displayed in a tooltip instead, unless a tooltip was already supplied at create time.  
         * 
         * <p>The <code class="prettyprint">display</code> option will be ignored if no icons are specified via the <code class="prettyprint">icons</code> option.
         * 
         * @expose
         * @memberof! oj.ojButton
         * @instance
         * @type {string}
         * @ojvalue {string} "all" Display both the label and icons.
         * @ojvalue {string} "icons" Display only the icons.
         * @default <code class="prettyprint">"all"</code>
         * 
         * @example <caption>Initialize the button with the <code class="prettyprint">display</code> option specified:</caption>
         * $( ".selector" ).ojButton( { "display": "icons" } );
         * 
         * @example <caption>Get or set the <code class="prettyprint">display</code> option, after initialization:</caption>
         * // getter
         * var display = $( ".selector" ).ojButton( "option", "display" );
         * 
         * // setter
         * $( ".selector" ).ojButton( "option", "display", "icons" );
         */
        display: "all",
        
        /**
         * Text to show in the button. 
         * 
         * <p>When not specified (<code class="prettyprint">null</code>) at create time, the element's HTML content is used, or its 
         * <code class="prettyprint">value</code> attribute if the element is an input element of type button, submit, or reset, or 
         * the HTML content of the associated label element if the element is an input of type radio or checkbox.
         * 
         * <p>After create time, the label should be set via this API, not by setting the underlying DOM attribute.
         * 
         * <p>The 2-way <code class="prettyprint">label</code> binding offered by the <code class="prettyprint">ojComponent</code> 
         * binding should be used instead of Knockout's built-in <code class="prettyprint">text</code> binding, as the former 
         * sets the API, while the latter sets the underlying DOM attribute.
         * 
         * @expose
         * @memberof! oj.ojButton
         * @instance
         * @type {?string}
         * @default <code class="prettyprint">null</code>
         * 
         * @example <caption>Initialize the button with the <code class="prettyprint">label</code> option specified:</caption>
         * $( ".selector" ).ojButton( { "label": "custom label" } );
         * 
         * @example <caption>Get or set the <code class="prettyprint">label</code> option, after initialization:</caption>
         * // getter
         * var label = $( ".selector" ).ojButton( "option", "label" );
         * 
         * // setter
         * $( ".selector" ).ojButton( "option", "label", "custom label" );
         */
        label: null,
        
        /**
         * Icons to display in the button.  Support is as follows:
         * <ul>
         *   <li>Any combination of start and end icons can be specified, with or without the label (see <code class="prettyprint">display</code> option).</li>
         *   <li>Icons are supported for push buttons created from buttons and anchors, and for toggle buttons (radios and checkboxes).</li>
         *   <li>Icons are not supported for push buttons created from inputs of type button, submit, and reset.</li>
         * </ul>
         * 
         * <p>The start icon is displayed before the label text (on the left in LTR), and the end icon is displayed after the 
         * label (on the right in LTR).  In RTL, the positions are reversed.
         * 
         * <p>The value for the <code class="prettyprint">start</code> and <code class="prettyprint">end</code> properties should be one or more style class names (as seen in the 
         * examples) or <code class="prettyprint">null</code> (the default).
         * 
         * @expose
         * @memberof! oj.ojButton
         * @instance
         * @type {Object}
         * @default <code class="prettyprint">{ start: null, end: null }</code>
         * 
         * @example <caption>Initialize the button, specifying only one icon:</caption>
         * $( ".selector" ).ojButton({ "icons": { start:'demo-icon-sprite demo-icon-locked' } });
         * 
         * @example <caption>Get or set the <code class="prettyprint">icons</code> option, after initialization:</caption>
         * // getter
         * var icons = $( ".selector" ).ojButton( "option", "icons" );
         * 
         * // setter, specifying both icons:
         * $( ".selector" ).ojButton( "option", "icons", { start: 'demo-icon-sprite demo-icon-gear', 
         *                                                 end: 'demo-icon-sprite demo-icon-triangle-1-s'} );
         */
        icons:
        {
            /** @expose */
            start: null,
            /** @expose */
            end: "auto" 
        },
        
        /**
         * <p>JQ selector identifying the JET Menu that the button should launch. If specified, the button is a WAI-ARIA-compliant menu button.  
         * 
         * <p>By default, menu buttons have a downward pointing "dropdown" arrow for their end icon.  See the <code class="prettyprint">icons</code> option for details.
         * 
         * <p>Menu button functionality is supported for Buttons based on button or anchor tags.  (Buttons based on input tags either do not support the dropdown icon, 
         * or do not make sense for use as a menu button, or both.)
         * 
         * <p>The JET Menu should be initialized before being set on a button's <code class="prettyprint">menu</code> option.  This means that if the menu is specified 
         * at create time, then the menu should be initialized first, before the button referencing it is initialized.  If the components are initialized using 
         * <code class="prettyprint">ojComponent</code> bindings, then the order can be controlled either by using separate <code class="prettyprint">applyBindings</code> 
         * calls, or by placing the menu before the button in the document.
         * 
         * <p>The menu-before-button ordering can lead to a less intuitive tab order.  To avoid this while using a single <code class="prettyprint">applyBindings</code> call, the
         * <code class="prettyprint">menu</code> option can be set after both components are initialized, thus meeting the requirement that the menu be inited when set 
         * on the button.
         * 
         * @expose
         * @memberof! oj.ojButton
         * @instance
         * @type {Object}
         * @default <code class="prettyprint">null</code>
         * 
         * @example <caption>Initialize a menu button:</caption>
         * $( ".selector" ).ojButton({ "menu": "#myMenu" });
         * 
         * @example <caption>Get or set the <code class="prettyprint">menu</code> option, after initialization:</caption>
         * // getter
         * var menu = $( ".selector" ).ojButton( "option", "menu" );
         * 
         * // setter
         * $( ".selector" ).ojButton( "option", "menu", ".my-marker-class" );
         */
        menu: null

        // Events
        
        /**
         * Triggered when the button is created.
         *
         * @event 
         * @name create
         * @memberof! oj.ojButton
         * @instance
         * @property {Event} event <code class="prettyprint">jQuery</code> event object
         * @property {Object} ui Empty object included for consistency with other events
         * 
         * @example <caption>Initialize the button with the <code class="prettyprint">create</code> callback specified:</caption>
         * $( ".selector" ).ojButton({
         *     "create": function( event, ui ) {}
         * });
         * 
         * @example <caption>Bind an event listener to the <code class="prettyprint">ojcreate</code> event:</caption>
         * $( ".selector" ).on( "ojcreate", function( event, ui ) {} );
         */
        // create event declared in superclass, but we still want the above API doc
    },
    
    _create: function() // Override of protected base class method.  Method name needn't be quoted since is in externs.js.
    {
        // Add "form reset" handler to form (if any) that updates checked state of all buttons on form.
        // Register on the form once with a "static" button namespace, not once per button with each particular button's namespace, 
        // so handler doesn't get removed if this particular button is destroyed.
        this.element.closest( "form" )
            .unbind( "reset" + BUTTON_EVENT_NAMESPACE )
            .bind( "reset" + BUTTON_EVENT_NAMESPACE, function() {
                var form = $( this );
                setTimeout(function() {
                    var $buttons = form.find( ":oj-button" ).each(function() {
                        $( this ).data( "oj-ojButton" )._applyCheckedStateFromDom(false);
                    });
                    
                    // if last button in form has been destroyed or moved out, remove the handler
                    if (!$buttons.length)
                        form.unbind( "reset" + BUTTON_EVENT_NAMESPACE );
                }, 1 );
            } );
        
        // Sync up disabled option and disabled DOM property.
        // If app set the option to valid value (true/false), then that wins, else DOM wins (which always has a valid value).
        if ( typeof this.options.disabled !== "boolean" )
        {   // then app either didn't set the option from its initial value of null, or they set it 
            // to invalid value which we'll ignore, so set the option from the DOM.  Just set the ivar without calling _setOption()
            // here, since we call it below.
            // For anchors, this line always sets it to false.  (Neither JQUI nor JET look for the .oj-disabled class for anchors, 
            // so the only way to disable an anchor button at create time is via the API.  At refresh time, JQUI did look 
            // for the .oj-disabled class, but our refresh doesn't handle disabled.)
            this.options.disabled = !!this.element.prop( "disabled" );
        } // else the app definitely set the option to true or false, since default was null, so set app's value 
        // on the DOM.  No need to do that here, since we call _setOption("disabled"...) below, which sets the DOM property.
        
        // facilitate removing menuButton handlers separately, if app clears the "menu" option
        this.menuEventNamespace = this.eventNamespace + "menu";
        
        this._initButtonTypes();
        this.hasTitle = !!this.rootElement.attr( "title" );

        var self = this,
            options = this.options,
            toggleButton = this.type === "checkbox" || this.type === "radio",
            activeClass = !toggleButton ? "oj-active" : "",
            focusClass = "oj-focus";

        this.rootElement.addClass( BASE_CLASSES );
        
        this.buttonElement
            .bind( "mouseenter" + this.eventNamespace, function() {
                if ( options.disabled )
                    return;
                if ( this === _lastActive ) 
                    self.rootElement.addClass( "oj-active" );

                self.rootElement.addClass( "oj-hover" )
                                .removeClass( "oj-default" );
            })
            .bind( "mouseleave" + this.eventNamespace, function() {
                self.rootElement.removeClass( "oj-hover" );

                if ( options.disabled )
                    return;
                self.rootElement.removeClass( activeClass );
                self._addOrRemoveOJDefaultClass();
            })
            .bind( "click" + this.eventNamespace, function( event ) {
                if ( options.disabled )
                {
                    event.preventDefault();
                    event.stopImmediatePropagation();
                }
            });

        this.element
            .attr( "role", "button" )
            .bind( "focus" + this.eventNamespace, function() {
                // no need to check disabled, focus won't be triggered anyway
                self.rootElement.addClass( focusClass )
                                .removeClass( "oj-default" );
            })
            .bind( "blur" + this.eventNamespace, function() {
                self.rootElement.removeClass( focusClass );
                self._addOrRemoveOJDefaultClass();
            });

        if ( toggleButton )
        {
            this.element.bind( "change" + this.eventNamespace, function( event ) {
                self._applyCheckedStateFromDom(true); // we just get one change event for entire radio group, even though up to 2 changed, so must refresh entire radio group, not just this button
                
                // if in a buttonset that tracks checked state (i.e. checkbox set or single 
                // radio group), then set that option and fire optionChange event
                var buttonset = $( this ).closest( ":oj-buttonset" ).data( "oj-ojButtonset" );
                var checkedState = buttonset && buttonset._getCheckedFromDom(buttonset.$buttons);
                if (buttonset && checkedState!==undefined)
                {
                    buttonset._optionChangeOriginalEvent = event;
                    
                    // only sets the option and fires optionChange, since _optionChangeOriginalEvent ivar is set
                    buttonset._setOption("checked", checkedState);
                }
            });
            
            // Required for FF, where click-drag on checkbox/radio btn's label(JET decorates label as button for toggle buttons ) 
            // will not yield in to click event and also trasfers focus out of the <input> element and hence breaks arrow navigation. 
            // To fix, If mouse moves between mouseDown/mouseUp (drag) with in the boundaries of button then focus should be set 
            // on the button which will ensure proper arrow key navigation(see bug 18477039 for more details).
            this.buttonElement
                .bind("mousedown" + this.eventNamespace, function(event) {
                    if (options.disabled)
                        return;
                    _lastToggleActive = this;
                    self.document.one("mouseup", function() {
                        _lastToggleActive = null;
                    });
                })
                .bind("mouseup" + this.eventNamespace, function(event) {
                    if (options.disabled)
                        return;
                    if (this === _lastToggleActive) {
                        self.element.focus();
                    }
                });
        }

        if ( this.type === "checkbox" )
        {
            this.buttonElement.bind( "click" + this.eventNamespace, function(event) {
                if ( options.disabled )
                    return false;
            });
            
            // role="button" requires both Space and Enter support, but radios and checkboxes natively support only Space, so add Enter.
            // This fire-click-on-Enter logic gives Enter the same behavior as Space for checkboxes in Chrome, FF, and IE9:
            // In Chrome28 and IE9, for Space and Enter on Checkboxes, first the "checked" value updates, then change event, then click event.
            // In FF22, for Space and Enter on Checkboxes, first the "checked" value updates, then click event, then change event.
            // Unlike the radio Enter handler, we get this good behavior by only firing "click".
            this.element.bind( "keyup" + this.eventNamespace, function(event) {
                if ( event.keyCode === $.ui.keyCode.ENTER ) {
                    if ( !options.disabled ) {
                        //console.log("checkbox Enter handler firing click event");
                        self.element.click();
                    }
                }
            });
        } else if ( this.type === "radio" )
        {
            this.buttonElement.bind( "click" + this.eventNamespace, function() {
                if ( options.disabled )
                {
                    return false;
                }
            });
            
            // role="button" requires both Space and Enter support, but radios and checkboxes natively support only Space, so add Enter.
            // For radios, this handler gives Enter in Chrome28/ IE9/ FF22 the same behavior as Space on Chrome.  Since Space in IE/FF is 
            // different than Space in Chrome, this means that Enter and Space are not quite the same within those browsers.
            // For Space and Enter on unchecked radios in Chrome28 and IE9:
            //   - first the "Checked" value updates, then change event, then click event.
            // For already-checked radios, where activation would just check it again:
            //   - Space and Enter in Chrome28, and Enter in IE9:  do nothing.
            //   - Space in IE9:  first the "Checked" value updates, then click event.  (No change event since nothing changed.)
            //     (This is the only Chrome/IE9 Space/Enter difference.)
            // In FF22:
            //   - Space on unchecked radios: first the "Checked" value updates, then click event, then change event.
            //   - Enter on unchecked radios is same as Chrome.  (Different event ordering than FF.)
            //   - Space on checked radios is like IE9: first the "Checked" value updates, then click event.  (No change event since nothing changed.)
            //   - Enter on checked radios is same as Chrome.  (Do-nothing.)
            this.element.bind( "keyup" + this.eventNamespace, function(event) {
                if ( event.keyCode === $.ui.keyCode.ENTER )
                {
                    if ( !self.element[0].checked && !options.disabled ) {
                        //console.log("radio Enter handler found radio unchecked, so checking it and firing click event");

                        // Unlike the checkbox Enter handler, we set checked=true and fire changed before firing click, without which 
                        // we didn't get the exact behavior described above.  Without setting checked, the click handlers in all 3 desktop
                        // browsers saw the "old" "checked" value when Enter was pressed on radios, which broke Buttonset's focus mgmt logic.
                        // If we set checked, then change no longer fires automatically, in at least some browsers, so we have to fire it 
                        // manually, both for apps that rely on it, and because our code relies on our change listener to update the "checked" styling.
                        self.element[0].checked = true;
                        self.element.change();
                        self.element.click();
                    }
                }
            });
        } else // neither checkbox nor radio, so not a toggle button, so element, buttonElement, and rootElement are all the same node
        {
            this.buttonElement
                .bind( "mousedown" + this.eventNamespace, function( event ) {
                    if ( options.disabled ) {
                        return false;
                    }
                    if ( event.which === 1 ) // don't show active/pressed-down state unless left mouse button, since only that button will click the button after mouseup
                    { 
                        $( this ).addClass( "oj-active" )
                                 .removeClass( "oj-default" );
                        _lastActive = this;
                        self.document.one( "mouseup", function() {
                            _lastActive = null;
                        });
                    }
                })
                .bind( "mouseup" + this.eventNamespace, function() {
                    if ( options.disabled ) 
                        return false;
                    $( this ).removeClass( "oj-active" );
                    self._addOrRemoveOJDefaultClass();
                })
                .bind( "keydown" + this.eventNamespace, function(event) {
                    if ( options.disabled ) 
                        return false;
                    if ( event.keyCode === $.ui.keyCode.SPACE || event.keyCode === $.ui.keyCode.ENTER ) {
                        $( this ).addClass( "oj-active" )
                                 .removeClass( "oj-default" );
                    }
                })
                // see #8559, we bind to blur here in case the button element loses
                // focus between keydown and keyup, it would be left in an "active" state
                .bind( "keyup" + this.eventNamespace + " blur" + this.eventNamespace, function() {
                    $( this ).removeClass( "oj-active" );
                    self._addOrRemoveOJDefaultClass();
                });

            if ( this.buttonElement.is("a") ) 
            {
                this.buttonElement.bind( "keyup" + this.eventNamespace, function(event) {
                    if ( event.keyCode === $.ui.keyCode.SPACE ) 
                    {
                        // JQUI's TODO: pass through original event correctly (just as 2nd argument doesn't work)
                        $( this ).click();
                    }
                });
            }
        } // end of: if (checkbox) {} else if (radio) {} else {} 
        
        this._setOption( "disabled", options.disabled );
        this._handleLabelAndIconsAtCreateTime();
        this._setupMenuButton();
        
        // call this at the *end* of _create, since it needs to know whether any state classes like oj-active, oj-disabled, oj-selected, oj-hover, .oj-focus 
        // have been applied.
        this._addOrRemoveOJDefaultClass();

        this._super();
    },
   
    _initButtonTypes: function() // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
    { 
        var labelSelector, checked;

        // for toggle buttons (radio/checkbox), element is <input>, buttonElement is <label>,
        // and rootElement is a new wrapper element we create.
        if ( this.element.is("input[type=checkbox]") )
            this.type = "checkbox";
        else if ( this.element.is("input[type=radio]") )
            this.type = "radio";
        
        // for push buttons (next 2 cases), element, buttonElement, and rootElement are all the same elem.  We ignore <label> if present.
        else if ( this.element.is("input[type=button],input[type=submit],input[type=reset]") )
            this.type = "input";
        else if ( this.element.is("button,a"))
            this.type = "button";
        else 
            throw new Error("JET Button not supported on this element type");

        if ( this.type === "checkbox" || this.type === "radio" ) 
        {
            // TBD: rather than requiring the label to be supplied, should we just create one for them if it's not there?
            labelSelector = "label[for='" + this.element.attr("id") + "']";
            this.buttonElement = this.element.siblings().filter( labelSelector ).addClass( "oj-button-label" );
             
            this.element
                .addClass( "oj-helper-hidden-accessible" )
                .add(this.buttonElement) // doesn't mutate this.element
                .wrapAll("<span></span>"); // add root node around label/input

            this.rootElement = this.element.parent(); // the new root
            
            checked = this.element[0].checked;
            if ( checked ) {
                this.rootElement.addClass( "oj-selected" )
                                .removeClass( "oj-default");
            }
            // else no need to removeClass since this code runs only at _create time
            
            // must be set for toggle buttons even if false, since presence of this attr conveys to AT's 
            // whether it's a toggle button or push button.
            this.element.attr( "aria-pressed", checked );
        } else 
        {
            this.buttonElement = this.element;
            this.rootElement = this.element;
        }
    },

    /**
     * Returns a <code class="prettyprint">jQuery</code> object containing the element visually representing the button.  For checkboxes and radios, this is the label, not the input.  
     * 
     * <p>This method does not accept any arguments.
     * 
     * @expose
     * @memberof! oj.ojButton
     * @instance
     * @return {jQuery} the button
     * 
     * @example <caption>Invoke the <code class="prettyprint">widget</code> method:</caption>
     * var widget = $( ".selector" ).ojButton( "widget" );
     */
    widget: function() // Override of public base class method.  Method name needn't be quoted since is in externs.js.
    { 
        return this.rootElement;
    },
    
    _destroy: function() // Override of protected base class method.  Method name needn't be quoted since is in externs.js.
    {
        this._removeMenuBehavior();
        
        // TBD: won't need this after the restore-attrs feature is in place.
        this.element
            .removeClass( "oj-helper-hidden-accessible" )
            .removeAttr( "role" )
            .removeAttr( "aria-pressed" );
        
        var isToggle = this.type === "checkbox" || this.type === "radio";
        
        // TBD: won't need this after the restore-attrs feature is in place.
        if ( !isToggle ) 
            this.rootElement.removeClass( BASE_CLASSES + " " + STATE_CLASSES + " " + TYPE_CLASSES );
        
        this.buttonElement.html( this.buttonElement.find(".oj-button-text").html() );
        
        if ( !isToggle )
        {
            // TBD: won't need this after the restore-attrs feature is in place.
            if ( !this.hasTitle )
                this.rootElement.removeAttr( "title" );
        } else 
        {
            this.buttonElement.removeClass( "oj-button-label" ); // TBD: won't need this after the restore-attrs feature is in place.
            this.element.unwrap(); // remove rootElement
        }

        if( _lastToggleActive === this.buttonElement[0] )
        {
            _lastToggleActive = null; //clear _lastToggleActive flag, while destroying the button.
        }
    },

    _setOption: function( key, value ) // Override of protected base class method.  Method name needn't be quoted since is in externs.js.
    {
        this._super( key, value );
        
        switch (key) 
        {
            case "disabled":
                // _super() applies oj-disabled and aria-disabled to rootElement (see code below), and removes oj-hover/focus/active from associated "-ables"
                value = !!value;
                
                if (!this.element.is("a")) // i.e. <button> or <input> (including type=radio|checkbox|other)
                {
                    // <button> and <input> (including type=radio|checkbox|other) have this property, but <a> doesn't
                    this.element.prop( "disabled", value ); // JQUI sets this for <a>'s too.
                    
                    //Toggle oj-enabled style class based on the disabled flag as it should have either oj-enabled or oj-disbaled not both at any point of time.
                    this.widget().toggleClass( "oj-enabled", !value );
                    
                    // _super() puts aria-disabled on the rootElement.  Per wai-aria, don't put aria-disabled on element already having disabled 
                    // attr.  (And if we DID apply aria-disabled, for radios/checkboxes it should go on the element / input, not the buttonElement / label or rootElement, 
                    // so the _super() behavior used by JQUI button is doubly wrong.)
                    this.rootElement.removeAttr( "aria-disabled" );
                } // else is <a>, so we keep the aria-disabled that _super() put on it.
                  // Unlike radios/checkboxes, _super() puts it on the correct element for <a>'s since element and rootElement are both the <a>.
                
                if (value)
                {
                    // TBD: when the handling of oj-active in baseComponent._setOption("disabled") is finalized, review whether this should be handled there instead.
                    this.widget().removeClass("oj-active oj-default");
                    
                    // when disabling a menu button, dismiss the menu if open
                    this._dismissMenu(null, null, true);
                }
                else
                {
                    this._addOrRemoveOJDefaultClass();
                }

                break;
            case "label":
                this._setLabelOption();
                break;
            case "display":
                if ( this.type !== "input" ) // <input type=button|submit|reset> doesn't support child nodes, thus no icons, icon-only buttons, etc.
                    this._setDisplayOptionOnDom();
                break;
            case "icons":
                this._setIconsOption(true);
                break;
            case "menu": // setting/clearing the menu sets whether this is a menuButton
                if (this.options.icons.end === "auto") // then the end icon is a dropdown arrow iff the new menu value points to a valid menu, so must call...
                    this._setIconsOption(false);
                this._setupMenuButton();
                break;
        }
    },
    
    /**
     * Refreshes the button. JET components require a <code class="prettyprint">refresh()</code> after a supported DOM change is made 
     * that affects the component, of which the component would otherwise be unaware.  
     * 
     * <p>This method calls <code class="prettyprint">baseComponent.refresh()</code>, but doesn't currently do anything Button-specific.
     * Note that anything having a JS API, such as the Button's label, disabled state, and checked state, must be set via the API, not 
     * by mutating the DOM and calling <code class="prettyprint">refresh()</code>.  (For the checked state, see Buttonset's 
     * <code class="prettyprint">checked</code> option.)  
     * 
     * @expose 
     * @memberof! oj.ojButton
     * @instance
     * 
     * @example <caption>Invoke the <code class="prettyprint">refresh</code> method:</caption>
     * $( ".selector" ).ojButton( "refresh" );
     */
    refresh: function() // Override of public base class method (unlike JQUI).  Method name needn't be quoted since is in externs.js.
    {
        this._super();
    },
    
    // If this button is radio/checkbox, then this method gets the checked state from DOM's 
    // "checked" prop and toggles oj-selected and aria-pressed accordingly.
    // If wholeGroup param is true, and this button is a radio, then do that for all buttons in the group.
    _applyCheckedStateFromDom: function(wholeGroup) // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
    {
        if ( this.type === "radio" ) 
        {
            (wholeGroup ? _radioGroup( this.element[0] ) : this.element ).each(function() {
                var $radioWidget = $( this ).data( "oj-ojButton" ); // definitely exists because _radioGroup() checks for :oj-button 
                
                if ( this.checked )
                {
                    $radioWidget.rootElement.addClass( "oj-selected" )
                                            .removeClass( "oj-default" );
                    $radioWidget.element.attr( "aria-pressed", "true" );
                } else 
                {
                    $radioWidget.rootElement.removeClass( "oj-selected" );
                    $radioWidget._addOrRemoveOJDefaultClass();
                    $radioWidget.element.attr( "aria-pressed", "false" );
                }
            });
        } else if ( this.type === "checkbox" ) 
        {
            if ( this.element[0].checked ) 
            {
                this.rootElement.addClass( "oj-selected" )
                                .removeClass( "oj-default" );
                this.element.attr( "aria-pressed", "true" );
            } else 
            {
                this.rootElement.removeClass( "oj-selected" );
                this._addOrRemoveOJDefaultClass();
                this.element.attr( "aria-pressed", "false" );
            }
        }
    },
    
    /* 
     * Method name sums it up.  Should only be called at create time.
     */
    _handleLabelAndIconsAtCreateTime: function() // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
    {
        var keepDom = false;
        if ( this.options.label === null ) {
            keepDom = true;
            this.options.label = (this.type === "input" ? this.buttonElement.val() : this.buttonElement.html());
        }
        
        if ( this.type === "input" ) { // <input type=button|submit|reset> doesn't support child nodes, thus no icons, etc.
            this._setLabelOnDomOfSpanlessButton();
        } else { // <button>, <a>, checkboxes, and radios
            var textSpan = this._setLabelOnDomAtCreateTime(keepDom);
            var hasStartIcon = this._setIconOnDom(true);
            var hasEndIcon = this._setIconOnDom(false);
            this._setDisplayOptionOnDom(textSpan, hasStartIcon, hasEndIcon);
        }
    },
    
    /*
     * Replace the button contents with a span containing the label:
     * - If app didn't set the label option, then reparent their DOM label to the new span.
     * - If app set the label option, then set escaped version onto label span.
     * Either way, button contents are completely replaced with the new span.
     * 
     * Should only be called at create time.
     * 
     * @return the new textSpan
     */
    _setLabelOnDomAtCreateTime: function(keepDom) // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
    {
        var buttonElement = this.buttonElement;
        var textSpan = $( "<span class='oj-button-text'></span>", this.document[0] );
        
        if (keepDom) {
            textSpan.append(buttonElement.contents());
        } else { 
            buttonElement.empty();
            textSpan.text(this.options.label); // performs escaping; e.g. if label is <a>foo</a>, then text() replaces the span's contents with a text node containing that literal string (rather than setting innerHtml).
        }
        
        buttonElement.append(textSpan);
        return textSpan;
    },
    
    /*
     * Following is an old TBD from before the refactoring.  Now that we've sharply reduced the amount of unnecessary DOM replacement when 
     * options like label and icons are set, is this still an issue?  If so, can we further minimize the churn to fix it?
     * TBD: Per http://www.quirksmode.org/blog/archives/2007/01/a_note_about_ev.html, if a click handler blows away the thing that was 
     * clicked, it stops the click event from bubbling any further.  For antonym buttons like Play/Pause where the app puts a click handler
     * on the button that toggles its label and/or icons, this method replaces the clicked element, e.g. a <span> inside the <button>, 
     * stopping the bubble. [UPDATE: we keep the span now but change its contents.  Does that fix it?].  This makes bubbling brittle.  
     * Consider improving and/or doc'ing the issue.
     */
    
    /*
     * This method takes care of everything that needs to happen when the "label" option is set *after* create time.
     */
    _setLabelOption: function() // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
    {
        if ( this.type === "input" ) { // <input type=button|submit|reset> doesn't support child nodes, thus no icons, etc.
            this._setLabelOnDomOfSpanlessButton();
        } else {
            var textSpan = this.buttonElement.find( '.oj-button-text' );
            textSpan.text(this.options.label); // performs escaping; e.g. if label is <a>foo</a>, then text() replaces the span's contents with a text node containing that literal string (rather than setting innerHtml).
            this._setDisplayOptionOnDom(textSpan);
        }
    },
    
    /*
     * This method should only be called when the button is a "spanless" button, i.e. <input type=button|submit|reset>. It is called when the label is set, 
     * both at create time and when it is set later.  
     */
    _setLabelOnDomOfSpanlessButton: function() // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
    {
        // TBD: The "if label" check is from JQUI.  Is there some reason that setting "" should be ignored?
        // Probably not too harmful since they should set "display" option to "icons" instead, or set " " if they really want to.
        if ( this.options.label )
            this.element.val( this.options.label ); // escaping is automatic; e.g. if label is <span>foo</span>, then val() sets that literal string on the input's "value" attr.
    },
    
    /*
     * When the param is true, this method takes care of everything that needs to happen when the "icons" option is set *after* create time.
     * When the param is false, this method takes care of everything that needs to happen when the "menu" option is set *after* create time, when icons.end is already "auto", 
     * which the caller should verify before calling this method.  (When icons.end === "auto", toggling the "is a menuButton" status affects the end icon.)
     */
    _setIconsOption: function(doStart) // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
    {
        if ( this.type === "input" ) // <input type=button|submit|reset> doesn't support child nodes, thus no icons, etc.
            return;
        
        var hasStartIcon;
        if (doStart)
            hasStartIcon = this._setIconOnDom(true);
        
        var hasEndIcon = this._setIconOnDom(false);
        this._setDisplayOptionOnDom(undefined, hasStartIcon, hasEndIcon);
    },
    
    /*
     * This method sets either the start or end icon on the DOM, depending on the param, adding or removing the 
     * icon span as needed.  It is called both at create time and when the icon changes later.
     * 
     * @param isStart boolean, whether is start or end icon
     * @return boolean indicating whether an icon was set on DOM
     */
    _setIconOnDom: function(isStart) // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
    {
        if (isStart) {
            var standardIconClass = 'oj-button-icon-start';
            var appIconClass = this.options.icons.start;
            var lastIvar = "_lastStartIcon";
            var pendTo = "prependTo";
        } else {
            standardIconClass = 'oj-button-icon-end';
            appIconClass = this._getEndIconOption();
            lastIvar = "_lastEndIcon";
            pendTo = "appendTo";
        }
        
        var iconSpan = this.buttonElement.find( "."+standardIconClass );
        
        if ( appIconClass ) {
            if ( iconSpan.length ) {
                // remove the app icon class we set last time
                var oldAppIconClass = this[lastIvar];
                iconSpan.removeClass(oldAppIconClass);
            } else {
                iconSpan = $( "<span></span>" )
                    .addClass( standardIconClass )
                    [pendTo]( this.buttonElement );
            }
            iconSpan.addClass( appIconClass );
        } else {
            iconSpan.remove();
        }
        
        // remember the app icon class we set, so we can remove it next time
        this[lastIvar] = appIconClass;
        
        return !!appIconClass;
    },
    
    /*
     * Gets the actual end icon.  If icons.end is "auto", the answer depends on whether this is a menuButton or not.
     */
    _getEndIconOption: function() // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
    {
        var icons = this.options.icons;
        return (icons.end === "auto") 
               ? (this._getMenu() ? "oj-component-icon oj-button-menu-dropdown-icon" : null)
               : icons.end;
    },
    
    /*
     * Hides / shows the label, and adds / removes the rootElement tooltip, depending on whether 
     * display is "icons" (and whether there are in fact icons).  Doesn't add/remove the 
     * tooltip if app provided one initially.
     * 
     * Sets the corresponding root style class, e.g. "oj-button-text-only" or "oj-button-text-icon-start".
     * 
     * TODO: need to call this *after* setRootAttributes so app has a chance to set their own 
     * tooltip for checkbox/radio.  
     * 
     * Must be called when display, icons, or label options are set.
     * If icons.end is "auto", must be called when menu option is set.
     * 
     * Caller must check that it's not a spanless button before calling this method.
     * 
     * All params optional.
     */
    _setDisplayOptionOnDom: function(textSpan, hasStartIcon, hasEndIcon) // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
    {
        if (textSpan === undefined)
            textSpan = this.buttonElement.find( '.oj-button-text' );
        if (hasStartIcon === undefined)
            hasStartIcon = !!this.options.icons.start;
        if (hasEndIcon === undefined)
            hasEndIcon = !!this._getEndIconOption();
        
        var multipleIcons = hasStartIcon && hasEndIcon;
        var atLeastOneIcon = hasStartIcon || hasEndIcon;
        var displayIsIcons = this.options.display === "icons";
        
        if ( atLeastOneIcon && displayIsIcons )
        {
            textSpan.addClass( "oj-helper-hidden-accessible" );
            
            if ( !this.hasTitle )
            {
                var buttonText = /** @type {string}  tell GCC is getter, not setter, overload of text() */
                                 (textSpan.text());
                this.rootElement.attr( "title", $.trim( buttonText ) ); // use buttonText, which is escaped, not options.label, which isn't!
            }
        } else
        {
            textSpan.removeClass( "oj-helper-hidden-accessible" );
            
            if ( !this.hasTitle )
                this.rootElement.removeAttr( "title" );
        }
        
        var buttonClass = 
            !atLeastOneIcon
                ? "oj-button-text-only"
                : displayIsIcons
                    ? multipleIcons ? "oj-button-icons-only" : "oj-button-icon-only"
                    : multipleIcons 
                        ? "oj-button-text-icons"
                        : hasStartIcon
                            ? "oj-button-text-icon-start" 
                            : "oj-button-text-icon-end";
        
        this.rootElement.removeClass( TYPE_CLASSES )
                        .addClass( buttonClass );
    },
    
    /* 
     * This method adds/removes menuButton stuff from the element, based on the Button's "menu" option.
     */
    _setupMenuButton: function() // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
    {
        this._removeMenuBehavior();
        
        var menu = this._getMenu(); // non-null iff all criteria are met for this to truly be a menuButton
        if ( menu ) 
        {
            var self = this;
            this.element
                .attr("aria-haspopup", true)
                .on( "keydown" + this.menuEventNamespace, function( event ) { 
                    if (event.which === $.ui.keyCode.DOWN ) 
                    {
                        self._showMenu(event, "firstItem", menu);
                        return false;
                    } else if (event.which === $.ui.keyCode.ESCAPE )
                    {
                        self._dismissMenu(event, menu);
                        return false;
                    }

                    return true;
                })
                .on( "click" + this.menuEventNamespace, function( event ) {
                    //console.log("mb click handler");
                    if (!menu.__spaceEnterDownInMenu)
                    {
                        //console.log("mb click handler toggling");
                        self._toggleMenu(event, menu);
                    }
                    menu.__spaceEnterDownInMenu = false;
                    return false;
                });
            menu.widget()
                .on( "oj__dismiss" + this.menuEventNamespace, function( event, ui ) {
                    //console.log(this.options.label + ": mb dismiss handler");
                    self._menuDismissHandler(event);
                })
                .on( "ojbeforeshow" + this.menuEventNamespace, function( event, ui ) {
                    //console.log(this.options.label + ": mb beforeshow handler");
                    // if something else launches the same menu (including the case where it's our own *context* menu),
                    // then the *menuButton* menu is no longer showing, so unpress the button.
                    if (!self._launchingMenu)
                    {
                        //console.log(this.options.label + ": mb beforeshow handler calling dismiss handler");
                        self._menuDismissHandler(event);
                    }
                    self._launchingMenu = false;
                });
        }
    },
    
    /*
     * This method removes menuButton functionality from the element
     */
    _removeMenuBehavior: function() { // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        this.element
            .removeAttr( "aria-haspopup" )
            .off( this.menuEventNamespace );
    },
    
    /* 
     * This Button is a MenuButton iff 1-3 are all true:
     *   (1) the "menu" option is specified
     *   (2) it's well-formed and points to a valid, already inited JET Menu
     *   (3) this is a <button> or <a> (not <input> of any type).
     * This method returns isMenuButton ? menu : null.
     * (Do NOT return null just because button is disabled, since that would mean disabled menuButtons lose their dropdown arrow, and possibly other problems.)
     */
    _getMenu: function() { // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        var menu = this.options.menu;
//        var menuOptionSpecified = !!menu;
        
        if ( menu ) 
            menu = $(menu).data( "oj-ojMenu" ); // if selector finds >1 element, .data() uses the first one.
                                                // if selector finds 0 elements, .data() returns nothing.
        if ( menu && this.element.not("input"))
            return menu;
        
//        if (menuOptionSpecified)
            // TODO: log: menu option specified but was malformed or this is an input
        
        return null;
    },
    
    /* 
     * Shows the menuButton menu if there is one and we're not disabled.
     * 
     * MenuButton types:
     * - We support menuButtons on push buttons based on <button> and <a>.
     *     - Architects require that we support menuButtons on at least some types of push buttons.
     *       I.e. if checkbox-based menuButtons were supported, it would not be OK for that to be the only type that's supported.
     * - <input type=button|submit|reset> work fine using the same code path as <button> and <a>, but architects approved proposal 
     *   not to support them for following reasons:
     *     - submit/reset menubuttons are semantically / behaviorally absurd.
     *     - these types don't support icons, i.e. the dropdown icon.
     *     - reduces exposure to issues like we had for checkboxes, without sacrificing anything since these flavors were undesirable
     *       for menuButton use anyway.
     *  - Radios are inappropriate for menuButtons.  Alternate clicks should open and close the menu, with corresponding visual 
     *    feedback from button, but radios are idempotent: they stay pressed on repeated clicks.
     *  - Architects approved proposal not to support checkboxes for following reasons:  
     *      - Checkbox-based menuButtons were considered a bit odd, and we had zero requirements for it.
     *      - The only thing they buy anyone is the checked state corresponding to the menu-open state, but there are several ways for 
     *        apps to find out if the menu is open, e.g. check its "hidden" status, check whether the oj-selected class is present, etc.
     *      - They proved to be somewhat brittle, with *different* event-ordering problems in each browser.  Even if we spent the time 
     *        to fix it, they could still be a source of problems later, which didn't seem worth it for a flavor no one wanted.
     * 
     * @param event required
     * @param focus required
     * @param menu optional. pass it if already have it
     */
    _showMenu: function(event, focus, menu) // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
    {
        if (this.options.disabled) 
            return;
        if (!menu)
            menu = this._getMenu();
        if (menu) 
        {
            // Per UX requirements, menuButtons should look pressed/checked iff the menu is open:
            // - For push buttons, per architectural review, just add/remove oj-selected even though it's a push button.
            //     - Per a11y review, that's fine, but do NOT apply aria-pressed to push buttons, which would turn it into a toggle button for AT users.  He said that 
            //       would just confuse things, and that the visual pressed-in look was just eye candy in this case, not semantics that we need to show to AT users. 
            // - If checkbox menuButtons were supported, obviously we'd toggle the pressed look by checking/unchecking the button, which in turn would toggle oj-selected.
            //   In that case, we'd fire DOM checked event (right?) and if wrapped in Buttonset, update its checked option and fire optionChange event.
            this.rootElement.addClass( "oj-selected" )
                            .removeClass( "oj-default" );
            
            // No need to fire click event, since not appropriate for DownArrow, and already fired for user click.
            
            this._launchingMenu = true;
            menu.show(event, {"launcher": this.element, "focus": focus});
            this._menuVisible = true;
        }
    },
    
    /* 
     * Dismisses the menuButton menu if there is one, and if either we're not disabled or force is true
     * 
     * @param event optional
     * @param menu optional. pass it if already have it
     * @param: force: if true, will skip the disabled check; useful when dismissing *because* we've become disabled
     */
    _dismissMenu: function(event, menu, force) // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
    {
        if (!force && this.options.disabled) 
            return;
        if (!menu)
            menu = this._getMenu();
        if (menu)
            menu.__dismiss(event); // causes _menuDismissHandler to be called
    },
    
    /*
     * Handles menu dismissals, whether or not we dismissed it ourselves.  
     * See comments on similar code in _showMenu().
     * 
     * Also called by the beforeShow listener we put on the menu, *if* the launch was by something else, 
     * including our own context menu.  So if something steals our menu, we uncheck the button.
     * 
     * @param event must remain optional, since some callers of _dismissMenu have no event
     */
    _menuDismissHandler: function(event) // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
    {
        //console.log(this.options.label + ": button._menuDismissHandler called");
        if ( this.type === "button" ) {
            // then only reason for .oj-selected to be present is if it's an open menu button, 
            // in which case remove the class since the menu is being dismissed
            this.rootElement.removeClass( "oj-selected" );
            this._addOrRemoveOJDefaultClass();
        }
        // else it's not a menu button.  Probably never called in that case, but if it is, there's no need to 
        // clear oj-selected.  If this is a toggle button, doing so w/b harmful.

        
        this._menuVisible = false;
    },
    
    /*
     * Shows or dismisses the menu.
     * 
     * @param event required
     * @param menu optional. pass it if already have it
     */
    _toggleMenu: function(event, menu) // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
    {
        if (this._menuVisible)
        {
            //console.log(this.options.label + ": _toggleMenu dismissing");
            this._dismissMenu(event, menu);
        } else 
        {
            //console.log(this.options.label + ": _toggleMenu showing");
            this._showMenu(event, "none", menu);
        }
    },

    /*
    * Adds the <code class="prettyprint">oj-default</code> marker to the component element if it is not already marked with any one these state markers, else removes oj-default: 
    *  <code class="prettyprint">oj-active, oj-disabled, oj-selected, oj-hover, .oj-focus</code>
    *
    * @private
    */
    _addOrRemoveOJDefaultClass: function()
    {
        if ( ! this.rootElement.is( ".oj-active, .oj-disabled, .oj-selected, .oj-hover, .oj-focus" ))
            this.rootElement.addClass( "oj-default" );
        else
            this.rootElement.removeClass( "oj-default" );
    }
    
    // API doc for inherited methods with no JS in this file:

    /**
     * Removes the button functionality completely. This will return the element back to its pre-init state.
     * 
     * <p>This method does not accept any arguments.
     * 
     * @method
     * @name oj.ojButton#destroy
     * @memberof! oj.ojButton
     * @instance
     * 
     * @example <caption>Invoke the <code class="prettyprint">destroy</code> method:</caption>
     * $( ".selector" ).ojButton( "destroy" );
     */
});

/**
 * @class
 * @name oj.ojButtonset
 * @augments oj.baseComponent
 * 
 * @classdesc
 * <h3 id="buttonsetOverview-section">
 *   JET Buttonset Component
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#buttonsetOverview-section"></a>
 * </h3>
 * 
 * <p>Description: Themeable, WAI-ARIA-compliant visual and semantic grouping container for [JET Buttons]{@link oj.ojButton}.
 * 
 * <p>The JET Buttonset component can be used to group related buttons, such as a group of radios or checkboxes.  Buttonset provides
 * visual and semantic grouping and WAI-ARIA-compliant focus management.
 * 
 * <p>When a Buttonset is created or refreshed, it creates JET Buttons out of all contained DOM elements supported by JET Button 
 * that are not already Buttons, by calling <code class="prettyprint">.ojButton()</code> on them.
 * 
 * <p>A buttonset that contains radios should contain all radios in the radio group.  Checkboxes and radios in the buttonset should specify the 
 * <code class="prettyprint">value</code> attribute, since the <code class="prettyprint">checked</code> option refers to that attribute.
 * 
 * 
 * <h3 id="keyboard-section">
 *   Keyboard interaction and Focus management
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
 * </h3>
 * 
 * <p>JET Buttonset manages its own focus.  It maintains a single tabstop, with arrow-key navigation within the buttonset.  This navigation 
 * skips disabled buttons, wraps around at the end, and adjusts correctly in RTL.
 * 
 * <p> When tabbing back into the buttonset, focus goes to the most recently focused button.  (To address a browser limitation, if that button is an 
 * unchecked radio having a checked groupmate, the latter is focused instead.)
 * 
 * <p>As with any JET Button, buttons in a buttonset are activated with <kbd>Enter</kbd> or <kbd>Spacebar</kbd>.  
 * 
 * <p>The application should not do anything to interfere with the focus management.  E.g. it should not set the <code class="prettyprint">tabindex</code> of the buttons, or 
 * do anything that prevents enabled buttons from being a tabstop.  Also, enabled buttons should remain user-visible, without which arrow-key
 * navigation to the button would cause the focus to seemingly disappear.
 * 
 * <p>The buttonset's focus management should be turned off when placing the buttonset in a [JET Toolbar]{@link oj.ojToolbar}.  See the <code class="prettyprint">focusManagement</code> option.
 * 
 * 
 * <h3 id="a11y-section">
 *   Accessibility
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
 * </h3>
 * 
 * <p>JET Buttonset takes care of focus management, as noted above, and setting <code class="prettyprint">role="group"</code> on the buttonset element.  
 * 
 * <p>In addition, as shown in the online demos, the application is responsible for applying <code class="prettyprint">aria-label</code> and/or 
 * <code class="prettyprint">aria-controls</code> attributes like the following to the buttonset element, if applicable per the instructions that follow:
 * 
 * <pre class="prettyprint">
 * <code>aria-label="Choose only one beverage.  Use left and right arrow keys to navigate."
 * aria-controls="myTextEditor"
 * </code></pre>
 * 
 * <p>A sentence like the first is appropriate for a buttonset consisting of a radio group, in order to convey the "select one" semantics 
 * to AT users.  It should be omitted for checkboxes and push buttons.
 * 
 * <p>The second sentence lets the user know how to navigate.  It should be omitted if the buttonset's focus management is turned off via 
 * the <code class="prettyprint">focusManagement</code> option.
 * 
 * <p>The <code class="prettyprint">aria-controls</code> attribute is appropriate if the buttonset is controlling something else on the page, e.g. 
 * bold/italic/underline buttons controlling a rich text editor.  
 * 
 * 
 * <h3 id="rtl-section">
 *   Reading direction
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#rtl-section"></a>
 * </h3>
 * 
 * <p>As with any JET component, in the unusual case that the directionality (LTR or RTL) changes post-init, the buttonset must be <code class="prettyprint">refresh()</code>ed.  
 * 
 * 
 * <h3 id="pseudos-section">
 *   Pseudo-selectors
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#pseudos-section"></a>
 * </h3>
 * 
 * <p>The <code class="prettyprint">:oj-buttonset</code> pseudo-selector can be used in jQuery expressions to select JET Buttonsets.  For example:
 * 
 * <pre class="prettyprint">
 * <code>$( ":oj-buttonset" ) // selects all JET Buttonsets on the page
 * $myEventTarget.closest( ":oj-buttonset" ) // selects the closest ancestor that is a JET Buttonset
 * </code></pre>
 * 
 * 
 * <h3 id="binding-section">
 *   Declarative Binding
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#binding-section"></a>
 * </h3>
 * 
 * <p>For components like Buttonset and Menu that contain a number of like items, applications may wish to use a <code class="prettyprint">foreach</code> Knockout binding 
 * to stamp out the contents.  This binding cannot live on the same node as the JET <code class="prettyprint">ojComponent</code> binding, and must instead live on a nested 
 * virtual element as follows:
 * 
 * <pre class="prettyprint">
 * <code>&lt;div id="drinkset" data-bind="ojComponent: {component: 'ojButtonset', checked: drink}"
 *      aria-label="Choose only one beverage.  Use left and right arrow keys to navigate.">
 *     &lt;!-- ko foreach: drinkRadios -->
 *         &lt;label data-bind="attr: {for: id}, text: label">&lt;/label>
 *         &lt;input type="radio" name="beverage"
 *                data-bind="value: id, attr: {id: id}"/>
 *     &lt;!-- /ko -->
 * &lt;/div>
 * </code></pre>
 * 
 * 
 * <h3 id="jqui2jet-section">
 *   JET for jQuery UI developers
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#jqui2jet-section"></a>
 * </h3>
 * 
 * <ol>
 *   <li>All JQUI and JET components inherit <code class="prettyprint">disable()</code> and <code class="prettyprint">enable()</code> methods from the base class.  This API 
 *       duplicates the functionality of the <code class="prettyprint">disabled</code> option.  In JET, to keep the API as lean as possible, we 
 *       have chosen not to document these methods outside of this section.</li>
 *   <li>JQUI Buttonset has an undocumented <code class="prettyprint">items</code> option allowing apps to get and set the selector used by Buttonset to find all its 
 *       buttonizable descendants.  This option has been removed in JET, as we do not want this to be settable.</li>
 *   <li>The focus management functionality is new in JET.</li>
 * </ol>
 * 
 * <p>Also, event names for all JET components are prefixed with "oj", instead of component-specific prefixes like "buttonset" or "menu".  
 * E.g. the JQUI <code class="prettyprint">buttonsetcreate</code> event is <code class="prettyprint">ojcreate</code> in JET, as shown in the doc for that event.
 * Reason:  This makes the API more powerful.  It allows apps to listen to "foo" events from <em>all</em> JET components via:
 * 
 * <pre class="prettyprint">
 * <code>$( ".selector" ).on( "ojfoo", myFunc);
 * </code></pre>
 * 
 * or to "foo" events only from JET Buttonsets (the JQUI functionality) via:
 * 
 * <pre class="prettyprint">
 * <code>$( ".selector" ).on( "ojfoo", ":oj-buttonset", myFunc);
 * </code></pre>
 * 
 * 
 * <!-- - - - - Above this point, the tags are for the class.
 *              Below this point, the tags are for the constructor (initializer). - - - - - - -->
 * 
 * 
 * @desc Creates a JET Buttonset.  If called after the buttonset is already created, is equivalent to the 
 * "set many options" overload of <code class="prettyprint">option()</code>.  
 * 
 * @param {Object=} options a map of option-value pairs to set on the component
 * 
 * @example <caption>Initialize the buttonset with no options specified:</caption>
 * $( ".selector" ).ojButtonset();
 * 
 * @example <caption>Initialize the buttonset with some options and callbacks specified:</caption>
 * $( ".selector" ).ojButtonset( { "disabled": true, "create": function( event, ui ) {} } );
 * 
 * @example <caption>Initialize the buttonset via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;div id="beverages" data-bind="ojComponent: { component: 'ojButtonset', 
 *                                               disabled: true, 
 *                                               create: setupButtonset }">
 */
oj.__registerWidget("oj.ojButtonset", $['oj']['baseComponent'], 
{
    version: "1.0.0", // TODO: doesn't get renamed even when unquoted and not in (our) externs.js file, so I'm leaving it for now.  Is it used anywhere, e.g. build tool?  If so, should prob quote or extern or something.  If not, should it get moved to @version (if that exists) or similar, or just remove, or...?
    
    // private.  Was an undocumented JQUI option, which we removed, so I moved from options to here and added underscore.  Leave unquoted so gets renamed by GCC as desired.
    _items: "button, input[type=button], input[type=submit], input[type=reset], input[type=checkbox], input[type=radio], a",
    
    widgetEventPrefix : "oj", 

    options: // options is in externs.js.  TODO: same as other prototype fields.
    {
        /**
         * The <code class="prettyprint">checked</code> option indicates which radio or checkboxes in the Buttonset are selected.
         * It corresponds to the <code class="prettyprint">value</code> attribute of those elements, which should always be set.
         * 
         * <p>If this Buttonset consists of a single radio group, and no other buttons, then <code class="prettyprint">checked</code> 
         * is a string equal to the <code class="prettyprint">value</code> attribute of the checked radio.  The option is 
         * <code class="prettyprint">null</code> if and only if no radio is selected.  Thus, an n-radio group has n+1 valid 
         * <code class="prettyprint">checked</code> values: the n radio values, and <code class="prettyprint">null</code> .
         * 
         * <p>If this Buttonset consists of one or more checkboxes, and no other buttons, then <code class="prettyprint">checked</code> is 
         * a possibly empty, non-<code class="prettyprint">null</code> string array containing the <code class="prettyprint">value</code> 
         * attributes of the checked checkboxes.  This array has "set", not "list", semantics; i.e. order is neither important nor guaranteed.
         * Thus, an n-checkbox set has 2^n valid <code class="prettyprint">checked</code> values: the 2^n possible subsets of n checkboxes.
         * 
         * <p>In all other cases, <code class="prettyprint">checked</code> is <code class="prettyprint">null</code>.
         * 
         * <p>After create time, the <code class="prettyprint">checked</code> state should be set via this API, not by setting the underlying DOM attribute.
         * 
         * <p>The 2-way <code class="prettyprint">checked</code> binding offered by the <code class="prettyprint">ojComponent</code> binding 
         * should be used instead of Knockout's built-in <code class="prettyprint">checked</code> binding,
         * as the former sets the API, while the latter sets the underlying DOM attribute.
         * 
         * <p>An <code class="prettyprint">optionChange</code> event is fired whenever this option changes, whether due to user interaction 
         * or programmatic intervention.  If the value is the same as the previous value (using order-independent "set" equality for 
         * checkboxes), no event will be fired.
         * 
         * <p>Often there is no need to listen for this event, since the <code class="prettyprint">ojComponent</code> 
         * <code class="prettyprint">checked</code> binding, discussed above, will update the bound 
         * observable whenever the <code class="prettyprint">checked</code> state changes.  
         * 
         * @expose
         * @memberof! oj.ojButtonset
         * @instance
         * @type {?string|Array.<string>|undefined}
         * @default If not initially set, is initialized to reflect the initial DOM state
         * 
         * @example <caption>Initialize a buttonset with the <code class="prettyprint">checked</code> option specified:</caption>
         * // radio
         * $( ".selector" ).ojButtonset( { "checked": "tea" } );
         * 
         * // checkbox
         * $( ".selector" ).ojButtonset( { "checked": ["bold", "italic"] } );
         * 
         * @example <caption>Get or set the <code class="prettyprint">checked</code> option, after initialization:</caption>
         * // getter
         * var display = $( ".selector" ).ojButtonset( "option", "checked" );
         * 
         * // radio setter
         * $( ".selector" ).ojButtonset( "option", "checked", "tea" );
         * 
         * // checkbox setter
         * $( ".selector" ).ojButtonset( "option", "checked", ["bold", "italic"] );
         */
        checked: undefined, // initial value that's different from any valid values like null, so _create() can tell whether app set it.
                            // At Create time will definitely be replaced with valid value.
        
        /**
         * If the <code class="prettyprint">disabled</code> option is set to <code class="prettyprint">true</code> at create time, then 
         * all its buttons will be disabled.  If it is <code class="prettyprint">false</code> at create time, then each button's 
         * <code class="prettyprint">disabled</code> status will be set from the button's API and DOM in the same way 
         * as a standalone JET Button.
         * 
         * <p>Setting the <code class="prettyprint">disabled</code> option after creation will enable or disable all contained buttons.  Enabling or 
         * disabling the individual buttons will not update the value of Buttonset's <code class="prettyprint">disabled</code> option.
         * 
         * @member
         * @name disabled
         * @memberof! oj.ojButtonset
         * @instance
         * @type {boolean}
         * @default <code class="prettyprint">false</code>
         * 
         * @example <caption>Initialize the buttonset with the <code class="prettyprint">disabled</code> option specified:</caption>
         * $( ".selector" ).ojButtonset( { "disabled": true } );
         * 
         * @example <caption>Get or set the <code class="prettyprint">disabled</code> option, after initialization:</caption>
         * // getter (does not reflect changes made directly to the buttons)
         * var disabled = $( ".selector" ).ojButtonset( "option", "disabled" );
         * 
         * // setter
         * $( ".selector" ).ojButtonset( "option", "disabled", true );
         */
        // disabled option declared in superclass, but we still want the above API doc

        /**
         * The <code class="prettyprint">focusManagement</code> option should be set to <code class="prettyprint">"none"</code> when the 
         * Buttonset is placed in a [JET Toolbar]{@link oj.ojToolbar}.  This allows the Toolbar to manage the focus with no interference from the Buttonset, 
         * so that arrow keys move within the entire Toolbar, not just within the Buttonset.  
         * 
         * @expose
         * @memberof! oj.ojButtonset
         * @instance
         * @type {string}
         * @ojvalue {string} "oneTabstop" Focus management is enabled.  The Buttonset is a single tabstop with arrow-key navigation.
         * @ojvalue {string} "none" Focus management is disabled, to avoid interfering with the focus management of a containing component.
         * @default <code class="prettyprint">"oneTabstop"</code>
         * 
         * @example <caption>Initialize the buttonset with the <code class="prettyprint">focusManagement</code> option specified:</caption>
         * $( ".selector" ).ojButtonset( { "focusManagement": "none" } );
         * 
         * @example <caption>Get or set the <code class="prettyprint">focusManagement</code> option, after initialization:</caption>
         * // getter
         * var display = $( ".selector" ).ojButtonset( "option", "focusManagement" );
         * 
         * // setter
         * $( ".selector" ).ojButtonset( "option", "focusManagement", "none" );
         */
        focusManagement: "oneTabstop",
        
        // Events
        
        /**
         * Fired whenever a supported component option changes, whether due to user interaction or programmatic 
         * intervention.  If the new value is the same as the previous value, no event will be fired.
         * 
         * <p>Currently there is one supported option, <code class="prettyprint">checked</code>.  Additional 
         * options may be supported in the future, so listeners should verify which option is changing 
         * before taking any action.
         * 
         * <p>Often there is no need to listen for this event, since the 2-way <code class="prettyprint">checked</code> 
         * binding offered by the <code class="prettyprint">ojComponent</code> binding will update the bound 
         * observable whenever the <code class="prettyprint">checked</code> state changes.
         * 
         * @expose 
         * @event 
         * @memberof! oj.ojButtonset
         * @instance
         * @property {Event} event <code class="prettyprint">jQuery</code> event object
         * @property {Object} ui Parameters
         * @property {string} ui.option the name of the option that is changing
         * @property {?string|Array.<string>} ui.previousValue the previous value of the option.
         *     <code class="prettyprint">null</code> iff the previous value was <code class="prettyprint">null</code>.
         * @property {?string|Array.<string>} ui.value the current value of the option.
         *     <code class="prettyprint">null</code> iff the current value is <code class="prettyprint">null</code>.
         * @property {Object} ui.optionMetadata information about the option that is changing
         * @property {string} ui.optionMetadata.writeback <code class="prettyprint">"shouldWrite"</code> or 
         *           <code class="prettyprint">"shouldNotWrite"</code>.  For use by the JET writeback mechanism.
         * 
         * @example <caption>Initialize the buttonset with the <code class="prettyprint">optionChange</code> callback specified:</caption>
         * $( ".selector" ).ojButtonset({
         *     "optionChange": function( event, ui ) {}
         * });
         *
         * @example <caption>Bind an event listener to the <code class="prettyprint">ojoptionchange</code> event:</caption>
         * $( ".selector" ).on( "ojoptionchange", function( event, ui ) {} );
         */
        optionChange: null
        
        /**
         * Triggered when the buttonset is created.
         *
         * @event 
         * @name create
         * @memberof! oj.ojButtonset
         * @instance
         * @property {Event} event <code class="prettyprint">jQuery</code> event object
         * @property {Object} ui Empty object included for consistency with other events
         * 
         * @example <caption>Initialize the buttonset with the <code class="prettyprint">create</code> callback specified:</caption>
         * $( ".selector" ).ojButtonset({
         *     "create": function( event, ui ) {}
         * });
         * 
         * @example <caption>Bind an event listener to the <code class="prettyprint">ojcreate</code> event:</caption>
         * $( ".selector" ).on( "ojcreate", function( event, ui ) {} );
         */
        // create event declared in superclass, but we still want the above API doc
    },
    
    // If this is a radio or checkbox buttonset, and the specified checked value is valid, 
    //   then sets it on the buttons' checked properties in the DOM, and returns true,
    // Else it's an invalid value, or it's the non-radio, non-checkbox case and null was passed, which is valid for that case, 
    //   then returns false without changing DOM.
    // Does not set oj-selected or aria-pressed, so must call _applyCheckedStateFromDom() after this.  
    //   TBD: optionally, this method could do that work, perhaps controlled by a param
    // This method is called by _setOption("checked", ...) and _create > _setup.  
    // Does NOT require the buttons to already be JET Buttons (useful for _setup caller).
    _setCheckedOnDom: function(checked, $buttons) // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
    {
        var type = $.type(checked);
        var valid;
        
        // If caller passes null there are 3 cases: (the radio branch handles null in all cases)
        // - This is a radio group, for which null means "no radio checked".  The radio branch will uncheck all radios
        //   and return true indicating that it was a valid value so it updated the DOM.
        // - This is a checkbox set, for which null is an invalid value.  The radio branch will correctly do nothing and return false.  
        // - Neither radio nor checkbox case, for which null is the one and only valid value.  The radio branch will do nothing 
        //   (correct; there's nothing to set on the DOM) and return false.  The only caller than calls in this case is the 
        //   _create > _setup caller, for which either return value is OK, since it can either keep the null value or call 
        //   _getCheckedFromDom which will return null.  _setOption doesn't call this method in this 3rd case.  
        if (type === "string" || type === "null") // radio
        {
            // before setting *any* buttons, verify that *all* buttons are radios in same group, and that the checked 
            // value to be set is null or matches one of the radio values
            var name = $buttons[0].name;
            valid = (name || $buttons.length<=1) // if name is "" and there's >1 radio, then they're in separate radio groups
                && $buttons.filter("input[type=radio][name=" + name + "]").length === $buttons.length 
                && (checked===null || $buttons.filter("[value=" + checked + "]").length);
            
            if ( valid )
            {
                $buttons.each(function() {
                    this.checked = (this.value === checked);
                });
            }
            
            return valid;
        } else if (type === "array") // checkbox
        {
            // before setting any buttons, verify that the checked value to be set is valid:
            
            // verify that all buttons are checkboxes, since is array
            valid = $buttons.filter("input[type=checkbox]").length === $buttons.length;
            
            // in a sorted copy of the array (concat makes a copy), verify no dupes and 
            // that all entries are values in the buttonset
            var last;
            valid = valid && checked.concat().sort().every(function(elem, index, array) {
                var retVal = elem !== last && $buttons.filter("[value=" + elem + "]").length;
                last = elem;
                return retVal;
            });
            
            if (valid)
            {
                $buttons.each(function() {
                    this.checked = (checked.indexOf(this.value) > -1);
                });
            }
            return valid;
        } else 
        {
            // didn't set on DOM b/c value was invalid (not the right type for *any* kind of buttonset)
            return false; 
        }
    },
    
    // if all buttons are radios with same group, returns value attr of selected radio (string), or null if none selected
    // else if all buttons are checkboxes, returns non-null, possibly empty string array containing values of selected checkboxes
    // else returns undefined.  In the API we use null, not undefined, for this case, so callers should map undefined to null before setting on DOM. 
    _getCheckedFromDom: function($buttons) // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
    {
        var checked = undefined;
        var isRadio = null;
        var name = null;
        
        $buttons.each(function(index) {
            // at this point, all previous buttons, if any, were all radios in same group, or were all checkboxes
            var tagName = this.tagName.toLowerCase();
            if (tagName !== "input")
            {
                checked = undefined;
                return false; // stop iterating
            }
            
            var currentType = this.type.toLowerCase();
            var currentIsRadio;
            var currentName;
            
            if (currentType === "radio"){
                currentIsRadio = true;
                currentName = this.name.toLowerCase();
            } else if (currentType === "checkbox")
            {
                currentIsRadio = false;
                currentName = null;
            } else 
            {
                checked = undefined;
                return false; // stop iterating
            }
            
            // at this point, current button is input of type radio or checkbox
            
            // If this is not the first button, then bail if:
            // - this is a radio and previous were checkboxes or vice versa
            // - this is a radio in a different group than previous ones, which can happen 
            //   if the group names are different, or if the names are all "", in which 
            //   case each radio is in a separate radio group.
            if ( (checked !== undefined) // must be !== not != 
                 && ( currentIsRadio !== isRadio 
                      || currentName !== name
                      || (isRadio && !name) ) )
            { 
                checked = undefined;
                return false; // stop iterating
            }
            
            // at this point, all buttons so far including this one are either all radios in same group, or are all checkboxes
            
            if (checked === undefined) // this is first button
            {
                checked = currentIsRadio 
                    ? this.checked ? this.value : null
                    : this.checked ? [this.value] : [];
                isRadio = currentIsRadio;
                name = currentName;
            } else if (this.checked)
            {
                if (isRadio) 
                    checked = this.value;
                else
                    checked.push(this.value);
            } // else not first button and not checked, so leave "checked" at whatever value we set on previous iteration
        });
        
        return checked;
    },
    
    // are 2 checked option values equal?
    _checkedEquals: function(checked1, checked2) // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
    {
        // handle null, string, and (rare) identically equal arrays
        if (checked1 === checked2)
            return true;
        else // handle arrays.  order needn't be same
            return $.type(checked1) === "array" && $.type(checked2) === "array" 
                   && !$(checked1).not(checked2).length && !$(checked2).not(checked1).length;
        
    },
    
    _create: function() // Override of protected base class method.  Method name needn't be quoted since is in externs.js.
    {
        this.element
            .addClass( "oj-buttonset oj-component" )
            .attr( "role", "group" );
        
        // call _setup from _create, not _init, so create listeners (called after _create before _init) see a fully inited component.
        // We don't implement _init at all, since it's intended to perform startup behaviors like autoOpen, 
        // not initing state or performing a refresh, and we have no such startup behaviors.
        this._setup(true);
        
        this._super(); // TODO: call this at beginning of method.  This will happen as part of the JET create-time refactoring.
    },

    /* 
     * Component developers: This API and functionality is subject to change pending architectural review!
     * See the baseComponent method for preliminary API doc.
     */
    _showContextMenu: function(menu, event)
    {
      // TODO: currently CM not supported when focusManagement off, because there's not necessarily a tabbable thing in the buttonset if 
      // focus is somewhere else in the toolbar.  Need to put focus on (say) body in that case.  New focus() solution should address this sort of thing.
      menu.show(event, {"launcher": this.element.find(":oj-button[tabindex=0]"), "focus": "menu"});
    },

    _setOption: function( key, value ) // Override of protected base class method.  Method name needn't be quoted since is in externs.js.
    {
        var bail = false;
        
        // if Button is calling this method due to user interaction checking a button, this is set; else it's not.
        var optionChangeOriginalEvent = this._optionChangeOriginalEvent;
        this._optionChangeOriginalEvent = null;
        
        if ( key === "disabled" )
            this.$buttons.ojButton( "option", key, value );
        
        // if app called option, but not if called because user clicked button.  In latter case we know we 
        // passed a valid non-undefined value, and DOM is already up to date.
        if ( key === "checked" && !optionChangeOriginalEvent) 
        {
            if (value === null && this._getCheckedFromDom(this.$buttons) === undefined)
            {
                // _getCheckedFromDom() returns undefined iff buttonset is neither a single radio group nor a checkbox set.
                // In this case, when they pass null (the only valid value), there's nothing to set on DOM, 
                // but let_super() call and event firing logic run since it's a valid value.  The event almost always 
                // won't fire since the old value would have been null too, but if it was a different value the event 
                // will fire as it should.  The only way that could happen is if this buttonset was previously a checkbox set 
                // or single radio group, but now is not (e.g. incompatible button added), and buttonset hasn't been refreshed since then.
            } else 
            {
                var successful = this._setCheckedOnDom(value, this.$buttons);
                if (successful) 
                {
                    // Set oj-selected/aria-pressed on all buttons' DOM:
                    this.$buttons.each(function() {
                        $( this ).data( "oj-ojButton" )._applyCheckedStateFromDom(false);
                    });
                    // Let _super() call and event firing happen.
                } else 
                { // invalid value
                    // Don't set anything on DOM.
                    bail = true; // don't fire event or call _super()
                    // TODO: Maybe log.
                }
            }
        }
        
        if (!bail)
        {
            var previousValue = this.options[key];
            this._super( key, value );
            // TBD: optionally could reference some metadata somewhere rather than hard-coding list of supported options and their equals methods here,
            //      e.g. static buttonsetOptionChangeMap = { "checked" : {equals: checkedEquals} }
            if ( key === "checked" ) // the only supported optionChange option
                this._fireOptionChange(key, previousValue, value, this._checkedEquals, optionChangeOriginalEvent); 
        }
    },
    
    // TBD: this method could be pushed up to superclass if desired.
    _fireOptionChange: function(key, previousValue, value, equals, originalEvent) // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
    {
        if (!equals.call(this, previousValue, value))
        {
            var ui = { 
                "option": key,
                "previousValue": previousValue, 
                "value": value,
                // (originalEvent is non-null) iff (option change is due to user interaction) iff (binding should write back the value)
                "optionMetadata": {"writeback": originalEvent ? "shouldWrite" : "shouldNotWrite"}
            };
            this._trigger( "optionChange", originalEvent, ui );
        }
    },
    
    /**
     * Refreshes the buttonset, including the following:
     * 
     * <ul>
     *   <li>Creates JET Buttons out of all contained DOM elements supported by JET Button that are not already Buttons, by calling <code class="prettyprint">.ojButton()</code> on them.
     *   <li>Re-applies focus management / keyboard navigation.
     *   <li>Applies special styles to the first and last button of the buttonset (e.g. for rounded corners, depending on theming).
     *   <li>Rechecks the reading direction (LTR vs. RTL).
     * </ul>
     * 
     * <p>A <code class="prettyprint">refresh()</code> is required in the following circumstances:
     * <ul>
     *   <li>After buttons are added to or removed from the buttonset.</li>
     *   <li>After a change to the <code class="prettyprint">disabled</code> status of any of the buttons in the buttonset.</li>
     *   <li>After the reading direction (LTR vs. RTL) changes.</li>
     * </ul>
     * 
     * <p>This method does not accept any arguments.
     * 
     * @expose 
     * @memberof! oj.ojButtonset
     * @instance
     * 
     * @example <caption>Invoke the <code class="prettyprint">refresh</code> method:</caption>
     * $( ".selector" ).ojButtonset( "refresh" );
     */
    refresh: function() // Override of public base class method (unlike JQUI).  Method name needn't be quoted since is in externs.js.
    {
        this._super();
        this._setup(false);
    },
    
    _setup: function(isCreate) // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
    {
        var self = this;
        this.isRtl = this._GetReadingDirection() === "rtl";
        
        // remove empty text nodes that are generated if there's any whitespace between the tags in the HTML.
        // The inline-block display means that these text nodes display as a space between the buttons.
        // TBD: this seems to be the most efficient way to do this in JQ; maybe use JS.
        this.element.find(":not(iframe)").andSelf().contents().filter(function() {
            return this.nodeType === 3 && this.nodeValue.trim() === "";
        }).remove();
        
        this.$buttons = this.element.find( this._items );
        
        if (isCreate) 
        {
            // At create time, if app provided a valid "checked" option, it wins over whatever's in the DOM.
            var successful = this._setCheckedOnDom(this.options.checked, this.$buttons);
            // Successful or not, don't call _setOption(), since don't want to fire optionChange event at create time
            // (The JQUI framework does NOT call _setOption at create time.)  Refresh happens below.
            if (!successful) // option value wasn't valid
            {
                var newChecked = this._getCheckedFromDom(this.$buttons);
                this.options.checked = newChecked === undefined ? null : newChecked;
            }
        } else 
        {
            // There are 2 ways the DOM and checked option could be out of synch at refresh time:
            // 1. An existing JET Button, that was already in this Buttonset, may have had its HTML checked prop 
            //    set directly by the app, which we don't support.  The Buttonset API should have been called instead.
            // 2. The set of contained buttons may have changed (where the current buttons may or may not have already 
            //    been buttonized).  The type of set (checkboxes, radios, or other) may even have changed.
            // #2 is the sort of thing that refresh() is for: a DOM change for which there is no API, so the right thing 
            // for the app to do is to change the DOM and call refresh()).
            // Even though we don't wish to support #1 (DOM change that should have been done via the API), we have 
            // to support #2.  It would be too much trouble to write our support for #2 in such a way as to make sure 
            // that #1 doesn't work.
            // In any case, refresh() should refresh the API from the DOM, not refresh the DOM from the API.
            // Don't call _setOption() here, since it does redundant work.  (_applyCheckedStateFromDom() is already 
            // called below.)  So set ivar and fire event directly.  We decided to fire optionChange event even in this 
            // case, when refresh() notices that the checked state changed underneath us.  
            var newChecked = this._getCheckedFromDom(this.$buttons);
            newChecked = (newChecked === undefined) ? null : newChecked;
            var oldChecked = this.options.checked;
        
            this.options.checked = newChecked;
            var shouldFire = true; // fire event at end, not in the middle
        }
        
        // Create or not, successful set or not, checked option and checked props are now in synch, so we just need to 
        // set .oj-selected and aria-pressed on each button.  This is done below by either the _applyCheckedStateFromDom()
        // call (for existing buttons) or the initializer call (for new buttons).
        
        this.$buttons
            // refresh any buttons underneath us that already exist, like JQUI does
            // TBD:  Now that Bset has a checked option, the recursive refreshing of the Bset's buttons is necessary in more cases than before.  
            //   Review whether it's still desirable to add a refresh() param that would allow turning off this recursive
            //   refreshing.  That was previously approved, but changing the default (compared to JQUI) was not approved.
            //   The refresh param wouldn't help for creates; for that we'd need to add a Buttonset option.  
            //   See also _destroy() code comment.
            .filter( ":oj-button" )
                .ojButton( "refresh" )
                .each(function() {
                    $( this ).data( "oj-ojButton" )._applyCheckedStateFromDom(false); // set .oj-selected and aria-pressed
                })
            .end()
            
            // Create buttons underneath us
            .not( ":oj-button" )
                .ojButton() // sets .oj-selected and aria-pressed
            .end()
        
            // Update rounded corners
            .map(function() {
                return $( this ).ojButton( "widget" )[ 0 ];
            })
                .removeClass( "oj-buttonset-corner-start oj-buttonset-corner-end" )
                .filter( ":first" )
                    .addClass( "oj-buttonset-corner-start" )
                .end()
                .filter( ":last" )
                    .addClass( "oj-buttonset-corner-end" )
                .end()
            .end()
            
        // See disabled option's jsdoc for description of how disabled is handled at create and refresh time.
        // Must do this after creating the buttons above since at create time, a true value for Bset.disabled should win over the DOM and Button API.
        // Must do this before the focus mgmt code, which needs to know which buttons are disabled.
        if (isCreate && this.options.disabled)
            this.$buttons.ojButton("option", "disabled", true);
        
        if (this.options.focusManagement==="oneTabstop")
        {
            // When buttonset is binding listeners to buttons, use the Buttonset's eventNamespace, not the Button's 
            // eventNamespace, to facilitate later unbinding only the Buttonset listeners.
        
            // For checkbox/radio, we're binding to inputs, not labels.
            
            // Put listeners on every button, b/c it's too unreliable to put them on the buttonset node and rely on event bubbling.
            // - E.g. bubbling doesn't work for antonym buttons (is this still true after the refactoring?) -- see comment on Button._setLabelOption().
            // - Likewise, focus mgmt can't just break if app listener stops propagation.
            // - Both of these problems still happen when using the delegation / selector overload of .on(); there is no special JQ bubbling magic.
            
            this.$buttons
                .unbind( "keydown" + this.eventNamespace )
                .bind( "keydown" + this.eventNamespace, function(event) { 
                    self._handleKeyDown(event, $(this)); 
                })

                .unbind( "click" + this.eventNamespace )
                .bind( "click" + this.eventNamespace, function(event) {
                    if ( !$(this).ojButton("option", "disabled") ) 
                    { 
                        // Normally the button will be tabbable after the click, since (a) if we reach here, the clicked button is enabled, and 
                        // (b) an unchecked radio before the click will normally be checked after the click.  But just in case it's unchecked 
                        // (e.g. due to app listener), we let callee run it thru _mapToTabbable() before using, as usual.
                        self._setTabStop( $(this) );
                    }
                })
                .unbind( "focus" + this.eventNamespace )
                .bind( "focus" + this.eventNamespace, function(event) { 
                    self._setTabStop( $(this) );
                });
        
            // the subset of Buttonset buttons that are enabled.  Disabled buttons are not tabbable.
            this.$enabledButtons = this.$buttons.filter(function(index) {
                return !$( this ).ojButton( "option", "disabled" );
            });

            this._initTabindexes(isCreate);
        }
        
        if (shouldFire)
            this._fireOptionChange("checked", oldChecked, newChecked, this._checkedEquals, null); 
    },
    
    // For create, make only the first enabled button tabbable.  (We decided to have Shift-Tab go to first, not last, button.)
    // For refreshes, keep the existing tabstop if we can, otherwise proceed as with create.
    // Either way, if that button is a radio and some radio in its group is checked, make that one tabbable instead.
    // If there are no enabled buttons, makes them all untabbable.
    // No return value.
    _initTabindexes: function(isCreate) // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
    {
        // even for refreshes where we'll wind up keeping the same tabstop, must make everything untabbable first, to ensure any new buttons become untabbable.
        var $last = $(this._lastTabStop);
        this._lastTabStop = undefined;
        this.$buttons.attr( "tabindex", "-1" );
        var $newTabStop; // callee might map this to radio groupmate
        
        // TBD: for refreshes when $last is a disabled radio with a checked enabled groupmate and they are in the buttonset, the groupmate would be 
        // a valid tabstop, but this defaults to the first.
        if (isCreate || !$last.is(this.$enabledButtons)) 
        {
            // is create, or is refresh but must treat like create b/c $last is empty, or not enabled, or no longer in the buttonset
            $newTabStop = this.$enabledButtons.first(); // if empty (none enabled), no tabstop will be set
        } else 
        {
            // is a refresh, and $last is non-empty and is an enabled button still in the buttonset.  May be a radio whose groupmate
            // has become checked, in which case callee will map it to that groupmate.
            $newTabStop = $last;
        }
        this._setTabStop( $newTabStop );
    },
    
    // For each button in $button (in our usage always 0-1 button hence $button singular), if that button is an unchecked radio 
    // with a checked groupmate (which means it's not tabbable), then map it to the checked one (checked enabled radios are 
    // tabbable, and we know it's enabled per the argument below).
    // 
    // $button contains 0 or more buttons to map.  Must be enabled since disabled buttons aren't tabbable.
    // Returns the mapped JQ object (which the caller will make the tabstop).
    // 
    // We know that this.$enabledButtons contains all buttons in $button, and all of their potentially checked radio-groupmates, since:
    // - The above "enabled" requirement guarantees that $button's contents are all in $enabledButtons.
    // - The prohibition against radio groupmates that are not in the buttonset, and the prohibition against checked disabled groupmates 
    //   of enabled radios, guarantee that if $button is a radio, then all of its potentially checked groupmates are enabled and thus in 
    //   $enabledButtons.
    // 
    // Firefox browser issue:   (TODO: should we doc this?  File FF and/or JET bug?)
    // 
    // When this method maps an unchecked radio to its checked groupmate, the caller ensures that the former still has focus, but the latter
    // is the tabstop for when the user tabs out and back in.  When tabbing / Shift-Tabbing from the unchecked radio in the direction of the 
    // checked one, Chrome and IE9 are smart enough to tab out of the radio group to the adjacent tabstop as desired.  But in FF, focus goes to 
    // the checked one, which is not what we want.
    // 
    // Reason: Chrome and IE9 are smart enough never to tab within a radio group.  If focus is in the radio group, Tab and Shift-Tab exit the radio group.
    // But in FF, [a radio is reachable via Tab/Shift-Tab from within the group] if [it's enabled, tabindex != -1, and either checked or has no 
    // checked groupmates], i.e. [it would be reachable via Tab/Shift-Tab from outside the group if all its groupmates happened to be untabbable 
    // (e.g. disabled)].  In other words, FF is the only one that fails to distinguish between radios that could be valid tabstops from outside, and
    // those that should be valid tabstops from inside.  
    // 
    // This impl improves on the native behavior.  In FF, in an unchecked radio group, every single radio is a tabstop.  Our use of tabindex=-1 
    // guarantees that we never tab within the group in that case.  It's only a checked groupmate that can be tabbed to from within. (So at 
    // most one unwanted tabstop.)
    // 
    // After much time and effort, the latter issue seems to be infeasible to fix in any robust, non-brittle way.  E.g.:
    // - Clearing all tabstops and restoring on tab-out of buttonset:  FF provides no reliable way to find out whether a blur is exiting the entire 
    //   buttonset.  The obvious setTimeout workaround needed to be unacceptably long (e.g. 250ms) and even then was unreliable.  If we ever fail 
    //   to restore the tabstop, the buttonset becomes untabbable and inaccessible.
    // - Every other approach had similar robustness issues. 
    _mapToTabbable: function( $button ) // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
    {
        var $enabledButtons = this.$enabledButtons;
        return $button.map(function(index, elem) {
            // Buttons other than radios, and checked radios, are always tabbable if they're enabled, which this method requires.
            // Radios w/ name="" (incl name omitted) are not in a radio group, not even with other radios with w/ name="".  Radios 
            // with no groupmates are always tabbable, since either they're checked, or they're unchecked with no checked groupmate.
            if (elem.type != "radio" || elem.checked || elem.name == "")
                return elem;
            else 
            {
                // elem is unchecked radio in real (not "") group, which is tabbable iff no groupmate is checked.  Per above doc, we know that 
                // all of its potentially checked groupmates are in $enabledButtons.
                var $checkedRadio = _radioGroup(elem, $enabledButtons).filter(":checked");
                return ($checkedRadio.length ? $checkedRadio[0] : elem);
            }
        });
    },
    
    // Set which button is in the tab sequence.
    // $button should contain 0 or 1 button to be made tabbable (since at most one should be tabbable at a time).
    //   If 0 (i.e. no enabled buttons), all will become untabbable.  If 1, it must be tabbable in every way (e.g. enabled) except possibly 
    //   being an unchecked radio with a checked groupmate, which this method will map to its checked groupmate, which 
    //   we know is enabled thus tabbable since we require that checked radios with enabled groupmates not be disabled.  
    // No return value.
    _setTabStop: function( $button ) // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
    {
//        if (!window.setTabStopCounter) window.setTabStopCounter=1; // REMOVE, is only for console.log's
//        console.log("in _setTabStop: " + window.setTabStopCounter++ + ".  Orig (premap) button checked: " + $button[0].checked); // + " and is:");
//        console.log($button[0]);
        
        $button = this._mapToTabbable( $button );
        var button = $button[0]; // button is undefined iff $button is empty iff we need to clear all tabstops b/c there are no enabled buttons to make tabbable
        var last = this._lastTabStop; // last is undefined iff $(last) is empty iff there are no existing tabstops to clear (b/c _initTabindexes just ran 
                                      // or previously there were no enabled buttons to make tabbable)
        
//        console.log("mapped button and last button are:");  console.log(button);  console.log(last);  console.log(".");
        
        // Cases: both are undefined: have no tabstops; want to keep it that way (b/c none enabled), so do nothing
        //        both are node X: X is the tabstop; want to keep it that way, so do nothing
        //        last is node X; button is undefined: X is the tabstop; want to clear it w/o replacing it (b/c none enabled).  This logic does that.
        //        last is undefined; button is node X: no existing tabstop; want to make X the tabstop.  This logic does that.
        //        last is node X; button is node Y: X is the tabstop; want to clear it and make Y the tabstop.  This logic does that.
        if ( button !== last) {
            //console.log("setting tab stop to " + $button.attr("id"));  console.log("$(last).length:");  console.log($(last).length);
            
            $(last).attr( "tabindex", "-1" ); // no-op iff $(last) is empty iff (see comment above)
            $button.attr( "tabindex", "0" ); // no-op iff $button is empty iff (see comment above)
            this._lastTabStop = button;
        }
    },
    
    // No return value.
    _handleKeyDown: function(event, $button) // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
    {
        switch (event.which) {
            case $.ui.keyCode.LEFT:  // left arrow
            case $.ui.keyCode.RIGHT: // right arrow
                event.preventDefault();
                
                var $enabledButtons = this.$enabledButtons;
                var length = $enabledButtons.length;
                if (length<2) // nowhere to navigate to; currently focused button is the only enabled one in buttonset
                    break;
                
                var oldIndex = $enabledButtons.index($button);
                var increment = ((event.which == $.ui.keyCode.RIGHT) ^ this.isRtl) ? 1 : -1;
                var newIndex = (oldIndex+increment+length)%length; // wrap around if at start/end of buttonset
                
                // A11y office recommended treating radios like other buttons: Arrow moves focus without selecting, Spacebar selects, 
                // which we prefer too.  Since we're using role='button', not 'radio', we don't need to follow the WAI-ARIA radio behavior 
                // where Arrow moves focus and selects, Ctrl-Arrow moves focus without selecting.  
                $enabledButtons.eq(newIndex).focus();
                break;
            case $.ui.keyCode.UP:   // up arrow
            case $.ui.keyCode.DOWN: // down arrow
                // Per above comment, treating radios like buttons, which have no native or WAI-ARIA-mandated up/down arrow behavior, 
                // so disable native focus-and-select behavior.  
                if ( $button.attr("type")=="radio" )
                    event.preventDefault();
                break;
            
            // Don't need Space/Enter handlers.  For all buttons except already-checked radios in some browsers, Space/Enter fire a click event 
            // (natively or manually), which already calls _setTabStop.  For checked radios (which are focused if they're getting 
            // this key event), _setTabStop has already been called for whichever happened 2nd:  focus (an already checked radio) or
            // check (an already focused radio) via click/Space/Enter.  We don't support programmatically checking the button; it must 
            // be done via the "checked" option.
        }
    },
    
    _destroy: function() // Override of protected base class method.  Method name needn't be quoted since is in externs.js.
    {
        this.element
            .removeClass( "oj-buttonset oj-component" )
            .removeAttr( "role" );
        
        if (this.options.focusManagement==="oneTabstop") 
            this.$buttons.attr( "tabindex", "0" );
        
        this.$buttons
            .map(function() {
                return $( this ).ojButton( "widget" )[ 0 ];
            })
                // do .removeClass outside the filter in case button has been destroyed but still has these Buttonset styles on it.
                // TBD: if this has definitely been taken care of already for destroyed buttons, then move inside filter.
                .removeClass( "oj-buttonset-corner-start oj-buttonset-corner-end" )
            .end()
    
            // Recursively destroy Bset's buttons like JQUI.  
            // TBD: The recursive destroy makes it impossible to ungroup the buttons if desired, i.e. destroy the Buttonset without destroying its buttons.
            //   As discussed in _setup() code comment, it was approved to add refresh() and/or destroy() params that would allow turning off
            //   the recursive behavior, but changing the default (compared to JQUI) was not approved.
            //   When not destroying the buttons, must instead restore the buttons to a not-in-buttonset state, i.e. remove Bset stuff, restore any 
            //   Button stuff we removed, etc.
            .ojButton( "destroy" );
    }
    
    // API doc for inherited methods with no JS in this file:

    /**
     * Returns a <code class="prettyprint">jQuery</code> object containing the buttonset element.  
     * 
     * <p>This method does not accept any arguments.
     * 
     * @method
     * @name oj.ojButtonset#widget
     * @memberof! oj.ojButtonset
     * @instance
     * @return {jQuery} the buttonset element
     * 
     * @example <caption>Invoke the <code class="prettyprint">widget</code> method:</caption>
     * var widget = $( ".selector" ).ojButtonset( "widget" );
     */

    /**
     * Removes the buttonset functionality completely, including focus management, and recursively <code class="prettyprint">destroy()</code>s 
     * the contained buttons. This will return the element back to its pre-init state.
     * 
     * <p>This method does not accept any arguments.
     * 
     * @method
     * @name oj.ojButtonset#destroy
     * @memberof! oj.ojButtonset
     * @instance
     * 
     * @example <caption>Invoke the <code class="prettyprint">destroy</code> method:</caption>
     * $( ".selector" ).ojButtonset( "destroy" );
     */
});

// -----------------------------------------------------------------------------
// "private static members" shared by all buttons and buttonsets
// -----------------------------------------------------------------------------

var _lastActive, _lastToggleActive ,
    
    // "static" namespace for events associated with all buttons on page/form/etc., not just one.  E.g. see form reset handler at top of _create().
    // this.eventNamespace, used for individual button instances, is .ojButtonX, whereX = 0, 1, 2, etc.
    BUTTON_EVENT_NAMESPACE = ".ojButton",
    
    BASE_CLASSES = "oj-button oj-component oj-enabled oj-default", // oj-enabled is a state class, but convenient to include in this var instead
    STATE_CLASSES = "oj-hover oj-active oj-selected", // TBD: oj-hover doesn't really need to be listed here since this var is only used to remove classes from rootElement at destroy time, which already happens because we register rootElement as a hoverable.  Same might apply to oj-active if we switch to an activeable paradigm.
    TYPE_CLASSES = "oj-button-icons-only oj-button-icon-only oj-button-text-icons oj-button-text-icon-start oj-button-text-icon-end oj-button-text-only",
    
    /**
     * In all cases, the return value includes only radios that are an :oj-button, i.e. radios that have been buttonized.
     * 
     * Where this method looks for radio groupmates:
     *
     * - If $elems is present (even if empty), 
     *     - This method will only look in that set, and will not attempt to weed out any false positives as defined below. 
     *       (So in this case, return value includes the specified radio iff it's an :oj-button in $elems.)
     * - Else this method looks in exactly the places where groupmates (including the original radio) would live, i.e. not in 
     *   the places false positives would live.  (So in both of the following cases, return value includes the specified radio 
     *   iff it's an :oj-button.)  Specifically:
     *     - If radio is in a form, this method will only look in that form.
     *     - Else, this method will look in the radio's document, but not in any forms.
     * 
     * Radios w/ name="" (incl name omitted) are not in a radio group (i.e. no SelectOne semantics), not even with other radios with 
     * w/ name="".  So if radio is nameless, the return value will include only radio (or nothing at all if it isn't an :oj-button, or 
     * if $elems is passed and it doesn't include radio).  
     * 
     * False positives: radios with nonempty names that match radio's name, but are actually not groupmates (i.e. no SelectOne 
     * relationship), e.g. because they're from a different form.
     * 
     * 
     * @param {!Element} radio  a radio button.  Not a JQ object, other button or element type, or null.
     * @param {jQuery=} $elems  optional JQ object, containing 0 or more elems that aren't necessarily radios or buttons, in which to look for groupmates.
     *                          E.g. the elements in a buttonset or toolbar.  Must not contain any false positives as defined above.
     */
    _radioGroup = function( radio, $elems )
    {
        var name = radio.name,
            form = radio.form,
            $radios;
        if ( name ) 
        {
            name = name.replace( /'/g, "\\'" ); // escape single quotes
            var selector = ":radio[name='" + name + "']:oj-button";
            if ( $elems ) 
            {
                $radios = $elems.filter( selector );
            } else if ( form ) 
            {
                $radios = $( form ).find( selector );
            } else 
            {
                $radios = $( selector, radio.ownerDocument )
                    .filter(function() {
                        return !this.form;
                    });
            }
        } else 
        {
            $radios = ($elems ? $elems.filter( radio ) : $( radio )).filter(":oj-button");
        }
        return $radios;
    };

}() ); // end of Button / Buttonset wrapper function

// TODO: how should copyright notice and header change in our fork?  See related Q's / TODO's in ojButton.js.
/*!
 * jQuery UI Menu @VERSION
 * http://jqueryui.com
 *
 * Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/menu/
 *
 * Depends:
 *  jquery.ui.core.js
 *  jquery.ui.widget.js
 *  jquery.ui.position.js
 */
(function() {

/**
 * @class 
 * @name oj.ojMenu
 * @augments oj.baseComponent
 * 
 * @classdesc
 * <h3 id="menuOverview-section">
 *   JET Menu Component
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#menuOverview-section"></a>
 * </h3>
 * 
 * <p>Description: Themeable, WAI-ARIA-compliant menu with mouse and keyboard interactions for navigation.
 * 
 * <p>A JET Menu can be created from any valid markup as long as the elements have a strict parent/child relationship 
 * and each menu item has an anchor. The most commonly used element is the unordered list ( <code class="prettyprint">&lt;ul></code> ):
 * 
 * <pre class="prettyprint">
 * <code>&lt;ul id="menu">
 *   &lt;li>&lt;a href="#">Item 1&lt;/a>&lt;/li>
 *   &lt;li>&lt;a href="#">Item 2&lt;/a>&lt;/li>
 *   &lt;li>&lt;a href="#">Item 3&lt;/a>
 *     &lt;ul>
 *       &lt;li>&lt;a href="#">Item 3-1&lt;/a>&lt;/li>
 *       &lt;li>&lt;a href="#">Item 3-2&lt;/a>&lt;/li>
 *       &lt;li>&lt;a href="#">Item 3-3&lt;/a>&lt;/li>
 *       &lt;li>&lt;a href="#">Item 3-4&lt;/a>&lt;/li>
 *       &lt;li>&lt;a href="#">Item 3-5&lt;/a>&lt;/li>
 *     &lt;/ul>
 *   &lt;/li>
 *   &lt;li>&lt;a href="#">Item 4&lt;/a>&lt;/li>
 *   &lt;li>&lt;a href="#">Item 5&lt;/a>&lt;/li>
 * &lt;/ul>
 * </code></pre>
 * 
 * <p>If you use a structure other than <code class="prettyprint">&lt;ul></code>/<code class="prettyprint">&lt;li></code>, including using the same element for the menu and the menu items, use the 
 * <code class="prettyprint">menuSelector</code> option to specify a way to differentiate the two elements, e.g., <code class="prettyprint">menuSelector: "div.menuElement"</code>.
 * 
 * <p>Any menu item can be disabled by adding the <code class="prettyprint">oj-disabled</code> class to that element.  As with any DOM change, doing so post-init 
 * requires a <code class="prettyprint">refresh()</code> of the component.  
 * 
 * 
 * <h3 id="icons-section">
 *   Icons
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#icons-section"></a>
 * </h3>
 * 
 * <p>The submenu icon can be customized via theming.
 * 
 * <p>To add other icons to menu items, include them in the markup:  
 * <!-- TODO: if they're required to include oj-menu-item-icon, should probably call that out.  Is that our rqmt?  Likewise, should we mention the class name they use to set the submenu icon? -->
 * 
 * <pre class="prettyprint">
 * <code>&lt;ul id="menu">
 *   &lt;li id="foo">&lt;a href="#">&lt;span class="oj-menu-item-icon demo-icon-font demo-palette-icon">&lt;/span>Foo&lt;/a>&lt;/li>
 * &lt;/ul>
 * </code></pre>
 * 
 * 
 * <h3 id="dividers-section">
 *   Dividers
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#dividers-section"></a>
 * </h3>
 * 
 * <p>Divider elements can be created by including unlinked menu items that contain only spaces and/or dashes, or nothing at all:  
 * 
 * <pre class="prettyprint">
 * <code>&lt;ul id="menu">
 *   &lt;li>&lt;a href="#">Item 1&lt;/a>&lt;/li>
 *   &lt;li>---&lt;/li>
 *   &lt;li>&lt;a href="#">Item 2&lt;/a>&lt;/li>
 * &lt;/ul>
 * </code></pre>
 * 
 * <p>For WAI-ARIA compliance, JET automatically adds <code class="prettyprint">role="separator"</code> to the divider element.
 * 
 * 
 * <h3 id="keyboard-section">
 *   Keyboard interaction
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
 * </h3>
 * 
 * <table class="keyboard-table">
 *   <thead>
 *     <tr>
 *       <th>Key</th>
 *       <th>Use</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td><kbd>Enter</kbd> or <kbd>Space</kbd></td>
 *       <td>Invoke the focused menu item's action, which may be opening a submenu.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>UpArrow</kbd></td>
 *       <td> Move focus to the previous menu item, wrapping around at the top.</tr>
 *     <tr>
 *       <td><kbd>DownArrow</kbd></td>
 *       <td> Move focus to the next menu item, wrapping around at the bottom.</tr>
 *     <tr>
 *       <td><kbd>RightArrow</kbd> (<kbd>LeftArrow</kbd> in RTL)</td>
 *       <td> Open the submenu, if available.</tr>
 *     <tr>
 *       <td><kbd>LeftArrow</kbd> (<kbd>RightArrow</kbd> in RTL)</td>
 *       <td> Close the current submenu and move focus to the parent menu item. If not in a submenu, do nothing.</tr>
 *     <tr>
 *       <td><kbd>Esc</kbd></td>
 *       <td> Close the current submenu and move focus to the parent menu item. If not in a submenu, do nothing.</tr>
 *     <tr>
 *       <td><kbd>Home</kbd></td>
 *       <td> Move focus to the first menu item.</tr>
 *     <tr>
 *       <td><kbd>End</kbd></td>
 *       <td> Move focus to the last menu item.</tr>
 * </tbody></table>
 * 
 * <p>Typing a letter moves focus to the first item whose title starts with that character. Repeating the same character cycles through matching items. 
 * Typing more characters within the one second timer matches those characters.  
 * 
 * <p>Note that the "Search for text when I start typing" feature in Firefox can interfere with web content that accepts keystrokes, such as this "type a letter" feature of JET Menu.  
 * 
 * <p>Disabled items can receive keyboard focus, but do not allow any other interaction.
 * 
 * 
 * <h3 id="rtl-section">
 *   Reading direction
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#rtl-section"></a>
 * </h3>
 * 
 * <p>As with any JET component, in the unusual case that the directionality (LTR or RTL) changes post-init, the menu must be <code class="prettyprint">refresh()</code>ed.  
 * 
 * 
 * <h3 id="pseudos-section">
 *   Pseudo-selectors
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#pseudos-section"></a>
 * </h3>
 * 
 * <p>The <code class="prettyprint">:oj-menu</code> pseudo-selector can be used in jQuery expressions to select JET Menus.  For example:
 * 
 * <pre class="prettyprint">
 * <code>$( ":oj-menu" ) // selects all JET Menus on the page
 * $myEventTarget.closest( ":oj-menu" ) // selects the closest ancestor that is a JET Menu
 * </code></pre>
 * 
 * 
 * <h3 id="binding-section">
 *   Declarative Binding
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#binding-section"></a>
 * </h3>
 * 
 * <p>For components like Menu and Buttonset that contain a number of like items, applications may wish to use a <code class="prettyprint">foreach</code> Knockout binding
 * to stamp out the contents.  This binding cannot live on the same node as the JET <code class="prettyprint">ojComponent</code> binding, and must instead live on a nested 
 * virtual element as follows:
 * 
 * <pre class="prettyprint">
 * <code>&lt;ul id="menu" data-bind="ojComponent: {component: 'ojMenu'}">
 *     &lt;!-- ko foreach: menuItems -->
 *         &lt;li data-bind="attr: {id: id}, css: {'oj-disabled': disabled}">
 *             &lt;a href="#" data-bind="text: label">&lt;/a>
 *         &lt;/li>
 *     &lt;!-- /ko -->
 * &lt;/ul>
 * </code></pre>
 * 
 * 
 * <h3 id="jqui2jet-section">
 *   JET for jQuery UI developers
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#jqui2jet-section"></a>
 * </h3>
 * 
 * <ol>
 *   <li>All JQUI and JET components inherit <code class="prettyprint">disable()</code> and <code class="prettyprint">enable()</code> methods from the base class.  This API 
 *       duplicates the functionality of the <code class="prettyprint">disabled</code> option.  In JET, to keep the API as lean as possible, we 
 *       have chosen not to document these methods outside of this section.</li>
 *   <li>JQUI Menu has <code class="prettyprint">menus</code> and <code class="prettyprint">position</code> options.  For clarity, these options have been renamed to 
 *       <code class="prettyprint">menuSelector</code> and <code class="prettyprint">submenuPosition</code> in JET Menu.</li>
 *   <li>JQUI Menu has a <code class="prettyprint">role</code> option, which defaults to <code class="prettyprint">"menu"</code>.  This option was removed in JET Menu.  Reason: 
 *       JET Menu is a menu component; thus we feel that the only appropriate WAI-ARIA role for our component is <code class="prettyprint">"menu"</code>.</li>
 *   <li>JQUI Menu has <code class="prettyprint">isFirstItem()</code> and <code class="prettyprint">isLastItem()</code> methods, which were removed in JET Menu.  Reason:  To 
 *       keep the API lean, we prefer to avoid methods with such specific functionality.</li>
 *   <li>JQUI Menu has <code class="prettyprint">nextPage()</code> and <code class="prettyprint">previousPage()</code> methods, which were removed in JET Menu.  Reason:  
 *       In JET we wish to promote best design practices.  Menus with scrollbars are considered undesirable UX.</li>
 *   <li>JET Menu swaps the functionality of the left and right arrow keys in RTL.</li>
 *   <li>JET Menu creates WAI-ARIA compliant separator elements, by applying <code class="prettyprint">role="separator"</code> to them.</li>
 * </ol>
 * 
 * <p>Also, event names for all JET components are prefixed with "oj", instead of component-specific prefixes like "menu" or "button".  
 * E.g. the JQUI <code class="prettyprint">menucreate</code> event is <code class="prettyprint">ojcreate</code> in JET, as shown in the doc for that event.
 * Reason:  This makes the API more powerful.  It allows apps to listen to "foo" events from <em>all</em> JET components via:
 * 
 * <pre class="prettyprint">
 * <code>$( ".selector" ).on( "ojfoo", myFunc);
 * </code></pre>
 * 
 * or to "foo" events only from JET Menus (the JQUI functionality) via:
 * 
 * <pre class="prettyprint">
 * <code>$( ".selector" ).on( "ojfoo", ":oj-menu", myFunc);
 * </code></pre>
 * 
 * 
 * <!-- - - - - Above this point, the tags are for the class.
 *              Below this point, the tags are for the constructor (initializer). - - - - - - -->
 * 
 * 
 * @desc Creates a JET Menu.  If called after the menu is already created, it is equivalent to the 
 * "set many options" overload of <code class="prettyprint">option()</code>.  
 * 
 * @param {Object=} options a map of option-value pairs to set on the component
 * 
 * @example <caption>Initialize the menu with no options specified:</caption>
 * $( ".selector" ).ojMenu();
 * 
 * @example <caption>Initialize the menu with some options and callbacks specified:</caption>
 * $( ".selector" ).ojMenu( { "disabled": true, "create": function( event, ui ) {} } );
 * 
 * @example <caption>Initialize the menu via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;ul id="menu" data-bind="ojComponent: { component: 'ojMenu', 
 *                                         disabled: true, 
 *                                         select: menuItemSelect }">
 */
oj.__registerWidget("oj.ojMenu", $['oj']['baseComponent'], {
    version: "1.0.0", // doesn't get renamed even when unquoted and not in (our) externs.js file, so I'm leaving it unquoted for now.  TODO: Is it used anywhere, e.g. build tool?  If so, should prob quote or extern or something.  If not, should it get moved to @version (if that exists) or similar, or just remove, or...?
    defaultElement: "<ul>", // added to externs.js, since this is an override of a superclass member.  (That's the rule for public methods, what about protected fields?)  TODO: Would @override do the job and be better than externing?
    delay: 300, // like version, doesn't get renamed even when unquoted and not in (our) externs.js file, so I'm leaving it unquoted for now.  Unlike version, I assume this is completely private, but do NOT rename to _delay since there's an inherited instance method by that name.
    role: "menu", // private.  I moved from options to here since no longer public option.  Leave unquoted so gets renamed by GCC as desired.
    widgetEventPrefix : "oj",
    _MENU_CLICK_AWAY_HANDLER_KEY:"ojMenuClickAwayHandler", 
    options: { // options is in externs.js, so no need for quotes
        /**
         * Disables the menu if set to <code class="prettyprint">true</code>.
         * 
         * @member
         * @name disabled
         * @memberof! oj.ojMenu
         * @instance
         * @type {boolean}
         * @default <code class="prettyprint">false</code>
         * 
         * @example <caption>Initialize the menu with the <code class="prettyprint">disabled</code> option specified:</caption>
         * $( ".selector" ).ojMenu( { "disabled": true } );
         * 
         * @example <caption>Get or set the <code class="prettyprint">disabled</code> option, after initialization:</caption>
         * // getter
         * var disabled = $( ".selector" ).ojMenu( "option", "disabled" );
         * 
         * // setter
         * $( ".selector" ).ojMenu( "option", "disabled", true );
         */
        // disabled option declared in superclass, but we still want the above API doc
        
        /**
         * Identifies the position of this menu when launched via the <code class="prettyprint">show()</code> method or via menu button or 
         * context menu functionality.
         * 
         * <p>By default, the menu is positioned relative to the launching event if that event is a right-click mouse event, and the launcher 
         * element otherwise.  Both of those items are passed to the <code class="prettyprint">show()</code> method.  This behavior is 
         * appropriate for context menus and menu buttons.  If a value is set on the <code class="prettyprint">of</code> field, then the menu 
         * is positioned relative to that element or position instead.  
         * 
         * <p>Please refer to the jQuery UI [Position]{@link http://api.jqueryui.com/position/} utility for more details about the various choices.
         * 
         * <p>See also <code class="prettyprint">show()</code> for more details.
         * 
         * @expose 
         * @memberof! oj.ojMenu
         * @instance
         * @type {Object}
         * @default <code class="prettyprint">{ "my": "left top", "at": "left bottom" }</code>
         * 
         * @example <caption>Initialize the menu with the <code class="prettyprint">menuPosition</code> option specified:</caption>
         * $( ".selector" ).ojMenu({ menuPosition: { "my": "left top", "at": "right-5 top+5" } });
         * 
         * @example <caption>Get or set the <code class="prettyprint">menuPosition</code> option, after initialization:</caption>
         * // getter
         * var position = $( ".selector" ).ojMenu( "option", "menuPosition" );
         *  
         * // setter
         * $( ".selector" ).ojMenu( "option", "menuPosition", { "my": "left top", "at": "right-5 top+5" } );
         */
        menuPosition: {
            /** @expose */
            my: "left top",
            /** @expose */
            at: "left bottom"
        },

        /**
         * Selector for the elements that serve as the menu container, including submenus.
         * 
         * <p>Note: The <code class="prettyprint">menuSelector</code> option should not be changed after initialization. Existing submenus will not be updated.
         * 
         * @expose 
         * @memberof! oj.ojMenu
         * @instance
         * @type {string}
         * @default <code class="prettyprint">"ul"</code>
         * 
         * @example <caption>Initialize the menu with the <code class="prettyprint">menuSelector</code> option specified:</caption>
         * $( ".selector" ).ojMenu({ menuSelector: "div" });
         * 
         * @example <caption>Get the <code class="prettyprint">menuSelector</code> option, after initialization:</caption>
         * // getter
         * var menuSelector = $( ".selector" ).ojMenu( "option", "menuSelector" );
         */
        menuSelector: "ul",
        
        /**
         * Identifies the position of submenus.  By default, the submenu is positioned relative to the parent menu item, but if a value is set on 
         * the <code class="prettyprint">of</code> field, then the submenu is positioned relative to that element or position instead.  
         * 
         * <p>Please refer to the jQuery UI [Position]{@link http://api.jqueryui.com/position/} utility for more details about the various choices.
         * 
         * @expose 
         * @memberof! oj.ojMenu
         * @instance
         * @type {Object}
         * @default <code class="prettyprint">{ "my": "left top", "at": "right top" }</code>
         * 
         * @example <caption>Initialize the menu with the <code class="prettyprint">submenuPosition</code> option specified:</caption>
         * $( ".selector" ).ojMenu({ submenuPosition: { "my": "left top", "at": "right-5 top+5" } });
         * 
         * @example <caption>Get or set the <code class="prettyprint">submenuPosition</code> option, after initialization:</caption>
         * // getter
         * var position = $( ".selector" ).ojMenu( "option", "submenuPosition" );
         *  
         * // setter
         * $( ".selector" ).ojMenu( "option", "submenuPosition", { "my": "left top", "at": "right-5 top+5" } );
         */
        submenuPosition: {
            /** @expose */
            my: "left top",
            /** @expose */
            at: "right top"
        },

        // Events
        
        /**
         * Triggered before this menu is launched via the <code class="prettyprint">show()</code> method or via menu button or context menu functionality.
         * The launch can be cancelled by calling <code class="prettyprint">event.preventDefault()</code>.
         *
         * @expose 
         * @event 
         * @memberof! oj.ojMenu
         * @instance
         * @property {Event} event <code class="prettyprint">jQuery</code> event object
         * @property {Object} ui Parameters
         * @property {jQuery} ui.launcher the launcher element that was passed to the <code class="prettyprint">show()</code> method.
         * 
         * @example <caption>Initialize the menu with the <code class="prettyprint">beforeShow</code> callback specified:</caption>
         * $( ".selector" ).ojMenu({
         *     "beforeShow": function( event, ui ) {}
         * });
         *
         * @example <caption>Bind an event listener to the <code class="prettyprint">ojbeforeshow</code> event:</caption>
         * $( ".selector" ).on( "ojbeforeshow", function( event, ui ) {} );
         */
        beforeShow: null,
        
        /**
         * Triggered when a menu item loses focus.
         *
         * @expose 
         * @event 
         * @memberof! oj.ojMenu
         * @instance
         * @property {Event} event <code class="prettyprint">jQuery</code> event object
         * @property {Object} ui Parameters
         * @property {jQuery} ui.item the currently active menu item
         * 
         * @example <caption>Initialize the menu with the <code class="prettyprint">blur</code> callback specified:</caption>
         * $( ".selector" ).ojMenu({
         *     "blur": function( event, ui ) {}
         * });
         *
         * @example <caption>Bind an event listener to the <code class="prettyprint">ojblur</code> event:</caption>
         * $( ".selector" ).on( "ojblur", function( event, ui ) {} );
         */
        blur: null,
        
        /**
         * Triggered when the menu is created.
         *
         * @event 
         * @name create
         * @memberof! oj.ojMenu
         * @instance
         * @property {Event} event <code class="prettyprint">jQuery</code> event object
         * @property {Object} ui Empty object included for consistency with other events
         * 
         * @example <caption>Initialize the menu with the <code class="prettyprint">create</code> callback specified:</caption>
         * $( ".selector" ).ojMenu({
         *     "create": function( event, ui ) {}
         * });
         * 
         * @example <caption>Bind an event listener to the <code class="prettyprint">ojcreate</code> event:</caption>
         * $( ".selector" ).on( "ojcreate", function( event, ui ) {} );
         */
        // create event declared in superclass, but we still want the above API doc
        
        /**
         * Triggered when a menu gains focus or a menu item becomes active.
         *
         * @expose 
         * @event 
         * @memberof! oj.ojMenu
         * @instance
         * @property {Event} event <code class="prettyprint">jQuery</code> event object
         * @property {Object} ui Parameters
         * @property {jQuery} ui.item the currently active menu item
         * 
         * @example <caption>Initialize the menu with the <code class="prettyprint">focus</code> callback specified:</caption>
         * $( ".selector" ).ojMenu({
         *     "focus": function( event, ui ) {}
         * });
         *
         * @example <caption>Bind an event listener to the <code class="prettyprint">ojfocus</code> event:</caption>
         * $( ".selector" ).on( "ojfocus", function( event, ui ) {} );
         */
        focus: null,
        
        /**
         * Triggered when a menu item is selected.  Applications should listen for this event, not the 
         * <code class="prettyprint">click</code> event, to detect when a menu item has been selected. 
         *
         * @expose 
         * @event 
         * @memberof! oj.ojMenu
         * @instance
         * @property {Event} event <code class="prettyprint">jQuery</code> event object
         * @property {Object} ui Parameters
         * @property {jQuery} ui.item the currently active menu item
         * 
         * @example <caption>Initialize the menu with the <code class="prettyprint">select</code> callback specified:</caption>
         * $( ".selector" ).ojMenu({
         *     "select": function( event, ui ) {}
         * });
         *
         * @example <caption>Bind an event listener to the <code class="prettyprint">ojselect</code> event:</caption>
         * $( ".selector" ).on( "ojselect", function( event, ui ) {} );
         */
        select: null
    },

    _create: function() { // Override of protected base class method.  Method name needn't be quoted since is in externs.js.
        this.activeMenu = this.element;
        // flag used to prevent firing of the click handler
        // as the event bubbles up through nested menus
        this.mouseHandled = false;
        this.element
            .uniqueId()
            .addClass( "oj-menu oj-component" )
            
            .toggleClass( "oj-menu-icons", !!this.element.find( ".oj-component-icon" ).length )
            
            .attr({
                "role": this.role,
                "tabIndex": "0"
            });
            // pass true to catch these events on all menus, not just enabled menus
            this._on(true, {
                //Required to stick the focus on disabled menu.
                "mousedown .oj-menu-item": function(event) {
                    if (this.options.disabled) {
                        event.preventDefault();
                    }
                },
                "click": function(event) {
                    if (this.options.disabled) {
                        event.preventDefault();
                    }
                },
                //On Esc key focus should be shifted to launcher and dismiss menu.
                "keydown": function(event) {
                    if (this.options.disabled) {
                        if (event.keyCode === $.ui.keyCode.ESCAPE) {
                            if (this._launcher) { // if this is a popup menu that's currently shown
                                this._focusLauncherAndDismiss(event);
                            }
                        }
                    }
                }
            });
        
        // needed since _setOption() is not automatically called at create time.
        // TBD: Would be a little better to toggle these 2 things rather than only setting them if true, as in superclass _setOption().
        if ( this.options.disabled ) {
            this.element
                .addClass( "oj-disabled" )
                .attr( "aria-disabled", "true" );
        }

        this._on({
            // Prevent focus from sticking to links inside menu after clicking
            // them (focus should always stay on UL during navigation).
            "mousedown .oj-menu-item > a": function( event ) {
                event.preventDefault();
            },
            "click .oj-disabled > a": function( event ) {
                event.preventDefault();
            },
            "click": function(event) {
                // when the click event bubbles out of the root menu element, we're done with it, so 
                // reset this flag to its initial value of false in preparation for the next click
                this.mouseHandled = false;
            },
            "click .oj-menu-item:has(a)": function( event ) {
                var target = $( event.target ).closest( ".oj-menu-item" );
                // the mouseHandled var ensures that the click is handled only for the originally clicked
                // menu item, not for the parent menu items to which it bubbles.
                if ( !this.mouseHandled && target.not( ".oj-disabled" ).length ) {
                    this.mouseHandled = true;
                    if (this.active && this.active.closest(target).length && this.active.get(0) != target.get(0)) {
                        //If current active menu item  is decendent of (and not equal to) target menu item then 
                        //sub menu of the curent target is already open and hence no need to 
                        //1. expand the sub menu 
                        //2. as current target is a menu item having sub menu no need to invoke this.select(event).
                        return;
                    }
                    // Open submenu on click
                    if ( target.has( ".oj-menu" ).length ) {
                        this.expand( event );
                    }
                    else {
                        //Invoke select only for leaf menu items
                        this.select(event);
                        if (!this.element.is(":focus")) {
                            // Redirect focus to the menu
                            this.element.trigger("focus", [true]);

                            // If the active item is on the top level, let it stay active.
                            // Otherwise, blur the active item since it is no longer visible.
                            if (this.active && this.active.parents(".oj-menu").length === 1) {
                                clearTimeout(this.timer);
                            }
                        }
                    }
                }
            },
            "mouseenter .oj-menu-item": function( event ) {
                var target = $( event.currentTarget );
                // Remove oj-active class from siblings of the newly focused menu item
                // to avoid a jump caused by adjacent elements both having a class with a border
                target.siblings().children( ".oj-active" ).removeClass( "oj-active" );
                this.focus( event, target );
            },
            "mouseleave": this.collapseAll,
            "mouseleave .oj-menu": this.collapseAll,
            "focus": function( event, keepActiveItem ) {
                // If there's already an active item, keep it active
                // If not, activate the first item
                var item = this.active || this.element.children( ".oj-menu-item" ).eq( 0 );

                if ( !keepActiveItem ) {
                    this.focus( event, item );
                }
            },
            "keydown": this._keydown,
            "keyup": function( event ) {
                if (event.keyCode == $.ui.keyCode.ENTER || event.keyCode == $.ui.keyCode.SPACE) 
                    this.__spaceEnterDownInMenu = false;
            }
        });
        
        this._setup();

        this._registerClickAwayHandler();
        this._super();
    },

    //Registers one click away handler on document, only if it is not already registered by another menu widget.
    _registerClickAwayHandler: function() {
        var clikAwayHandler = this.document.data(this._MENU_CLICK_AWAY_HANDLER_KEY);
        if (!clikAwayHandler) {
        // Clicks outside of a menu collapse any open menus, and dismiss the entire menu if it's a popup
            clikAwayHandler = function(event) {
                //Focus event needs to be captured because, in case of menu button (where focus is still on menu button instead of open menu), if user does 
                //a taboff to another element then menu should be closed. With this we also no need to have additional "blur" handler on menu to close the menu popup/submenus.
                
                //Despite of focus/mousedown, still keydown listener is required for contextmenu events especially for menubutton with browser default context menu 
                //and user pressed contextmenu keyboard key(not right mouse click). 
                
                //Checking event.KeyCode along with event.which as currently event created by jquery-simulate.js is setting only event.keyCode for chrome/IE. 
                //This avoids test failures. This can be removed after jquery simulates event properly.
                
                if (event.type === "focus" || event.type === "mousedown" || event.which == 93 || (event.which == 121 && event.shiftKey) || event.keyCode == 93) { // Windows contextMenu key (93) or Shift-F10 (121)
                    //Clone _openPopupMenus as __dismiss() will remove the open menu from _openPopupMenus list                   
                    var openPopupMenus = _openPopupMenus.slice(0, _openPopupMenus.length);
                    $.each(openPopupMenus , function(index, menu) {
                        //Close all open menus unless the mouseDown/focus/keyDown event came from that specific menu.
                        if (!$(event.target).closest(menu.element).length && (event.type === "keydown" || (event.type === "mousedown" && event.which === 3) || !$(event.target).closest(menu._launcher).length)) {
                            menu.collapseAll(event);
                            if (menu._launcher)
                                menu.__dismiss(event);
                        }
                    });
                };
            }

            this.document.data(this._MENU_CLICK_AWAY_HANDLER_KEY, clikAwayHandler);
            //Capture the event on document to close the menu popup. Must do this in capture phase so that menu is closed even if something eats the event.
            this.document[0].addEventListener("keydown", clikAwayHandler, true);    
            this.document[0].addEventListener("mousedown", clikAwayHandler, true);
            this.document[0].addEventListener("focus", clikAwayHandler, true);
        }
    },

    //Unregisters click away handler on document, only if there are no menu widgets on the page.
    _unregisterClickAwayHandler: function() {
        var clikAwayHandler = this.document.data(this._MENU_CLICK_AWAY_HANDLER_KEY);
        //Remove click away handler while destroying last menu instance.
        if (clikAwayHandler && $(":oj-menu").length === 1 ) {
            //Ensure that all listeners removed on document while destroying the menu.   
            this.document[0].removeEventListener("keydown", clikAwayHandler, true);
            this.document[0].removeEventListener("mousedown", clikAwayHandler, true);
            this.document[0].removeEventListener("focus", clikAwayHandler, true);
            this.document.removeData(this._MENU_CLICK_AWAY_HANDLER_KEY);
        }
    },
    
    _destroy: function() { // Override of protected base class method.  Method name needn't be quoted since is in externs.js.
        // Destroy (sub)menus
        this.element
            .removeAttr( "aria-activedescendant" )
            .find( ".oj-menu" ).addBack()
                .removeClass( "oj-menu oj-component oj-menu-icons" )
                .removeAttr( "role" )
                .removeAttr( "tabIndex" )
                .removeAttr( "aria-labelledby" )
                .removeAttr( "aria-hidden" )
                .removeAttr( "aria-disabled" )
                .removeUniqueId()
                .show();

        // Destroy menu items
        this.element.find( ".oj-menu-item" )
            .removeClass( "oj-menu-item" )
            .removeAttr( "role" )
            .children( "a" )
                .removeAttr( "aria-disabled" )
                .removeUniqueId()
                .removeClass( "oj-hover" )
                .removeAttr( "tabIndex" )
                .removeAttr( "role" )
                .removeAttr( "aria-haspopup" )
                .children().each( function() {
                    var elem = $( this );
                    if ( elem.data( "oj-ojMenu-submenu-icon" ) ) {
                        elem.remove();
                    }
                });

        // Destroy anchors
        this.element.find( "a" ).removeAttr( "aria-expanded" );
        
        // Destroy menu dividers
        this.element.find( ".oj-menu-divider" )
            .removeClass( "oj-menu-divider" )
            .removeAttr( "role" );
        
        this._unregisterClickAwayHandler();

        // Remove the menu from openPopupMenus list if it is still added.
        if(_openPopupMenus.indexOf(this) >= 0)
            _openPopupMenus.splice(_openPopupMenus.indexOf(this),1);
    },

    _keydown: function( event ) { // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        /*jshint maxcomplexity:20*/
        var match, prev, character, skip, regex,
            preventDefault = true;

        function escape( value ) {
            return value.replace( /[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&" );
        }

        switch ( event.keyCode ) {
        case $.ui.keyCode.HOME:
            this._move( "first", "first", event );
            break;
        case $.ui.keyCode.END:
            this._move( "last", "last", event );
            break;
        case $.ui.keyCode.UP:
            this.previous( event );
            break;
        case $.ui.keyCode.DOWN:
            this.next( event );
            break;
        case $.ui.keyCode.LEFT:
        case $.ui.keyCode.RIGHT:
            var isExpand = (event.keyCode === $.ui.keyCode.RIGHT) ^ this.isRtl;
            if (isExpand) {
                if ( this.active && !this.active.is( ".oj-disabled" ) ) {
                    this.expand( event );
                }
            } else {
                this.collapse( event );
            }
            break;
        case $.ui.keyCode.ENTER:
        case $.ui.keyCode.SPACE:
            this._activate( event );
            
            this.__spaceEnterDownInMenu = true;
            var self = this;
            
            // The spaceEnterDelay and __spaceEnterDownInMenu code addresses an issue where closing a menu, from within the menu via 
            // Space or Enter, can immediately reopen the menu, because the keyUp can happen after focus has jumped to the button, 
            // which clicks the button, which reopens the menu.  Repros most readily in Firefox.
            var spaceEnterDelay = 100; // 1 not enough in FF; 100 seems to do it.  If continued problems, try increasing this value.

            setTimeout(function () {
                self.__spaceEnterDownInMenu = false;
            }, spaceEnterDelay); 
            
            break;
        // this handles enabled menus.  For disabled menus, see this handler: this._on(true, {...});
        case $.ui.keyCode.ESCAPE:
            if (this._launcher) { // if this is a popup menu that's currently shown
                // TBD: Currently using the exact code (checking aria-activedescendant) that worked in the v0.5 demo.  Seems cleaner to use this.active (or maybe 
                // this.activeMenu?), but per todo's in this file, the jqui code doesn't seem to do a good job of keeping the 2 in synch, so sticking with tried-and-true for now.
                var activeItemId = this.element.attr("aria-activedescendant"); // <a> or nothing
                var topLevelAnchorSelector = "#" + this.element.attr("id") + ">*>a"; // * is typically <li>
                var submenuOpen = activeItemId && !$("#" + activeItemId).is( topLevelAnchorSelector );

                if (submenuOpen)
                    this.collapse( event );
                else
                    this._focusLauncherAndDismiss( event );
            } else {
                this.collapse( event );
            }
            break;
        default:
            preventDefault = false;
            prev = this.previousFilter || "";
            character = String.fromCharCode( event.keyCode );
            skip = false;

            clearTimeout( this.filterTimer );

            if ( character === prev ) {
                skip = true;
            } else {
                character = prev + character;
            }

            regex = new RegExp( "^" + escape( character ), "i" );
            match = this.activeMenu.children( ".oj-menu-item" ).filter(function() {
                return regex.test( $( this ).children( "a" ).text() );
            });
            match = skip && match.index( this.active.next() ) !== -1 ?
                this.active.nextAll( ".oj-menu-item" ) :
                match;

            // If no matches on the current filter, reset to the last character pressed
            // to move down the menu to the first item that starts with that character
            if ( !match.length ) {
                character = String.fromCharCode( event.keyCode );
                regex = new RegExp( "^" + escape( character ), "i" );
                match = this.activeMenu.children( ".oj-menu-item" ).filter(function() {
                    return regex.test( $( this ).children( "a" ).text() );
                });
            }

            if ( match.length ) {
                this.focus( event, match );
                if ( match.length > 1 ) {
                    this.previousFilter = character;
                    this.filterTimer = this._delay(function() {
                        delete this.previousFilter;
                    }, 1000 );
                } else {
                    delete this.previousFilter;
                }
            } else {
                delete this.previousFilter;
            }
        }

        if ( preventDefault ) {
            event.preventDefault();
        }
    },

    /*
     * Called for Space and Enter
     */
    _activate: function( event ) { // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        if ( !this.active.is( ".oj-disabled" ) ) {
            if ( this.active.children( "a[aria-haspopup='true']" ).length ) {
                this.expand( event );
            } else {
                this.select( event );
            }
        }
    },

    /**
     * Refreshes the visual state of the menu. JET components require a <code class="prettyprint">refresh()</code> after the DOM is 
     * programmatically changed underneath the component.  For Menu, this includes:
     * 
     * <ul>
     *   <li>After menu items or submenus are added or removed.</li>
     *   <li>After a change to a menu item's disabled status (which is set by applying or removing the <code class="prettyprint">oj-disabled</code> 
     *       class from the menu item).</li>
     *   <li>After the reading direction (LTR vs. RTL) changes.</li>
     * </ul>
     * 
     * <p>This method does not accept any arguments.
     * 
     * @expose 
     * @memberof! oj.ojMenu
     * @instance
     * 
     * @example <caption>Invoke the <code class="prettyprint">refresh</code> method:</caption>
     * $( ".selector" ).ojMenu( "refresh" );
     */
    refresh: function() { // Override of public base class method (unlike JQUI).  Method name needn't be quoted since is in externs.js.
        this._super();
        this._setup();
    },

    _setup: function() { // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        this.isRtl = this._GetReadingDirection() === "rtl";
        var self=this,
            menus,
            submenus = this.element.find( this.options.menuSelector );

        // Initialize nested menus
        submenus.filter( ":not(.oj-menu)" )
            .addClass( "oj-menu oj-component" )
            .hide()
            .attr({
                "role": this.role,
                "aria-hidden": "true"
            })
            .each(function() {
                var menu = $( this ),
                    item = self._getSubmenuItem( menu ),
                    submenuIcon = $( "<span>" );
                
                submenuIcon   // separate stmt rather than chaining, since GCC can't tell that this is the setter overload of .data().
                    .addClass( "oj-menu-submenu-icon oj-component-icon" )
                    .data( "oj-ojMenu-submenu-icon", true ); // TODO: can't we just look for the class at destroy time rather than adding this data?

                item
                    .attr( "aria-haspopup", "true" )
                    .attr( "aria-expanded", "false" ) // per a11y team, live on <a>, not <ul> like JQUI
                    .prepend( submenuIcon );
                var itemId = /** @type {string|undefined}  tell GCC is getter, not setter, overload of attr() */
                             (item.attr( "id" ));
                
                // itemId is undefined if id attr not present, in which case following stmt is a chainable no-op (returns 
                // "this" and doesn't set anything).
                menu.attr( "aria-labelledby", itemId );
            });

        menus = submenus.add( this.element );
        var children = menus.children();
        
        // Anything that used to be a divider, but now has an "a", should become a menu element.
        children.filter( ".oj-menu-divider" ).has("a")
            .removeClass("oj-menu-divider oj-menu-item") // remove oj-menu-item if somehow present to ensure that it enters following block
            .removeAttr("role");
        
        // Don't refresh list items that are already adapted
        // TBD: .has prob has better perf than :has
        children.filter( ":not(.oj-menu-item):has(a)" )
            .addClass( "oj-menu-item" )
            .attr( "role", "presentation" )
            .children( "a" )
                .uniqueId()
                .attr({
                    "tabIndex": "-1",
                    "role": this._itemRole()
                });

        // Initialize unlinked menu-items containing spaces and/or dashes only as dividers
        children.filter( ":not(.oj-menu-item)" ).each(function() {
            var item = $( this );
            // hyphen, em dash, en dash
            if ( !/[^\-\u2014\u2013\s]/.test( item.text() ) ) {
                item.addClass( "oj-menu-divider" )
                    .attr( "role", "separator" );
            }
        });

        // Add aria-disabled to any disabled menu item, and remove it from any recently enabled menu item
        children.filter( ".oj-disabled" ).children( "a" ).attr( "aria-disabled", "true" );
        children.filter( ":not(.oj-disabled)" ).children( "a" ).removeAttr( "aria-disabled" );

        // If the active item has been removed, blur the menu
        if ( this.active && !$.contains( this.element[ 0 ], this.active[ 0 ] ) ) {
            this.blur();
        }
    },
    
    /*
     * Given a list of one or more submenus (typically <ul>'s), finds the <a>'s that are their labels.  
     */
    _getSubmenuItem: function(submenu) { // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        return submenu.prev( "a" );
    },

    _itemRole: function() { // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        return "menuitem"; 
//        {
//            "menu": "menuitem",
//            "listbox": "option"
//        }[ this.role ];
    },

    /**
     * Activates the specified menu item and triggers the menu's <code class="prettyprint">focus</code> event.
     * 
     * @expose 
     * @memberof! oj.ojMenu
     * @instance
     * @param {Event} event - What triggered the menu item to gain focus.  May be <code class="prettyprint">null</code>, but may not be omitted.
     * @param {!jQuery} item - The menu item to focus/activate.  Its containing submenu, if any, must already be expanded.
     * 
     * @example <caption>Invoke the <code class="prettyprint">focus</code> method:</caption>
     * $( ".selector" ).ojMenu( "focus", null, menu.find( ".oj-menu-item:last" ) );
     */
    focus: function( event, item ) { // Public, not an override (not in base class), so use @expose with unquoted method name.
        var nested, focused;
        this.blur( event, event && event.type === "focus" );

        this.active = item.first();
        focused = this.active.children( "a" ).addClass( "oj-focus" );
        // Only update aria-activedescendant if there's a role
        // otherwise we assume focus is managed elsewhere
        if ( this.role ) {
            this.element.attr( "aria-activedescendant", focused.attr( "id" ) );
        }

        // Highlight active parent menu item, if any
        this.active
            .parent()
            .closest( ".oj-menu-item" )
            .children( "a:first" )
            .addClass( "oj-active" );

        if ( event && event.type === "keydown" ) {
            this._close();
        } else {
            this.timer = this._delay(function() {
                this._close();
            }, this.delay );
        }

        nested = item.children( ".oj-menu" );
        if ( nested.length && event && ( /^mouse/.test( event.type ) && !this.active.hasClass( "oj-disabled" ) ) ) {
            this._startOpening(nested);
        }
        this.activeMenu = item.parent();

        this._trigger( "focus", event, { "item": item } ); // TODO: item.first() or this.active
    },

    /**
     * Removes focus from the active menu item, if any.  Does not affect whether the menu itself 
     * has browser focus.  Resets any active element styles and triggers the menu's <code class="prettyprint">blur</code> event.
     * 
     * @expose 
     * @memberof! oj.ojMenu
     * @instance
     * @param {Event=} event - What triggered the menu item to blur.  May be <code class="prettyprint">null</code> or omitted.
     * 
     * @example <caption>Invoke the <code class="prettyprint">blur</code> method:</caption>
     * $( ".selector" ).ojMenu( "blur" ) );
     */
    blur: function( event /*, fromFocus*/ ) { // Public, not an override (not in base class), so use @expose with unquoted method name.
        // fromFocus is an internal param that should not be JSDoc'd.  It's true iff the caller is the focus() method.
        // The JSDoc claim that the first param can be omitted is directed at public callers; it can't be omitted (but could be null) when fromFocus is being passed.
        // Now using "arguments" to refer to the internal param, to keep GCC happy, which doesn't like optional params before params that aren't marked optional.
        var fromFocus = arguments[1];
        
        if ( !fromFocus ) {
            clearTimeout( this.timer );
        }

        if ( !this.active ) {
            return;
        }

        this.active.children( "a" ).removeClass( "oj-focus" );
        this.active = null; // TODO: shouldn't this also clear aria-activedescendant?

        this._trigger( "blur", event, { "item": this.active } );
    },
    
    _focusLauncherAndDismiss: function( event ) { // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        this._launcher.focus();
        this.__dismiss( event );
    },
    
    /*
     * TODO: JSDoc, then add 2nd star above
     * TODO: Should we just make this method, and the event, public?  Surface for review if so.
     * 
     * @private (actually internal, not private)
     */
    __dismiss: function(event) { // Internal visibility; called by Button's MenuButton functionality.  Not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        this.element.hide().attr( "aria-hidden", "true" );
        this._launcher = undefined;
        
        // TODO: if keep this, check whether actually open first, to avoid spurious events
        this._trigger( "__dismiss", event, {} ); // internal event

        //Remove menu from openPopupMenus list
        if(_openPopupMenus.indexOf(this) >= 0)
            _openPopupMenus.splice(_openPopupMenus.indexOf(this),1);
    },
    
    // TODO: make the bullets for the 'params' param a table?
    /**
     * Launches this menu as a popup, after firing the <code class="prettyprint">beforeShow</code> event.  Listeners to that event can cancel the launch 
     * via <code class="prettyprint">event.preventDefault()</code>, and can tweak menu configuration as needed, such as 
     * <code class="prettyprint">menuPosition</code>.
     * 
     * @expose
     * @memberof! oj.ojMenu
     * @instance
     * 
     * @param {Event} event What triggered the menu launch.  May be <code class="prettyprint">null</code>, but may not be omitted.
     * 
     * @param {Object.<string, string>} params  Map including one or more of the following keys: 
     *     <ul>
     *       <li><code class="prettyprint">"launcher"</code>: Required.  The DOM element (which may or may not be a JET component) that launched the popup menu.  
     *         Focus is returned to this node upon menu dismissal. Can be the <code class="prettyprint">string</code> id of the DOM node, or a 
     *         <code class="prettyprint">jQuery</code> object containing the node.
     *       </li>
     *       <li><code class="prettyprint">"focus"</code>: Optional; defaults to <code class="prettyprint">"firstItem"</code>.  Values are the following <code class="prettyprint">string</code>s:
     *         <ul>
     *           <li><code class="prettyprint">"none"</code>: Leaves focus where it is, e.g. on the launching component (e.g. WAI-ARIA MenuButton Space/Enter behavior).  Use this value 
     *               if setting focus in the <code class="prettyprint">beforeShow</code> listener.</li>
     *           <li><code class="prettyprint">"menu"</code>: Focuses the menu itself with no menu item focused (e.g. typical Context Menu behavior).</li>
     *           <li><code class="prettyprint">"firstItem"</code>: Focuses the first menu item (e.g. WAI-ARIA MenuButton DownArrow behavior).</li>
     *         </ul>
     *       </li>
     *     </ul>
     * 
     * @example <caption>Invoke the <code class="prettyprint">show</code> method:</caption>
     * $( ".selector" ).ojMenu( "show", myEvent, {launcher: "myElement"} );
     */
    show: function( event, params ) { // Public, not an override (not in base class), so use @expose with unquoted method name.
        // we don't know at create time that we're a popup, so do popup init on first call to show, which is when we find out we're a popup.
        // TBD: would do this at init time if we add a "type" component option.
        if (!this._popupInited) {
            this._popupInit();
            this._popupInited = true;
        }
        
        if (!params || !params["launcher"]) {
            // TODO: log a warning or error: need launcher so can return focus to it.
            return;
        }
        
        var launcher = params["launcher"]; // GCC needs bracket syntax even if you declare the field via @param {{launcher:(string|jQuery), focus: string}} params
        
        var cancelled = !this._trigger( "beforeShow", event, {"launcher": launcher} );
        
        if (cancelled) 
            return;
        
        launcher = $.type(launcher) === "string" 
                   ? $("#" + launcher)
                   : launcher;
        
        //Close all other open menus
        var currentMenu = this.element[0];
        //Clone _openPopupMenus as __dismiss() will remove the open menu from _openPopupMenus list
        var openPopupMenus = _openPopupMenus.slice(0, _openPopupMenus.length);
        $.each(openPopupMenus , function(index, menu) {
            if (menu.element[0] !== currentMenu) {
                menu.collapseAll(event);
                if (menu._launcher)
                    menu.__dismiss(event);
            }
        });
        
        // following JQUI's pattern of copying even if don't need to change anything.  
        // TBD: is that important b/c position() might mutate it, or can we optimize this?  Applies to submenu code too.
        var position = $.extend({}, this.options.menuPosition );
        
        if (position.of == null) {
            // TBD: this isRightClick check works so far, but supposedly browsers are supposed to fire contextmenu event for Shift-F10 too, 
            // so might have to check other stuff like coordinates to distinguish from keyboard.
            var isRightClick = (event && event.type === "contextmenu");
            position.of = isRightClick ? event : launcher;
        }
        
        this.element
            .show()
            .removeAttr( "aria-hidden" )
            .position( position );
        
        var focusFirstItem = params.focus === "firstItem";
        var focusMenu = focusFirstItem || params.focus === "menu" ;
        
        if (focusMenu)
            this.element.focus();

        if (focusFirstItem) {
            this.focus(event, this.element.children().first());
        } else {
            this.blur(event);
        }

        // store launcher so we can return focus to it, e.g. if Esc pressed.  Ivar is non-null iff menu is a popup and is currently shown.
        this._launcher = launcher;

        //Add current menu to openPopupMenus so that it will be closed on focus lost/click away.
        _openPopupMenus.push(this);
    },
    
    _popupInit: function() { // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        this.element.css({position: 'absolute', // make it a popup menu
                          zIndex:999}); // workaround for 17307603.  TODO: remove when fixed
    },
    
    _startOpening: function( submenu ) { // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        clearTimeout( this.timer );

        // Don't open if already open fixes a Firefox bug that caused a .5 pixel
        // shift in the submenu position when mousing over the submenu icon
        if ( submenu.attr( "aria-hidden" ) !== "true" ) {
            return;
        }

        this.timer = this._delay(function() {
            this._close();
            this._open( submenu );
        }, this.delay );
    },
    
    _open: function( submenu ) { // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        var position = $.extend({
            "of": this.active
        }, this.options.submenuPosition );

        clearTimeout( this.timer );
        this.element.find( ".oj-menu" ).not( submenu.parents( ".oj-menu" ) )
            .hide()
            .attr( "aria-hidden", "true" );

        submenu
            .show()
            .removeAttr( "aria-hidden" )
            .position( position );
        
        this._getSubmenuItem(submenu).attr( "aria-expanded", "true" );
        
        if (!this._launcher && _openPopupMenus.indexOf(this) < 0) {
            _openPopupMenus.push(this);
        }
    },

    /**
     * Closes some or all open submenus.
     * 
     * @expose 
     * @memberof! oj.ojMenu
     * @instance
     * @param {Event=} event - What triggered the menu to collapse.  May be <code class="prettyprint">null</code>.  
     *                         May be omitted if the <code class="prettyprint">all</code> parameter is omitted.
     * @param {boolean=} all - Indicates whether all submenus should be closed or only submenus below and including the menu that is or 
     *                         contains the target of the triggering event.  Defaults to <code class="prettyprint">false</code>.
     * 
     * @example <caption>Invoke the <code class="prettyprint">collapseAll</code> method:</caption>
     * $( ".selector" ).ojMenu( "collapseAll ", null, true );
     */
    collapseAll: function( event, all ) { // Public, not an override (not in base class), so use @expose with unquoted method name.
        this._collapseAll(event, all, this.delay);
    },
    
    //see doc on collapseAll(), only difference here is, if argument delay is not passed, it collapses the menu immediately.
    _collapseAll: function(event, all, delay) {
        clearTimeout(this.timer);
        var self = this;
        var collapseMenu = function() {
            // If we were passed an event, look for the submenu that contains the event
            var currentMenu = all ? self.element :
                $(event && event.target).closest(self.element.find(".oj-menu"));

            // If we found no valid submenu ancestor, use the main menu to close all sub menus anyway
            if (!currentMenu.length) {
                currentMenu = self.element;
            }

            self._close(currentMenu);

            self.blur(event);
            self.activeMenu = currentMenu;
        };
        if (delay) {
            this.timer = this._delay(collapseMenu, delay);
        } else {
            collapseMenu();
        }
    },

    // With no arguments, closes the currently active menu - if nothing is active
    // it closes all menus.  If passed an argument, it will search for menus BELOW
    _close: function( startMenu ) { // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        if ( !startMenu ) {
            startMenu = this.active ? this.active.parent() : this.element;
        }

        var menus = startMenu.find( ".oj-menu" );
        menus.hide()
             .attr( "aria-hidden", "true" );
        this._getSubmenuItem( menus ).attr( "aria-expanded", "false" );
        startMenu.find( "a.oj-active" ).removeClass( "oj-active" );

        if (!this._launcher) {
            // If the current menu is not a popup menu and it's submenu is already open then remove the menu from _openPopupMenus 
            // while closing the submenus of top level menu.
            if (_openPopupMenus.indexOf(this) >= 0) {
                if (startMenu === this.element) {
                    _openPopupMenus.splice(_openPopupMenus.indexOf(this), 1);
                }
            }
        }
    },

    /**
     * Closes the currently active submenu.
     * 
     * @expose 
     * @memberof! oj.ojMenu
     * @instance
     * @param {Event=} event - What triggered the menu to collapse.  May be <code class="prettyprint">null</code> or omitted.
     * 
     * @example <caption>Invoke the <code class="prettyprint">collapse</code> method:</caption>
     * $( ".selector" ).ojMenu( "collapse" );
     */
    collapse: function( event ) { // Public, not an override (not in base class), so use @expose with unquoted method name.
        var newItem = this.active &&
            this.active.parent().closest( ".oj-menu-item", this.element );
        if ( newItem && newItem.length ) {
            this._close();
            this.focus( event, newItem );
        }
    },

    /**
     * Opens the submenu below the currently active item, if one exists.
     * 
     * @expose 
     * @memberof! oj.ojMenu
     * @instance
     * @param {Event=} event - What triggered the menu to expand.  May be <code class="prettyprint">null</code> or omitted.
     * 
     * @example <caption>Invoke the <code class="prettyprint">expand</code> method:</caption>
     * $( ".selector" ).ojMenu( "expand" );
     */
    expand: function( event ) { // Public, not an override (not in base class), so use @expose with unquoted method name.
        var newItem = this.active &&
            this.active
                .children( ".oj-menu " )
                .children( ".oj-menu-item" )
                .first();

        if ( newItem && newItem.length ) {
            this._open( newItem.parent() );

            // Delay so Firefox will not hide activedescendant change in expanding submenu from AT
            this._delay(function() {
                this.focus( event, newItem );
            });
        }
    },

    /**
     * Moves active state to next menu item.
     * 
     * @expose 
     * @memberof! oj.ojMenu
     * @instance
     * @param {Event=} event - What triggered the focus to move.  May be <code class="prettyprint">null</code> or omitted.
     * 
     * @example <caption>Invoke the <code class="prettyprint">next</code> method:</caption>
     * $( ".selector" ).ojMenu( "next" );
     */
    next: function( event ) { // Public, not an override (not in base class), so use @expose with unquoted method name.
        this._move( "next", "first", event );
    },

    /**
     * Moves active state to previous menu item.
     * 
     * @expose 
     * @memberof! oj.ojMenu
     * @instance
     * @param {Event=} event - What triggered the focus to move.  May be <code class="prettyprint">null</code> or omitted.
     * 
     * @example <caption>Invoke the <code class="prettyprint">previous</code> method:</caption>
     * $( ".selector" ).ojMenu( "previous" );
     */
    previous: function( event ) { // Public, not an override (not in base class), so use @expose with unquoted method name.
        this._move( "prev", "last", event );
    },


    _isFirstItem: function() { // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        return this.active && !this.active.prevAll( ".oj-menu-item" ).length;
    },

    _isLastItem: function() { // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        return this.active && !this.active.nextAll( ".oj-menu-item" ).length;
    },


    _move: function( direction, filter, event ) { // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        var next;
        if ( this.active ) {
            if ( direction === "first" || direction === "last" ) {
                next = this.active
                    [ direction === "first" ? "prevAll" : "nextAll" ]( ".oj-menu-item" )
                    .eq( -1 );
            } else {
                next = this.active
                    [ direction + "All" ]( ".oj-menu-item" )
                    .eq( 0 );
            }
        }
        if ( !next || !next.length || !this.active ) {
            next = this.activeMenu.children( ".oj-menu-item" )[ filter ]();
        }

        this.focus( event, next );
    },

    /* TODO: update JSdoc to be something like this revised version, once todo's in code are resolved.  
     * Let selectItem be the currently active menu item if any, else the menu item containing the target of the supplied event if any, else null.
     * 
     * If selectItem is non-null, this method selects that item, collapses all submenus, and triggers the menu's 
     * <code class="prettyprint">select</code> event.
     */
    /**
     * Selects the currently active menu item, collapses all submenus and triggers the menu's <code class="prettyprint">select</code> event.
     * 
     * @expose 
     * @memberof! oj.ojMenu
     * @instance
     * @param {Event=} event - What triggered the selection.  May be <code class="prettyprint">null</code> or omitted.
     * 
     * @example <caption>Invoke the <code class="prettyprint">select</code> method:</caption>
     * $( ".selector" ).ojMenu( "select" );
     */
    select: function( event ) { // Public, not an override (not in base class), so use @expose with unquoted method name.
        // TODO: shouldn't this set aria-activedescendant in synch with this.active?
        // OLD: this.active = this.active || $( event.target ).closest( ".oj-menu-item" );
        // NEW: this new code does approp. null-checks and parent-checks, but still has issues like 17501993.
        // TODO: we should probably prevent selecting a non-leaf, and make sure we're consistent with overall 
        // behavior re: whether a non-leaf can be active
        if (!this.active && event && event.target ) {
            var menuItem = $( event.target ).closest( ".oj-menu-item" );
            if (menuItem.closest( this.element ).length)
                this.active = menuItem;
        }
        
        if (!this.active)
            return;
        // END OF "NEW" CODE
        
        var ui = { "item": this.active };
        if ( !this.active.has( ".oj-menu" ).length ) {
            //As user selected the menu-item and we can collapse the menu immediately otherwise 
            //mouseleave event handler will invoke collapseAll() on event.target 
            //which will clear the scheduled collapseAll() on this.element and hence submenu will not be collapsed 
            //which later causes submenu open on re-launching menu. 
            this._collapseAll( event, true );
        }

        // if this is a popup menu that's currently shown
        if (this._launcher) {
            //if this is a leaf. TODO: for 18640337, move the isLeaf check to
            //the top, since this entire method should do nothing if not a leaf (except log a
            //warning if the method was called externally).
            if (!ui.item.children(this.options.menuSelector).length)
                this._focusLauncherAndDismiss(event);
        }
        
        // TODO: should this fire before or after calling _focusLauncherAndDismiss()?
        this._trigger( "select", event, ui );
    }
    
    // API doc for inherited methods with no JS in this file:

    /**
     * Returns a <code class="prettyprint">jQuery</code> object containing the menu.  
     * 
     * <p>This method does not accept any arguments.
     * 
     * @method
     * @name oj.ojMenu#widget
     * @memberof! oj.ojMenu
     * @instance
     * @return {jQuery} the menu
     * 
     * @example <caption>Invoke the <code class="prettyprint">widget</code> method:</caption>
     * var widget = $( ".selector" ).ojMenu( "widget" );
     */

    /**
     * Removes the menu functionality completely. This will return the element back to its pre-init state.
     * 
     * <p>This method does not accept any arguments.
     * 
     * @method
     * @name oj.ojMenu#destroy
     * @memberof! oj.ojMenu
     * @instance
     * 
     * @example <caption>Invoke the <code class="prettyprint">destroy</code> method:</caption>
     * $( ".selector" ).ojMenu( "destroy" );
     */
});

// "private static members" shared by all menus

// Array to track all opened menu popups. All the menus opened by Menu Buttons/ Context Menu/using menu.show() and standalone menus having open submenus, will be added to list 
// and later will be removed on __dismiss()/_close() on menu popup/standalone menu.
var _openPopupMenus = new Array();

}());

/*
** Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved. 
** Important:
** - This file is designed to be shared verbatim among the ADFui products.
** - Do not add framework-specific dependencies in this file (it must be self-contained).
** - Do not change this file without testing it in other ADFui products (ADF Faces, JET, etc.).
*/
if (!window.adf) { /** @expose */ window.adf = {}; };
//explicitly declare var adf to avoid compilation error in JET
var adf                        = window.adf;
adf.shared                     = adf.shared || {};
adf.shared.impl                = adf.shared.impl || {};
adf.shared.impl.conveyorBelt   = adf.shared.impl.conveyorBelt || {};
// must be explicitly assigned to the window.adf.shared.impl object for cross-framework sharing
/**
 * Constructor.
 * @param {Object} elem DOM element associated with the conveyor
 * @param {string} orientation Direction of scrolling, either horizontal or vertical
 * @param {Object} contentParent DOM element whose children are the items to scroll
 * @param {boolean} bRtl True if the reading direction is right-to-left, otherwise false
 * @param {Object} buttonInfo Map of properties for the following button information:
 *  - prevButtonId: Id to use for the scroll previous button,
 *  - nextButtonId: Id to use for the scroll next button,
 *  - prevButtonStyleClass: Style class name to use for the scroll previous button,
 *  - nextButtonStyleClass: Style class name to use for the scroll next button,
 *  - prevButtonIcon: Icon element to use for the scroll previous button,
 *  - nextButtonIcon: Icon element to use for the scroll next button,
 * @param {Object} callbackInfo Map of properties for the following callback information:
 *  - scrollFunc: Callback function to animate scrolling a DOM element, 
 *  - firstVisibleItemChangedFunc: Callback function to notify when the first visible item changes, 
 *  - addResizeListener: Callback function to add a resize listener for a DOM element
 *  - removeResizeListener: Callback function to remove a resize listener for a DOM element
 *  - callbackObj: Optional object on which the callback functions are defined
 *    has changed
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon = function(
  elem, orientation, contentParent, bRtl, buttonInfo, callbackInfo)
{
  this._elem = elem;
  this._orientation = orientation;
  this._contentParent = contentParent;
  this._bRtl = bRtl;
  if (buttonInfo)
  {
    //need to check for existence of properties on buttonInfo before assigning 
    //them to vars because advanced closure compiler will otherwise complain if 
    //they're not defined
    if (buttonInfo.prevButtonId)
      this._prevButtonId = buttonInfo.prevButtonId;
    if (buttonInfo.nextButtonId)
      this._nextButtonId = buttonInfo.nextButtonId;
    if (buttonInfo.prevButtonStyleClass)
      this._prevButtonStyleClass = buttonInfo.prevButtonStyleClass;
    if (buttonInfo.nextButtonStyleClass)
      this._nextButtonStyleClass = buttonInfo.nextButtonStyleClass;
    if (buttonInfo.prevButtonIcon)
      this._prevButtonIcon = buttonInfo.prevButtonIcon;
    if (buttonInfo.nextButtonIcon)
      this._nextButtonIcon = buttonInfo.nextButtonIcon;
  }
  if (callbackInfo)
  {
    //need to check for existence of properties on callbackInfo before assigning 
    //them to vars because advanced closure compiler will otherwise complain if 
    //they're not defined
    if (callbackInfo.scrollFunc)
      this._scrollFunc = callbackInfo.scrollFunc;
    if (callbackInfo.firstVisibleItemChangedFunc)
      this._firstVisibleItemChangedFunc = callbackInfo.firstVisibleItemChangedFunc;
    if (callbackInfo.callbackObj)
      this._callbackObj = callbackInfo.callbackObj;
    if (callbackInfo.addResizeListener)
      this._addResizeListenerFunc = callbackInfo.addResizeListener;
    if (callbackInfo.removeResizeListener)
      this._removeResizeListenerFunc = callbackInfo.removeResizeListener;
  }
  
  this._bExternalScroll = true;
  this._firstVisibleItemIndex = 0;
  
  //copied basic checks from AdfAgent
  var navUserAgent = navigator.userAgent;
  var agentName = navUserAgent.toLowerCase();
  if (agentName.indexOf("gecko/") !== -1)
  {
    this._bAgentGecko = true;
  }
  else if (agentName.indexOf("opera") !== -1)
  {
    this._bAgentOpera = true;
  }
  else if (agentName.indexOf("applewebkit") !== -1 ||
           agentName.indexOf("safari") !== -1)
  {
    this._bAgentWebkit = true;
  }
};

/**
 * Setup the conveyor belt.
 * @param {boolean} bInit True for initialization, false for refresh
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype.setup = function(bInit)
{
  var self = this;
  var cbcClass = adf.shared.impl.conveyorBelt.ConveyorBeltCommon;
  if (bInit)
  {
    //create the content and overflow containers
    this._createInnerContainers();
    
    //create the next/prev buttons
    this._createPrevButton(this._prevButtonId, this._prevButtonStyleClass, this._prevButtonIcon);
    this._createNextButton(this._nextButtonId, this._nextButtonStyleClass, this._nextButtonIcon);
    
    var nextButton = this._nextButton;
    var tableCellDivNextButton = this._tableCellDivNextButton;
    if (tableCellDivNextButton)
    {
      //use the width of the div containing the button because it will include 
      //any margins specified in the button style class
      this._buttonWidth = tableCellDivNextButton.offsetWidth;
      this._buttonHeight = nextButton.offsetHeight;
    }
    else
    {
      var vertDivNextButton = this._vertDivNextButton;
      this._buttonWidth = nextButton.offsetWidth;
      //use the height of the div containing the button because it will include 
      //any margins specified in the button style class
      this._buttonHeight = vertDivNextButton.offsetHeight;
    }
    
    //hide the buttons until we know we need them
    this._hidePrevButton();
    this._hideNextButton();
    
    //handle the mouse wheel on the whole conveyor
    this._mouseWheelListener = function (event) {self._handleMouseWheel(event);};
    cbcClass._addBubbleEventListener(this._elem, "mousewheel", this._mouseWheelListener);
    cbcClass._addBubbleEventListener(this._elem, "wheel", this._mouseWheelListener);
    
    //handle swipe gestures on the overflow container, which excludes the next/prev buttons
    this._touchStartListener = function (event) {self._handleTouchStart(event);};
    cbcClass._addBubbleEventListener(this._overflowContainer, "touchstart", this._touchStartListener);
    this._touchMoveListener = function (event) {self._handleTouchMove(event);};
    cbcClass._addBubbleEventListener(this._overflowContainer, "touchmove", this._touchMoveListener);
    this._touchEndListener = function (event) {self._handleTouchEnd(event);};
    cbcClass._addBubbleEventListener(this._overflowContainer, "touchend", this._touchEndListener);
    cbcClass._addBubbleEventListener(this._overflowContainer, "touchcancel", this._touchEndListener);
    
    this._origScroll = 0;
  }
  else
  {
    //need to restore inner DOM to its initial state before we can accurately
    //calculate sizes
    this._reinitializeInnerDom();
  }

  //clear any old sizes so that new sizes will be calculated
  this._clearCachedSizes();
  //adjust overflow size
  this._adjustOverflowSize(bInit);
  //handle an initial resize
  this._handleResize(true);
  
  if (bInit && this._addResizeListenerFunc)
  {
    this._handleResizeFunc = function(width, height) {self._handleResize(false);};
    //listen for resizes on both the conveyor itself and on its content
    this._addResizeListenerFunc.call(this._callbackObj, this._elem, this._handleResizeFunc);
    this._addResizeListenerFunc.call(this._callbackObj, this._contentContainer, this._handleResizeFunc);
  }
};

/**
 * Destroy the conveyor belt.
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype.destroy = function()
{
  var elem = this._elem;
  var cbcClass = adf.shared.impl.conveyorBelt.ConveyorBeltCommon;
  cbcClass._removeBubbleEventListener(elem, "mousewheel", this._mouseWheelListener);
  cbcClass._removeBubbleEventListener(elem, "wheel", this._mouseWheelListener);
  cbcClass._removeBubbleEventListener(this._overflowContainer, "touchstart", this._touchStartListener);
  cbcClass._removeBubbleEventListener(this._overflowContainer, "touchmove", this._touchMoveListener);
  cbcClass._removeBubbleEventListener(this._overflowContainer, "touchend", this._touchEndListener);
  cbcClass._removeBubbleEventListener(this._overflowContainer, "touchcancel", this._touchEndListener);
  this._mouseWheelListener = null;
  this._touchStartListener = null;
  this._touchMoveListener = null;
  this._touchEndListener = null;
  
  //remove listeners before reparenting original children and clearing member 
  //variables
  if (this._removeResizeListenerFunc && this._handleResizeFunc)
  {
    this._removeResizeListenerFunc.call(this._callbackObj, elem, this._handleResizeFunc);
    this._removeResizeListenerFunc.call(this._callbackObj, this._contentContainer, this._handleResizeFunc);
  }
  this._handleResizeFunc = null;
  
  //move the original content children from the _contentTableDiv back to the 
  //original DOM element
  cbcClass._reparentChildrenFromTable(this._contentTableDiv, elem, this._isHorizontal());
  //clear the stored array of content elements
  this._arContentElements = null;
  if (this._tableDiv)
  {
    //the overflow, content, and buttons are all children of the table div
    elem.removeChild(this._tableDiv);
  }
  else
  {
    //the _contentContainer is a child of the _overflowContainer, so will be removed with it
    elem.removeChild(this._overflowContainer);
    elem.removeChild(this._vertDivNextButton);
    elem.removeChild(this._vertDivPrevButton);
  }
  
  this._nextButton = null;
  this._prevButton = null;
  this._contentContainer = null;
  this._overflowContainer = null;
  this._contentTableDiv = null;
  this._tableDiv = null;
  this._tableCellDivPrevButton = null;
  this._tableCellDivNextButton = null;
  this._prevButtonWrapper = null;
  this._nextButtonWrapper = null;
  this._vertDivPrevButton = null;
  this._vertDivNextButton = null;
  this._clearCachedSizes();
  
  this._elem = null;
  this._scrollFunc = null;
  this._firstVisibleItemChangedFunc = null;
  this._addResizeListenerFunc = null;
  this._removeResizeListenerFunc = null;
  this._callbackObj = null;
};

/**
 * Set the id of the item to make first visible.
 * @param {string} id id of the item to make first visible
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype.setFirstVisibleItem = function(id)
{
  var sizes = this._getSizes();
  for (var i = 0; i < sizes.length; i++)
  {
    var sizeObj = sizes[i];
    if (sizeObj.id === id)
    {
      this._setCurrScroll(sizeObj.start, true);
      break;
    }
  }
};

/**
 * Reparent the DOM child nodes from their old parent node to a new parent table
 * node.
 * @param {Object} fromNode Old parent DOM node
 * @param {Object} toTable New parent table DOM node
 * @param {boolean} bHoriz True to make the table horizontal, false for vertical
 * @return {Array} Array of child elements reparented to the table
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon._reparentChildrenToTable = function(fromNode, toTable, bHoriz)
{
  var cbcClass = adf.shared.impl.conveyorBelt.ConveyorBeltCommon;
  var tableRow = null;
  if (bHoriz)
  {
    tableRow = cbcClass._createTableRowDiv();
    toTable.appendChild(tableRow);
  }
  var arElements = null;
  
  var fromNodeChildren = fromNode.childNodes;
  while (fromNodeChildren.length > 0)
  {
    if (!arElements)
      arElements = [];
    
    var child = fromNodeChildren[0];
    if (child.nodeType === 1)
    {
      if (!bHoriz)
      {
        tableRow = cbcClass._createTableRowDiv();
        toTable.appendChild(tableRow);
      }
      
      var tableCell = cbcClass._createTableCellDiv();
      tableCell.appendChild(child);
      tableRow.appendChild(tableCell);
      arElements.push(child);
    }
    else
    {
      //if child is not an element node, simply append it to the table or 
      //tableRow without wrapping it in a tableCell
      if (bHoriz)
      {
        tableRow.appendChild(child);
      }
      else
      {
        toTable.appendChild(child);
      }
    }
  }
  return arElements;
};

/**
 * Reparent the DOM child nodes from a table to a new parent node.
 * @param {Object} fromTable Old parent table DOM node
 * @param {Object} toNode New parent DOM node
 * @param {boolean} bHoriz True if the table is horizontal, false if vertical
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon._reparentChildrenFromTable = function(fromTable, toNode, bHoriz)
{
  if (!fromTable)
    return;
  
  var tableRows = fromTable.childNodes;
  while (tableRows.length > 0)
  {
    var tableRow = tableRows[0];
    if (tableRow.nodeType === 1)
    {
      var tableCells = tableRow.childNodes;
      while (tableCells.length > 0)
      {
        var tableCell = tableCells[0];
        if (tableCell.nodeType === 1)
        {
          var cellContent = tableCell.firstChild;
          toNode.appendChild(cellContent);
          //only reparented child of tableCell, so still need to remove
          //tableCell itself
          tableRow.removeChild(tableCell);
        }
        else
        {
          //if child is not an element node, simply append it to the new parent
          toNode.appendChild(tableCell);
        }
      }
      //need to remove row from table
      fromTable.removeChild(tableRow);
    }
    else
    {
      //if child is not an element node, simply append it to the new parent
      toNode.appendChild(tableRow);
    }
  }
};

/**
 * Get the computed style of the given DOM element.
 * @param {Object} elem DOM element
 * @return {Object} Computed style for the element
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon._getComputedStyle = function(elem)
{
  var elemOwnerDoc = elem.ownerDocument;
  var defView = elemOwnerDoc.defaultView;
  var computedStyle = null;
  if (defView)
  {
    //this line copied from AdfAgent.getComputedStyle()
    computedStyle = defView.getComputedStyle(elem, null);
  }
  else
  {
    //this line copied from AdfIEAgent.getComputedStyle()
    computedStyle = elem.currentStyle;
  }
  return computedStyle;
};

/**
 * Get the inner width of the given DOM element (inside borders and padding).
 * @param {Object} elem DOM element
 * @return {number} Width of element
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon._getElemInnerWidth = function(elem)
{
  var cbcClass = adf.shared.impl.conveyorBelt.ConveyorBeltCommon;
  var computedStyle = cbcClass._getComputedStyle(elem);
  //the computedStyle width is the inner width of the elem
  return cbcClass._getCSSLengthAsInt(computedStyle.width);
};

/**
 * Get the inner height of the given DOM element (inside borders and padding).
 * @param {Object} elem DOM element
 * @return {number} Height of element
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon._getElemInnerHeight = function(elem)
{
  var cbcClass = adf.shared.impl.conveyorBelt.ConveyorBeltCommon;
  var computedStyle = cbcClass._getComputedStyle(elem);
  //the computedStyle height is the inner height of the elem
  return cbcClass._getCSSLengthAsInt(computedStyle.height);
};

/**
 * Get the int value of a CSS length.
 * @param {string} cssLength cssLength as a String
 * @return {number} cssLength as an int
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon._getCSSLengthAsInt = function(cssLength)
{
  //this function copied from AdfAgent.getCSSLengthAsInt
  if ((cssLength.length) > 0 && (cssLength != 'auto'))
  {
    var intLength = parseInt(cssLength, 10);

    if (isNaN(intLength))
      intLength = 0;

    return intLength;
  }
  return 0;
};

/**
 * Add a bubble event listener to the given DOM node.
 * @param {Object} node DOM node
 * @param {string} type Event type
 * @param {Function} listener Listener function
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon._addBubbleEventListener = function(node, type, listener)
{
  if (node.addEventListener)
  {
    node.addEventListener(type, listener, false);
  }
  else if (node.attachEvent)
  {
    node.attachEvent("on" + type, listener);
  }
};

/**
 * Remove a bubble event listener from the given DOM node.
 * @param {Object} node DOM node
 * @param {string} type Event type
 * @param {Function} listener Listener function
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon._removeBubbleEventListener = function(node, type, listener)
{
  if (node.removeEventListener)
  {
    node.removeEventListener(type, listener, false);
  }
  else if (node.detachEvent)
  {
    node.detachEvent("on" + type, listener);
  }
};

/**
 * Get the wheel delta from a mousewheel event.
 * @param {Object} event Event object
 * @return {number} Wheel delta
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon._getWheelDelta = function(event)
{
  var wheelDelta = 0;
  if (event.wheelDelta != null)
  {
    wheelDelta = event.wheelDelta;
  }
  //use bracket notation to avoid compilation warning in JET
  else if (event["deltaY"] != null)
  {
    wheelDelta = -event["deltaY"];
  }
  else
  {
    wheelDelta = -event.detail;
  }
  return wheelDelta;
};

/**
 * Create a div styled like a table.
 * @return {Node} div styled like a table row
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon._createTableDiv = function()
{
  var tableDiv = document.createElement("div");
  var style = tableDiv.style;
  style.display = "table";
  return tableDiv;
};

/**
 * Create a div styled like a table row.
 * @return {Node} div styled like a table row
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon._createTableRowDiv = function()
{
  var tableRowDiv = document.createElement("div");
  var style = tableRowDiv.style;
  style.display = "table-row";
  return tableRowDiv;
};

/**
 * Create a div styled like a table cell.
 * @return {Node} div styled like a table cell
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon._createTableCellDiv = function()
{
  var tableCellDiv = document.createElement("div");
  var style = tableCellDiv.style;
  style.display = "table-cell";
  return tableCellDiv;
};

/**
 * Wrap the given element in an inline-block div and append it to the given 
 * parent element.  Restrict the max size of the wrapper div to be its reported 
 * offset size.  This helps prevent off-by-one pixel errors when the size of the
 * element is really a float instead of an int, as reported by the offset size.  
 * @param {Node} elem DOM element to wrap
 * @param {Node} parentElem Parent DOM element to append child to
 * @param {boolean} bWidth True to restrict the element's width, false otherwise
 * @param {boolean} bHeight True to restrict the element's height, false otherwise
 * @return {Node} The wrapper div element
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon._wrapAndRestrictSize = function(
  elem, parentElem, bWidth, bHeight)
{
  var wrapperDiv = document.createElement("div");
  var wrapperDivStyle = wrapperDiv.style;
  //make sure the wrapper div fits its content
  wrapperDivStyle.display = "inline-block";

  //need to add everything to the DOM before getting sizes
  wrapperDiv.appendChild(elem);
  parentElem.appendChild(wrapperDiv);
  
  //restrict the size of the wrapper div so that it's an integer value
  if (bWidth)
  {
    wrapperDivStyle.maxWidth = wrapperDiv.offsetWidth + "px";
  }
  if (bHeight)
  {
    wrapperDivStyle.maxHeight = wrapperDiv.offsetHeight + "px";
  }
  
  return wrapperDiv;
};

/**
 * Determine if this conveyor belt is horizontal or vertical.
 * @return {boolean} True if the conveyor belt is horizontal, false if vertical
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._isHorizontal = function()
{
  return (this._orientation === "horizontal");
};

/**
 * Determine if this conveyor belt is empty.
 * @return {boolean} True if the conveyor belt is empty, false if not
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._isEmpty = function()
{
  var contentParent = this._getContentParent();
  return !contentParent.hasChildNodes();
};

/**
 * Restore inner DOM to its initial state before sizes were calculated.
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._reinitializeInnerDom = function()
{
  //restore inner DOM to initial state in order to accurately calculate new sizes

  //save original scroll value for use in _adjustOverflowSize()
  this._origScroll = this._getCurrScroll();
  this._clearOverflowMaxSize();
  this._setOverflowScroll(0);

  //hide the buttons until we know we need them
  this._hidePrevButton();
  this._hideNextButton();
};

/**
 * Clear cached sizes.
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._clearCachedSizes = function()
{
  this._totalSize = null;
  this._sizes = null;
};

/**
 * Handle a component resize.
 * @param {boolean} bSetup True when called from setup, false otherwise
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._handleResize = function(bSetup)
{
  //if this is not the first call, need to reinitialize the inner DOM before
  //we can accurately calculate new sizes (if this is the first call, DOM
  //is already in initial state)
  if (!bSetup)
  {
    this._reinitializeInnerDom();
  }
  this._clearCachedSizes();
  if (!this._totalSize || !this._sizes)
  {
    //measure content size
    this._totalSize = this._measureContents();
  }
  //if this is not the first call, need to adjust the overflow size (if this 
  //is the first call, the overflow size was already adjusted in setup)
  if (!bSetup)
  {
    this._adjustOverflowSize();
  }
  //center buttons orthogonal to conveyor orientation
  var totalSize = this._totalSize;
  this._alignButtons(totalSize.w, totalSize.h);
};

/**
 * Center the overflow buttons orthogonal to the conveyor orientation.
 * @param {number} w Width to align inside
 * @param {number} h Height to align inside
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._alignButtons = function(w, h)
{
  var nextButton = this._nextButton;
  var prevButton = this._prevButton;
  var nextButtonStyle = nextButton.style;
  var prevButtonStyle = prevButton.style;
  
  if (this._isHorizontal())
  {
    var vOffset = .5 * (h - this._buttonHeight);
    nextButtonStyle.top = vOffset + "px";
    prevButtonStyle.top = vOffset + "px";
  }
  else
  {
    var hOffset = .5 * (w - this._buttonWidth);
    if (!this._bRtl)
    {
      nextButtonStyle.left = hOffset + "px";
      prevButtonStyle.left = hOffset + "px";
    }
    else
    {
      nextButtonStyle.left = -hOffset + "px";
      prevButtonStyle.left = -hOffset + "px";
    }
  }
};

/**
 * Adjust the overflow size.
 * @param {boolean} bInit True for initialization, false for refresh
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._adjustOverflowSize = function(bInit)
{
  var contentContainer = this._contentContainer;
  var bHoriz = this._isHorizontal();

  var cbcClass = adf.shared.impl.conveyorBelt.ConveyorBeltCommon;
  var elemInnerSize = bHoriz ? 
                      cbcClass._getElemInnerWidth(this._elem) : 
                      cbcClass._getElemInnerHeight(this._elem);
  //constrain the max overflow size if necessary
  if ((bHoriz ? contentContainer.offsetWidth : contentContainer.offsetHeight) > elemInnerSize)
  {
    this._setOverflowMaxSize(elemInnerSize);
  }
  
  this._minScroll = 0;
  //take the button size into account for max scroll position
  this._maxScroll = bHoriz ? 
                    contentContainer.offsetWidth - elemInnerSize + this._buttonWidth : 
                    contentContainer.offsetHeight - elemInnerSize + this._buttonHeight;
  //constrain max scroll
  if (this._maxScroll < 0)
  {
    this._maxScroll = 0;
  }
  
  //hide buttons AFTER calculating sizes above, but BEFORE updating scroll position below
  this._hidePrevButton();
  this._hideNextButton();
  
  //refresh current scroll position AFTER calculating sizes above
  this._setCurrScroll(bInit ? this._minScroll : this._origScroll, true);
  this._origScroll = 0;
};

/**
 * Create the inner overflow and content containers.
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._createInnerContainers = function()
{
  //the original children of the conveyor elem will be reparented to the contentContainer;
  //the conveyor elem will contain the overflowContainer, which will contain the contentContainer, which
  //will contain the original children
  
  var self = this;
  var bHoriz = this._isHorizontal();
  
  var overflowContainer = document.createElement("div");
  this._overflowContainer = overflowContainer;
  var overflowContainerStyle = overflowContainer.style;
  overflowContainerStyle.overflow = "hidden";
  overflowContainerStyle.display = this._getCssDisplay();
  overflowContainerStyle.position = "relative";
  //ojTabs: verticalAlign top is needed so there's no gap between the tab bar and the tab content in Jet Tabs
  if (bHoriz)
  {
    overflowContainerStyle.verticalAlign = "top";
  }
  
  var elem = this._elem;
  var cbcClass = adf.shared.impl.conveyorBelt.ConveyorBeltCommon;
  var contentContainer = document.createElement("div");
  this._contentContainer = contentContainer;
  var contentContainerStyle = contentContainer.style;
  contentContainerStyle.position = "relative";
  if (bHoriz)
  {
    //ojTabs: set display of content container to inline-block so that its size
    //will be driven by its children
    contentContainerStyle.display = "inline-block";
  }
  overflowContainer.appendChild(contentContainer);
  
  var tableDiv = null;
  if (bHoriz)
  {
    //layout the buttons and overflow container in divs styled like table cells
    //in a single row in order to guarantee that they don't accidentally wrap
    //(don't want to specify white-space:nowrap because that would get inherited
    //by the content and either conveyor or the app would potentially have to
    //restore the initial value)
    tableDiv = cbcClass._createTableDiv();
    this._tableDiv = tableDiv;
    var tableRowDiv = cbcClass._createTableRowDiv();
    var tableCellDivPrevButton = cbcClass._createTableCellDiv();
    this._tableCellDivPrevButton = tableCellDivPrevButton;
    var tableCellDivOverflow = cbcClass._createTableCellDiv();
    var tableCellDivNextButton = cbcClass._createTableCellDiv();
    this._tableCellDivNextButton = tableCellDivNextButton;
    
    tableCellDivOverflow.appendChild(overflowContainer);
    tableRowDiv.appendChild(tableCellDivPrevButton);
    tableRowDiv.appendChild(tableCellDivOverflow);
    tableRowDiv.appendChild(tableCellDivNextButton);
    tableDiv.appendChild(tableRowDiv);
  }
  
  //reparent children from elem to contentContainer before adding overflow and
  //content containers to elem;
  //create table to hold content items to enforce either single column or single
  //row layout
  var contentTableDiv = cbcClass._createTableDiv();
  var arContentElements = cbcClass._reparentChildrenToTable(elem, contentTableDiv, bHoriz);
  //if there is a nested contentParent, then we need to put its children into
  //arContentElements instead of the children of the elem
  if (this._contentParent)
  {
    arContentElements = [];
    var contentParent = this._contentParent;
    var contentChildren = contentParent.children;
    var numContentChildren = contentChildren.length;
    for (var i = 0; i < numContentChildren; i++)
    {
      var child = contentChildren[i];
      if (child.nodeType === 1)
      {
        arContentElements.push(child);
      }
    }
  }
  //save the content elements so we can walk through them in _measureContents
  //instead of walking through the table div itself
  this._arContentElements = arContentElements;
  //only need to save the content table and add it to the content container if 
  //there is actual content (this also helps _isEmpty() to function correctly)
  if (arContentElements && arContentElements.length > 0)
  {
    this._contentTableDiv = contentTableDiv;
    contentContainer.appendChild(contentTableDiv);
  }
  
  if (tableDiv)
  {
    elem.appendChild(tableDiv);
  }
  else
  {
    var vertDivPrevButton = document.createElement("div");
    this._vertDivPrevButton = vertDivPrevButton;
    var vertDivNextButton = document.createElement("div");
    this._vertDivNextButton = vertDivNextButton;
    elem.appendChild(vertDivPrevButton);
    elem.appendChild(overflowContainer);
    elem.appendChild(vertDivNextButton);
  }
  
  if (bHoriz)
  {
    //the overflow container is sometimes taller than the content container,
    //apparently because the content container is an inline-block, so we 
    //compensate for that extra, artificial vertical space by reducing the 
    //bottom margin of the overflow container
    var overflowHeight = overflowContainer.offsetHeight;
    var contentHeight = contentContainer.offsetHeight;
    if (overflowHeight > contentHeight)
    {
      overflowContainerStyle.marginBottom = (contentHeight - overflowHeight) + "px";
    }
  }
  
  //the overflow container listens to DOM scroll events in case the scroll was triggered externally,
  //for example when the user tabs through the child content
  cbcClass._addBubbleEventListener(overflowContainer, "scroll", function (event) {self._handleScroll(event);});
};

/**
 * Get the value to use for the CSS display attribute.
 * @return {string} Value to use for CSS display attribute
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._getCssDisplay = function()
{
  return this._isHorizontal() ? "inline-block" : "block";
};

/**
 * Create the prev button.
 * @param {string} buttonId Id to use for the button
 * @param {string} buttonStyleClass Style class to use for the button
 * @param {Node} icon Button icon element
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._createPrevButton = function(
  buttonId, buttonStyleClass, icon)
{
  var self = this;
  var prevButton = document.createElement("div");
  this._prevButton = prevButton;
  if (buttonId)
  {
    prevButton.setAttribute("id", buttonId);
  }
  prevButton.setAttribute("class", buttonStyleClass);
  //hide the button from screen readers because it is not keyboard accessible
  prevButton.setAttribute("aria-hidden", "true");
  var prevButtonStyle = prevButton.style;
  prevButtonStyle.display = this._getCssDisplay();
  prevButtonStyle.position = "relative";
  var bHoriz = this._isHorizontal();
  if (bHoriz)
  {
    prevButtonStyle.verticalAlign = "top";
  }
  var cbcClass = adf.shared.impl.conveyorBelt.ConveyorBeltCommon;
  cbcClass._addBubbleEventListener(prevButton, "click", function (event) {self._scrollPrev();});
  if (this._tableCellDivPrevButton)
  {
    //the button belongs to the table cell
    var tableCell = this._tableCellDivPrevButton;
    
    //wrap the button in another div that we can use to get the size, because
    //the table cell div seems to be one pixel bigger (maybe when the button
    //size is really a float?);
    //then the wrapper div size will be restricted to be the actual reported
    //size of the button, which results in the table cell div being the same size
    this._prevButtonWrapper = cbcClass._wrapAndRestrictSize(prevButton, tableCell, bHoriz, !bHoriz);
  }
  else
  {
    //make the prev button the first child
    var elem = this._vertDivPrevButton;
    elem.appendChild(prevButton);
  }
  
  if (icon)
  {
    prevButton.appendChild(icon);
  }
};

/**
 * Create the next button.
 * @param {string} buttonId Id to use for the button
 * @param {string} buttonStyleClass Style class to use for the button
 * @param {Node} icon Button icon element
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._createNextButton = function(
  buttonId, buttonStyleClass, icon)
{
  var self = this;
  var nextButton = document.createElement("div");
  this._nextButton = nextButton;
  if (buttonId)
  {
    nextButton.setAttribute("id", buttonId);
  }
  nextButton.setAttribute("class", buttonStyleClass);
  //hide the button from screen readers because it is not keyboard accessible
  nextButton.setAttribute("aria-hidden", "true");
  var nextButtonStyle = nextButton.style;
  nextButtonStyle.display = this._getCssDisplay();
  nextButtonStyle.position = "relative";
  var bHoriz = this._isHorizontal();
  if (bHoriz)
  {
    nextButtonStyle.verticalAlign = "top";
  }
  var cbcClass = adf.shared.impl.conveyorBelt.ConveyorBeltCommon;
  cbcClass._addBubbleEventListener(nextButton, "click", function (event) {self._scrollNext();});
  if (this._tableCellDivNextButton)
  {
    //the button belongs to the table cell
    var tableCell = this._tableCellDivNextButton;
    
    //wrap the button in another div that we can use to get the size, because
    //the table cell div seems to be one pixel bigger (maybe when the button
    //size is really a float?);
    //then the wrapper div size will be restricted to be the actual reported
    //size of the button, which results in the table cell div being the same size
    this._nextButtonWrapper = cbcClass._wrapAndRestrictSize(nextButton, tableCell, bHoriz, !bHoriz);
  }
  else
  {
    //make the next button the last child
    var elem = this._vertDivNextButton;
    elem.appendChild(nextButton);
  }
  
  if (icon)
  {
    nextButton.appendChild(icon);
  }
};

/**
 * Get the content parent.
 * @return {Object} parent DOM element of the content
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._getContentParent = function()
{
  //if an explicit content parent was not specified, it will be the _contentContainer
  var contentParent = this._contentParent;
  if (!contentParent)
  {
    contentParent = this._contentContainer;
  }
  return contentParent;
};

/**
 * Measure the contents of the conveyor.
 * @return {Object} Total size of the contents
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._measureContents = function()
{
  var contentParent = this._getContentParent();
  var contentTableDiv = this._contentTableDiv;
  var arContentElements = this._arContentElements;
  var totalSize = {w: 0, h: 0};
  var sizes = [];
  if (contentParent.hasChildNodes() && contentTableDiv && arContentElements &&
      arContentElements.length > 0)
  {
    var children = arContentElements;
    var bHoriz = this._isHorizontal();
    var contentWidth = 0;

    //get the width of the contentContainer, not the contentParent, because
    //in JET, if the children are in a buttonset, for example, the offsetLeft
    //of the children is relative to the contentContainer, not the 
    //contentParent
    var contentContainer = this._contentContainer;
    contentWidth = contentContainer.offsetWidth;

    var startOffset = 0;
    var prevSizeObj = null;
    for (var i = 0; i < children.length; i++)
    {
      var child = children[i];
      if (child.nodeType === 1)
      {
        var ww = child.offsetWidth;
        var hh = child.offsetHeight;
        var childId = child.id;
        var sizeObj = {w: ww, h: hh, id: childId};
        //calculating the start assumes that the browser has done the appropriate layout;
        //subtract 1 from the end so it's the last pixel of this child, not the start of the next child
        if (bHoriz)
        {
          //if RTL, still want to save the start coords in logical, ascending order beginning with 0
          if (this._bRtl)
          {
            sizeObj.start = contentWidth - (child.offsetLeft + ww);
          }
          else
          {
            sizeObj.start = child.offsetLeft;
          }
          
          //Offset each item's start coord by the first item's offset to handle cases like text-align:right,
          //where the items may be right-aligned within the content container.  We still want our logical 
          //coords to start at 0.
          if (i === 0)
            startOffset = sizeObj.start;
          sizeObj.start -= startOffset;
          
          totalSize.w = sizeObj.start + ww;
          totalSize.h = Math.max(totalSize.h, hh);
          sizeObj.end = totalSize.w - 1;
        }
        else
        {
          sizeObj.start = child.offsetTop;
          totalSize.w = Math.max(totalSize.w, ww);
          totalSize.h = sizeObj.start + hh;
          sizeObj.end = totalSize.h - 1;
        }
        
        //if this item overlaps the previous item, adjust the previous item to
        //end just before this item (can happen, for example, with horizontal
        //JET buttonsets)
        if (prevSizeObj)
        {
          if (prevSizeObj.end >= sizeObj.start)
          {
            var overlap = prevSizeObj.end - (sizeObj.start - 1);
            prevSizeObj.end -= overlap;
            if (bHoriz)
            {
              prevSizeObj.w -= overlap;
            }
            else
            {
              prevSizeObj.h -= overlap;
            }
          }
        }
        
        sizes.push(sizeObj);
        prevSizeObj = sizeObj;
      }
    }
  }
  this._sizes = sizes;
  return totalSize;
};

/**
 * Get the array of content sizes.
 * @return {Array} Array of content sizes
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._getSizes = function()
{
  //only calculate sizes if they haven't been calculated already
  if (!this._sizes)
  {
    var totalSize = this._measureContents();
    //only save the total size if it hasn't already been saved
    if (!this._totalSize)
    {
      this._totalSize = totalSize;
    }
  }
  return this._sizes;
};

/**
 * Get the DOM element to use to show or hide the next button.
 * @return {Node} DOM element to use to show or hide the next button
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._getNextButtonDisplayElem = function()
{
  return this._nextButtonWrapper ? this._nextButtonWrapper : this._nextButton;
};

/**
 * Get the DOM element to use to show or hide the prev button.
 * @return {Node} DOM element to use to show or hide the prev button
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._getPrevButtonDisplayElem = function()
{
  return this._prevButtonWrapper ? this._prevButtonWrapper : this._prevButton;
};

/**
 * Show the next button.
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._showNextButton = function()
{
  var elem = this._getNextButtonDisplayElem();
  var style = elem.style;
  style.display = this._getCssDisplay();
};

/**
 * Show the prev button.
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._showPrevButton = function()
{
  var elem = this._getPrevButtonDisplayElem();
  var style = elem.style;
  style.display = this._getCssDisplay();
};

/**
 * Hide the next button.
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._hideNextButton = function()
{
  var elem = this._getNextButtonDisplayElem();
  var style = elem.style;
  style.display = "none";
};

/**
 * Hide the prev button.
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._hidePrevButton = function()
{
  var elem = this._getPrevButtonDisplayElem();
  var style = elem.style;
  style.display = "none";
};

/**
 * Determine if the next button is shown.
 * @return {boolean} true if shown, false if hidden
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._isNextButtonShown = function()
{
  var elem = this._getNextButtonDisplayElem();
  var style = elem.style;
  return style.display !== "none";
};

/**
 * Determine if the prev button is shown.
 * @return {boolean} True if shown, false if hidden
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._isPrevButtonShown = function()
{
  var elem = this._getPrevButtonDisplayElem();
  var style = elem.style;
  return style.display !== "none";
};

/**
 * Get the size of a next/prev button along the direction of conveyor orientation.
 * @return {number} Size of a button
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._getButtonSize = function()
{
  return this._isHorizontal() ? this._buttonWidth : this._buttonHeight;
};

/**
 * Update visibility of the next/prev buttons and adjust scroll position accordingly.
 * @param {number} scroll Desired scroll position
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._updateButtonVisibility = function(scroll)
{
  var buttonSize = this._getButtonSize();
  var ovScroll = this._getCurrScroll();
  var ovSize = this._getCurrViewportSize();
  var bNeedsScroll = this._needsScroll();
  //if scrolling to the start, hide the prev button and reclaim its space
  if (scroll <= this._minScroll)
  {
    if (this._isPrevButtonShown())
    {
      ovSize += buttonSize;
      ovScroll -= buttonSize;
    }
    this._hidePrevButton();
  }
  //if not at the start, show the prev button and allocate space for it
  else if (bNeedsScroll)
  {
    if (!this._isPrevButtonShown())
    {
      ovSize -= buttonSize;
      ovScroll += buttonSize;
    }
    this._showPrevButton();
  }

  //if scrolling to the end, hide the next button and reclaim its space
  if (scroll >= this._maxScroll)
  {
    if (this._isNextButtonShown())
    {
      ovSize += buttonSize;
    }
    this._hideNextButton();
  }
  //if not at the end, show the next button and allocate space for it
  else if (bNeedsScroll)
  {
    if (!this._isNextButtonShown())
    {
      ovSize -= buttonSize;
    }
    this._showNextButton();
  }
  //update the overflow container
  this._setOverflowScroll(ovScroll);
  if (bNeedsScroll)
  {
    this._setOverflowMaxSize(ovSize);
  }
  else
  {
    this._clearOverflowMaxSize();
  }
};

/**
 * Set the max size of the overflow container.
 * @param {number} size Overflow max size
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._setOverflowMaxSize = function(size)
{
  var overflowContainer = this._overflowContainer;
  var overflowContainerStyle = overflowContainer.style;
  var s = size + "px";
  if (this._isHorizontal())
  {
    overflowContainerStyle.maxWidth = s;
  }
  else
  {
    overflowContainerStyle.maxHeight = s;
  }
};

/**
 * Clear the max size of the overflow container.
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._clearOverflowMaxSize = function()
{
  var overflowContainer = this._overflowContainer;
  var overflowContainerStyle = overflowContainer.style;
  if (this._isHorizontal())
  {
    overflowContainerStyle.maxWidth = "";
  }
  else
  {
    overflowContainerStyle.maxHeight = "";
  }
};

/**
 * Set the overflow scroll position.
 * @param {number} scroll Overflow logical scroll position
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._setOverflowScroll = function(scroll)
{
  var overflowContainer = this._overflowContainer;
  if (this._isHorizontal())
  {
    overflowContainer.scrollLeft = this._convertScrollLogicalToBrowser(scroll);
  }
  else
  {
    overflowContainer.scrollTop = scroll;
  }
};

/**
 * Get the current overflow viewport size.
 * @return {number} Overflow viewport size
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._getCurrViewportSize = function()
{
  var overflowContainer = this._overflowContainer;
  return this._isHorizontal() ? overflowContainer.offsetWidth : overflowContainer.offsetHeight;
};

/**
 * Set the scroll position.
 * @param {number} scroll Desired scroll position
 * @param {boolean} bImmediate True to make the change immediately, false to animate it
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._setCurrScroll = function(scroll, bImmediate)
{
  //don't do anything if we're already in the middle of scrolling
  if (!this._bScrolling)
  {
    //if this function is called, the conveyor internally initiated the scroll, so turn off the 
    //flag for an externally triggered scroll
    this._bExternalScroll = false;
    this._setCurrScrollHelper(scroll, bImmediate);
  }
};

/**
 * Helper function to set scroll position.
 * @param {number} scroll Desired scroll position
 * @param {boolean} bImmediate True to make the change immediately, false to animate it
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._setCurrScrollHelper = function(scroll, bImmediate)
{
  if (this._isEmpty())
    return;
  
  this._bScrolling = true;
  scroll = this._constrainScroll(scroll);
  //update button visibility before scrolling
  this._updateButtonVisibility(scroll);
  var scrollFunc = this._scrollFunc;
  //if making the change immediately, simply call the anim end function
  if (bImmediate || !scrollFunc || scroll === this._getCurrScroll())
  {
    this._onScrollAnimEnd(scroll);
  }
  //if animating the change, call out to the provided callback
  else
  {
    var cbcClass = adf.shared.impl.conveyorBelt.ConveyorBeltCommon;
    // 1.1 px/ms is the desired animation speed, so calculate the duration based on the distance to scroll
    var duration = Math.abs(this._getCurrScroll() - scroll) / cbcClass._SCROLL_SPEED;
    var self = this;
    var onEndFunc = function () {self._onScrollAnimEnd(scroll);};
    //need to convert the logical scroll to the browser value for animating
    scrollFunc.call(this._callbackObj, this._overflowContainer, this._convertScrollLogicalToBrowser(scroll), 
                    duration, onEndFunc);
  }
};

/**
 * Get the current scroll position.
 * @return {number} Logical scroll position
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._getCurrScroll = function()
{
  var overflowContainer = this._overflowContainer;
  return this._isHorizontal() ? this._convertScrollBrowserToLogical(overflowContainer.scrollLeft) : 
                                overflowContainer.scrollTop;
};

/**
 * Determine if the conveyor needs to show scroll buttons.
 * @return {boolean} True if scrolling is needed, false if not
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._needsScroll = function()
{
  var contentContainer = this._contentContainer;
  var overflowContainer = this._overflowContainer;
  return this._isHorizontal() ? 
    contentContainer.offsetWidth > overflowContainer.offsetWidth : 
    contentContainer.offsetHeight > overflowContainer.offsetHeight;
};

/**
 * Constrain the scroll position.
 * @param {number} scroll Desired scroll position
 * @return {number} Constrained scroll position
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._constrainScroll = function(scroll)
{
  if (!this._needsScroll() || scroll < this._minScroll)
  {
    scroll = this._minScroll;
  }
  else if (scroll > this._maxScroll)
  {
    scroll = this._maxScroll;
  }
  return scroll;
};

/**
 * Handle a mousewheel event.
 * @param {Object} event Event object
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._handleMouseWheel = function(event)
{
  //if we're already scrolling, just consume the event
  var bConsumeEvent = this._bScrolling;
  if (this._needsScroll() && !this._bScrolling)
  {
    var cbcClass = adf.shared.impl.conveyorBelt.ConveyorBeltCommon;
    var wheelDelta = cbcClass._getWheelDelta(event);
    if (wheelDelta < 0 && this._isNextButtonShown())
    {
      bConsumeEvent = true;
      this._scrollNext();
    }
    else if (wheelDelta > 0 && this._isPrevButtonShown())
    {
      bConsumeEvent = true;
      this._scrollPrev();
    }
  }
  if (bConsumeEvent)
  {
    event.preventDefault();
    event.stopPropagation();
  }
};

/**
 * Handle a touchstart event.
 * @param {Object} event Event object
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._handleTouchStart = function(event)
{
  var eventTouches = event.touches;
  if (this._needsScroll() && !this._bScrolling && eventTouches.length === 1)
  {
    this._bTouch = true;
    //save off some initial information at the start of a swipe
    var firstTouch = eventTouches[0];
    this._touchStartCoord = this._isHorizontal() ? firstTouch.pageX : firstTouch.pageY;
    this._touchStartScroll = this._getCurrScroll();
    this._touchStartNextScroll = this._calcNextScroll();
    this._touchStartPrevScroll = this._calcPrevScroll();
  }
};

/**
 * Handle a touchmove event.
 * @param {Object} event Event object
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._handleTouchMove = function(event)
{
  //only need to do something if we also received the touchstart
  if (this._bTouch)
  {
    var bHoriz = this._isHorizontal();
    var eventTouches = event.touches;
    var firstTouch = eventTouches[0];
    var touchCoord = bHoriz ? firstTouch.pageX : firstTouch.pageY;
    var diff = touchCoord - this._touchStartCoord;
    //only scroll next/prev if the swipe is longer than the threshold; if it's less, then just
    //drag the items with the swipe
    var cbcClass = adf.shared.impl.conveyorBelt.ConveyorBeltCommon;
    var overflowContainer = this._overflowContainer;
    var threshold = cbcClass._SWIPE_THRESHOLD * 
                    (bHoriz ? overflowContainer.offsetWidth : overflowContainer.offsetHeight);
    //if swiping under the threshold, just move the conveyor with the swipe
    if (Math.abs(diff) < threshold)
    {
      this._setCurrScroll(this._touchStartScroll - diff, true);
    }
    //if swiping beyond the threshold, scroll to the next/prev set of items
    else
    {
      //in non-RTL, if swiping left or up, scroll next; otherwise scroll prev
      //in RTL, if swiping right or up, scroll next; otherwise scroll prev
      var bNext = (bHoriz && this._bRtl) ? (diff > 0) : (diff < 0);
      this._setCurrScroll(bNext ? this._touchStartNextScroll : this._touchStartPrevScroll);
      //don't scroll again for this same swipe
      this._bTouch = false;
    }
  }
};

/**
 * Handle a touchend event.
 * @param {Object} event Event object
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._handleTouchEnd = function(event)
{
  //if a full page swipe hasn't happened, scroll back to the original position
  if (this._bTouch)
  {
    this._setCurrScroll(this._touchStartScroll);
  }
  this._bTouch = false;
};

/**
 * Handle a DOM scroll event.
 * @param {Object} event Event object
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._handleScroll = function(event)
{
  //if the scroll was triggered externally, for example by tabbing through 
  //child items, then update the visual state of the conveyor to match the
  //new scroll state
  if (this._bExternalScroll && !this._bScrolling)
  {
    this._setCurrScrollHelper(this._getCurrScroll(), true);
  }
};

/**
 * Function called after a scroll finishes.
 * @param {number} scroll Scroll position
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._onScrollAnimEnd = function(scroll)
{
  //set the desired value after the animation to make sure that the final value is exactly what was intended,
  //in case the animation introduced interpolation errors
  this._setOverflowScroll(scroll);
  //toggle the externalScroll flag in a timeout so that it happens after any current processing finishes
  this._setExternalScrollTimeout();
  this._bScrolling = false;
  //if there is a callback to notify about a change of first visible item, call it now
  if (this._firstVisibleItemChangedFunc)
  {
    this._firstVisibleItemIndex = this._calcFirstVisibleItemIndex();
    //if there is more than one item visible, and the first item is only 
    //partially visible, then save the second item as the actual first visible 
    //item for state purposes (if the last navigation had been prev,
    //we would want the last visible item to remain visible)
    var lastVisIndex = this._calcLastVisibleItemIndex();
    var sizes = this._getSizes();
    var sizeObj = sizes[this._firstVisibleItemIndex];
    if (this._firstVisibleItemIndex !== lastVisIndex &&
        this._getCurrScroll() > sizeObj.start &&
        this._firstVisibleItemIndex < sizes.length - 2)
    {
      this._firstVisibleItemIndex++;
      sizeObj = sizes[this._firstVisibleItemIndex];
    }
    this._firstVisibleItemId = sizeObj.id;
    var firstVisibleItemChangedFunc = this._firstVisibleItemChangedFunc;
    firstVisibleItemChangedFunc.call(this._callbackObj, this._firstVisibleItemId);
  }
};

/**
 * Set a timout to reset the externalScroll flag.
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._setExternalScrollTimeout = function()
{
  var self = this;
  var f = function () {if (self) self._bExternalScroll = true;};
  window.setTimeout(f, 0); 
};

/**
 * Scroll to the next set of items.
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._scrollNext = function()
{
  if (!this._bScrolling)
    this._setCurrScroll(this._calcNextScroll());
};

/**
 * Scroll to the previous set of items.
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._scrollPrev = function()
{
  if (!this._bScrolling)
    this._setCurrScroll(this._calcPrevScroll());
};

/**
 * Calculate the scroll position for the next set of items.
 * @return {number} Next scroll position
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._calcNextScroll = function()
{
  var nextIndex = this._calcNextVisibleItemIndex();
  var scroll = 0;
  //if single item is bigger than viewport, then scroll by viewport size
  if (nextIndex === this._calcFirstVisibleItemIndex())
  {
    scroll = this._getCurrScroll() + this._getCurrViewportSize();
  }
  else
  {
    scroll = this._calcStartScroll(nextIndex);
  }
  return scroll;
};

/**
 * Calculate the scroll position for the previous set of items.
 * @return {number} Previous scroll position
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._calcPrevScroll = function()
{
  var prevIndex = this._calcPrevVisibleItemIndex();
  var scroll = 0;
  //if single item is bigger than viewport, then scroll by viewport size
  if (prevIndex === this._calcLastVisibleItemIndex())
  {
    scroll = this._getCurrScroll() - this._getCurrViewportSize();
  }
  else
  {
    scroll = this._calcEndScroll(prevIndex);
  }
  //if at the end and scrolling prev, anticipate the next button becoming 
  //visible and adjust the scroll position
  if (!this._isNextButtonShown())
  {
    scroll += this._getButtonSize();
  }
  //if scrolling prev and the scroll position is less than the size of the prev button, just
  //scroll to the very beginning because the prev button should get hidden
  if (scroll < this._getButtonSize())
  {
    scroll = this._minScroll;
  }
  return scroll;
};

/**
 * Calculate the scroll position for the start of the specified item.
 * @param {number} index Index of the item to scroll to
 * @return {number} Scroll position
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._calcStartScroll = function(index)
{
  var sizes = this._getSizes();
  var sizeObj = sizes[index];
  return sizeObj.start;
};

/**
 * Calculate the scroll position for the end of the specified item.
 * @param {number} index Index of the item to scroll to
 * @return {number} Scroll position
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._calcEndScroll = function(index)
{
  var sizes = this._getSizes();
  var sizeObj = sizes[index];
  return sizeObj.end - this._getCurrViewportSize() + 1;
};

/**
 * Calculate the index of the first visible item.
 * @return {number} Index of first visible item
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._calcFirstVisibleItemIndex = function()
{
  var currScroll = this._getCurrScroll();
  var i = this._calcItemIndex(currScroll);
  return (i < 0) ? 0 : i;
};

/**
 * Calculate the index of the last visible item.
 * @return {number} Index of last visible item
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._calcLastVisibleItemIndex = function()
{
  var elemSize = this._getCurrViewportSize();
  var currScroll = this._getCurrScroll() + elemSize - 1;
  var i = this._calcItemIndex(currScroll);
  var sizes = this._getSizes();
  return (i < 0) ? sizes.length - 1 : i;
};

/**
 * Calculate the index of the previous visible item.
 * @return {number} Index of previous visible item
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._calcPrevVisibleItemIndex = function()
{
  var currScroll = this._getCurrScroll() - 1;
  var i = this._calcItemIndex(currScroll);
  return (i < 0) ? 0 : i;
};

/**
 * Calculate the index of the next visible item.
 * @return {number} Index of next visible item
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._calcNextVisibleItemIndex = function()
{
  var elemSize = this._getCurrViewportSize();
  var currScroll = this._getCurrScroll() + elemSize;
  var i = this._calcItemIndex(currScroll);
  var sizes = this._getSizes();
  return (i < 0) ? sizes.length - 1 : i;
};

/**
 * Calculate the index of the item at the given scroll position.
 * @param {number} scroll Scroll position
 * @return {number} Index of item at given scroll position
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._calcItemIndex = function(scroll)
{
  var sizes = this._getSizes();
  for (var i = 0; i < sizes.length; i++)
  {
    var sizeObj = sizes[i];
    if (scroll <= sizeObj.end)
      return i;
  }
  return -1;
};

/**
 * Convert a logical scroll position to its corresponding browser value.
 * @param {number} scroll logical scroll position
 * @return {number} browser scroll position
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._convertScrollLogicalToBrowser = function(scroll)
{
  //(comment mostly copied from AdfConveyorBeltSupport)
  //If this is LTR or RTL mode in IE, then we want the default positive new scroll value.
  //If FF in RTL, then get the negative scroll value
  //If Webkit in RTL, to scroll to a position, we resolve this equation:
  // contentContainerWidth - browserScroll = overflowContainerWidth + logicalScroll
  var newScroll = scroll;
  if (this._bRtl && this._isHorizontal())
  {
    if (this._bAgentGecko) {
      newScroll = -scroll;
    }
    else if (this._bAgentWebkit || this._bAgentOpera) {
      var contentContainer = this._contentContainer;
      var overflowContainer = this._overflowContainer;
      newScroll = contentContainer.offsetWidth - overflowContainer.offsetWidth - scroll;
    }
  }
  return newScroll;
};

/**
 * Convert a browser scroll position to its corresponding logical value.
 * @param {number} scroll browser scroll position
 * @return {number} logical scroll position
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon.prototype._convertScrollBrowserToLogical = function(scroll)
{
  //(comment mostly copied from AdfConveyorBeltSupport)
  //If this is LTR or RTL mode in IE, then we want the default positive new scroll value.
  //If FF in RTL, then get the negative scroll value
  //If Webkit in RTL, to scroll to a position, we resolve this equation:
  // contentContainerWidth - browserScroll = overflowContainerWidth + logicalScroll
  
  //because the equations are the same whether converting from browser -> logical or logical -> browser,
  //simply call _convertScrollLogicalToBrowser from here
  //(NOTE: want to leave _convertScrollBrowserToLogical as a separate function so that it's clear from the
  //calling code which conversion direction is used, and in case the conversion impls ever need to be changed)
  return this._convertScrollLogicalToBrowser(scroll);
};

/**
 * Scroll animation speed (px/ms).
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon._SCROLL_SPEED = 1.1;
/**
 * Touch swipe threshold (percentage of conveyor size).
 */
adf.shared.impl.conveyorBelt.ConveyorBeltCommon._SWIPE_THRESHOLD = .33;
/**
 * @class 
 * @constructor
 * @name oj.ojConveyorBelt
 * @augments oj.baseComponent
 * 
 * @classdesc
 * <h3 id="conveyorBeltOverview-section">
 *   JET ConveyorBelt Component
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#conveyorBeltOverview-section"></a>
 * </h3>
 * 
 * <p>Description: Container component that manages overflow for its child
 * components and allows scrolling among them.
 * 
 * <p>A JET ConveyorBelt can be created from any 
 * <code class="prettyprint">&lt;div></code> element that contains
 * multiple child elements at the same level to scroll among.  The root must be
 * a <code class="prettyprint">&lt;div></code> element because the ConveyorBelt 
 * will create additional DOM elements between the root and the scrollable child
 * elements.  
 * <p>The size of the ConveyorBelt must somehow be constrained in order for 
 * there to be overflow to manage, for example by specifying CSS 
 * <code class="prettyprint">max-width</code> or
 * <code class="prettyprint">max-height</code>.  
 * <p>If the elements to be scrolled among are direct children of the
 * ConveyorBelt, then ConveyorBelt will ensure that they are laid out
 * appropriately for its orientation.  However, if the elements to be scrolled
 * among are contained by a single nested descendant element, the 
 * <code class="prettyprint">contentParent</code>, then it is up to calling code
 * to ensure that the elements are laid out appropriately.  For example, 
 * elements can be forced horizontal by using CSS
 * <code class="prettyprint">white-space:nowrap</code>, or vertical by using 
 * <code class="prettyprint">display:block</code>, before creating the 
 * ConveyorBelt.  
 * 
 * <pre class="prettyprint">
 * <code>
 * &lt;div id="conveyorBelt" style="max-width:100px;"
 *      data-bind="ojComponent: {component: 'ojConveyorBelt'}">
 *   &lt;button id="button1">Alpha&lt;/button>
 *   &lt;button id="button2">Beta&lt;/button>
 *   &lt;button id="button3">Gamma&lt;/button>
 *   &lt;button id="button4">Delta&lt;/button>
 *   &lt;button id="button5">Epsilon&lt;/button>
 *   &lt;button id="button6">Zeta&lt;/button>
 * &lt;/div>
 * </code></pre>
 * 
 * <h3 id="keyboard-section">
 *   Keyboard interaction
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
 * </h3>
 *
 * <p>ConveyorBelt does not directly support keyboard interaction.
 * 
 * 
 * <h3 id="accessibility-section">
 *   Accessibility
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#accessibility-section"></a>
 * </h3>
 *
 * <p>ConveyorBelt itself does nothing special for accessibility.  
 * It is the responsibility of the application developer to make the items in 
 * the conveyor accessible.  Sighted keyboard-only users need to be able to 
 * access the items in the conveyor just by using the keyboard.
 * It is up to the child items of the ConveyorBelt to support keyboard 
 * navigation.  If child items support tab navigation, the browser may scroll 
 * them into view when they receive focus.  If child items support other forms 
 * of keyboard navigation, for example by using the arrow keys, it is up to the 
 * child items to scroll themselves into view.  This may be done, for example, 
 * by calling the DOM function <code class="prettyprint">focus()</code> or 
 * <code class="prettyprint">scrollIntoView()</code> on the item.  
 * ConveyorBelt will be aware of tab based or programmatic scrolling and will 
 * honor it, updating itself to toggle visibility of the overflow indicators as 
 * needed.  
 * 
 * 
 * <h3 id="rtl-section">
 *   Reading direction
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#rtl-section"></a>
 * </h3>
 * 
 * <p>As with any JET component, in the unusual case that the directionality 
 * (LTR or RTL) changes post-init, the conveyorBelt must be 
 * <code class="prettyprint">refresh()</code>ed.
 * 
 * 
 * <h3 id="pseudos-section">
 *   Pseudo-selectors
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#pseudos-section"></a>
 * </h3>
 * 
 * <p>The <code class="prettyprint">:oj-conveyorbelt</code> pseudo-selector can 
 * be used in jQuery expressions to select JET ConveyorBelt.  For example:
 * 
 * <pre class="prettyprint">
 * <code>$( ":oj-conveyorbelt" ) // selects all JET ConveyorBelts on the page
 * $myEventTarget.closest( ":oj-conveyorbelt" ) // selects the closest ancestor that is a JET ConveyorBelt
 * </code></pre>
 * 
 * 
 * <h3 id="jqui2jet-section">
 *   JET for jQuery UI developers
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#jqui2jet-section"></a>
 * </h3>
 * 
 * <p>Event names for all JET components are prefixed with "oj", instead of 
 * component-specific prefixes like "conveyorBelt".  
 * 
 * <!-- - - - - Above this point, the tags are for the class.
 *              Below this point, the tags are for the constructor (initializer). - - - - - - -->
 * 
 * @desc Creates a JET ConveyorBelt. 
 * @example <caption>Initialize the conveyorBelt with no options specified:</caption>
 * $( ".selector" ).ojConveyorBelt();
 * 
 * @example <caption>Initialize the conveyorBelt with some options specified:</caption>
 * $( ".selector" ).ojConveyorBelt( { "orientation": "vertical" } );
 * 
 * @example <caption>Initialize the conveyorBelt via the JET 
 * <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;div id="conveyorBelt" data-bind="ojComponent: { component: 'ojConveyorBelt', orientation: 'vertical'}">
 */
(function()
{
oj.__registerWidget("oj.ojConveyorBelt", $['oj']['baseComponent'],
{
  version: "1.0.0",
  defaultElement: "<div>",
  widgetEventPrefix: "oj",

  options:
  {
    /** 
     * Specify the orientation of the conveyorBelt.
     *
     * @expose 
     * @memberof! oj.ojConveyorBelt
     * @instance
     * @type {string}
     * @ojvalue {string} "horizontal" Orient the conveyorBelt horizontally.
     * @ojvalue {string} "vertical" Orient the conveyorBelt vertically.
     * @default <code class="prettyprint">"horizontal"</code>
     *
     * @example <caption>Initialize the conveyorBelt with the 
     * <code class="prettyprint">orientation</code> option specified:</caption>
     * $( ".selector" ).ojConveyorBelt( { "orientation": "vertical" } );
     * 
     * @example <caption>Get or set the <code class="prettyprint">orientation</code> 
     * option after initialization:</caption>
     * // getter
     * var orientation = $( ".selector" ).ojConveyorBelt( "option", "orientation" );
     * 
     * // setter
     * $( ".selector" ).ojConveyorBelt( "option", "orientation", "vertical" );
     */
    orientation: "horizontal",
    /** 
     * Specify the selector of the descendant DOM element in the conveyorBelt
     * that directly contains the items to scroll among.  
     *
     * @expose 
     * @memberof! oj.ojConveyorBelt
     * @instance
     * @type {?string}
     * @default <code class="prettyprint">null</code>
     *
     * @example <caption>Initialize the conveyorBelt with the 
     * <code class="prettyprint">contentParent</code> option specified:</caption>
     * $( ".selector" ).ojConveyorBelt( { "contentParent": "#myContentDiv" } );
     * 
     * @example <caption>Get or set the <code class="prettyprint">contentParent</code> 
     * option after initialization:</caption>
     * // getter
     * var contentParent = $( ".selector" ).ojConveyorBelt( "option", "contentParent" );
     * 
     * // setter
     * $( ".selector" ).ojConveyorBelt( "option", "contentParent", "#myContentDiv" );
     */
    contentParent: null
  },

  /**
   * After _ComponentCreate and _AfterCreate, 
   * the widget should be 100% set up. this._super should be called first.
   * @override
   * @protected
   * @instance
   * @memberof! oj.ojConveyorBelt
   */
  _ComponentCreate : function () // Override of protected base class method.  
  {
    //call superclass first
    this._super();
    
    var elem = this.element;  
    elem.addClass("oj-conveyorbelt oj-component");
  },

  /** 
   * Called every time ojConveyorBelt is called without attributes. It's essentially
   * a hard-reset.
   * @memberof! oj.ojConveyorBelt
   * @instance
   * @override
   * @protected
   */
  _init: function() // Override of protected base class method.  
  {
    this._setup(true);
  },

  // This method currently runs at create, init, and refresh time (since refresh() is called by _init()).
  /**
   * Refreshes the visual state of the conveyorBelt. JET components require a 
   * <code class="prettyprint">refresh()</code> or re-init after the DOM is 
   * programmatically changed underneath the component.
   * 
   * <p>This method does not accept any arguments.
   * 
   * @expose 
   * @memberof! oj.ojConveyorBelt
   * @instance
   * 
   * @example <caption>Invoke the <code class="prettyprint">refresh</code> method:</caption>
   * $( ".selector" ).ojConveyorBelt( "refresh" );
   */
  refresh: function() // Override of public base class method.  
  {
    this._super();
    
    //if RTL has changed, just destroy and recreate the ConveyorBeltCommon
    var bRTL = (this._GetReadingDirection() === "rtl");
    var bRecreate = (bRTL !== this._bRTL);
    if (bRecreate)
    {
      this._destroyCBCommon();
    }
    this._setup(bRecreate);
  },

  // isInit is true for init (create and re-init), false for refresh
  /** 
   * Setup the conveyorBelt.
   * @param {boolean} isInit true if _setup is called from _init(), false
   *        if called from refresh()
   * @memberof! oj.ojConveyorBelt
   * @instance
   * @private
   */
  _setup: function(isInit) // Private, not an override (not in base class).  
  {
    this._bRTL = (this._GetReadingDirection() === "rtl");
    var elem = this.element;  
    var options = this.options;
    if (isInit)
    {
      if (!this._cbCommon)
      {
        var orientation = options.orientation;
        var prevStyleClass = null;
        var nextStyleClass = null;
        var prevIcon = null;
        var nextIcon = null;
        var animateScrollFunc = null;
        if (orientation !== "vertical")
        {
          prevStyleClass = "oj-enabled oj-conveyorbelt-overflow-indicator oj-start oj-default";
          nextStyleClass = "oj-enabled oj-conveyorbelt-overflow-indicator oj-end oj-default";
          prevIcon = this._createIcon("oj-conveyorbelt-overflow-icon oj-start");
          nextIcon = this._createIcon("oj-conveyorbelt-overflow-icon oj-end");
          animateScrollFunc = this._animateScrollLeft;
        }
        else
        {
          prevStyleClass = "oj-enabled oj-conveyorbelt-overflow-indicator oj-top oj-default";
          nextStyleClass = "oj-enabled oj-conveyorbelt-overflow-indicator oj-bottom oj-default";
          prevIcon = this._createIcon("oj-conveyorbelt-overflow-icon oj-top");
          nextIcon = this._createIcon("oj-conveyorbelt-overflow-icon oj-bottom");
          animateScrollFunc = this._animateScrollTop;
        }
        var buttonInfo = {};
        buttonInfo.prevButtonStyleClass = prevStyleClass;
        buttonInfo.nextButtonStyleClass = nextStyleClass;
        buttonInfo.prevButtonIcon = prevIcon;
        buttonInfo.nextButtonIcon = nextIcon;
        var callbackInfo = {};
        callbackInfo.addResizeListener = oj.DomUtils.addResizeListener;
        callbackInfo.removeResizeListener = oj.DomUtils.removeResizeListener;
        //disable scroll animation during testing
        if (elem.attr("_ojConveyorBeltTesting") !== "true")
        {
          callbackInfo.scrollFunc = animateScrollFunc;
        }
        var contentParentElem = null;
        if (options.contentParent)
        {
          contentParentElem = $(options.contentParent)[0];
        }
        this._cbCommon = new window.adf.shared.impl.conveyorBelt.ConveyorBeltCommon(
            elem[0],
            orientation, 
            contentParentElem,
            this._bRTL, 
            buttonInfo, 
            callbackInfo);
      }
    }
    var cbCommon = this._cbCommon;
    cbCommon.setup(isInit);
    if (isInit)
    {
      var children = elem.find(".oj-conveyorbelt-overflow-indicator");
      var numChildren = children.size();
      for (var i = 0; i < numChildren; i++)
      {
        var child = children.get(i);
        this._setupButtonMouseStyles(child);
      }
    }
  },

  /** 
   * Destroy the conveyorBelt.
   * @memberof! oj.ojConveyorBelt
   * @instance
   * @override
   * @protected
   */
  _destroy: function() // Override of protected base class method.  
  {
    this._destroyCBCommon();
    var elem = this.element;
    elem.removeClass("oj-conveyorbelt oj-component");
    
    //call superclass last
    this._super();
  },

  /** 
   * Set an option on the conveyorBelt.
   * @memberof! oj.ojConveyorBelt
   * @instance
   * @override
   * @protected
   */
  _setOption: function(key, value) // Override of protected base class method.
                                   // Method name needn't be quoted since is in externs.js.
  {
    var bRecreate = false;
    switch (key) 
    {
      //when changing containerParent or orientation, just destroy and recreate
      //the ConveyorBeltCommon
      case "containerParent":
      case "orientation":
        bRecreate = true;
        break;
    }
    //if recreating, destroy the ConveyorBeltCommon before calling superclass
    //_setOption
    if (bRecreate)
    {
      this._destroyCBCommon();
    }
    this._super(key, value);
    //if recreating, setup the new ConveyorBeltCommon after calling superclass
    //_setOption
    if (bRecreate)
    {
      this._setup(true);
    }
  },

  /** 
   * Destroy the ConveyorBeltCommon.
   * @memberof! oj.ojConveyorBelt
   * @instance
   * @private
   */
  _destroyCBCommon: function()
  {
    var cbCommon = this._cbCommon;
    if (cbCommon)
    {
      cbCommon.destroy();
    }
    this._cbCommon = null;
  },

  /** 
   * Setup mouse listeners to change button styles.
   * @param {Element} element DOM element to affect
   * @memberof! oj.ojConveyorBelt
   * @private
   */
  _setupButtonMouseStyles: function(element)
  {
    this._on(element,
      {
        mousedown: function( event ) {
          var currTarget = event.currentTarget;
          $(currTarget).addClass("oj-active");
        },
        mouseup: function( event ) {
          var currTarget = event.currentTarget;
          $(currTarget).removeClass("oj-active");
        },
        mouseenter: function( event ) {
          var currTarget = event.currentTarget;
          $(currTarget).addClass("oj-hover");
          $(currTarget).removeClass("oj-default");
        },
        mouseleave: function( event ) {
          var currTarget = event.currentTarget;
          $(currTarget).removeClass("oj-hover");
          $(currTarget).removeClass("oj-active");
          $(currTarget).addClass("oj-default");
        }
      });
  },

  /** 
   * Create a DOM element for an icon.
   * @param {string} iconStyleClass Style class for the icon
   * @memberof! oj.ojConveyorBelt
   * @private
   */
  _createIcon: function(iconStyleClass)
  {
    var span = document.createElement("span");
    span.setAttribute("class", "oj-component-icon oj-clickable-icon " + iconStyleClass);
    return span;
  },

  /** 
   * Animate setting the scrollLeft DOM property.
   * @param {Element} elem DOM element to scroll
   * @param {number} value Scroll value
   * @param {number} duration Duration of animation, in ms
   * @param {function()} onEndFunc Function to call when the animation ends
   * @memberof! oj.ojConveyorBelt
   * @private
   */
  _animateScrollLeft: function(elem, value, duration, onEndFunc)
  {
    var props = {};
    props["scrollLeft"] = value;
    //use swing instead of easeInOutCubic because easeInOutCubic isn't found
    //when running in the cookbook
    $(elem).animate(props, duration, "swing", onEndFunc);
  },

  /** 
   * Animate setting the scrollTop DOM property.
   * @param {Element} elem DOM element to scroll
   * @param {number} value Scroll value
   * @param {number} duration Duration of animation, in ms
   * @param {function()} onEndFunc Function to call when the animation ends
   * @memberof! oj.ojConveyorBelt
   * @private
   */
  _animateScrollTop: function(elem, value, duration, onEndFunc)
  {
    var props = {};
    props["scrollTop"] = value;
    //use swing instead of easeInOutCubic because easeInOutCubic isn't found
    //when running in the cookbook
    $(elem).animate(props, duration, "swing", onEndFunc);
  },
  
  /**
   * Return the subcomponent node represented by the documented locator 
   * attribute values.
   * Test authors should target sub elements using the following names:
   * <ul>
   * <li><b>oj-conveyorbelt-start-overflow-indicator</b>: the start overflow indicator of a
   * horizontal ConveyorBelt</li>
   * <li><b>oj-conveyorbelt-end-overflow-indicator</b>: the end overflow indicator of a
   * horizontal ConveyorBelt</li>
   * <li><b>oj-conveyorbelt-top-overflow-indicator</b>: the top overflow indicator of a
   * vertical ConveyorBelt</li>
   * <li><b>oj-conveyorbelt-bottom-overflow-indicator</b>: the bottom overflow indicator of
   * a vertical ConveyorBelt</li>
   * </ul>
   * @expose
   * @memberof! oj.ojConveyorBelt
   * @instance
   * @override
   * @param {Object} locator An Object containing at minimum a subId property 
   *        whose value is a string, documented by the component, that allows 
   *        the component to look up the subcomponent associated with that 
   *        string.  It contains:<p>
   *        component: optional - in the future there may be more than one 
   *        component contained within a page element<p>
   *        subId: the string, documented by the component, that the component 
   *        expects in getNodeBySubId to locate a particular subcomponent
   * @returns {Element|null} the subcomponent located by the subId string passed
   *          in locator, if found.<p>
   */
  getNodeBySubId: function(locator)
  {
    if (locator == null)
    {
      return this.element ? this.element[0] : null;
    }
    
    var subId = locator['subId'];
    if (subId === "oj-conveyorbelt-start-overflow-indicator") {
      return this.widget().find(".oj-conveyorbelt-overflow-indicator.oj-start")[0];
    }
    if (subId === "oj-conveyorbelt-end-overflow-indicator") {
      return this.widget().find(".oj-conveyorbelt-overflow-indicator.oj-end")[0];
    }
    if (subId === "oj-conveyorbelt-top-overflow-indicator") {
      return this.widget().find(".oj-conveyorbelt-overflow-indicator.oj-top")[0];
    }
    if (subId === "oj-conveyorbelt-bottom-overflow-indicator") {
      return this.widget().find(".oj-conveyorbelt-overflow-indicator.oj-bottom")[0];
    }
    
    // Non-null locators have to be handled by the component subclasses
    return null;
  }
}); // end of oj.__registerWidget

}()); // end of ConveyorBelt wrapper function
/**
 * @class 
 * @name oj.ojThematicMap
 * @augments oj.baseComponent
 * 
 * @classdesc
 * <h3 id="thematicMapOverview-section">
 *   JET Thematic Map Component
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#thematicMapOverview-section"></a>
 * </h3>
 * 
 * <p>Thematic Map component for JET. Thematic maps are used to display data corresponding to a geographic location
 * or region, such as election data for a state or sales by territory for a product.</p>
 * 
 * <p>This component should be bound to an HTML div element, and the SVG DOM that it generates should be treated as a 
 * black box, as it is subject to change.  This component should not be extended.</p>
 * 
 * <pre class="prettyprint">
 * <code>
 * &lt;div data-bind="ojComponent: {
 *   component: 'ojThematicMap',
 *   basemap: 'usa',
 *   areaLayers: [{
 *     layer: 'states',
 *     areaDataLayer: {
 *       areas: [{color:'#003366', location:'FL'},
 *               {color:'#CC3300', location:'TX'},
 *               {color:'#99CC33', location:'CA'}]
 *     }
 *   }]
 * }"/>
 * </code>
 * </pre>
 * 
 * <h3 id="thematicMapOptions-section">
 *   Options
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#thematicMapOptions-section"></a>
 * </h3>
 * 
 * <p>Full documentation for the options method, including APIs for data, style properties, and interactivity, is 
 * available <a title="Options Documentation" href="dvt/thematicMap.xml">here</a>.</p>
 * 
 * @desc Creates a JET Thematic Map.
 * @example <caption>Initialize the Thematic Map with no options specified:</caption>
 * $(".selector").ojThematicMap();
 * 
 * @example <caption>Initialize the Thematic Map with some options:</caption>
 * $(".selector").ojThematicMap({basemap: 'usa'});
 * 
 * @example <caption>Initialize the Thematic Map via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;div data-bind="ojComponent: {component: 'ojThematicMap'}">
 */
oj.__registerWidget('oj.ojThematicMap', $['oj']['dvtBaseComponent'], 
{
  version : "1.0.0", 
  widgetEventPrefix : "oj",
  options: {
    /**
     * Triggered after data items are selected or de-selected.
     * 
     * @property {Object} ui event payload
     * @property {Array} ui.items an array containing objects describing the selected data items
     * @property {string} ui.items.dataLayerId the id of the data layer to which the data item belongs
     * @property {string} ui.items.id the id of the data item
     * 
     * @example <caption>Initialize the component with the <code class="prettyprint">select</code> callback specified:</caption>
     * $(".selector").ojThematicMap({
     *   "select": function(event, ui){}
     * });
     *
     * @example <caption>Bind an event listener to the <code class="prettyprint">ojselect</code> event:</caption>
     * $(".selector").on("ojselect", function(event, ui){});
     * 
     * @expose 
     * @event 
     * @memberof! oj.ojThematicMap
     * @instance
     */
    select : null
  },
  
  _loadedBasemaps : [],
  _checkBasemaps : [],  
  _supportedLocales : ['ar','cs','da','de','el','es','fi','fr','hu','it','iw','ja','ko','nl','no','pl','pt','pt_BR','ro','ru','sk','sv','th','tr','zh_CN','zh_TW'],
 
  
  /**
   * @override
   */
  _CreateComponent : function(context, callback, callbackObj) {
    return DvtThematicMap.newInstance(context, callback, callbackObj);
  },
  
  /**
   * @override
   */
  _GetComponentStyleClasses : function() {
    var styleClasses = this._super();
    styleClasses.push('oj-thematicmap');
    return styleClasses;
  },
  
  /**
   * @override
   */
  _GetChildStyleClasses : function() {
    var styleClasses = this._super();
	  styleClasses['oj-dvtbase oj-thematicmap'] = {'path' : 'animationDuration', 'property' : 'animation-duration'};
    styleClasses['oj-thematicmap-arealayer'] = [
      {'path' : 'styleDefaults/areaStyle', 'property' : 'CSS_BACKGROUND_PROPERTIES'},
      {'path' : 'styleDefaults/labelStyle', 'property' : 'CSS_TEXT_PROPERTIES'}
    ];
    styleClasses['oj-thematicmap-area'] = {'path' : 'styleDefaults/dataAreaDefaults/borderColor', 'property' : 'border-top-color'};
    styleClasses['oj-thematicmap-area oj-hover'] = {'path' : 'styleDefaults/dataAreaDefaults/hoverColor', 'property' : 'border-top-color'};
    styleClasses['oj-thematicmap-area oj-selected'] = [
      {'path' : 'styleDefaults/dataAreaDefaults/selectedInnerColor', 'property' : 'border-top-color'}, 
      {'path' : 'styleDefaults/dataAreaDefaults/selectedOuterColor', 'property' : 'border-bottom-color'}];
    styleClasses['oj-thematicmap-marker'] = [
      {'path' : 'styleDefaults/dataMarkerDefaults/labelStyle', 'property' : 'CSS_TEXT_PROPERTIES'},
      {'path' : 'styleDefaults/dataMarkerDefaults/color', 'property' : 'background-color'},
      {'path' : 'styleDefaults/dataMarkerDefaults/opacity', 'property' : 'opacity'},
      {'path' : 'styleDefaults/dataMarkerDefaults/borderStyle', 'property' : 'border-style'},
      {'path' : 'styleDefaults/dataMarkerDefaults/borderColor', 'property' : 'border-top-color'},
      {'path' : 'styleDefaults/dataMarkerDefaults/borderWidth', 'property' : 'border-width'}
    ];
    return styleClasses;
  },
   
  /**
   * @override
   */
  _LoadResources : function() {
    this._loadBasemap();
  },
  
  /**
   * @override
   */
  _Render : function() {
    // do not render until all basemaps are loaded
    for (var i=0; i<this._checkBasemaps.length; i++) {
      if (!this._loadedBasemaps[this._checkBasemaps[i]])
        return;
    }
    this._checkBasemaps = [];
    this._super();
  },
  
  // Load the basemaps and resource bundles 
  _loadBasemap : function() {
    var basemap = this.options['basemap'];
    if (basemap) {
      var locale = oj.Config.getLocale();
      
      // Track basemaps that need to be loaded before rendering
      basemap = basemap.charAt(0).toUpperCase()+basemap.slice(1);
          
      var areaLayers = this.options['areaLayers'];
      // load area layer basemaps
      if (areaLayers) {
        for (var i=0; i<areaLayers.length; i++) {
          var layer = areaLayers[i]['layer'];
          if (layer) {
            layer = layer.charAt(0).toUpperCase()+layer.slice(1);
            this._loadBasemapHelper(basemap, layer, locale);
          }
        }
      }
      
      // load city basemap
      var pointDataLayers = this.options['pointDataLayers'];
      if (pointDataLayers && pointDataLayers.length > 0)
        this._loadBasemapHelper(basemap, 'Cities', locale);
    }
  },
  
  /**
   * Utility function for loading resource bundles by url.
   * @param {string} url The url of the resource to load
   * @private
   */
  _loadResourceByUrl : function(url) {
    // resource is already loaded or function tried to load this resource but failed
    if(this._loadedBasemaps[url])
      return;
    
    var resolvedUrl = oj.Config.getResourceUrl(url);
    var thisRef = this;
    var loadedBundles = this._loadedBasemaps;
    $.getScript(resolvedUrl, function( data, textStatus, jqxhr ) {
      loadedBundles[url] = true;
      thisRef._Render();
    });
  },
  
  _loadBasemapHelper : function(basemap, layer, locale) {
    var relativeUrl = 'resources/internal-deps/dvt/thematicMap/basemaps/DvtBaseMap'+basemap+layer+'.js';
    this._checkBasemaps.push(relativeUrl);

    if (locale.indexOf('en') === -1) {
      // split locale by subtags and try to load resource bundle that satisfies
      var splitLocale = locale.split('_');
      var localeList = [];
      for (var j = 0; j < splitLocale.length; j++) {
        var tempLocale = '';
        for (var k = 0; k < (j + 1); k++) {
          if (k != 0)
            tempLocale += '_';
          tempLocale += splitLocale[k];
        }
        localeList.push(tempLocale)
      }

      var bundleName = 'resources/internal-deps/dvt/thematicMap/resourceBundles/'+basemap+layer+'Bundle';
      // Go thru list of supported DVT languages
      for (var i = localeList.length - 1; i >= 0; i++) {
        if (this._supportedLocales.indexOf(localeList[i]) !== -1) {
          var bundleUrl = bundleName + "_" + localeList[i] + ".js";
//          this._checkBasemaps.push(bundleUrl);
          this._loadResourceByUrl(bundleUrl);
          break;
        }
      }
    }
    
    this._loadResourceByUrl(relativeUrl);
  },
  
  /**
   * @override
   */
  _HandleEvent : function(event) {
    var type = event && event.getType ? event.getType() : null, selectedItems, selection, i, selectedItem;
    if(type === DvtSelectionEvent.TYPE) {
      selectedItems = [];
      selection = event.getSelection();
      var dataLayerId = null;//event.getParamValue('clientId');
      for(i=0; i<selection.length; i++) {
        selectedItem = {'id': selection[i], 'dataLayerId': dataLayerId};
        selectedItems.push(selectedItem);  
      }
      this._trigger('select', null, {'items': selectedItems});
    }
    else {
      this._super(event);
    }
  },
  
  /**
   * Test authors should target thematic map sub elements using the following names:
   * dataLayerId:area[id] - An area indexed by the given id in a data layer with id dataLayerId
   * dataLayerId:marker[id] - A marker indexed by the given id in a data layer with id dataLayerId
   * @override
   */
  getNodeBySubId : function(locator) {
    return this._super(locator);
  },
  
  /**
   * Thematic map supports the following ids for sub elements:
   * dataLayerId:area[id] - An area indexed by the given id in a data layer with id dataLayerId
   * dataLayerId:marker[id] - A marker indexed by the given id in a data layer with id dataLayerId
   * @override
   */
  getSubIdByNode : function(locator) {
    return this._super(locator);
  },
  
  /**
   * Returns a ThematicMapArea object for automation testing verification.
   * @param {String} dataLayerId The dataLayer id
   * @param {String} id The area id 
   * @return {Object} The thematic map area with the given id 
   *                             within the given data layer or null if none exists
   * @expose
   */
  getArea : function(dataLayerId, id) {
    var auto = this._component.getAutomation();
    return new oj.ThematicMapArea(auto.getData(dataLayerId, 'area', id));
  },
  
  /**
   * Returns a ThematicMapMarker object for automation testing verification.
   * @param {String} dataLayerId The dataLayer id
   * @param {String} id The marker id 
   * @return {Object} The thematic map marker with the given id 
   *                             within the given data layer or null if none exists
   * @expose
   */
  getMarker : function(dataLayerId, id) {
    var auto = this._component.getAutomation();
    return new oj.ThematicMapMarker(auto.getData(dataLayerId, 'marker', id));
  }
});
/**
 * An object used for automation verification of thematic map markers.
 * Applications should not create this object.
 * @param {Object} data An object containing verification data
 * @constructor
 * @export
 */  
oj.ThematicMapMarker = function(data) {
  this._data = data;
};

/**
 * Returns the color of a thematic map marker
 * @return {String} The marker color
 * @export
 */
oj.ThematicMapMarker.prototype.getColor = function() {
  return this._data ? this._data['color'] : null;
};

/**
 * Returns the label of a thematic map marker
 * @return {String} The marker tooltip
 * @export
 */
oj.ThematicMapMarker.prototype.getTooltip = function() {
  return this._data ? this._data['tooltip'] : null;
};

/**
 * Returns the tooltip of a thematic map marker
 * @return {String} The marker tooltip
 * @export
 */
oj.ThematicMapMarker.prototype.getLabel = function() {
  return this._data ? this._data['label'] : null;
};
/**
 * An object used for automation verification of thematic map areas.
 * Applications should not create this object.
 * @param {Object} data An object containing verification data
 * @constructor
 * @export
 */  
oj.ThematicMapArea = function(data) {
  this._data = data;
};

/**
 * Returns the color of a thematic map area
 * @returns {String} The area color
 * @export
 */
oj.ThematicMapArea.prototype.getColor = function() {
  return this._data ? this._data['color'] : null;
};

/**
 * Returns the tooltip of a thematic map area
 * @returns {String} The area tooltip
 * @export
 */
oj.ThematicMapArea.prototype.getTooltip = function() {
  return this._data ? this._data['tooltip'] : null;
};

/**
 * Returns the label of a thematic map area
 * @returns {String} The area label
 * @export
 */
oj.ThematicMapArea.prototype.getLabel = function() {
  return this._data ? this._data['label'] : null;
};
/*!
* jQuery UI Resizable @VERSION
* http://jqueryui.com
*
* Copyright 2014 jQuery Foundation and other contributors
* Released under the MIT license.
* http://jquery.org/license
*
* http://api.jqueryui.com/resizable/
*/

/*
*
* Cloned from resizable.js 4.9.2014 by lmolesky.
*   - This widget is NOT EXPOSED.
*     ojResizable is made available only to dialog and other components that need to call resize functionality.
*   - Options minWidth, minHeight, maxWidth, and maxHeight have been deleted
*   - Removed zIndex option
*   - Removed css write of zIndex (this is supported in style sheets)
*
*/

(function() {

    var mouseHandled = false;
    $( document ).mouseup( function() {
	mouseHandled = false;
    });


    oj.__registerWidget("oj.ojResizable", $['oj']['baseComponent'], {
	version: "1.0.0",
        widgetEventPrefix : "oj", 

	options: {

	/////////////////////////////////////////////////////////////////////////////////////
	//
	// Mouse Options (copied)
	//
	/////////////////////////////////////////////////////////////////////////////////////

	    /** 
             *
             * @private
             * @expose
             * @memberof! oj.ojResizable
	     * @instance
             *
             */
	    cancel: "input,textarea,button,select,option",

	    /** 
             *
             * @private
             * @expose
             * @memberof! oj.ojResizable
	     * @instance
             *
             */
	    distance: 1,

	    /** 
             *
             * @private
             * @expose
             * @memberof! oj.ojResizable
	     * @instance
             *
             */
	    delay: 0,

	/////////////////////////////////////////////////////////////////////////////////////
	//
	// Resize Options
	//
	/////////////////////////////////////////////////////////////////////////////////////


	    /** 
             *
             * @private
             * @expose
             * @memberof! oj.ojResizable
	     * @instance
             *
             */
	    alsoResize: false,
	    /** 
             *
             * @private
             * @expose
             * @memberof! oj.ojResizable
	     * @instance
             *
             */
	    animate: false,
	    /** 
             *
             * @private
             * @expose
             * @memberof! oj.ojResizable
	     * @instance
             *
             */
	    animateDuration: "slow",
	    /** 
             *
             * @private
             * @expose
             * @memberof! oj.ojResizable
	     * @instance
             *
             */
	    animateEasing: "swing",
	    /** 
             *
             * @private
             * @expose
             * @memberof! oj.ojResizable
	     * @instance
             *
             */
	    aspectRatio: false,
	    /** 
             *
             * @private
             * @expose
             * @memberof! oj.ojResizable
	     * @instance
             *
             */
	    autoHide: false,
	    /** 
             *
             * @private
             * @expose
             * @memberof! oj.ojResizable
	     * @instance
             *
             */
	    containment: false,
	    /** 
             *
             * @private
             * @expose
             * @memberof! oj.ojResizable
	     * @instance
             *
             */
	    ghost: false,
	    /** 
             *
             * @private
             * @expose
             * @memberof! oj.ojResizable
	     * @instance
             *
             */
	    grid: false,
	    /** 
             *
             * @private
             * @expose
             * @memberof! oj.ojResizable
	     * @instance
             *
             */
	    handles: "e,s,se",
	    /** 
             *
             * @private
             * @expose
             * @memberof! oj.ojResizable
	     * @instance
             *
             */
	    helper: false,

	    // See #7960
	    // zIndex: 90,

	    /////////////////
	    // callbacks
	    /////////////////


            /**
              * Triggered when the ojResizable is resized.
              *
              * @private
              * @expose
              * @event 
              * @name resize
              * @memberof! oj.ojResizable
              * @instance
              * @property {Event} event <code class="prettyprint">jQuery</code> event object
              * @property {Object} ui Empty object included for consistency with other events
              * 
              * @example <caption>Initialize the buttonset with the <code class="prettyprint">resize</code> callback specified:</caption>
              * $( ".selector" ).ojResizable({
              *     "resize": function( event, ui ) {}
              * });
              * 
              * @example <caption>Bind an event listener to the <code class="prettyprint">ojresize</code> event:</caption>
              * $( ".selector" ).on( "ojresize", function( event, ui ) {} );
              */
	    resize: null,

            /**
              * Triggered on the start of a resize operation.
              *
              * @private
              * @expose
              * @event 
              * @name start
              * @memberof! oj.ojResizable
              * @instance
              * @property {Event} event <code class="prettyprint">jQuery</code> event object
              * @property {Object} ui Empty object included for consistency with other events
              * 
              * @example <caption>Initialize the buttonset with the <code class="prettyprint">start</code> callback specified:</caption>
              * $( ".selector" ).ojResizable({
              *     "start": function( event, ui ) {}
              * });
              * 
              * @example <caption>Bind an event listener to the <code class="prettyprint">ojstart</code> event:</caption>
              * $( ".selector" ).on( "ojstart", function( event, ui ) {} );
              */
	    // note - jqui doc has .on("resizestart" 
	    start: null,


            /**
              * Triggered on the end of a resize operation.
              *
              * @private
              * @expose
              * @event 
              * @name stop
              * @memberof! oj.ojResizable
              * @instance
              * @property {Event} event <code class="prettyprint">jQuery</code> event object
              * @property {Object} ui Empty object included for consistency with other events
              * 
              * @example <caption>Initialize the buttonset with the <code class="prettyprint">stop</code> callback specified:</caption>
              * $( ".selector" ).ojResizable({
              *     "stop": function( event, ui ) {}
              * });
              * 
              * @example <caption>Bind an event listener to the <code class="prettyprint">ojstop</code> event:</caption>
              * $( ".selector" ).on( "ojstop", function( event, ui ) {} );
              */
	    // note - jqui doc has .on("resizestop" 
	    stop: null
	},

	/////////////////////////////////////////////////////////////////////////////////////
	//
	// Mouse Functions (copied)
	//
	/////////////////////////////////////////////////////////////////////////////////////

	_mouseInit: function() {
	    var that = this;

	    this.element
		.bind("mousedown." + this.widgetName, function(event) {
		    return that._mouseDown(event);
		})
		.bind("click." + this.widgetName, function(event) {
		    if (true === $.data(event.target, that.widgetName + ".preventClickEvent")) {
			$.removeData(event.target, that.widgetName + ".preventClickEvent");
			event.stopImmediatePropagation();
			return false;
		    }
		});

	    this.started = false;
	},

	// TODO: make sure destroying one instance of mouse doesn't mess with
	// other instances of mouse
	_mouseDestroy: function() {
	    this.element.unbind("." + this.widgetName);
	    if ( this._mouseMoveDelegate ) {
		this.document
		    .unbind("mousemove." + this.widgetName, this._mouseMoveDelegate)
		    .unbind("mouseup." + this.widgetName, this._mouseUpDelegate);
	    }
	},

	_mouseDown: function(event) {
	    // don't let more than one widget handle mouseStart
	    if ( mouseHandled ) {
		return;
	    }

	    // we may have missed mouseup (out of window)
	    (this._mouseStarted && this._mouseUp(event));

	    this._mouseDownEvent = event;

	    var that = this,
	    btnIsLeft = (event.which === 1),
	    // event.target.nodeName works around a bug in IE 8 with
	    // disabled inputs (#7620)
	    elIsCancel = (typeof this.options.cancel === "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);
	    if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
		return true;
	    }

	    this.mouseDelayMet = !this.options.delay;
	    if (!this.mouseDelayMet) {
		this._mouseDelayTimer = setTimeout(function() {
		    that.mouseDelayMet = true;
		}, this.options.delay);
	    }

	    if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
		this._mouseStarted = (this._mouseStart(event) !== false);
		if (!this._mouseStarted) {
		    event.preventDefault();
		    return true;
		}
	    }

	    // Click event may never have fired (Gecko & Opera)
	    if (true === $.data(event.target, this.widgetName + ".preventClickEvent")) {
		$.removeData(event.target, this.widgetName + ".preventClickEvent");
	    }

	    // these delegates are required to keep context
	    this._mouseMoveDelegate = function(event) {
		return that._mouseMove(event);
	    };
	    this._mouseUpDelegate = function(event) {
		return that._mouseUp(event);
	    };

	    this.document
		.bind( "mousemove." + this.widgetName, this._mouseMoveDelegate )
		.bind( "mouseup." + this.widgetName, this._mouseUpDelegate );

	    event.preventDefault();

	    mouseHandled = true;
	    return true;
	},

	_mouseMove: function(event) {
	    // IE mouseup check - mouseup happened when mouse was out of window
	    if ($.ui.ie && ( !document.documentMode || document.documentMode < 9 ) && !event.button) {
		return this._mouseUp(event);

		// Iframe mouseup check - mouseup occurred in another document
	    } else if ( !event.which ) {
		return this._mouseUp( event );
	    }

	    if (this._mouseStarted) {
		this._mouseDrag(event);
		return event.preventDefault();
	    }

	    if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
		this._mouseStarted =
		    (this._mouseStart(this._mouseDownEvent, event) !== false);
		(this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));
	    }

	    return !this._mouseStarted;
	},

	_mouseUp: function(event) {
	    this.document
		.unbind( "mousemove." + this.widgetName, this._mouseMoveDelegate )
		.unbind( "mouseup." + this.widgetName, this._mouseUpDelegate );

	    if (this._mouseStarted) {
		this._mouseStarted = false;

		if (event.target === this._mouseDownEvent.target) {
		    $.data(event.target, this.widgetName + ".preventClickEvent", true);
		}

		this._mouseStop(event);
	    }

	    mouseHandled = false;
	    return false;
	},

	_mouseDistanceMet: function(event) {
	    return (Math.max(
		Math.abs(this._mouseDownEvent.pageX - event.pageX),
		Math.abs(this._mouseDownEvent.pageY - event.pageY)
	    ) >= this.options.distance
		   );
	},

	_mouseDelayMet: function(/* event */) {
	    return this.mouseDelayMet;
	},


	/////////////////////////////////////////////////////////////////////////////////////
	//
	// Original Resize Functions
	//
	/////////////////////////////////////////////////////////////////////////////////////


	_num: function( value ) {
	    return parseInt( value, 10 ) || 0;
	},

	_isNumber: function( value ) {
	    return !isNaN( parseInt( value , 10 ) );
	},

	_hasScroll: function( el, a ) {

	    if ( $( el ).css( "overflow" ) === "hidden") {
		return false;
	    }

	    var scroll = ( a && a === "left" ) ? "scrollLeft" : "scrollTop",
	    has = false;

	    if ( el[ scroll ] > 0 ) {
		return true;
	    }

	    // TODO: determine which cases actually cause this to happen
	    // if the element doesn't have the scroll set, see if it's possible to
	    // set the scroll
	    el[ scroll ] = 1;
	    has = ( el[ scroll ] > 0 );
	    el[ scroll ] = 0;
	    return has;
	},

        /**
         * Triggered when the ojResizable is created.
         *
         * @private
         * @expose
         * @event 
         * @name create
         * @memberof! oj.ojResizable
         * @instance
         * @property {Event} event <code class="prettyprint">jQuery</code> event object
         * @property {Object} ui Empty object included for consistency with other events
         * 
         * @example <caption>Initialize the buttonset with the <code class="prettyprint">create</code> callback specified:</caption>
         * $( ".selector" ).ojResizable({
         *     "create": function( event, ui ) {}
         * });
         * 
         * @example <caption>Bind an event listener to the <code class="prettyprint">ojcreate</code> event:</caption>
         * $( ".selector" ).on( "ojcreate", function( event, ui ) {} );
         */
	// note - jqui has on("resizecreate", ... need to verify if we need some form of "ojcreate".
	_create: function() {

	    var n, i, handle, axis, hname,
	    that = this,
	    o = this.options;
	    this.element.addClass("oj-resizable");

	    $.extend(this, {
		_aspectRatio: !!(o.aspectRatio),
		aspectRatio: o.aspectRatio,
		originalElement: this.element,
		_proportionallyResizeElements: [],
		_helper: o.helper || o.ghost || o.animate ? o.helper || "oj-resizable-helper" : null
	    });

	    // Wrap the element if it cannot hold child nodes
	    if(this.element[0].nodeName.match(/canvas|textarea|input|select|button|img/i)) {

		this.element.wrap(
		    $("<div class='ui-wrapper' style='overflow: hidden;'></div>").css({
			position: this.element.css("position"),
			width: this.element.outerWidth(),
			height: this.element.outerHeight(),
			top: this.element.css("top"),
			left: this.element.css("left")
		    })
		);

		this.element = this.element.parent().data(
		    "oj-resizable", this.element.resizable( "instance" )
		);

		this.elementIsWrapper = true;

		this.element.css({ marginLeft: this.originalElement.css("marginLeft"), marginTop: this.originalElement.css("marginTop"), marginRight: this.originalElement.css("marginRight"), marginBottom: this.originalElement.css("marginBottom") });
		this.originalElement.css({ marginLeft: 0, marginTop: 0, marginRight: 0, marginBottom: 0});
		// support: Safari
		// Prevent Safari textarea resize
		this.originalResizeStyle = this.originalElement.css("resize");
		this.originalElement.css("resize", "none");

		this._proportionallyResizeElements.push(this.originalElement.css({ position: "static", zoom: 1, display: "block" }));

		// support: IE9
		// avoid IE jump (hard set the margin)
		this.originalElement.css({ margin: this.originalElement.css("margin") });

		this._proportionallyResize();
	    }

	    this.handles = o.handles || (!$(".oj-resizable-handle", this.element).length ? "e,s,se" : { n: ".oj-resizable-n", e: ".oj-resizable-e", s: ".oj-resizable-s", w: ".oj-resizable-w", se: ".oj-resizable-se", sw: ".oj-resizable-sw", ne: ".oj-resizable-ne", nw: ".oj-resizable-nw" });
	    if(this.handles.constructor === String) {

		if ( this.handles === "all") {
		    this.handles = "n,e,s,w,se,sw,ne,nw";
		}

		n = this.handles.split(",");
		this.handles = {};

		for(i = 0; i < n.length; i++) {

		    handle = $.trim(n[i]);
		    hname = "oj-resizable-"+handle;
		    axis = $("<div class='oj-resizable-handle " + hname + "'></div>");

		    // axis.css({ zIndex: o.zIndex });

		    // Todo: refine for alta styles
		    // 
		    // if ("se" === handle) {
		    // axis.addClass("ui-icon ui-icon-gripsmall-diagonal-se");
		    //}

		    this.handles[handle] = ".oj-resizable-"+handle;
		    this.element.append(axis);
		}
	    }

	    this._renderAxis = function(target) {

		var i, axis, padPos, padWrapper;

		target = target || this.element;

		for(i in this.handles) {

		    if(this.handles[i].constructor === String) {
			this.handles[i] = this.element.children( this.handles[ i ] ).first().show();
		    }

		    if (this.elementIsWrapper && this.originalElement[0].nodeName.match(/textarea|input|select|button/i)) {

			axis = $(this.handles[i], this.element);

			padWrapper = /sw|ne|nw|se|n|s/.test(i) ? axis.outerHeight() : axis.outerWidth();

			padPos = [ "padding",
				   /ne|nw|n/.test(i) ? "Top" :
				   /se|sw|s/.test(i) ? "Bottom" :
				   /^e$/.test(i) ? "Right" : "Left" ].join("");

			target.css(padPos, padWrapper);

			this._proportionallyResize();

		    }

		    // TODO: What's that good for? There's not anything to be executed left
		    if(!$(this.handles[i]).length) {
			continue;
		    }
		}
	    };

	    // TODO: make renderAxis a prototype function
	    this._renderAxis(this.element);

	    // removed 
	    // this._handles = $(".oj-resizable-handle", this.element).disableSelection();
	    this._handles = $(".oj-resizable-handle", this.element);

	    this._handles.mouseover(function() {
		if (!that.resizing) {
		    if (this.className) {
			axis = this.className.match(/oj-resizable-(se|sw|ne|nw|n|e|s|w)/i);
		    }
		    that.axis = axis && axis[1] ? axis[1] : "se";
		}
	    });

	    if (o.autoHide) {
		this._handles.hide();
		$(this.element)
		    .addClass("oj-resizable-autohide")
		    .mouseenter(function() {
			if (o.disabled) {
			    return;
			}
			$(this).removeClass("oj-resizable-autohide");
			that._handles.show();
		    })
		    .mouseleave(function(){
			if (o.disabled) {
			    return;
			}
			if (!that.resizing) {
			    $(this).addClass("oj-resizable-autohide");
			    that._handles.hide();
			}
		    });
	    }

	    this._mouseInit();

	},

	/**
	 * Remove the ojResizable functionality completely. 
	 * This will return the element back to its pre-init state.
	 * 
	 * <p>This method does not accept any arguments.
	 * 
         * @private
         * @expose
	 * @method
	 * @name oj.ojResizable#destroy
	 * @memberof! oj.ojResizable
	 * @instance
	 * 
	 * @example <caption>Invoke the <code class="prettyprint">destroy</code> method:</caption>
	 * var destroy = $( ".selector" ).ojResizable( "destroy" );
	 */

	_destroy: function() {

	    this._mouseDestroy();

	    var wrapper,
	    _destroy = function(exp) {
		$(exp).removeClass("oj-resizable oj-resizable-disabled oj-resizable-resizing")
		    .removeData("resizable").removeData("oj-resizable").unbind(".resizable").find(".oj-resizable-handle").remove();
	    };

	    // TODO: Unwrap at same DOM position
	    if (this.elementIsWrapper) {
		_destroy(this.element);
		wrapper = this.element;
		this.originalElement.css({
		    position: wrapper.css("position"),
		    width: wrapper.outerWidth(),
		    height: wrapper.outerHeight(),
		    top: wrapper.css("top"),
		    left: wrapper.css("left")
		}).insertAfter( wrapper );
		wrapper.remove();
	    }

	    this.originalElement.css("resize", this.originalResizeStyle);
	    _destroy(this.originalElement);

	    return this;
	},

	_mouseCapture: function(event) {
	    var i, handle,
	    capture = false;

	    for (i in this.handles) {
		handle = $(this.handles[i])[0];
		if (handle === event.target || $.contains(handle, event.target)) {
		    capture = true;
		}
	    }

	    return !this.options.disabled && capture;
	},

	_mouseStart: function(event) {

	    var curleft, curtop, cursor,
	    o = this.options,
	    iniPos = this.element.position(),
	    el = this.element;

	    this.resizing = true;

	    // Bugfix for http://bugs.jqueryui.com/ticket/1749
	    if ( (/absolute/).test( el.css("position") ) ) {
		el.css({ position: "absolute", top: el.css("top"), left: el.css("left") });
	    } else if (el.is(".ui-draggable")) {
		el.css({ position: "absolute", top: iniPos.top, left: iniPos.left });
	    }

	    this._renderProxy();

	    curleft = this._num(this.helper.css("left"));
	    curtop = this._num(this.helper.css("top"));

	    if (o.containment) {
		curleft += $(o.containment).scrollLeft() || 0;
		curtop += $(o.containment).scrollTop() || 0;
	    }

	    this.offset = this.helper.offset();
	    this.position = { left: curleft, top: curtop };
	    this.size = this._helper ? { width: this.helper.width(), height: this.helper.height() } : { width: el.width(), height: el.height() };
	    this.originalSize = this._helper ? { width: el.outerWidth(), height: el.outerHeight() } : { width: el.width(), height: el.height() };
	    this.originalPosition = { left: curleft, top: curtop };
	    this.sizeDiff = { width: el.outerWidth() - el.width(), height: el.outerHeight() - el.height() };
	    this.originalMousePosition = { left: event.pageX, top: event.pageY };

	    this.aspectRatio = (typeof o.aspectRatio === "number") ? o.aspectRatio : ((this.originalSize.width / this.originalSize.height) || 1);

	    // cursor = $(".oj-resizable-" + this.axis).css("cursor");
	    cursor = /** @type string */ ($(".oj-resizable-" + this.axis).css("cursor"));
	    $("body").css("cursor", cursor === "auto" ? this.axis + "-resize" : cursor);

	    el.addClass("oj-resizable-resizing");
	    this._propagate("start", event);
	    return true;
	},

	_mouseDrag: function(event) {

	    var data,
	    el = this.helper, props = {},
	    smp = this.originalMousePosition,
	    a = this.axis,
	    dx = (event.pageX-smp.left)||0,
	    dy = (event.pageY-smp.top)||0,
	    trigger = this._change[a];

	    this.prevPosition = {
		top: this.position.top,
		left: this.position.left
	    };
	    this.prevSize = {
		width: this.size.width,
		height: this.size.height
	    };

	    if (!trigger) {
		return false;
	    }

	    data = trigger.apply(this, [event, dx, dy]);

	    this._updateVirtualBoundaries(event.shiftKey);
	    if (this._aspectRatio || event.shiftKey) {
		data = this._updateRatio(data, event);
	    }

	    data = this._respectSize(data, event);

	    this._updateCache(data);

	    this._propagate("resize", event);

	    if ( this.position.top !== this.prevPosition.top ) {
		props.top = this.position.top + "px";
	    }
	    if ( this.position.left !== this.prevPosition.left ) {
		props.left = this.position.left + "px";
	    }
	    if ( this.size.width !== this.prevSize.width ) {
		props.width = this.size.width + "px";
	    }
	    if ( this.size.height !== this.prevSize.height ) {
		props.height = this.size.height + "px";
	    }
	    el.css( props );

	    if ( !this._helper && this._proportionallyResizeElements.length ) {
		this._proportionallyResize();
	    }

	    if ( !$.isEmptyObject( props ) ) {
		this._trigger( "resize", event, this.ui() );
	    }

	    return false;
	},

	_mouseStop: function(event) {

	    this.resizing = false;
	    var pr, ista, soffseth, soffsetw, s, left, top,
	    o = this.options, that = this;

	    if(this._helper) {

		pr = this._proportionallyResizeElements;
		ista = pr.length && (/textarea/i).test(pr[0].nodeName);
		soffseth = ista && this._hasScroll(pr[0], "left") /* TODO - jump height */ ? 0 : that.sizeDiff.height;
		soffsetw = ista ? 0 : that.sizeDiff.width;

		s = { width: (that.helper.width() - soffsetw), height: (that.helper.height() - soffseth) };
		left = (parseInt(that.element.css("left"), 10) + (that.position.left - that.originalPosition.left)) || null;
		top = (parseInt(that.element.css("top"), 10) + (that.position.top - that.originalPosition.top)) || null;

		if (!o.animate) {
		    this.element.css($.extend(s, { top: top, left: left }));
		}

		that.helper.height(that.size.height);
		that.helper.width(that.size.width);

		if (this._helper && !o.animate) {
		    this._proportionallyResize();
		}
	    }

	    $("body").css("cursor", "auto");

	    this.element.removeClass("oj-resizable-resizing");

	    this._propagate("stop", event);

	    if (this._helper) {
		this.helper.remove();
	    }

	    return false;

	},

	_updateVirtualBoundaries: function(forceAspectRatio) {
	    var pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b,
	    o = this.options;

	    b = {
		// minWidth: this._isNumber(o.minWidth) ? o.minWidth : 0,
		// maxWidth: this._isNumber(o.maxWidth) ? o.maxWidth : Infinity,
		// minHeight: this._isNumber(o.minHeight) ? o.minHeight : 0,
		// maxHeight: this._isNumber(o.maxHeight) ? o.maxHeight : Infinity

		minWidth: 0,
		maxWidth: Infinity,
		minHeight: 0,
		maxHeight: Infinity
	    };

	    if(this._aspectRatio || forceAspectRatio) {
		pMinWidth = b.minHeight * this.aspectRatio;
		pMinHeight = b.minWidth / this.aspectRatio;
		pMaxWidth = b.maxHeight * this.aspectRatio;
		pMaxHeight = b.maxWidth / this.aspectRatio;

		if(pMinWidth > b.minWidth) {
		    b.minWidth = pMinWidth;
		}
		if(pMinHeight > b.minHeight) {
		    b.minHeight = pMinHeight;
		}
		if(pMaxWidth < b.maxWidth) {
		    b.maxWidth = pMaxWidth;
		}
		if(pMaxHeight < b.maxHeight) {
		    b.maxHeight = pMaxHeight;
		}
	    }
	    this._vBoundaries = b;
	},

	_updateCache: function(data) {
	    this.offset = this.helper.offset();
	    if (this._isNumber(data.left)) {
		this.position.left = data.left;
	    }
	    if (this._isNumber(data.top)) {
		this.position.top = data.top;
	    }
	    if (this._isNumber(data.height)) {
		this.size.height = data.height;
	    }
	    if (this._isNumber(data.width)) {
		this.size.width = data.width;
	    }
	},

	_updateRatio: function( data ) {

	    var cpos = this.position,
	    csize = this.size,
	    a = this.axis;

	    if (this._isNumber(data.height)) {
		data.width = (data.height * this.aspectRatio);
	    } else if (this._isNumber(data.width)) {
		data.height = (data.width / this.aspectRatio);
	    }

	    if (a === "sw") {
		data.left = cpos.left + (csize.width - data.width);
		data.top = null;
	    }
	    if (a === "nw") {
		data.top = cpos.top + (csize.height - data.height);
		data.left = cpos.left + (csize.width - data.width);
	    }

	    return data;
	},

	_respectSize: function( data ) {

	    var o = this._vBoundaries,
	    a = this.axis,
	    ismaxw = this._isNumber(data.width) && o.maxWidth && (o.maxWidth < data.width), ismaxh = this._isNumber(data.height) && o.maxHeight && (o.maxHeight < data.height),
	    isminw = this._isNumber(data.width) && o.minWidth && (o.minWidth > data.width), isminh = this._isNumber(data.height) && o.minHeight && (o.minHeight > data.height),
	    dw = this.originalPosition.left + this.originalSize.width,
	    dh = this.position.top + this.size.height,
	    cw = /sw|nw|w/.test(a), ch = /nw|ne|n/.test(a);
	    if (isminw) {
		data.width = o.minWidth;
	    }
	    if (isminh) {
		data.height = o.minHeight;
	    }
	    if (ismaxw) {
		data.width = o.maxWidth;
	    }
	    if (ismaxh) {
		data.height = o.maxHeight;
	    }

	    if (isminw && cw) {
		data.left = dw - o.minWidth;
	    }
	    if (ismaxw && cw) {
		data.left = dw - o.maxWidth;
	    }
	    if (isminh && ch) {
		data.top = dh - o.minHeight;
	    }
	    if (ismaxh && ch) {
		data.top = dh - o.maxHeight;
	    }

	    // Fixing jump error on top/left - bug #2330
	    if (!data.width && !data.height && !data.left && data.top) {
		data.top = null;
	    } else if (!data.width && !data.height && !data.top && data.left) {
		data.left = null;
	    }

	    return data;
	},

	_proportionallyResize: function() {

	    if (!this._proportionallyResizeElements.length) {
		return;
	    }

	    var i, j, borders, paddings, prel,
	    element = this.helper || this.element;

	    for ( i=0; i < this._proportionallyResizeElements.length; i++) {

		prel = this._proportionallyResizeElements[i];

		if (!this.borderDif) {
		    this.borderDif = [];
		    borders = [prel.css("borderTopWidth"), prel.css("borderRightWidth"), prel.css("borderBottomWidth"), prel.css("borderLeftWidth")];
		    paddings = [prel.css("paddingTop"), prel.css("paddingRight"), prel.css("paddingBottom"), prel.css("paddingLeft")];

		    for ( j = 0; j < borders.length; j++ ) {
			this.borderDif[ j ] = ( parseInt( borders[ j ], 10 ) || 0 ) + ( parseInt( paddings[ j ], 10 ) || 0 );
		    }
		}

		prel.css({
		    height: (element.height() - this.borderDif[0] - this.borderDif[2]) || 0,
		    width: (element.width() - this.borderDif[1] - this.borderDif[3]) || 0
		});

	    }

	},

	_renderProxy: function() {

	    var el = this.element, o = this.options;
	    this.elementOffset = el.offset();

	    if(this._helper) {

		this.helper = this.helper || $("<div style='overflow:hidden;'></div>");

		this.helper.addClass(this._helper).css({
		    width: this.element.outerWidth() - 1,
		    height: this.element.outerHeight() - 1,
		    position: "absolute",
		    left: this.elementOffset.left +"px",
		    top: this.elementOffset.top +"px"
		    // zIndex: ++o.zIndex //TODO: Don't modify option
		});

		this.helper
		    .appendTo("body")
		    .disableSelection();

	    } else {
		this.helper = this.element;
	    }

	},

	_change: {
	    "e": function(event, dx) {
		return { width: this.originalSize.width + dx };
	    },
	    "w": function(event, dx) {
		var cs = this.originalSize, sp = this.originalPosition;
		return { left: sp.left + dx, width: cs.width - dx };
	    },
	    "n": function(event, dx, dy) {
		var cs = this.originalSize, sp = this.originalPosition;
		return { top: sp.top + dy, height: cs.height - dy };
	    },
	    "s": function(event, dx, dy) {
		return { height: this.originalSize.height + dy };
	    },
	    "se": function(event, dx, dy) {
		return $.extend(this._change["s"].apply(this, arguments), this._change["e"].apply(this, [event, dx, dy]));
	    },
	    "sw": function(event, dx, dy) {
		return $.extend(this._change["s"].apply(this, arguments), this._change["w"].apply(this, [event, dx, dy]));
	    },
	    "ne": function(event, dx, dy) {
		return $.extend(this._change["n"].apply(this, arguments), this._change["e"].apply(this, [event, dx, dy]));
	    },
	    "nw": function(event, dx, dy) {
		return $.extend(this._change["n"].apply(this, arguments), this._change["w"].apply(this, [event, dx, dy]));
	    }
	},

	_propagate: function(n, event) {
	    $.ui.plugin.call(this, n, [event, this.ui()]);
	    (n !== "resize" && this._trigger(n, event, this.ui()));
	},

	plugins: {},

	ui: function() {
	    return {
		originalElement: this.originalElement,
		element: this.element,
		helper: this.helper,
		position: this.position,
		size: this.size,
		originalSize: this.originalSize,
		originalPosition: this.originalPosition,
		prevSize: this.prevSize,
		prevPosition: this.prevPosition
	    };
	}

    });

    /*
* Resizable Extensions
*/

    $.ui.plugin.add("resizable", "animate", {

	stop: function( event ) {
	    // var that = $(this).resizable( "instance" ),
	    var that = $(this).data("oj-resizable"), // e

	    o = that.options,
	    pr = that._proportionallyResizeElements,
	    ista = pr.length && (/textarea/i).test(pr[0].nodeName),
	    soffseth = ista && that._hasScroll(pr[0], "left") /* TODO - jump height */ ? 0 : that.sizeDiff.height,
	    soffsetw = ista ? 0 : that.sizeDiff.width,
	    style = { width: (that.size.width - soffsetw), height: (that.size.height - soffseth) },
	    left = (parseInt(that.element.css("left"), 10) + (that.position.left - that.originalPosition.left)) || null,
	    top = (parseInt(that.element.css("top"), 10) + (that.position.top - that.originalPosition.top)) || null;

	    that.element.animate(
		$.extend(style, top && left ? { top: top, left: left } : {}), {
		    duration: o.animateDuration,
		    easing: o.animateEasing,
		    step: function() {

			var data = {
			    width: parseInt(that.element.css("width"), 10),
			    height: parseInt(that.element.css("height"), 10),
			    top: parseInt(that.element.css("top"), 10),
			    left: parseInt(that.element.css("left"), 10)
			};

			if (pr && pr.length) {
			    $(pr[0]).css({ width: data.width, height: data.height });
			}

			// propagating resize, and updating values for each animation step
			that._updateCache(data);
			that._propagate("resize", event);

		    }
		}
	    );
	}

    });

    $.ui.plugin.add( "resizable", "containment", {

	start: function() {
	    var element, p, co, ch, cw, width, height;

	    // that = $( this ).resizable( "instance" ),
	    var that = $(this).data("oj-resizable"); // z

	    var o = that.options,
	    el = that.element,
	    oc = o.containment,
	    ce = ( oc instanceof $ ) ? oc.get( 0 ) : ( /parent/.test( oc ) ) ? el.parent().get( 0 ) : oc;

	    if ( !ce ) {
		return;
	    }

	    that.containerElement = $( ce );

	    if ( /document/.test( oc ) || oc === document ) {
		that.containerOffset = {
		    left: 0,
		    top: 0
		};
		that.containerPosition = {
		    left: 0,
		    top: 0
		};

		that.parentData = {
		    element: $( document ),
		    left: 0,
		    top: 0,
		    width: $( document ).width(),
		    height: $( document ).height() || document.body.parentNode.scrollHeight
		};
	    } else {
		element = $( ce );
		p = [];
		$([ "Top", "Right", "Left", "Bottom" ]).each(function( i, name ) {
		    p[ i ] = that._num( element.css( "padding" + name ) );
		});

		that.containerOffset = element.offset();
		that.containerPosition = element.position();
		that.containerSize = {
		    height: ( element.innerHeight() - p[ 3 ] ),
		    width: ( element.innerWidth() - p[ 1 ] )
		};

		co = that.containerOffset;
		ch = that.containerSize.height;
		cw = that.containerSize.width;
		width = ( that._hasScroll ( ce, "left" ) ? ce.scrollWidth : cw );
		height = ( that._hasScroll ( ce ) ? ce.scrollHeight : ch ) ;

		that.parentData = {
		    element: ce,
		    left: co.left,
		    top: co.top,
		    width: width,
		    height: height
		};
	    }
	},

	resize: function( event, ui ) {
	    var woset, hoset, isParent, isOffsetRelative;

	    // that = $( this ).resizable( "instance" ),
	    var that = $(this).data("oj-resizable"); // y

	    var o = that.options,
	    co = that.containerOffset,
	    cp = that.position,
	    pRatio = that._aspectRatio || event.shiftKey,
	    cop = {
		top: 0,
		left: 0
	    },
	    ce = that.containerElement,
	    continueResize = true;

	    if ( ce[ 0 ] !== document && ( /static/ ).test( ce.css( "position" ) ) ) {
		cop = co;
	    }

	    if ( cp.left < ( that._helper ? co.left : 0 ) ) {
		that.size.width = that.size.width + ( that._helper ? ( that.position.left - co.left ) : ( that.position.left - cop.left ) );
		if ( pRatio ) {
		    that.size.height = that.size.width / that.aspectRatio;
		    continueResize = false;
		}
		that.position.left = o.helper ? co.left : 0;
	    }

	    if ( cp.top < ( that._helper ? co.top : 0 ) ) {
		that.size.height = that.size.height + ( that._helper ? ( that.position.top - co.top ) : that.position.top );
		if ( pRatio ) {
		    that.size.width = that.size.height * that.aspectRatio;
		    continueResize = false;
		}
		that.position.top = that._helper ? co.top : 0;
	    }

	    that.offset.left = that.parentData.left + that.position.left;
	    that.offset.top = that.parentData.top + that.position.top;

	    woset = Math.abs( ( that._helper ? that.offset.left - cop.left : ( that.offset.left - co.left ) ) + that.sizeDiff.width );
	    hoset = Math.abs( ( that._helper ? that.offset.top - cop.top : ( that.offset.top - co.top ) ) + that.sizeDiff.height );

	    isParent = that.containerElement.get( 0 ) === that.element.parent().get( 0 );
	    isOffsetRelative = /relative|absolute/.test( that.containerElement.css( "position" ) );

	    if ( isParent && isOffsetRelative ) {
		woset -= Math.abs( that.parentData.left );
	    }

	    if ( woset + that.size.width >= that.parentData.width ) {
		that.size.width = that.parentData.width - woset;
		if ( pRatio ) {
		    that.size.height = that.size.width / that.aspectRatio;
		    continueResize = false;
		}
	    }

	    if ( hoset + that.size.height >= that.parentData.height ) {
		that.size.height = that.parentData.height - hoset;
		if ( pRatio ) {
		    that.size.width = that.size.height * that.aspectRatio;
		    continueResize = false;
		}
	    }

	    if ( !continueResize ){
		that.position.left = ui.prevPosition.left;
		that.position.top = ui.prevPosition.top;
		that.size.width = ui.prevSize.width;
		that.size.height = ui.prevSize.height;
	    }
	},

	stop: function(){

	    // var that = $( this ).resizable( "instance" ),
	    var that = $(this).data("oj-resizable"), // x

	    o = that.options,
	    co = that.containerOffset,
	    cop = that.containerPosition,
	    ce = that.containerElement,
	    helper = $( that.helper ),
	    ho = helper.offset(),
	    w = helper.outerWidth() - that.sizeDiff.width,
	    h = helper.outerHeight() - that.sizeDiff.height;

	    if ( that._helper && !o.animate && ( /relative/ ).test( ce.css( "position" ) ) ) {
		$( this ).css({
		    left: ho.left - cop.left - co.left,
		    width: w,
		    height: h
		});
	    }

	    if ( that._helper && !o.animate && ( /static/ ).test( ce.css( "position" ) ) ) {
		$( this ).css({
		    left: ho.left - cop.left - co.left,
		    width: w,
		    height: h
		});
	    }
	}
    });

    $.ui.plugin.add("resizable", "alsoResize", {

	start: function () {
	    //var that = $(this).resizable( "instance" ),
	    var that = $(this).data("oj-resizable"), // w

	    o = that.options,
	    _store = function (exp) {
		$(exp).each(function() {
		    var el = $(this);
		    el.data("oj-resizable-alsoresize", {
			width: parseInt(el.width(), 10), height: parseInt(el.height(), 10),
			left: parseInt(el.css("left"), 10), top: parseInt(el.css("top"), 10)
		    });
		});
	    };

	    if (typeof(o.alsoResize) === "object" && !o.alsoResize.parentNode) {
		if (o.alsoResize.length) { o.alsoResize = o.alsoResize[0]; _store(o.alsoResize); }
		else { $.each(o.alsoResize, function (exp) { _store(exp); }); }
	    }else{
		_store(o.alsoResize);
	    }
	},

	resize: function (event, ui) {

	    // var that = $(this).resizable( "instance" ),
	    var that = $(this).data("oj-resizable"), // v

	    o = that.options,
	    os = that.originalSize,
	    op = that.originalPosition,
	    delta = {
		height: (that.size.height - os.height) || 0, width: (that.size.width - os.width) || 0,
		top: (that.position.top - op.top) || 0, left: (that.position.left - op.left) || 0
	    },

	    _alsoResize = function (exp, c) {
		$(exp).each(function() {
		    var el = $(this), start = $(this).data("oj-resizable-alsoresize"), style = {},
		    css = c && c.length ? c : el.parents(ui.originalElement[0]).length ? ["width", "height"] : ["width", "height", "top", "left"];

		    $.each(css, function (i, prop) {
			var sum = (start[prop]||0) + (delta[prop]||0);
			if (sum && sum >= 0) {
			    style[prop] = sum || null;
			}
		    });

		    el.css(style);
		});
	    };

	    if (typeof(o.alsoResize) === "object" && !o.alsoResize.nodeType) {
		$.each(o.alsoResize, function (exp, c) { _alsoResize(exp, c); });
	    }else{
		_alsoResize(o.alsoResize, null);
	    }
	},

	stop: function () {
	    $(this).removeData("resizable-alsoresize");
	}
    });

    $.ui.plugin.add("resizable", "ghost", {

	start: function() {

	    // var that = $(this).resizable( "instance" ), o = that.options, cs = that.size;
	    var that = $(this).data( "oj-resizable" ), o = that.options, cs = that.size;

	    that.ghost = that.originalElement.clone();
	    that.ghost
		.css({ opacity: 0.25, display: "block", position: "relative", height: cs.height, width: cs.width, margin: 0, left: 0, top: 0 })
		.addClass("oj-resizable-ghost")
		.addClass(typeof o.ghost === "string" ? o.ghost : "");

	    that.ghost.appendTo(that.helper);

	},

	resize: function(){

	    // var that = $(this).resizable( "instance" ),
	    var that = $(this).data("oj-resizable");  // b

	    if (that.ghost) {
		that.ghost.css({ position: "relative", height: that.size.height, width: that.size.width });
	    }
	},

	stop: function() {

	    // var that = $(this).resizable( "instance" );
	    var that = $(this).data("oj-resizable"); // c

	    if (that.ghost && that.helper) {
		that.helper.get(0).removeChild(that.ghost.get(0));
	    }
	}

    });

    $.ui.plugin.add("resizable", "grid", {

	resize: function() {

	    // var that = $(this).resizable( "instance" ),
	    var that = $(this).data("oj-resizable"), // d
	    
	    o = that.options,
	    cs = that.size,
	    os = that.originalSize,
	    op = that.originalPosition,
	    a = that.axis,
	    grid = typeof o.grid === "number" ? [o.grid, o.grid] : o.grid,
	    gridX = (grid[0]||1),
	    gridY = (grid[1]||1),
	    ox = Math.round((cs.width - os.width) / gridX) * gridX,
	    oy = Math.round((cs.height - os.height) / gridY) * gridY,
	    newWidth = os.width + ox,
	    newHeight = os.height + oy,
	    isMaxWidth = o.maxWidth && (o.maxWidth < newWidth),
	    isMaxHeight = o.maxHeight && (o.maxHeight < newHeight),
	    isMinWidth = o.minWidth && (o.minWidth > newWidth),
	    isMinHeight = o.minHeight && (o.minHeight > newHeight);

	    o.grid = grid;

	    if (isMinWidth) {
		newWidth = newWidth + gridX;
	    }
	    if (isMinHeight) {
		newHeight = newHeight + gridY;
	    }
	    if (isMaxWidth) {
		newWidth = newWidth - gridX;
	    }
	    if (isMaxHeight) {
		newHeight = newHeight - gridY;
	    }

	    if (/^(se|s|e)$/.test(a)) {
		that.size.width = newWidth;
		that.size.height = newHeight;
	    } else if (/^(ne)$/.test(a)) {
		that.size.width = newWidth;
		that.size.height = newHeight;
		that.position.top = op.top - oy;
	    } else if (/^(sw)$/.test(a)) {
		that.size.width = newWidth;
		that.size.height = newHeight;
		that.position.left = op.left - ox;
	    } else {
		if ( newHeight - gridY > 0 ) {
		    that.size.height = newHeight;
		    that.position.top = op.top - oy;
		} else {
		    that.size.height = gridY;
		    that.position.top = op.top + os.height - gridY;
		}
		if ( newWidth - gridX > 0 ) {
		    that.size.width = newWidth;
		    that.position.left = op.left - ox;
		} else {
		    that.size.width = gridX;
		    that.position.left = op.left + os.width - gridX;
		}
	    }
	}

    });

    // return $.ui.resizable;

}() );

// lory retrieved from https://raw.github.com/jquery/jquery-ui/1-10-stable/ui/jquery.ui.dialog.js on 09/03/2013, and then modified


//
// Issues: do we want our own copy of $ui.dialog ? 
// Notes:
//  -  $.ui.dialog.overlayInstances and $.ui.dialog['overlayInstances'] are synonyms
//  - $.uiBackCompat has been deprecated
//


/*!
 * jQuery UI Dialog @VERSION
 * http://jqueryui.com
 *
 * Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/dialog/
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 *  // jquery.ui.button.js
 *  jquery.oj.ojButton.js
 *	jquery.ui.draggable.js
 *	jquery.ui.mouse.js
 *	jquery.ui.position.js
 *	jquery.ui.resizable.js
 */
(function() {

    var /** @const */ _placeHolderPrefix = "ojDialogPlaceHolder-";
    var /** @const */ _wrapperPrefix = "ojDialogWrapper-";
    var /** @const */ _putback = true;

    var sizeRelatedOptions = {
	buttons: true,
	height: true,
/*
	maxHeight: true,
	maxWidth: true,
	minHeight: true,
	minWidth: true,
*/
	width: true
    },
    resizableRelatedOptions = {
	/*
	maxHeight: true,
	maxWidth: true,
	minHeight: true,
	minWidth: true
*/
    };

    /**
    * @class
    * @name oj.ojDialog
    *
    * @classdesc
    * <h3 id="dialogOverview-section">
    *   JET Dialog Component
    *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#dialogOverview-section"></a>
    * </h3>
    * <p>Description: Themeable, WAI-ARIA-compliant dialog component.
    * A dialog is a floating window that typically contains a title bar and a content area. 
    * The dialog window can be moved, resized and with the title area, and closed with the 'x' icon by default.</p>
    *
    *<p>If the content length exceeds the maximum height, a scrollbar will automatically appear.</p>
    *
    *<p>A bottom button bar and semi-transparent modal overlay layer are common options that can be added.</p>
    *
    *<h3>Focus</h3>
    *
    *<p>Upon opening a dialog, focus is automatically moved to the first item that matches the following:</p>
    *<ol>
    *  <li>The first element within the dialog with the <code>autofocus</code> attribute</li>
    *  <li>The first <a href="/tabbable-selector/"><code>:tabbable</code></a> element within the dialog's content</li>
    *  <li>The first <a href="/tabbable-selector/"><code>:tabbable</code></a> element within the dialog's buttonpane</li>
    *  <li>The dialog's close button</li>
    *  <li>The dialog itself</li>
    *</ol>
    *<p>While open, the dialog widget ensures that tabbing cycles focus between elements within the dialog itself, not elements outside of it. Modal dialogs additionally prevent mouse users fro  clicking on elements outside of the dialog.</p>
    *
    *<p>Upon closing a dialog, focus is automatically returned to the element that had focus when the dialog was opened.</p>
    *
    *<h3>HTML Markup and Style Classes</h3>
    *
    * Three formatting classes are provided:
    *
    *<ul>
    *  <li> <b> oj-dialog-header </b> </li>
    *  Optional. If oj-dialog-header is omitted, a header will automatically be created. 
    *  <li> <b> oj-dialog-body </b> </li>
    *  Expected. Formats the body of the dialog.
    *  <li> <b> oj-dialog-footer </b> </li>
    *  Expected. Formats the footer of the dialog.
    *</ul>
    *
    * For automically created headers, the title of the header is the dialog title. A close button will also be created.
    *
    *<h3>Examples</h3>
    *
    * The following defines a basic dialog.
    *
    * <pre class="prettyprint">
    * <code>
    *
    * &lt;div id="dialog" class="ojDialog" title="ojDialog Title"&gt;
    *     &lt;div class="oj-dialog-body"&gt;
    *         &lt;p&gt;Dialog Text&lt;/p&gt;
    *     &lt;/div&gt;
    *     &lt;div class="oj-dialog-footer"&gt;
    *        &lt;button id="buttonCancel" data-bind="ojComponent: 
    *              { component: 'ojButton', label: 'OK'}"&gt; &lt;/button&gt;
    *        &lt;button data-bind="ojComponent: 
    *              { component: 'ojButton', label: 'Cancel'}"&gt; &lt;/button&gt;
    *     &lt;/div&gt;
    * &lt;/div&gt;
    *
    * </code></pre>
    *
    * A dialog with user-defined header is shown next. Arbitrary header content can be defined using a user-defined header.
    *
    * <pre class="prettyprint">
    * <code>
    *
    * &lt;div id="dialog" class="ojDialog" title="ojDialog Title"&gt;
    *   &lt;div class="oj-dialog-header" aria-labelledby="dialog-title-id"&gt;
    *     &lt;span id="dialog-title-id" class="oj-dialog-title"&gt; User Defined Header&lt;/span&gt;
    *    &lt;/div&gt;
    *    &lt;div class="oj-dialog-body"&gt;
    *        &lt;p&gt;Dialog Text&lt;/p&gt;
    *        &lt;br&gt;
    *    &lt;/div&gt;
    *    &lt;div class="oj-dialog-footer"&gt;
    *       &lt;button data-bind="ojComponent: 
    *           { component: 'ojButton', label: 'OK'}"&gt; &lt;/button&gt;
    *       &lt;button id="buttonCancel" class="" data-bind="ojComponent: 
    *           { component: 'ojButton', label: 'Cancel'}"&gt; &lt;/button&gt;
    *    &lt;/div&gt;
    * &lt;/div&gt;
    * 
    * </code></pre>
    *
    * @desc Creates a JET Dialog.
    * @param {Object=} options a map of option-value pairs to set on the component
    * @example <caption>Initialize a (modal) dialog with no options specified:</caption>
    * $( ".selector" ).ojDialog();
    * @example <caption>Create a modeless dialog of width 400:</caption>
    * $("#dialog").ojDialog({width: '400', modality: "modeless"});
    */
    oj.__registerWidget("oj.ojDialog", $['oj']['baseComponent'], {
	version: "1.0.0",
        widgetEventPrefix : "oj", 
	options: 
	{
	    // Specify the appendTo container of the dialog. 
            // If the appendTo container is null, then dialogs will be appended inline.
            // Setting to "body" would append all dialogs to the end of the body.
	    /** 
             *
             * @expose 
             * @memberof! oj.ojDialog
	     * @instance
             * @type {string|null}
             * @deprecated 
             *
             */
	    // appendTo: null,


	    // 
            // <p> Specifies the location of open dialogs.
            // The default is "auto". 
            // "body" will append dialog content (for open dialogs) to the end of the HTML body.
            // The alternative is "inline", which will position dialog content in the same DOM hierarchy as the user's dialog markup.
            //
            // @expose 
            // @memberof! oj.ojDialog
            // @instance
            // @type {string}
            // @default <code class="prettyprint">"body"</code>
            //
            // @example <caption>Initialize the dialog with the <code class="prettyprint">location</code> option specified:</caption>
            // $(".selector" ).ojDialog( {location: "show" } );
            // 
            // @example <caption>Get or set the <code class="prettyprint">location</code> option, after initialization:</caption>
            // // getter
            // var location = $(".selector" ).ojDialog( "option", "location" );
            // 
            // // setter
            // $(".selector" ).ojDialog( "option", "location", "inline");
            // 
	    // location: "auto",

	    // 
             // @expose 
             // @memberof! oj.ojDialog
	     // @instance
             // @deprecated Replaced by initialVisibility.
             //
	    // autoOpen: true,

	    // 
             // @expose 
             // @memberof! oj.ojDialog
	     // @instance
             // @deprecated Replaced by html markup.
             //
	    // buttons: [],
	    //
             //
             // @expose 
             // @memberof! oj.ojDialog
             // @instance
             // @deprecated (replaced by cancelBehavior)
            //
	    // escapeBehavior: "close",

	    /**
	     * Specifies the cancel behavior of the dialog. The following are valid values:
             *
             * <ul>
             * <li> 
	     * <code class="prettyprint">"icon"</code> - (the default) (a) a close icon will automatically be created, and (b) the dialog will close when it has focus and user presses the escape (ESC) key.
             * </li> 
             * <li> 
	     * <code class="prettyprint">"none"</code> - no actions will be associated with the escape key.
             * </li> 
             * <li> 
	     * <code class="prettyprint">"escape"</code> -  the dialog will close when it has focus and user presses the escape (ESC) key. A close icon will not automatically be created.
             * </li> 
             * </ul>
             *
             * Note that the cancelBehavior applies to both automatic and user-defined headers. So by default, a user-defined header will have a system generated close icon.
             * @expose 
             * @memberof! oj.ojDialog
             * @instance
             * @type {string}
             * @default <code class="prettyprint">"icon"</code>
             *
             * @example <caption>Initialize the dialog to disable the default <code class="prettyprint">cancelBehavior</code></caption>
             * $(".selector" ).ojDialog( {cancelBehavior: "none" } );
             * 
             * @example <caption>Get or set the <code class="prettyprint">cancelBehavior</code> option, after initialization:</caption>
             * // getter
             * var cancelBehavior = $(".selector" ).ojDialog( "option", "cancelBehavior" );
             * 
             * // setter
             * $(".selector" ).ojDialog( "option", "cancelBehavior", "none");
             */
	    cancelBehavior: "icon",

	    // 
             // @expose 
             // @memberof! oj.ojDialog
	     // @instance
             // @deprecated (replaced by escapeBehavior)
             //
	    // closeOnEscape: true,

	    // 
             // @expose 
             // @memberof! oj.ojDialog
	     // @instance
             // @deprecated
             //
	    // closeText: "",

	    //
             // @expose 
             // @memberof! oj.ojDialog
	     // @instance
             // @deprecated
             //
             // dialogClass: "",

	    /**
	     * Specifies the drag affordance.
	     * If set to <code class="prettyprint">"title-bar"</code> (the default) the dialog will be draggable by the title bar.
	     * If <code class="prettyprint">"none"</code>, the dialog will not be draggable.
             *
             * @expose 
             * @memberof! oj.ojDialog
             * @instance
             * @type {string}
             * @default <code class="prettyprint">"title-bar"</code>
             *
             * @example <caption>Initialize the dialog to disable dragging <code class="prettyprint">dragAffordance</code></caption>
             * $(".selector" ).ojDialog( {dragAffordance: "none" } );
             * 
             * @example <caption>Get or set the <code class="prettyprint">dragAffordance</code> option, after initialization:</caption>
             * // getter
             * var dragAffordance = $(".selector" ).ojDialog( "option", "dragAffordance" );
             * 
             * // setter
             * $(".selector" ).ojDialog( "option", "dragAffordance", "none");
             */
	    dragAffordance: "title-bar",

	    //
             // @expose 
             // @memberof! oj.ojDialog
	     // @instance
             // @deprecated (renamed to dragAffordance)
             //
	    // draggable: true,

	    // 
             // @expose 
             // @memberof! oj.ojDialog
	     // @instance
             // @deprecated (use css classes instead)
	    // 
	    // hide: null,

	    /**
	     * The height of the dialog. <br>
	     * <strong>Multiple types are supported:</strong><ul>
	     * <li>
	     * <strong>Number</strong>: The height in pixels.</li>
	     * <li>
	     * <strong>String</strong>: The only supported string value is <code>"auto"</code> which will allow the dialog height to adjust based on its content.</li>
	     * </ul>
             *
             * @expose 
             * @memberof! oj.ojDialog
             * @type {string|number} 
             *
             * @example <caption>Initialize the dialog to a fixed height <code class="prettyprint">height</code></caption>
             * $(".selector" ).ojDialog( {height: 300 } );
             * 
             * @example <caption>Get or set the <code class="prettyprint">height</code> option, after initialization:</caption>
             * // getter
             * var height = $(".selector" ).ojDialog( "option", "height" );
             * 
             * // setter
             * $(".selector" ).ojDialog( "option", "height", 300);
             */
	    height: "auto",

	    /**
             * <p> Set the initial visibility of the dialog. 
	     * If set to <code class="prettyprint">"show"</code>, the dialog will automatically open upon initialization. 
	     * If <code class="prettyprint">"hide"</code>, the dialog will stay hidden until the <a href="#method-open"><code class="prettyprint">open()</code></a> method is called.
             *
             * @expose 
             * @memberof! oj.ojDialog
             * @instance
             * @type {string}
             * @default <code class="prettyprint">"hide"</code>
             *
             * @example <caption>Initialize the dialog with the <code class="prettyprint">initialVisibility</code> option specified:</caption>
             * $(".selector" ).ojDialog( {initialVisibility: "show" } );
             * 
             * @example <caption>Get or set the <code class="prettyprint">initialVisibility</code> option, after initialization:</caption>
             * // getter
             * var initialVisibility = $(".selector" ).ojDialog( "option", "initialVisibility" );
             * 
             * // setter
             * $(".selector" ).ojDialog( "option", "initialVisibility", "show");
             */
	    initialVisibility: "show",

	    // createTitlebar: true,

	    //
            // @expose 
             // @memberof! oj.ojDialog
	     // @instance
             // @deprecated (use css variables max-height instead)
             //
	    // maxHeight: null,
	    // 
             // @expose 
             // @memberof! oj.ojDialog
	     // @instance
             // @deprecated (use css variables max-width instead)
             //
	    // maxWidth: null,
	    // 
             // @expose 
             // @memberof! oj.ojDialog
	     // @instance
             // @deprecated (use css variables min-height instead)
             //
	    // minHeight: 150,
	    // 
             // @expose 
             // @memberof! oj.ojDialog
	     // @instance
             // @deprecated (use css variables min-width instead)
            //
	    // minWidth: 150,

	    //
             // @expose 
             // @memberof! oj.ojDialog
	     // @instance
             // @deprecated (replaced by modality)
             //
	    // modal: false,

	    /**
	     *
	     * The modality of the dialog. Valid values are:
             * <ul>
             * <li> 
	     * <code class="prettyprint">"modal"</code> - (the default) The dialog is modal. Interactions with other page elements are disabled. Modal dialogs overlay other page elements.
             * </li> 
             * <li> 
	     * <code class="prettyprint">"modeless"</code> - defines a modeless dialog.
             * </li> 
             * </ul>
             *
             * @expose 
             * @memberof! oj.ojDialog
             * @instance
             * @default <code class="prettyprint">"modal"</code>
             * @type {string}
             *
             * @example <caption>Initialize the dialog to a specific modality <code class="prettyprint">modality</code></caption>
             * $(".selector" ).ojDialog( {modality: "modal" } );
             * 
             * @example <caption>Get or set the <code class="prettyprint">modality</code> option, after initialization:</caption>
             * // getter
             * var modality = $(".selector" ).ojDialog( "option", "modality" );
             * 
             * // setter
             * $(".selector" ).ojDialog( "option", "modality", "modal");
             */
	    modality: "modal",

	    // todo: link to position utility?
	    // JQUi doc had { ..., of: button}} - what does this mean?



           /**
            * <p>Position object is defined by the jquery position API and is used to establish the location the
            * dialog will appear relative to another element.  The postion object contains the following properties:
            * "my", "at", "of", "colision", "using" and "within".</p>
            *
            * <p>The "my" and "at" properties defines aligment points relative to the dialog and other element.  The
            * "my" property represents the dialogs alignment where the "at" property represents the other element
            * that can be identified by "of" or defauts to the launcher when the dialog opens.  The values of these
            * properties describe a "horizontal vertical" location.</p>
            *
            * <p>Acceptable "horizontal" alignments values are: "right", "center", "left", "start", "end".  Note: Jet has
            * added "start" and "end" options to be more RTL friendly.  The Jet values of "start" and "end" normalize
            * to "right" or "left" depending on the direction of the document.</p>
            *
            * <p>Acceptable "vertical" alignment values are: "top", "center" and "bottom".</p>
            *
            * The following is a short summary of the most interesting positon properties:
            * <ul>
            *   <li><code class="prettyprint">my</code> - A "vertical horizontal" rule that defines the location of the dialog
            *       used for alignment.</li>
            *   <li><code class="prettyprint">at</code> - A "vertical horizontal" rule that defines the location of the
            *       other element for used alignment. The other element is defined by "of" or defaults to the open launcher
            *       argument if not specified.</li>
            * </ul>
            *
            * @expose
            * @memberof! oj.ojDialog
            * @instance
            * @type {Object}
            * @default <code class="prettyprint">{my: "center", at: "center", collision: "fit"}</code>
            *
            * @example <caption>Initialize the dialog with <code class="prettyprint">position</code> option specified:</caption>
            * $( ".selector" ).ojDialog( { "position": {"my": "left top", "at": "right top"} } );
            *
            * @example <caption>Get or set the <code class="prettyprint">position</code> option, after initialization:</caption>
            * // getter
            * var position = $( ".selector" ).ojDialog( "option", "position" );
            *
            * // setter
            * $( ".selector" ).ojDialog( "option", "position", {"my": "start bottom", "at": "end+14 top" } );
            */
     	    position: {
                /**
                 *
                 * @expose 
     		 * @type {string}
                 * @default <code class="prettyprint">"center"</code>
                 *
                 */
		my: "center",
                /**
                 *
                 * @expose 
		 * @type {string}
                 * @default <code class="prettyprint">"center"</code>
                 *
                 */
		at: "center",
                /**
                 *
                 * @expose 
		 * @type {Object}
                 * @default <code class="prettyprint">"window"</code>
                 *
                 */
		of: window,
                /**
                 *
                 * @expose 
		 * @type {string}
                 * @default <code class="prettyprint">"fit"</code>
                 *
                 */
		collision: "fit",
		// Ensure the titlebar is always visible
		using: function( pos ) {
		    var topOffset = $( this ).css( pos ).offset().top;
		    if ( topOffset < 0 ) {
			$( this ).css( "top", pos.top - topOffset );
		    }
		}
	    },

	    /**
	     *
	     * The resizeBehavior of the dialog. "resizable" (default) makes the dialog resizable.
             * "none" disables dialog resizability.
             *
             * @expose 
             * @memberof! oj.ojDialog
             * @instance
             * @type {string}
             * @default <code class="prettyprint">"resizable"</code>
             *
             * @example <caption>Initialize the dialog to a specific resizeBehavior <code class="prettyprint">resizeBehavior</code></caption>
             * $(".selector" ).ojDialog( {resizeBehavior: "none" } );
             * 
             * @example <caption>Get or set the <code class="prettyprint">resizeBehavior</code> option, after initialization:</caption>
             * // getter
             * var resizeBehavior = $(".selector" ).ojDialog( "option", "resizeBehavior" );
             * 
             * // setter
             * $(".selector" ).ojDialog( "option", "resizeBehavior", "none");
             */
	    resizeBehavior: "resizable",

	    //
             // @expose 
	     // @memberof! oj.ojDialog
	     // @instance
             // @deprecated Replaced by resizeBehavior.
             //
	    // resizable: true,


	    /**
	     *
	     * The role of the dialog. By default, role="dialog" is added to the generated HTML markup that surrounds the dialog.
             * When used as an alert dialog, the user should set role to "alertdialog".
             *
             * @expose 
             * @memberof! oj.ojDialog
             * @instance
             * @type {string}
             * @default <code class="prettyprint">"dialog"</code>
             *
             * @example <caption>Initialize the dialog with the <code class="prettyprint">role</code></caption> option specified:</caption>
             * $(".selector" ).ojDialog( {role: "alertdialog" } );
             * 
             * @example <caption>Get or set the <code class="prettyprint">role</code> option, after initialization:</caption>
             * // getter
             * var role = $(".selector" ).ojDialog( "option", "role" );
             * 
             * // setter
             * $(".selector" ).ojDialog( "option", "role", "alertdialog");
             */
	    role: "dialog",

	    //
            // @expose 
	    // @memberof! oj.ojDialog
	    // @instance
            // @deprecated (use css classes instead)
            //
	    // show: null,

	    /*
	     *
	     * Specify the title of the dialog. null is the default. 
             *
             * @expose 
             * @memberof! oj.ojDialog
	     * @instance
             * @type {string|null}
             *
             * @example <caption>Initialize the dialog to a specific title <code class="prettyprint">title</code></caption>
             * $(".selector" ).ojDialog( {title: "Title of Dialog" } );
             * 
             * @example <caption>Get or set the <code class="prettyprint">title</code> option, after initialization:</caption>
             * // getter
             * var title = $(".selector" ).ojDialog( "option", "title" );
             * 
             * // setter
             * $(".selector" ).ojDialog( "option", "title", "Title of Dialog");
             */
	    title: null,

	    /**
	     * The width of the dialog, in pixels <br>
	     * <strong>Multiple types are supported:</strong><ul>
	     * <li>
	     * <strong>Number</strong>: The width in pixels.</li>
	     * <li>
	     * <strong>String</strong>: The only supported string value is <code>"auto"</code> which will allow the dialog width to adjust based on its content.</li>
	     * </ul>
             *
             *
             * @expose 
             * @memberof! oj.ojDialog
	     * @instance
             * @type {string|number} 
             * @default <code class="prettyprint">300</code>
             *
             * @example <caption>Initialize the dialog to a fixed width <code class="prettyprint">width</code></caption>
             * $(".selector" ).ojDialog( {width: 400 } );
             * 
             * @example <caption>Get or set the <code class="prettyprint">width</code> option, after initialization:</caption>
             * // getter
             * var width = $(".selector" ).ojDialog("option", "width" );
             * 
             * // setter
             * $(".selector" ).ojDialog("option", "width", 400);
             */

	    // width: "auto",
	    width: "300",

	    ///////////////////////////////////////////////////////
	    // events
	    ///////////////////////////////////////////////////////

            /**
             * Triggered when a dialog is about to close. If cancelled, the dialog will not close.
             *
	     * @expose
             * @event 
             * @name beforeClose
             * @memberof! oj.ojDialog
             * @instance
             * @property {Event} event <code class="prettyprint">jQuery</code> event object
             * @property {Object} ui Empty object included for consistency with other events
             * 
             * @example <caption>Initialize the dialog with the <code class="prettyprint">beforeClose</code> callback specified:</caption>
             * $( ".selector" ).ojDialog({
             *     "beforeClose": function( event, ui ) {}
             * });
             * 
             * @example <caption>Bind an event listener to the <code class="prettyprint">ojbeforeClose</code> event:</caption>
             * $( ".selector" ).on( "ojbeforeClose", function( event, ui ) {} );
             */

	    beforeClose: null,

            /**
             * Triggered when the dialog is about to to open.
             *
	     * @expose
             * @event 
             * @name beforeOpen
             * @memberof! oj.ojDialog
             * @instance
             * @property {Event} event <code class="prettyprint">jQuery</code> event object
             * @property {Object} ui Empty object included for consistency with other events
             * 
             * @example <caption>Initialize the dialog with the <code class="prettyprint">beforeOpen</code> callback specified:</caption>
             * $( ".selector" ).ojDialog({
             *     "beforeOpen": function( event, ui ) {}
             * });
             * 
             * @example <caption>Bind an event listener to the <code class="prettyprint">ojbeforeOpen</code> event:</caption>
             * $( ".selector" ).on( "ojbeforeOpen", function( event, ui ) {} );
             */

	    beforeOpen: null,

            /**
             * Close the dialog. this method does not accept any arguments.
             *
	     * @expose
             * @event 
             * @name close
             * @name oj.ojDialog#close
             * @memberof! oj.ojDialog
             * @instance
             * 
             * @example <caption>Invoke the <code class="prettyprint">close</code> method:</caption>
             * $( ".selector" ).ojDialog("close");
             * 
             */

	    close : null,

	    //
             // @expose 
	     // @memberof! oj.ojDialog
	     // @instance
             // @deprecated (In the future, this functionality will be supported in HTML 5)
             //
	    // drag: null,

	    //
             // @expose 
	     // @memberof! oj.ojDialog
	     // @instance
             // @deprecated (In the future, this functionality will be supported in HTML 5)
             //
	    //dragStart: null,

	    //
             // @expose 
	     // @memberof! oj.ojDialog
	     // @instance
             // @deprecated (In the future, this functionality will be supported in HTML 5)
             //
	    // dragStop: null,

            /**
             * Triggered when the dialog gains focus.
             *
	     * @expose
             * @event 
             * @name focus
             * @memberof! oj.ojDialog
             * @instance
             * @property {Event} event <code class="prettyprint">jQuery</code> event object
             * @property {Object} ui Empty object included for consistency with other events
             * 
             * @example <caption>Initialize the dialog with the <code class="prettyprint">focus</code> callback specified:</caption>
             * $( ".selector" ).ojDialog({
             *     "focus": function( event, ui ) {}
             * });
             * 
             * @example <caption>Bind an event listener to the <code class="prettyprint">ojfocus</code> event:</caption>
             * $( ".selector" ).on( "ojfocus", function( event, ui ) {} );
             */

	    focus: null,
            /**
             * Triggered when the dialog is opened.
             *
	     * @expose
             * @event 
             * @name open
             * @memberof! oj.ojDialog
             * @instance
             * @property {Event} event <code class="prettyprint">jQuery</code> event object
             * @property {Object} ui Empty object included for consistency with other events
             * 
             * @example <caption>Initialize the dialog with the <code class="prettyprint">open</code> callback specified:</caption>
             * $( ".selector" ).ojDialog({
             *     "open": function( event, ui ) {}
             * });
             * 
             * @example <caption>Bind an event listener to the <code class="prettyprint">ojopen</code> event:</caption>
             * $( ".selector" ).on( "ojopen", function( event, ui ) {} );
             */
	    open: null,

            /**
             * Triggered when the dialog is being resized.
             *
	     * @expose
             * @event 
             * @name resize
             * @memberof! oj.ojDialog
             * @instance
             * @property {Event} event <code class="prettyprint">jQuery</code> event object
             * @property {Object} ui Empty object included for consistency with other events
             * 
	     * <ul>
	     * <li>
	     * <div><strong>event</strong></div>
	     * <div>Type: <a href="http://api.jquery.com/Types/#Event">Event</a>
	     * </div>
	     * <div></div>
	     * </li>
	     * <li>
	     * <div><strong>ui</strong></div>
	     * <div>Type: <a href="http://api.jquery.com/Types/#Object">Object</a>
	     * </div>
	     * <div></div>
	     * <ul>
	     * <li>
	     * <div><strong>originalPosition</strong></div>
	     * <div>Type: <a href="http://api.jquery.com/Types/#Object">Object</a>
	     * </div>
	     * <div>The CSS position of the dialog prior to being resized.</div>
	     * </li>
	     * <li>
	     * <div><strong>position</strong></div>
	     * <div>Type: <a href="http://api.jquery.com/Types/#Object">Object</a>
	     * </div>
	     * <div>The current CSS position of the dialog.</div>
	     * </li>
	     * <li>
	     * <div><strong>originalSize</strong></div>
	     * <div>Type: <a href="http://api.jquery.com/Types/#Object">Object</a>
	     * </div>
	     * <div>The size of the dialog prior to being resized.</div>
	     * </li>
	     * <li>
	     * <div><strong>size</strong></div>
	     * <div>Type: <a href="http://api.jquery.com/Types/#Object">Object</a>
	     * </div>
	     * <div>The current size of the dialog.</div>
	     * </li>
	     * </ul>
	     * </li>
	     * </ul>
	     * 
             * @example <caption>Initialize the dialog with the <code class="prettyprint">resize</code> callback specified:</caption>
             * $( ".selector" ).ojDialog({
             *     "resize": function( event, ui ) {}
             * });
             * 
             * @example <caption>Bind an event listener to the <code class="prettyprint">ojresize</code> event:</caption>
             * $( ".selector" ).on( "ojresize", function( event, ui ) {} );
             */
	    resize: null,

            /**
             * Triggered when the user starts resizing the dialog.
             *
	     * @expose
             * @event 
             * @name resizeStart
             * @memberof! oj.ojDialog
             * @instance
             * @property {Event} event <code class="prettyprint">jQuery</code> event object
             * @property {Object} ui Empty object included for consistency with other events
             * 
	     * <ul>
	     * <li>
	     * <div><strong>event</strong></div>
	     * <div>Type: <a href="http://api.jquery.com/Types/#Event">Event</a>
	     * </div>
	     * <div></div>
	     * </li>
	     * <li>
	     * <div><strong>ui</strong></div>
	     * <div>Type: <a href="http://api.jquery.com/Types/#Object">Object</a>
	     * </div>
	     * <div></div>
	     * <ul>
	     * <li>
	     * <div><strong>originalPosition</strong></div>
	     * <div>Type: <a href="http://api.jquery.com/Types/#Object">Object</a>
	     * </div>
	     * <div>The CSS position of the dialog prior to being resized.</div>
	     * </li>
	     * <li>
	     * <div><strong>position</strong></div>
	     * <div>Type: <a href="http://api.jquery.com/Types/#Object">Object</a>
	     * </div>
	     * <div>The current CSS position of the dialog.</div>
	     * </li>
	     * <li>
	     * <div><strong>originalSize</strong></div>
	     * <div>Type: <a href="http://api.jquery.com/Types/#Object">Object</a>
	     * </div>
	     * <div>The size of the dialog prior to being resized.</div>
	     * </li>
	     * <li>
	     * <div><strong>size</strong></div>
	     * <div>Type: <a href="http://api.jquery.com/Types/#Object">Object</a>
	     * </div>
	     * <div>The current size of the dialog.</div>
	     * </li>
	     * </ul>
	     * </li>
	     * </ul>
	     * 
             * @example <caption>Initialize the dialog with the <code class="prettyprint">resizeStart</code> callback specified:</caption>
             * $( ".selector" ).ojDialog({
             *     "resizeStart": function( event, ui ) {}
             * });
             * 
             * @example <caption>Bind an event listener to the <code class="prettyprint">ojresizeStart</code> event:</caption>
             * $( ".selector" ).on( "ojresizeStart", function( event, ui ) {} );
             */
	    resizeStart: null,

            /**
             * Triggered when the user stops resizing the dialog.
             *
	     * @expose
             * @event 
             * @name resizeStop
             * @memberof! oj.ojDialog
             * @instance
             * @property {Event} event <code class="prettyprint">jQuery</code> event object
             * @property {Object} ui Empty object included for consistency with other events
             * 
	     * <ul>
	     * <li>
	     * <div><strong>event</strong></div>
	     * <div>Type: <a href="http://api.jquery.com/Types/#Event">Event</a>
	     * </div>
	     * <div></div>
	     * </li>
	     * <li>
	     * <div><strong>ui</strong></div>
	     * <div>Type: <a href="http://api.jquery.com/Types/#Object">Object</a>
	     * </div>
	     * <div></div>
	     * <ul>
	     * <li>
	     * <div><strong>originalPosition</strong></div>
	     * <div>Type: <a href="http://api.jquery.com/Types/#Object">Object</a>
	     * </div>
	     * <div>The CSS position of the dialog prior to being resized.</div>
	     * </li>
	     * <li>
	     * <div><strong>position</strong></div>
	     * <div>Type: <a href="http://api.jquery.com/Types/#Object">Object</a>
	     * </div>
	     * <div>The current CSS position of the dialog.</div>
	     * </li>
	     * <li>
	     * <div><strong>originalSize</strong></div>
	     * <div>Type: <a href="http://api.jquery.com/Types/#Object">Object</a>
	     * </div>
	     * <div>The size of the dialog prior to being resized.</div>
	     * </li>
	     * <li>
	     * <div><strong>size</strong></div>
	     * <div>Type: <a href="http://api.jquery.com/Types/#Object">Object</a>
	     * </div>
	     * <div>The current size of the dialog.</div>
	     * </li>
	     * </ul>
	     * </li>
	     * </ul>
	     * 
             * @example <caption>Initialize the dialog with the <code class="prettyprint">resizeStop</code> callback specified:</caption>
             * $( ".selector" ).ojDialog({
             *     "resizeStop": function( event, ui ) {}
             * });
             * 
             * @example <caption>Bind an event listener to the <code class="prettyprint">ojresizeStop</code> event:</caption>
             * $( ".selector" ).on( "ojresizeStop", function( event, ui ) {} );
             */
	    resizeStop: null
	},

        
        /**
         * Triggered when the dialog is created.
         *
         * @expose
         * @event 
         * @name create
         * @memberof! oj.ojDialog
         * @instance
         * @property {Event} event <code class="prettyprint">jQuery</code> event object
         * @property {Object} ui Empty object included for consistency with other events
         * 
         * @example <caption>Initialize the buttonset with the <code class="prettyprint">create</code> callback specified:</caption>
         * $( ".selector" ).ojDialog({
         *     "create": function( event, ui ) {}
         * });
         * 
         * @example <caption>Bind an event listener to the <code class="prettyprint">ojcreate</code> event:</caption>
         * $( ".selector" ).on( "ojcreate", function( event, ui ) {} );
         */

	_create: function() {
	    this.originalCss = {
		display: this.element[0].style.display,
		width: this.element[0].style.width,
		minHeight: this.element[0].style.minHeight,
		maxHeight: this.element[0].style.maxHeight,
		height: this.element[0].style.height
	    };
	    this.originalPosition = {
		parent: this.element.parent(),
		index: this.element.parent().children().index( this.element )
	    };
	    this.originalTitle = this.element.attr("title");
	    this.options.title = this.options.title || this.originalTitle;

	    this._createWrapper();

	    this.element
		.show()
		.removeAttr("title")
		// .addClass("oj-dialog-content oj-component-content")
		.addClass("oj-dialog-content oj-dialog-default-content")
		.appendTo( this.uiDialog );

	    this.userDefinedDialog = false;

	    //
	    // For nexted content,
	    // we need to find UNTIL we see a .oj-dialog class (or .oj-dialog and oj-resizable)
	    //

	    var nestedContent = this.element.find(".oj-dialog");

	    if (nestedContent.length) {

		if (nestedContent.parents(".oj-dialog-header").length) 
		    this.userDefinedDialog = true;

	    } else {

		if (this.element.find(".oj-dialog-header").length) 
		    this.userDefinedDialog = true;

	    }

	    // if (this.uiDialog.find(".oj-dialog-header").length) 
	    // this.userDefinedDialog = true;

	    if (this.userDefinedDialog) {

		// var a = this.uiDialog.find(".oj-dialog-content");
		// var b = this.uiDialog.find(".oj-dialog-header");
		var b = this.element.find(".oj-dialog-header");

		b.prependTo(this.uiDialog);

		if (this.options.cancelBehavior === "icon")
		    this._createCloseButton(b);

	    }

	    // If a user-defined header is NOT there, then create a title bar
	    if (!this.userDefinedDialog) { this._createTitlebar(); }
	    // if (!this.uiDialog.find(".oj-dialog-header").length ) { this._createTitlebar(); }

	    // this._createButtonPane();

            // if ( this.options.draggable && $.fn.draggable ) {
	    if ( this.options.dragAffordance === "title-bar" && $.fn.draggable ) {
		this._makeDraggable();
	    }
	    // if ( this.options.resizable && $.fn.resizable ) {
	    if (this.options.resizeBehavior === "resizable" && $.fn.resizable) {
		this._makeResizable();
	    }

	    this._isOpen = false;
            
            this._super();
	},

	_init: function() {

	    if (this.options.initialVisibility === "show" ) {
		this.open();
	    }

	    // if ( this.options.autoOpen ) {
	    // this.open();
    	    // }

	},

	// 
	// Return the location to append to.
	// (Always returns "body" element)
	// 
	_appendTo: function() {

	    // var element = this.options.appendTo;
	    // if ( element && (element.jquery || element.nodeType) ) return $( element );
	    // return this.document.find( element || "body" ).eq( 0 );
	    return this.document.find("body").eq( 0 );
	},

	/**
	 * Remove the dialog functionality completely. 
	 * This will return the element back to its pre-init state.
	 * 
	 * <p>This method does not accept any arguments.
	 * 
	 * @method
	 * @name oj.ojDialog#destroy
	 * @memberof! oj.ojDialog
	 * @instance
	 * 
	 * @example <caption>Invoke the <code class="prettyprint">destroy</code> method:</caption>
	 * var destroy = $( ".selector" ).ojDialog( "destroy" );
	 */

	_destroy: function() {
	    var next,
	    originalPosition = this.originalPosition;

	    this._destroyOverlay();

	    this.element
		.removeUniqueId()
		// .removeClass("oj-dialog-content oj-component-content")
		.removeClass("oj-dialog-content")
		.css( this.originalCss )
	    // Without detaching first, the following becomes really slow
		.detach();

	    this.uiDialog.stop( true, true ).remove();

	    if ( this.originalTitle ) {
		this.element.attr( "title", this.originalTitle );
	    }

	    next = originalPosition.parent.children().eq( originalPosition.index );
	    // Don't try to place the dialog next to itself (#8613)
	    if ( next.length && next[0] !== this.element[0] ) {
		next.before( this.element );
	    } else {
		originalPosition.parent.append( this.element );
	    }
	},

	/**
	 * Returns a <code class="prettyprint">jQuery</code> object containing the generated wrapper.
	 * 
	 * <p>This method does not accept any arguments.
	 * 
	 * @expose
	 * @name oj.ojDialog#widget
	 * @memberof! oj.ojDialog
	 * @instance
	 * @return {jQuery} the dialog
	 * 
	 * @example <caption>Invoke the <code class="prettyprint">widget</code> method:</caption>
	 * var widget = $( ".selector" ).ojDialog( "widget" );
	 */

	widget: function() {
	    return this.uiDialog;
	},

	disable: $.noop,
	enable: $.noop,


	/**
	 * Closes the dialog.
	 * 
	 * <p>This method does not accept any arguments.
	 * 
	 * @method
	 * @name oj.ojDialog#close
	 * @memberof! oj.ojDialog
	 * @instance
         * @property {Event} event <code class="prettyprint">jQuery</code> event object
         * @return {void}
         * @fires oj.ojDialog#beforeClose
         * @fires oj.ojDialog#close
	 * 
	 * @example <caption>Invoke the <code class="prettyprint">close</code> method:</caption>
	 * var close = $( ".selector" ).ojDialog( "close" );
	 */
	close : function( event ) {
	    var that = this;

	    if ( !this._isOpen || this._trigger( "beforeClose", event ) === false ) {
		return;
	    }

	    this._isOpen = false;
	    this._destroyOverlay();

	    if ( !this.opener.filter(":focusable").focus().length ) {
		// Hiding a focused element doesn't trigger blur in WebKit
		// so in case we have nothing to focus on, explicitly blur the active element
		// https://bugs.webkit.org/show_bug.cgi?id=47182
		$( this.document[0].activeElement ).blur();
	    }

	    // this._hide( this.uiDialog, this.options.hide, function() {
	    this._hide( this.uiDialog, null, function() {
		that._trigger( "close", event );
	    });

	    if (_putback) {

		// Put the dialog back to its original location.
		// Old - this would put the unwrapped code back
		// $('#' + this._placeHolderId).replaceWith($('#' + this._elementId));

		// Remove the old wrapper.
		//$('#' + this._wrapperId).remove();

		//
		// Put contents and wrapper back to inline location.
		//
		$('#' + this._placeHolderId).replaceWith($('#' + this._wrapperId));

	    }
	},

	/**
	 * Returns true if the dialog is currently open.
	 * 
	 * <p>This method does not accept any arguments.
	 * 
	 * @method
	 * @name oj.ojDialog#isOpen
	 * @memberof! oj.ojDialog
	 * @instance
         * @property {Event} event <code class="prettyprint">jQuery</code> event object
	 * 
	 * @example <caption>Invoke the <code class="prettyprint">isOpen</code> method:</caption>
	 * var isOpen = $( ".selector" ).ojDialog( "isOpen" );
	 */
	isOpen: function() {
	    return this._isOpen;
	},

	/**
	 * Moves the dialog to the top of the dialog stack.
	 * 
	 * <p>This method does not accept any arguments.
	 * 
	 * @method
	 * @name oj.ojDialog#moveToTop
	 * @memberof! oj.ojDialog
	 * @instance
	 * 
	 * @example <caption>Invoke the <code class="prettyprint">moveToTop</code> method:</caption>
	 * var moveToTop = $( ".selector" ).ojDialog( "moveToTop" );
	 */
	moveToTop: function() {
	    this._moveToTop();
	},

	// 
	// For the opened dialog and focus managment,
	// _moveToTop moves the dialog to the top of the visibility stack.
	// The implementation is based on zIndexs.
	// 
	_moveToTop: function( event, silent ) {

	    if (this.options.appendTo === null) {

		// var lastDialog = $('.oj-dialog').not(':hidden').last();
		// if (!lastDialog) return false;

		var multipleDialogs = false;
		var zIndexSmallest = parseInt(this.uiDialog.css('zIndex'),10);
		// determine if we have multiple dialogs

		$(".oj-dialog").each(function() {

		    if ($(this) != this.uiDialog) {

			// $(this).css({position: 'absolute', zIndex:1049}); 
			multipleDialogs = true;
			var zIndexCurrent = parseInt($(this).css('zIndex'),10);
			if (zIndexSmallest > zIndexCurrent) {
			    zIndexSmallest = zIndexCurrent;
			}

		    }
		});

		var reset = false;
				     
		// If we have multiple dialogs, reset all the others to the smallest.
		if (multipleDialogs) {
		    $(".oj-dialog").each(function() {
			if ($(this) != this.uiDialog) {
			    $(this).css({position: 'absolute', zIndex:zIndexSmallest}); 
			    reset = true;
			}
		    });
		}

		if (multipleDialogs) 
		    this.uiDialog.css({position: 'absolute', zIndex:zIndexSmallest + 1}); 

		return(reset);

		// $("body").find('.oj-dialog').css({position: 'absolute', zIndex:1050}); 
		// this.element.parent().css({position: 'absolute', zIndex:1300}); 

		/*
                // Inline reparent approach.
                // Not used (we want to avoid reparenting for the inline case!)

		// 
		// Moves uiDialog after the last visible dialog.
		// 
		var lastDialog = $('.oj-dialog').not(':hidden').last();

		// return if there is no last visible dialog
		if (!lastDialog) return false;

		if (this.uiDialog != lastDialog) {
		    this.uiDialog.insertAfter(lastDialog);
		    if (!silent) 
			this._trigger( "focus", event );

		    return true;
		}
		return false;
               */


	    }
	    else {
		var moved = !!this.uiDialog.nextAll(":visible").insertBefore( this.uiDialog ).length;
		if ( moved && !silent ) {
		    this._trigger( "focus", event );
		}
		return moved;
	    }

	},

/*
	moveToTopOrig: function() {
	    this._moveToTopOrig();
        },

	_moveToTopOrig: function( event, silent ) {
	    var moved = !!this.uiDialog.nextAll(":visible").insertBefore( this.uiDialog ).length;
	    if ( moved && !silent ) {
		this._trigger( "focus", event );
	    }
	    return moved;
	},

*/
	// 
	// _moveToTopOld: function( event, silent ) {
	// $("body").find('.oj-dialog').css({position: 'absolute', zIndex:1050}); 
        // this.element.parent().css({position: 'absolute', zIndex:1300}); 
	// },
	// 

	/**
	 * Opens the dialog.
	 * 
	 * @method
	 * @name oj.ojDialog#open
	 * @memberof! oj.ojDialog
	 * @instance
         * @return {void}
         * @fires oj.ojDialog#beforeOpen
         * @fires oj.ojDialog#open
	 * 
	 * @example <caption>Invoke the <code class="prettyprint">open</code> method:</caption>
	 * var open = $( ".selector" ).ojDialog( "open" );
	 */
	open: function( event ) {

            // this.$element.on('click.ojDialog', $.proxy(this.uiDialog.hide, this));

	    if (this._trigger( "beforeOpen", event ) === false ) {
		return;
	    }

	    var that = this;

	    if ( this._isOpen ) {

		// orig
		// if ( this._moveToTop() ) {
		// this._focusTabbable();
		// }

		if ( this._moveToTop() ) {
		    this._focusTabbable();
		}

		return;
	    }

	    this._isOpen = true;
	    this.opener = $( this.document[0].activeElement );

	    this._size();

	    this._relocateWithPutback();
	    this._createOverlay();

	    // new code - this._position() was BEFORE relocateWithPutback()
	    this._position();

	    this._moveToTop( null, true ); // orig

	    // 
	    // Reduced functonality from jqueryUI since we now encourage
	    // the use of css classes for animation instead of the jQueryUI effects package
	    // exposed via jquery show()
	    // 
	    // this._show( this.uiDialog, this.options.show, function() {
	    this._show( this.uiDialog, null, function() {
		that._focusTabbable();
		that._trigger("focus");
	    });

	    this._trigger("open");
	},

	_focusTabbable: function() {
	    // Set focus to the first match:
	    // 1. First element inside the dialog matching [autofocus]
	    // 2. Tabbable element inside the content element
	    // 3. Tabbable element inside the buttonpane
	    // 4. The close button
	    // 5. The dialog itself
	    var hasFocus = this.element.find("[autofocus]");
	    if ( !hasFocus.length ) {
		hasFocus = this.element.find(":tabbable");
	    }
	    if ( !hasFocus.length ) {
		if (this.uiDialogButtonPane)
		    hasFocus = this.uiDialogButtonPane.find(":tabbable");
	    }
	    if ( !hasFocus.length ) {
		// todo: this may not exist when a user-defined header is used.
		// We may want to provide an api for the focusable element, or
		// check the oj-dialog-header markup
		if (this.uiDialogTitlebarClose)
		    hasFocus = this.uiDialogTitlebarClose.filter(":tabbable");
	    }
	    if ( !hasFocus.length ) {
		hasFocus = this.uiDialog;
	    }
	    hasFocus.eq( 0 ).focus();
	},

	_keepFocus: function( event ) {
	    function checkFocus() {
		var activeElement = this.document[0].activeElement,
		isActive = this.uiDialog[0] === activeElement ||
		    $.contains( this.uiDialog[0], activeElement );
		if ( !isActive ) {
		    this._focusTabbable();
		}
	    }
	    event.preventDefault();
	    checkFocus.call( this );
	    // support: IE
	    // IE <= 8 doesn't prevent moving focus even with event.preventDefault()
	    // so we check again later
	    this._delay( checkFocus );
	},

	_createWrapper: function() {

	    // make sure that the element has a unique id.
	    this.element.uniqueId();
	    this._elementId = this.element.attr('id');
	    this._wrapperId = _wrapperPrefix + this._elementId;

	    this.uiDialog = $("<div>")
		// .addClass( "oj-dialog oj-component oj-component-content oj-corner-all oj-front " +
		// .addClass( "oj-dialog oj-helper-reset-inheritable oj-component oj-dialog-front " +
	    // this.options.dialogClass )
		.addClass( "oj-dialog oj-helper-reset-inheritable oj-component oj-dialog-front ")
		.hide()
		.attr({
		    // Setting tabIndex makes the div focusable
		    'tabIndex': -1,
		    'role': this.options.role,
		    'id' : this._wrapperId
		});

	    // Set properties
	    this._cssMinWidth = this.element.css('min-width');
	    this.uiDialog.css("min-width", this._cssMinWidth);

	    this._cssMaxWidth = this.element.css('max-width');
	    this.uiDialog.css("max-width", this._cssMaxWidth);

	    this._cssMinHeight = this.element.css('min-height');
	    this.uiDialog.css("min-height", this._cssMinHeight);

	    this._cssMaxHeight = this.element.css('max-height');
	    this.uiDialog.css("max-height", this._cssMaxHeight);

	    this.uiDialog.insertBefore(this.element);  // position in-line

	    //
	    // we do not need to put the dialog at the end during create.
	    // 

	    // this._relocateWithPutback();

	    /*
	    if (this.options.location === "auto") 
		this.uiDialog.appendTo( this._appendTo() ); 
	    else if (this.options.location === "inline")
		this.uiDialog.insertBefore(this.element);  // position in-line
	    else 
		// append to the body
		this.uiDialog.appendTo( this._appendTo() ); // original,
*/

	    // .appendTo( this._appendTo() ); // original,

	    this._on( this.uiDialog, {
		keydown: function( event ) {

		    // if ( this.options.closeOnEscape && !event.isDefaultPrevented() && event.keyCode &&
		    // if (this.options.escapeBehavior === "close" && !event.isDefaultPrevented() && event.keyCode &&
		    if (this.options.cancelBehavior != "none" && !event.isDefaultPrevented() && event.keyCode &&
			event.keyCode === $.ui.keyCode.ESCAPE ) {
			event.preventDefault();
			this.close( event );
			return;
		    }

		    // prevent tabbing out of dialogs
		    if ( event.keyCode !== $.ui.keyCode.TAB ) {
			return;
		    }
		    var tabbables = this.uiDialog.find(":tabbable"),
		    first = tabbables.filter(":first"),
		    last  = tabbables.filter(":last");

		    if ( ( event.target === last[0] || event.target === this.uiDialog[0] ) && !event.shiftKey ) {
			first.focus( 1 );
			event.preventDefault();
		    } else if ( ( event.target === first[0] || event.target === this.uiDialog[0] ) && event.shiftKey ) {
			last.focus( 1 );
			event.preventDefault();
		    }
		},
		mousedown: function( event ) {
		    // if ( this._moveToTop( event ) ) {
		    // this._focusTabbable();
		    // }
		    if ( this._moveToTop( event ) ) {
			this._focusTabbable();
		    }
		}
	    });

	    // We assume that any existing aria-describedby attribute means
	    // that the dialog content is marked up properly
	    // otherwise we brute force the content as the description
	    if ( !this.element.find("[aria-describedby]").length ) {
		this.uiDialog.attr({
		    "aria-describedby": this.element.uniqueId().attr("id")
		});
	    }
	},

	// 
	// Create a close button.
	// 
	_createCloseButton: function(domDestination) {

	    this.uiDialogTitlebarClose = $("<button></button>")
		.ojButton({
		    display: "icons",
		    icons: {
			start: "oj-component-icon oj-dialog-close-icon"
		    },
		    text: false
		})
		.addClass("oj-dialog-header-close oj-button-no-chrome")
		.appendTo(domDestination );

	    this._on( this.uiDialogTitlebarClose, {
		click: function( event ) {
		    event.preventDefault();
		    this.close( event );
		}
	    });
	},

	_createTitlebar: function() {
	    var uiDialogTitle;

	    this.uiDialogTitlebar = $("<div>")
	    // .addClass("oj-dialog-titlebar oj-component-header oj-corner-all oj-helper-clearfix")
	    // .addClass("oj-dialog-titlebar oj-helper-clearfix")
		.addClass("oj-dialog-header oj-helper-clearfix")
		.prependTo( this.uiDialog );
	    this._on( this.uiDialogTitlebar, {
		mousedown: function( event ) {
		    // Don't prevent click on close button (#8838)
		    // Focusing a dialog that is partially scrolled out of view
		    // causes the browser to scroll it into view, preventing the click event
		    // if ( !$( event.target ).closest(".oj-fwk-icon-close") ) {
		    if ( !$( event.target ).closest(".oj-dialog-close-icon") ) {
			// Dialog isn't getting focus when dragging (#8063)
			this.uiDialog.focus();
		    }
		}
	    });

	    if (this.options.cancelBehavior === "icon")
		this._createCloseButton(this.uiDialogTitlebar);

	    uiDialogTitle = $("<span>")
		.uniqueId()
		.addClass("oj-dialog-title")
		.prependTo( this.uiDialogTitlebar );
	    this._title( uiDialogTitle );

	    this.uiDialog.attr({
		"aria-labelledby": uiDialogTitle.attr("id")
	    });
	},

	_title: function( title ) {
	    if ( !this.options.title ) {
		title.html("&#160;");
	    }
	    title.text( this.options.title );
	},

/*
	_createButtonPane: function() {
	    this.uiDialogButtonPane = $("<div>")
	    // .addClass("oj-dialog-buttonpane oj-component-content oj-helper-clearfix");
		.addClass("oj-dialog-buttonpane oj-helper-clearfix");

	    this.uiButtonSet = $("<div>")
		.addClass("oj-dialog-buttonset")
		.appendTo( this.uiDialogButtonPane );

	    // this._createButtons();
	},

*/


         //
         // the buttons option has been removed ...
         //
/*

	_createButtons: function() {
	    var that = this,
	    buttons = this.options.buttons;

	    // if we already have a button pane, remove it
	    this.uiDialogButtonPane.remove();
	    this.uiButtonSet.empty();

	    if ( $.isEmptyObject( buttons ) || ($.isArray( buttons ) && !buttons.length) ) {
		this.uiDialog.removeClass("oj-dialog-buttons");
		return;
	    }

	    $.each( buttons, function( name, props ) {
		var click, buttonOptions;
		props = $.isFunction( props ) ?
		    { click: props, text: name } :
		props;
		// Default to a non-submitting button
		props = $.extend( { type: "button" }, props );
		// Change the context for the click callback to be the main element
		click = props.click;
		props.click = function() {
		    click.apply( that.element[0], arguments );
		};
		buttonOptions = {
		    //  @expose 
		    icons: props.icons,
		    // @expose 
		    text: props['showText']
		};
		delete props.icons;
		delete props['showText'];
		$( "<button></button>", props )
		    .ojButton( buttonOptions )
		    .appendTo( that.uiButtonSet );
	    });
	    this.uiDialog.addClass("oj-dialog-buttons");
	    this.uiDialogButtonPane.appendTo( this.uiDialog );
	},
*/


	_makeDraggable: function() {
	    var that = this,
	    options = this.options;

	    function filteredUi( ui ) {
		return {
		    position: ui.position,
		    offset: ui.offset
		};
	    }

	    this.uiDialog.draggable({
		// cancel: ".oj-dialog-content, .oj-dialog-titlebar-close",
		// handle: ".oj-dialog-titlebar",
		cancel: ".oj-dialog-content, .oj-dialog-header-close",
		handle: ".oj-dialog-header",
		containment: "document",
		start: function( event, ui ) {
		    $( this ).addClass("oj-dialog-dragging");
		    that._blockFrames();
		    that._trigger( "dragStart", event, filteredUi( ui ) );
		},
		drag: function( event, ui ) {
		    that._trigger( "drag", event, filteredUi( ui ) );
		},
		stop: function( event, ui ) {
		    options.position = [
			ui.position.left - that.document.scrollLeft(),
			ui.position.top - that.document.scrollTop()
		    ];
		    $( this ).removeClass("oj-dialog-dragging");
		    that._unblockFrames();
		    that._trigger( "dragStop", event, filteredUi( ui ) );
		}
	    });
	},

	_makeResizable: function() {
	    var that = this,

	    options = this.options,

	    // handles = options.resizable,

	    // .oj-resizable has position: relative defined in the stylesheet
	    // but dialogs have to use absolute or fixed positioning
	    position = this.uiDialog.css("position"),
	    // resizeHandles = typeof handles === "string" ? handles : "n,e,s,w,se,sw,ne,nw";

	    resizeHandles = "n,e,s,w,se,sw,ne,nw";

	    function filteredUi( ui ) {
		return {
		    originalPosition: ui.originalPosition,
		    originalSize: ui.originalSize,
		    position: ui.position,
		    size: ui.size
		};
	    }

	    this._resizableComponent = this.uiDialog['ojResizable'].bind(this.uiDialog);

	    // this.uiDialog.['ojResizable']({
	    // this.uiDialog.resizable({

	    this._resizableComponent({
		cancel: ".oj-dialog-content",
		containment: "document",
		alsoResize: this.element,

		// maxWidth: options.maxWidth,
		// maxHeight: options.maxHeight,
		// minWidth: options.minWidth,
		minHeight: this._minHeight(),

		handles: resizeHandles,
		start: function( event, ui ) {
		    $( this ).addClass("oj-dialog-resizing");
		    that._blockFrames();
		    that._trigger( "ojstart", event, filteredUi( ui ) );
		},
		resize: function( event, ui ) {
		    that._trigger( "ojresize", event, filteredUi( ui ) );
		},
		stop: function( event, ui ) {
		    options.height = $( this ).height();
		    options.width = $( this ).width();
		    $( this ).removeClass("oj-dialog-resizing");
		    that._unblockFrames();
		    that._trigger( "ojstop", event, filteredUi( ui ) );
		}
	    })
		.css( "position", position );
	},

	_minHeight: function() {
	    var options = this.options;

	    return options.height === "auto" ?
 		// options.minHeight :
		this._cssMinHeight :
		// Math.min( options.minHeight, options.height );
		Math.min( this._cssMinHeight, options.height );
	},

	_position: function() {

	    // Need to show the dialog to get the actual offset in the position plugin
	    var isVisible = this.uiDialog.is(":visible");
	    if ( !isVisible ) {
		this.uiDialog.show();
	    }

	    var pos = this.options.position;

	    //
	    // Neet to adjust dependency on ojpopup. (talk to Max)
	    //
	    // var isRtl = this._GetReadingDirection() === "rtl";
	    // this.uiDialog.position(oj.PositionUtils.normalizeHorizontalAlignment(pos, isRtl));

	    this.uiDialog.position(pos);

	    // this.uiDialog.position( this.options.position );

	    if ( !isVisible ) {
		this.uiDialog.hide();
	    }
	},
	/**
	 * Sets one or more options for the dialog.
	 * 
	 * @method
	 * @name oj.ojDialog#setOptions
	 * @memberof! oj.ojDialog
	 * @instance
	 * @param options A map of option/value pairs to set
	 * 
	 * @example <caption>Invoke the method:</caption>
	 * $( ".selector" ).ojDialog( "option", {disabled: true});
	 */
	_setOptions: function( options ) {
	    var that = this,
	    resize = false,
	    resizableOptions = {};

	    $.each( options, function( key, value ) {
		that._setOption( key, value );

		if ( key in sizeRelatedOptions ) {
		    resize = true;
		}
		if ( key in resizableRelatedOptions ) {
		    resizableOptions[ key ] = value;
		}
	    });

	    if ( resize ) {
		this._size();
		this._position();
	    }
	    if ( this.uiDialog.is(":data(oj-resizable)") ) {
		// this.uiDialog.ojResizable( "option", resizableOptions );
		this._resizableComponent( "option", resizableOptions );
	    }
	},


	/**
	 * Sets one or more options for the dialog.
	 * 
	 * @method
	 * @name oj.ojDialog#setOptions
	 * @memberof! oj.ojDialog
	 * @instance
	 * @param key The name of the option name to set.
	 * @param value A value to set for the option.
	 * 
	 * @example <caption>Invoke the method:</caption>
	 * $( ".selector" ).ojDialog( "option", disabled, true);
	 */

	_setOption: function( key, value ) {
	    /*jshint maxcomplexity:15*/
	    var isDraggable, isResizable,
	    uiDialog = this.uiDialog;


	    // if ( key === "dialogClass" ) {
	    // uiDialog
	    // .removeClass( this.options.dialogClass )
	    //.addClass( value );
	    // }

	    if ( key === "disabled" ) {
		return;
	    }

	    this._super( key, value );

	    // if ( key === "appendTo" ) {
	    // this.uiDialog.appendTo( this._appendTo() );
	    // }


	    // if ( key === "buttons" ) {
	    // this._createButtons();
	    // }



	    // if ( key === "closeText" ) {
	    // this.uiDialogTitlebarClose.ojButton({
	    //// Ensure that we always pass a string
	    // label: "" + value
	    // });
	    // }


	    if ( key === "draggable" ) {
		isDraggable = uiDialog.is(":data(oj-draggable)");
		if ( isDraggable && !value ) {
		    uiDialog.draggable("destroy");
		}

		if ( !isDraggable && value ) {
		    this._makeDraggable();
		}
	    }

	    if ( key === "position" ) {
		this._position();
	    }

	    if ( key === "resizable" ) {
		// currently resizable, becoming non-resizable
		isResizable = uiDialog.is(":data(oj-resizable)");
		if ( isResizable && !value ) {
		    // uiDialog.ojResizable("destroy");
		    uiDialog._resizableComponent("destroy");
		}

		// currently resizable, changing handles
		if ( isResizable && typeof value === "string" ) {
		    // uiDialog.ojResizable( "option", "handles", value );
		    uiDialog._resizableComponent( "option", "handles", value );
		}

		// currently non-resizable, becoming resizable
		if ( !isResizable && value !== false ) {
		    this._makeResizable();
		}
	    }

	    if ( key === "title" ) {
		this._title( this.uiDialogTitlebar.find(".oj-dialog-title") );
	    }
	},

	_size: function() {
	    // If the user has resized the dialog, the .oj-dialog and .oj-dialog-content
	    // divs will both have width and height set, so we need to reset them
	    var nonContentHeight, minContentHeight, maxContentHeight,
	    options = this.options;

	    // Reset content sizing
	    this.element.show().css({
		width: "auto",
		minHeight: 0,
		maxHeight: "none",
		height: 0
	    });

	    if ( this._cssMinWidth > options.width ) {
		options.width = this._cssMinWidth;
	    }

	    // reset wrapper sizing
	    // determine the height of all the non-content elements
	    nonContentHeight = this.uiDialog.css({
		height: "auto",
		width: options.width
	    })
		.outerHeight();
	    minContentHeight = Math.max( 0, this._cssMinHeight - nonContentHeight );
	    maxContentHeight = typeof this._cssMaxHeight === "number" ?
		Math.max( 0, this._cssMaxHeight - nonContentHeight ) :
		"none";

	    if ( options.height === "auto" ) {
		this.element.css({
		    minHeight: minContentHeight,
		    maxHeight: maxContentHeight,
		    height: "auto"
		});
	    } else {
		this.element.height( Math.max( 0, options.height - nonContentHeight ) );
	    }

	    if (this.uiDialog.is(":data(oj-resizable)") ) {
		// this.uiDialog.ojResizable( "option", "minHeight", this._minHeight() );
		this.uiDialog._resizableComponent( "option", "minHeight", this._minHeight() );
	    }
	},

	_blockFrames: function() {
	    this.iframeBlocks = this.document.find( "iframe" ).map(function() {
		var iframe = $( this );

		var offset = /** @type {{left: number, top: number}}  */ (iframe.offset());

		return $( "<div>" )
		    .css({
			position: "absolute",
			width: iframe.outerWidth(),
			height: iframe.outerHeight()
		    })
		    .appendTo( iframe.parent() )
		    .offset( offset )[0];
	    });
	},

	_unblockFrames: function() {
	    if ( this.iframeBlocks ) {
		this.iframeBlocks.remove();
		delete this.iframeBlocks;
	    }
	},

	_allowInteraction: function( event ) {
	    if ( $( event.target ).closest(".oj-dialog").length ) {
		return true;
	    }

	    // TODO: Remove hack when datepicker implements
	    // the .oj-front logic (#8989)
	    return !!$( event.target ).closest(".oj-datepicker").length;
	},

	//
	// Place a system generated div in the DOM spot where the dialog is defined.
	// This is used later to return the dialog to its original relocated position.
	// Relocate the dialog to the end of the body.
	//
	_relocateWithPutback: function() {

	    if (_putback) {

		this._placeHolderId = _placeHolderPrefix + this._elementId;

		this._placeHolder = $("<div>")
		    .hide()
		    .attr({'id' : this._placeHolderId});

		this._placeHolder.insertBefore($('#' + this._wrapperId));  // position placeHolder at original in-line DOM location, before the wrapper id
	    }

	    this.uiDialog.appendTo( this._appendTo() ); 
	},

	_createOverlay: function() {

	    if (this.options.modality === "modeless" ) {
		return;
	    }

	    //if ( !this.options.modal ) {
	    // 		return;
	    // 	    }

	    var that = this,
	    widgetFullName = this.widgetFullName;
	    if ( !$.ui.dialog.overlayInstances) {
		// Prevent use of anchors and inputs.
		// We use a delay in case the overlay is created from an
		// event that we're going to be cancelling. (#2804)
		this._delay(function() {
		    // Handle .dialog().dialog("close") (#4065)
		    if ( $.ui.dialog.overlayInstances ) {
			this.document.bind( "focusin.dialog", function( event ) {
			    if ( !that._allowInteraction( event ) ) {
				event.preventDefault();
				$(".oj-dialog:visible:last .oj-dialog-content")
				    .data( widgetFullName )._focusTabbable();
			    }
			});
		    }
		});
	    }
	    
	    //
	    // create an overlay that will disable anything except the dialog.
	    //
	    this.overlay = $("<div>")
		.addClass("oj-component-overlay oj-dialog-front");

	    this.overlay.appendTo( this._appendTo() ); // original

	    /*
	    if (this.options.location === "auto") 
		this.uiDialog.appendTo( this._appendTo() ); 
	    else if (this.options.location === "inline")
		this.overlay.insertBefore(this.uiDialog);  // position in-line
	    else 
		this.overlay.appendTo( this._appendTo() ); // original
           */

	    this._on( this.overlay, {
		mousedown: "_keepFocus"
	    });

	    $.ui.dialog['overlayInstances']++;
	},

	_destroyOverlay: function() {

	    if (this.options.modality === "modeless" ) {
		return;
	    }

	    if ( this.overlay ) {
		$.ui.dialog['overlayInstances']--;

		if ( !$.ui.dialog.overlayInstances ) {
		    this.document.unbind( "focusin.dialog" );
		}
		this.overlay.remove();
		this.overlay = null;
	    }
	},

	/**
   * Return the subcomponent node represented by the documented locator 
   * attribute values.
   * Test authors should target sub elements using the following names:
   * <ul>
   * <li><b>oj-dialog-header</b>: dialog header div </li>
   * <li><b>oj-dialog-body</b>: dialog body div </li>
   * <li><b>oj-dialog-footer</b>: dialog footer div </li>
   * <li><b>oj-dialog-content</b>: dialog content div </li>
   * <li><b>oj-dialog-header-close</b>: dialog header-close button </li>
   * <li><b>oj-resizable-n</b>: North resizable handle </li>
   * <li><b>oj-resizable-e</b>: East resizable handle </li>
   * <li><b>oj-resizable-s</b>: South resizable handle </li>
   * <li><b>oj-resizable-w</b>: West resizable handle </li>
   * <li><b>oj-resizable-se</b>: Southeast resizable handle </li>
   * <li><b>oj-resizable-sw</b>: Southwest resizable handle </li>
   * <li><b>oj-resizable-ne</b>: Northeast resizable handle </li>
   * <li><b>oj-resizable-nw</b>: Northwest resizable handle </li>
   * </ul>
   * @expose
   * @memberof! oj.ojDialog
   * @instance
   * @override
   * @param {Object} locator An Object containing at minimum a subId property 
   *        whose value is a string, documented by the component, that allows 
   *        the component to look up the subcomponent associated with that 
   *        string.  It contains:<p>
   *        component: optional - in the future there may be more than one 
   *        component contained within a page element<p>
   *        subId: the string, documented by the component, that the component 
   *        expects in getNodeBySubId to locate a particular subcomponent
   * @returns {Element|null} the subcomponent located by the subId string passed
   *          in locator, if found.<p>
   */
	getNodeBySubId: function(locator)
	{
	    if (locator == null)
	    {
		return this.element ? this.element[0] : null;
	    }
	    
	    var subId = locator['subId'];

	    switch (subId) {

	    case "oj-dialog":
	    case "oj-dialog-header":
	    case "oj-dialog-body":
	    case "oj-dialog-footer":
	    case "oj-dialog-content":
	    case "oj-dialog-header-close":
	    case "oj-resizable-n":
	    case "oj-resizable-e":
	    case "oj-resizable-s":
	    case "oj-resizable-w":
	    case "oj-resizable-se":
	    case "oj-resizable-sw":
	    case "oj-resizable-ne":
	    case "oj-resizable-nw":

		var dotSubId = "." + subId;
		return (this.widget().find(dotSubId)[0]);
		break;

	    }

	    // Non-null locators have to be handled by the component subclasses
	    return null;
	}


    });

    $.ui.dialog['overlayInstances'] = 0;


}() );


/*-------------------------------------------------------------------------*/
/* Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.  */
/*-------------------------------------------------------------------------*/
/*                                                                         */
/* ojTree v1.0        Displays a Hierarchical Tree                         */
/*-------------------------------------------------------------------------*/
/* Depends:                                                                */
/*   jquery.ui.core.js                                                     */
/*   jquery.ui.widget.js                                                   */
/*-------------------------------------------------------------------------*/
/* This component is based on a heavily modified version of the following: */
/* jsTree 1.0-rc3                                                          */
/* http://jstree.com/                                                      */
/* Copyright (c) 2010 Ivan Bozhanov (vakata.com)                           */
/* Licensed same as jquery - under the terms of either the MIT License or  */
/* the GPL Version 2 License                                               */
/*   http://www.opensource.org/licenses/mit-license.php                    */
/*   http://www.gnu.org/licenses/gpl.html                                  */
/* $Date: 2011-02-09 01:17:14 +0200                                        */
/* $Revision: 236 $                                                        */
/*-------------------------------------------------------------------------*/


(function () 
{
  /*
  function debugObj(o)  {
    var s ;
    try { s = JSON.stringify(o) ; }
    catch (e) { s = "ERROR";}
    return s ;
  };
  */

  //  ojTree class names  
  var  /** @const */   OJT_OPEN          = "oj-tree-open",
       /** @const */   OJT_CLOSED        = "oj-tree-closed",
       /** @const */   OJT_LEAF          = "oj-tree-leaf",
       /** @const */   OJT_ICON          = "oj-tree-icon",
       /** @const */   OJT_HOVER         = "oj-tree-hovered",
       /** @const */   OJT_CLICKED       = "oj-tree-clicked",
       /** @const */   OJT_LAST          = "oj-tree-last",
       /** @const */   OJT_LOADING       = "oj-tree-loading",
       /** @const */   OJT_LAST_SELECTED = "oj-tree-last-selected",
       /** @const */   OJT_TITLE         = "oj-tree-title",
       /** @const */   OJT_DISABLED      = "oj-disabled";

  //  ojTree reorder class names  
  var  /** @const */   OJT_DRAG_OK       = "oj-tree-ok",
       /** @const */   OJT_DRAG_INVALID  = "oj-tree-invalid",
       /** @const */   OJT_MARKER        = "oj-tree-marker",
       /** @const */   OJT_MARKER_LINE   = "oj-tree-marker-line";

  //  WAI-ARIA  
  var  /** @const */   WA_ROLE              = "role",
       /** @const */   WA_TREE              = "tree",
       /** @const */   WA_TREEITEM          = "treeitem",
       /** @const */   WA_GROUP             = "group",
       /** @const */   WA_SELECTED          = "aria-selected",
       /** @const */   WA_EXPANDED          = "aria-expanded",
       /** @const */   WA_ACTIVEDESCENDANT  = "aria-activedescendant",
       /** @const */   WA_MULTISELECTABLE   = "aria-multiselectable";

  //  Data source in use
  var  /** @const */  DS_TREE       =  1,
       /** @const */  DS_COLLECTION =  2,
       /** @const */  DS_JSON       =  3,
       /** @const */  DS_HTML       =  4,
       /** @const */  DS_NONE       =  0,
       /** @const */  DS_ERROR      = -1;

  // Context Menu item id's
  var  /** @const */  _arMenuCmdMap = { "cut"    : "ojtreecut",
                                        "copy"   : "ojtreecopy",
                                        "paste"  : "ojtreepaste",
                                        "remove" : "ojtreeremove",
                                        "rename" : "ojtreerename"
                                      } ;
  /**
    *  Public event names
    *  @const
    */
  var  _aEvNames = ["select", "deselect", "hover", "dehover", "expand", "collapse", "loaded", "move",
                    "remove", "deselectAll", "rename", "refresh", "expandAll", "collapseAll", "destroy",
                    "create", "before",
                    "remove", "cut", "copy", "paste"] ;

  /**
    *  Return sanitized selector
    *  @private
    */
  function  _sanitizeSelector(hash) {
       return hash ? hash.replace( /[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g, "\\$&" ) : "";
  };

  /**
    *  Return sanitized html fragment for security
    *  @private
    */
  function  _escapeHtml(s) {
    var div = document.createElement('div');
    div.appendChild(document.createTextNode(s)) ;
    return div.innerHTML;
  };

  /**
    *  Return true if event name is public. 
    *  @private
    */
  function _isPublicEvent(s) {
     var  b = ($.inArray(s, _aEvNames) >= 0) ;
     if ((! b) && (s == "create_node")) {
       b = true ;
     }
     return b ;
  };

  /**
    *  Convert event names to ojTree style.
    *  @private
    */
  function _convertEventName(s) {
    // jsTree uses the same event names as its methods.  This behavior is changed for ojTree

    if      (s === "rename_node") {s = "rename";}
    else if (s === "set_focus")   {s = "focus";}
    else if (s === "unset_focus") {s = "unfocus";}
    else if (s === "delete_node") {s = "remove";}
    else if (s === "move_node")   {s = "move";}
    else if (s === "create_node") {s = "create";}

    return s ;
  };


  var scrollbar_width, e1, e2;
  $(function() {
     if (/msie/.test(navigator.userAgent.toLowerCase())) {
       e1 = $('<textarea cols="10" rows="2"></textarea>').css({ position: 'absolute', top: -1000, left: 0 }).appendTo('body');
       e2 = $('<textarea cols="10" rows="2" style="overflow: hidden;"></textarea>').css({ position: 'absolute', top: -1000, left: 0 }).appendTo('body');
       scrollbar_width = e1.width() - e2.width();
       e1.add(e2).remove();
     }
     else {
       e1 = $('<div />').css({ width: 100, height: 100, overflow: 'auto', position: 'absolute', top: -1000, left: 0 })
                        .prependTo('body').append('<div />').find('div').css({ width: '100%', height: 200 });
       scrollbar_width = 100 - e1.width();
       e1.parent().remove();
     }
  });


  /**
    *  Last remnants of jsTree css stuff.  TO BE REMOVED  TDO
    *  @param {Object=}  opts  The css data.
    *  @param {boolean=} bLink  True if opts.url is to be ignored.
    *  @private
    */
  function  _addSheet(opts, bLink)
  {
    var tmp    = false,
        isNew  = true;

    if (opts.str)  {
      if (opts.title)  {
        tmp = $("style[id='" + opts.title + "-stylesheet']")[0];
      }
      if (tmp)  {
        isNew = false;
      }
      else   {
        tmp = document.createElement("style");
        tmp.setAttribute('type',"text/css");
        if (opts.title) {
          tmp.setAttribute("id", opts.title + "-stylesheet");
        }
      }

      if (tmp.styleSheet)  {
        if (isNew)  {
          document.getElementsByTagName("head")[0].appendChild(tmp); 
          tmp.styleSheet.cssText = opts.str; 
        }
        else  {
          tmp.styleSheet.cssText = tmp.styleSheet.cssText + " " + opts.str;
        }
      }
      else   {
        tmp.appendChild(document.createTextNode(opts.str));
        document.getElementsByTagName("head")[0].appendChild(tmp);
      }

      return tmp.sheet || tmp.styleSheet;
    }

    if (opts.url) {
      if (bLink) {
        if (document.createStyleSheet)  {
          try  {
                 tmp = document.createStyleSheet(opts.url);    // IE
          }
          catch (e) { }

        }
        else  {
          tmp        = document.createElement('link');
          tmp.rel    = 'stylesheet';
          tmp.type   = 'text/css';
          tmp.media  = "all";
          tmp.href   = opts.url;

          document.getElementsByTagName("head")[0].appendChild(tmp);
          return tmp.styleSheet;
        }
      }
    }
  };

  /**
    * Stack of key handler objects for all trees
    * @private
    */
  var  _aKeyHandlerStack = [] ;

  /**
    * Add key combination handler to stack, and add listener 
    * @private
    */
  function  _addKeyFilter(obj)
  {
    _aKeyHandlerStack.push(obj) ;
    $(obj._selector).keydown(_KeyFilterHandler) ;
  };  

  /**
    * Handle keystroke from _KeyFilter and dispatch to the 
    * relevent accessibility key combination handler.
    * @private
    */
  function  _KeyFilterHandler(e)
  {
    var s = "" ;
  
    if (e.ctrlKey) {
      s += "ctrl+" ;
    }
    else if (e.shiftKey) {
      s += "shift+" ;
    }
//  if (e.metaKey) {
//    s += "meta+" ;                // TDO  Mac!
//  }

    var key = e.which ;
    switch(key) {
      case 32:                      // Space
                s += "space"
                break;
      case 37:                      // Left arrow
                s += "left"
                break;
      case 38:                      // Up arrow
                s += "up"
                break;
      case 39:                      // Right arrow
                s += "right"
                break;
      case 40:                      // Down arrow
                s += "down"
                break;
      case 46:                      // Delete
                s += "del"
                break;
      case 33:                      // Page Up
                s += "pgup"
                break;
      case 34:                      // Page Down
                s += "pgdn"
                break;
      case 35:                      // End
                s += "end"
                break;
      case 36:                      // Home
                s += "home"
                break;
//    case 112:                     // F1
      case 113:                     // F2
/*
      case 114:                     // F3
      case 115:                     // F4
      case 116:                     // F5
      case 117:                     // F6
      case 118:                     // F7
      case 119:                     // F8
      case 120:                     // F9
      case 121:                     // F10
      case 122:                     // F11
      case 123:                     // F12
*/
                s += ("f" + ('1' - (112 - key))) ;
                break;
    }

    if (s.length === 0) {
      return ;
    }

    // If we can find a handler from a tree with focus, dispatch
    // the keystroke event to it.
    var retHandler = undefined ;
    $.each(_aKeyHandlerStack, function(i, obj) {
        if (obj._this._data.ui.focused) {         // does associated tree have focus
          if (obj._handler[s]) {                  // yes, does it have a matching handler function
            e.preventDefault() ;
            retHandler = obj._handler[s].call(obj._this, e) ;
            return false ;          // break out of $.each
          }
        }
    });
    return retHandler;

  };

  /**
    * Remove key combination handler from stack and remove listener 
    * @private
    */
  function  _removeKeyFilter(selector)
  {
    $.each(_aKeyHandlerStack, function(i) {
       if (_aKeyHandlerStack[i]._selector === selector) {
         $(selector).off("keydown") ;
         _aKeyHandlerStack[i] = null ;
         _aKeyHandlerStack.splice(i, 1) ;
         return false ;
       }
    }) ;
  };


  /**
    * @private
    */
  var _instance   = -1 ;      // current Tree instance id
  var _aInstances = [] ;

/**
  * @class
  * @name oj.ojTree
  * @augments oj.baseComponent
  *
  * @classdesc
  * <h3 id="treeOverview-section">
  *   JET Tree Component
  *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#treeOverview-section"></a>
  * </h3>
  *
  * The ojTree component allows a user to display the hierarchical relationship between the nodes of a tree.<p>
  * The tree contents can be specified in JSON format, or by prepopulating the tree's containing &lt;div&gt; with
  * HTML &lt;ul&gt; list markup.
  * </p></br>
  * 
  * <h4 id="treeJSON-section"> JSON Node Format</h4>
  * </br>
  * Each node object typically has a <code class="prettyprint">title</code> and an
  * <code class="prettyprint">attr</code> property. Any node can be defined as a parent by supplying
  * a <code class="prettyprint">children</code> property, which is an array of more node definitions.
  * (Note that if a node has a <code class="prettyprint">children</code> property defined, but no children
  * are actually specified, then ojTree will perform lazy-loading by requesting child node data only
  * when a node is expanded for the first time - refer to <code class="prettyprint">option</code> property
  * <code class="prettyprint">data</code>.
  * <p>Example: Basic JSON Tree definition
  * <pre class="prettyprint">
  * <code>
  *[
  *   {                                    
  *     "title": "Home",
  *     "attr": {"id": "home"},
  *   },
  *   { 
  *     "title": "News",
  *     "attr": {"id": "news"}
  *   },
  *   { 
  *      "title": "Blogs",
  *      "attr": {"id": "blogs"},
  *      "children": [ {
  *                       "title": "Today",
  *                       "attr": {"id": "today"}
  *                    },
  *                    {
  *                       "title": "Yesterday",
  *                       "attr": {"id": "yesterday"}
  *                    }
  *                  ]
  *   }
  *] 
  *</code></pre>
  *</p></br>
  * Whatever attributes are defined for the <code class="prettyprint">attr</code> property are transferred
  * to the associated DOM &lt;li&gt; element. A <code class="prettyprint">metadata</code> attribute can also be
  * defined for arbitrary user-defined data that is to be associated with a node. (This metadata is
  * maintained within the ojTree instance, and is not represented in the DOM.)  A node's metadata can be retrieved
  * using the jQuery .data() method.
  * </p></br>Example: Expanded use of the <code class="prettyprint">attr</code> property
  * <pre class="prettyprint">
  * <code>
  *[
  *  { 
  *    "title": "Home",
  *    "attr": {
  *               "id": "home",
  *               "myattr1": "Hello",         &lt;-- additional user-defined attributes
  *               "myattr2": "World"         &lt;-- additional user-defined attributes 
  *            },
  *    "metadata": {                          &lt;-- node metadata
  *                  "type": "T123",
  *                  "val": 42,
  *                  "active": true
  *                }
  *  },
  *
  *  . . .
  *]
  *</code></pre>
  *
  * </p></br>Example: Retrieving node attributes and data
  * <pre class="prettyprint">
  * <code>
  *$("#mytree).on("ojtreehover", function (ev, ui){
  *
  *  // ui.item = node
  *  // ui.item.attr("id")         -  retrieve a node attribute
  *  // ui.item.attr("myattr1")    -    ..
  *  // ui.item.data("active")     -  retrieve the "active" meta-data value from previous example
  *
  *});
  *</code></pre>
  *</p></br>
  * For flexibility, attributes can also be applied to the node's &lt;a&gt; element if required, by specifying
  * the node <code class="prettyprint">data</code> property as an object.
  * </p>Example: Using the data property
  * <pre class="prettyprint">
  * <code>
  *{
  *   "attr" : { "id" : "myid" },                    &lt;-- this is set on the &lt;li&gt;
  *   "data" : {
  *              "attr" : {
  *                         "flags"   : "A-B",       &lt;-- this is set on the &lt;a&gt;
  *                         "title" : "This is a tooltip"
  *                       }
  *             }
  *}
  *</code></pre>
  *</p></br>
  * <h4 id="treeHTML-section"> HTML Node Format</h4>
  * </br>
  * A Tree can be populated via standard HTML markup using a &lt;ul&gt; list structure - refer to
  * <code class="prettyprint">option</code> property <code class="prettyprint">"data"</code>.  In
  * the case where the <code class="prettyprint">"data"</code> option has not been defined, ojTree
  * will use any HTML markup defined in the Tree's containing &lt;div&gt;, and on startup the &lt;ul&gt;
  * the markup will be detached from the containing &lt;div&gt;, saved, and used as a template to create a new
  * tree structure in its place.  When the tree is destroyed, the original markup is restored.  Lazy loading of 
  * a node's children (when expanded) is performed if any node indicates that it has children,  
  * but its child &lt;ul&gt; list is left empty.
  * </p></br>Example: Using HTML markup to populate a Tree.
  * <pre class="prettyprint">
  * <code>
  * &lt;div id="mytree"&gt;
  *    &lt;ul&gt;
  *       &lt;li id="home"&gt;
  *          &lt;a href="#"&lt;Home&gt;/a&gt;
  *       &lt;/li&gt;
  *       &lt;li id="news"&gt;
  *          &lt;a href="#"&gt;News&lt;/a&gt;
  *       &lt;/li&gt;
  *       &lt;li id="blogs"&gt;
  *            &lt;a href="#"&gt;Blogs&lt;/a&gt;
  *            &lt;ul&gt;
  *              &lt;li id="today"&gt;
  *                 &lt;a href="#"&gt;Today&lt;/a&gt;
  *              &lt;/li>
  *              &lt;li id="yesterday"&gt;
  *                 &lt;a href="#"&gt;Yesterday&lt;/a&gt;
  *              &lt;/li&gt;
  *            &lt;/ul&gt;
  *       &lt;/li&gt;
  * &lt;/div&gt;
  </code></pre>
  * </p></br>
  * <h3 id="keyboard-section">Keyboard interaction<a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a></h3>
  * <table class="keyboard-table">
  *   <thead>
  *     <tr>
  *       <th>Key</th>
  *       <th>Use</th>
  *     </tr>
  *   </thead>
  *   <tbody>
  *     <tr>
  *       <td><kbd>Up/down arrow</kbd></td>
  *       <td>Moves between visible nodes.</td>
  *     </tr>
  *     <tr>
  *       <td><kbd>Left-arrow</kbd></td>
  *       <td>On an expanded node, collapses the node.<br>On a collapsed or leaf node, moves focus to the node's parent.</td>
  *     </tr>
  *     <tr>
  *       <td><kbd>Right-arrow</kbd></td>
  *       <td>On a collapsed node, expands the node.<br>On an expanded node, moves to the first first child of the node.<br>On an end node, does nothing.</td>
  *     </tr>
  *     <tr>
  *       <td><kbd>Space bar</kbd></td>
  *       <td>Toggles the select status of the node.</td>
  *     </tr>
  *     <tr>
  *       <td><kbd>Home</kbd></td>
  *       <td>Moves to the top node of the tree.</td>
  *     </tr>
  *     <tr>
  *       <td><kbd>End</kbd></td>
  *       <td>Moves to the last visible node of the tree.</td>
  *     </tr>
  *     <tr>
  *       <td><kbd>Shift-Up arrow</kbd></td>
  *       <td>Extends selection up one node (assuming multiple selection has been defined).</td>
  *     </tr>
  *     <tr>
  *       <td><kbd>Shift-Down arrow</kbd></td>
  *       <td>Extends selection down one node (assuming multiple selection has been defined).</td>
  *     </tr>
  *     <tr>
  *       <td><kbd>Shift-Home</kbd></td>
  *       <td>Extends selection up to the top-most node.</td>
  *     </tr>
  *     <tr>
  *       <td><kbd>Shift+pgDn</kbd></td>
  *       <td>Extends selection to the last node.</td>
  *     </tr>
  *     <tr>
  *       <td><kbd>Ctrl+Space bar</kbd></td>
  *       <td>Toggles the selection state of the current node (assuming multiple selection has been defined).</td>
  *     </tr>
  *     <tr>
  *       <td><kbd>Shift+Space bar</kbd></td>
  *       <td>Extends selection to the current node (assuming multiple selection has been defined).</td>
  *     </tr>
  *     <tr>
  *       <td><kbd>* (asterisk)</kbd></td>
  *       <td>Expands all nodes.</td>
  *     </tr>
  * </tbody></table>
  *
  *
  * @desc Creates a JET Tree.
  * @param {Object=} options a map of option-value pairs to set on the component
  * 
  * @example <caption>Initialize the Tree with options:</caption>
  * $( ".selector" ).ojTree( {"animDuration": 0, "selectionMode": "single"} );
  * 
  */
  oj.__registerWidget("oj.ojTree", $['oj']['baseComponent'], 
  {
     version           : "1.0.0", 
     widgetEventPrefix : "oj", 
     defaultElement    : "<div>", 

     options: {
                /** Disables the tree if set to <code class="prettyprint">true</code>.
                  * 
                  * @member
                  * @name disabled
                  * @memberof! oj.ojTree
                  * @instance
                  * @type {boolean}
                  * @default <code class="prettyprint">false</code>
                  * 
                  * @example <caption>Initialize the tree with the <code class="prettyprint">disabled</code> option specified:</caption>
                  * $( ".selector" ).ojTree( { "disabled": true } );
                  * 
                  * @example <caption>Get or set the <code class="prettyprint">disabled</code> option, after initialization:</caption>
                  * // getter
                  * var disabled = $( ".selector" ).ojTree( "option", "disabled" );
                  * 
                  * // setter
                  * $( ".selector" ).ojTree( "option", "disabled", true );
                  */
                  // disabled option declared in superclass, but we still want the above API doc

                /**
                  * Identifies the JET Menu that the component should launch as a context menu on right-click or
                  * <kbd>Shift-F10</kbd>. If specified, the browser's native context menu will be replaced by the
                  * specified JET Menu.
                  * 
                  * <p>To specify a JET context menu on a DOM element that is not a JET component, see the
                  * <code class="prettyprint">ojContextMenu</code> binding.  
                  * 
                  * <p>To make the page semantically accurate from the outset, applications are encouraged to specify the
                  * context menu via the standard HTML5 syntax shown in the below example.  When the component is
                  * initialized, the context menu thus specified will be set on the component.
                  *
                  * <p>When defining a contextMenu, ojTree will provide built-in behavior for "edit" style functionality
                  *  (e.g. cut/copy/paste) if the following format for menu &lt;li&gt; item's is used (no &lt;a&gt; 
                  *  elements are required):
                  * <ul><li> &lt;li data-oj-command="oj-tree-cut" /&gt;</li>
                  *     <li> &lt;li data-oj-command="oj-tree-copy" /&gt;</li>
                  *     <li> &lt;li data-oj-command="oj-tree-paste" /&gt;</li>
                  *     <li> &lt;li data-oj-command="oj-tree-remove" /&gt;</li>
                  *     <li> &lt;li data-oj-command="oj-tree-rename" /&gt;</li>
                  * </ul>
                  * The available translated text will be applied to menu items defined this way.
                  *
                  * <p>The JET Menu should be initialized before any component using it as a context menu.
                  * 
                  * @member
                  * @name contextMenu
                  * @memberof! oj.ojTree
                  * @instance
                  * @type {string | null}
                  * @default <code class="prettyprint">null</code>
                  * 
                  * @example <caption>Initialize a JET Tree with a context menu:</caption>
                  * // via recommended HTML5 syntax:
                  * &lt;div id="myTree" contextmenu="myMenu" data-bind="ojComponent: { ... }>
                  * 
                  * // via JET initializer (less preferred) :
                  * $( ".selector" ).ojTree({ "contextMenu": "#myContextMenu"  ... } });
                  * 
                  * @example <caption>Get or set the <code class="prettyprint">contextMenu</code> option for
                  *      an ojTree after initialization:</caption>
                  * // getter
                  * var menu = $( ".selector" ).ojTree( "option", "contextMenu" );
                  * 
                  * // setter
                  * $( ".selector" ).ojTree( "option", "contextMenu", "#myContextMenu"} );
                  */

                /**
                  * Specifies an animation duration in milliseconds for expanding or collapsing a node.
                  * Specify zero to inhibit animation.
                  * @type {number}
                  * @default <code class="prettyprint">500</code>
                  * @expose
                  * @instance
                  * @memberof! oj.ojTree
                  */
                animDuration  : 500,

                /**
                  * Specifies whether the user is permitted to reorder the nodes within the same tree using drag and drop.</br></br>
                  * Specify an object with the property "reorder" set to <code class="prettyprint">true</code> to enable
                  * reordering.  Setting the <code class="prettyprint">"reorder"</code> property to <code class="prettyprint">false</code>,
                  * or setting the <code class="prettyprint">"dnd"</code> property to <code class="prettyprint">false</code> (or omitting
                  * it), disables reordering support. 
                  * 
                  * @example <caption>Example: Enable drag and drop for tree node reordering</caption>
                  * dnd : (
                  *         "reorder" : true
                  *       }
                  *
                  * @type {Object | boolean}
                  * @default <code class="prettyprint">false</code>
                  * @expose
                  * @instance
                  * @memberof! oj.ojTree
                  */
                dnd : false,

                /**
                  * Specify <span class="code-caption">true</span> if expanding a node programatically should
                  * also expand its parents (i.e all parent nodes down to this node will be expanded).
                  * @type {boolean}
                  * @default <code class="prettyprint">false</code>
                  * @expose
                  * @instance
                  * @memberof! oj.ojTree
                  */
                expandParents : false,

                /**
                  * Specifies whether any nodes should be initially expanded on start-up.   Specify an array
                  * of node id's, or the string <span class="code-caption">"all"</span> if all parent nodes
                  * should be expanded.  The value may optionally be specified as an empty array.
                  * @type {Array | null}
                  * @default <code class="prettyprint">null</code>
                  * @expose
                  * @instance
                  * @memberof! oj.ojTree
                  */
                initExpanded  : null,

                initLoaded    : [],                  // suppressed per design review

                /**
                  * Specifies whether selection is permitted, and whether more than one node
                  * can be selected at a time.  Values are <span class="code-caption">"single"</span>
                  * for single selection, <span class="code-caption">"multiple"</span> to allow multiple
                  * concurrent selections, and <span class="code-caption">"none"</span> to inhibit selection.
                  * @type {string}
                  * @default <code class="prettyprint">"single"</code>
                  * @expose
                  * @instance
                  * @memberof! oj.ojTree
                  */
                selectionMode             :  "single" ,

                /**
                  *  Specifies what action is to be taken when a selected node's parent is collapsed.  Specify
                  *  false if nothing is to be done. Specify <span class="code-caption">"selectParent"</span>
                  *  if the node's closed parent is to be selected, or specify <span class="code-caption">"deselect"</span>
                  *  if the node is to be deselected.
                  * @type {boolean | string}
                  * @default <code class="prettyprint">false</code>
                  * @expose
                  * @instance
                  * @memberof! oj.ojTree
                  */
                selectedParentCollapse    :  false ,

                /**
                  *  Specifies what action is to be taken when a node is programmatically expanded.  Specify
                  *  <span class="code-caption">true</span> if all of the node's closed parents should be opened
                  *  automatically.  If <span class="code-caption">false</span> is specified, the node is selected but will
                  *  remain invisible if its parents are currently collapsed.
                  * @type {boolean}
                  * @default <code class="prettyprint">true</code>
                  * @expose
                  * @instance
                  * @memberof! oj.ojTree
                  */
                selectedParentExpand      :  true ,

                /**
                  * Specifies the action to take when a selected node is deleted.  If set to 
                  * <span class="code-caption">true</span>, its previous sibling (or parent, if no previous siblings)
                  * is selected.  If <span class="code-caption">false</span> is specified, no action is taken.
                  * @type {boolean}
                  * @default <code class="prettyprint">false</code>
                  * @expose
                  * @instance
                  * @memberof! oj.ojTree
                  */
                selectPrevOnDelete        :  false ,

//              "initSelected"              :  [],         // removed per Design Review

                /**
                  * Specifies the data source used to populate the tree. Currently supported data sources are a <code class="prettyprint">JsonTreeDataSource</code>,
                  * or json, or html.</br></br> 
                  * The general format of the <code class="prettyprint">data</code> option is one of the following:
                  *</br></br>
                  *<ul>
                  *   <li>data : oj.JsonTreeDataSource</br></br></li>
                  *   <li>data : null    (or omit) - ojTree will look at the containing &lt;div&gt;
                  *                       and use any existing html &lt;ul&gt; markup found</br></br></li>
                  *   <li>data : "  json string  "</br></br></li>
                  *   <li>data : [ array of json objects ]</br></br></li>
                  *   <li>data : "&lt;ul&gt;&lt;li&gt; ...  html markup string  &lt;/ul&gt;"</br></br></li>
                  *   <li>data : { "data" : &nbsp; &nbsp; ... or &nbsp; &nbsp; "ajax" : &nbsp; &nbsp; . . . &nbsp; &nbsp;}  &nbsp; &nbsp; &nbsp; // retrieve json or html</li>
                  * </ul>
                  *</br>
                  * Use of the <code class="prettyprint">"data"</code> property of the <code class="prettyprint">data</code> option,
                  * specifies that the tree is to be populated from JSON or HTML (local or remote).
                  * The <code class="prettyprint">"data"</code> object contains one of two properties:
                  * <ul>
                  *  <li>"data"</li>
                  *  <li>"ajax"</li>
                  * </ul>
                  *  An optional <code class="prettyprint">"dataType"</code> property may also be specified, which can take the
                  *  value <code class="prettyprint">"json"</code> or <code class="prettyprint">"html"</code>, and indicates
                  *  what kind of data is being returned in the <code class="prettyprint">"data"</code> or
                  *  <code class="prettyprint">"ajax"</code> method (default is "json").
                  * </ul>
                  *
                  * When <span class="code-caption">"data"</span> is specified as an object, its <span class="code-caption">"data"</span> property may be specified as a function which
                  * receives two arguments: <span class="code-caption">node</span>, and <span class="code-caption">fn</span>.
                  * </p></br>
                  * Example: Skeleton outline of a <code class="prettyprint">"data"</code> function:
                  *</br>
                  *<pre class="prettyprint">
                  *<code>
                  *data : {
                  *          "data" : function(node, fn) {
                  *                    // node  -  the jQuery wrapped node to be expanded for a lazy load,
                  *                    //          or -1 if it is the initial call to load the tree.
                  *                    // fn    -  a function to call with the JSON to be applied.
                  *
                  *                    fn( new_json_node_data ) ;   // return the JSON
                  *                   }
                  *        }
                  *</code></pre>
                  * </br>
                  * The <code class="prettyprint">"ajax"</code> property of the <code class="prettyprint">"data"</code> option
                  * allows remote JSON to be retrieved. It may be specified as an object (refer to the
                  * jQuery .ajax() settings object). If may also be specified as <code class="prettyprint">false</code> or
                  * omitted, if no AJAX operations are performed.</br></br>
                  * When specified as an object, it should contain the following two properties:
                  * <ul>
                  *  <li>type</li>
                  *  <li>url</li>
                  * </ul>
                  *<pre class="prettyprint">
                  *<code>
                  *"ajax" : {
                  *           "type": "GET",
                  *           "url":   "my_url"      // some url to the content
                  *          }
                  *</code></pre>
                  * <code class="prettyprint">"url"</code> may also be specified as a function which should return
                  * a url string:
                  *</br>
                  *<pre class="prettyprint">
                  *<code>
                  *"ajax" : {
                  *           "type" : "GET",
                  *           "url":   function (node) {
                  *                         ... return a url string ...
                  *                     }
                  *          )
                  *</code></pre>
                  * </br>
                  *  where  <span class="code-caption">node</span> is a parent node (can be used for lazy loading), or -1 to
                  *  indicate the initial tree load.
                  * </br></br>
                  *  Optionally, <span class="code-caption">success</span> and <span class="code-caption">error</span>
                  *  functions may be defined. If the <span class="code-caption">success</span> function returns a
                  *  value, it will be used to populate the tree; this can be useful if there is a need to transform
                  *  the data returned by a server at the client before it is displayed in the tree.
                  * </br></br></br>
                  *
                  * Note: to enable lazy loading of a parent node, specify that it has children but do not define them.
                  * When it is opened, data() or ajax() will be called with the node whose JSON is to be returned.</br></br>
                  *@example <caption>Example 1: Skeleton outline of success and error functions</caption>
                  *<code>
                  *"ajax": {
                  *          "type":"GET",
                  *          "url": myurl    &lt;-- url to full tree JSON
                  *          "success" : function(data, status, obj) {
                  *                        // data   = the JSON data
                  *                        // status = "success"
                  *                        // obj    = the AJAX object.
                  *                        trace("Ajax " + status) ;
                  *                        // return the data, can transform it first if required.
                  *                        // if no return value, the data is used untransformed.
                  *          },
                  *          "error" : function(reason, feedback, obj) {
                  *                        // reason e.g. "parsererror"
                  *                        // feedback.message  e.g. "unexpected string"
                  *                        // obj    = the AJAX object.
                  *                        trace("Ajax error " + reason + " feedback=" + feedback.message) ;
                  *          },
                  * </code>
                  *
                  *@example <caption>Example 2:  Load the complete tree from locally defined JSON.</caption>
                  *<code>
                  *"data" :  [
                  *            { 
                  *             "title": "Home",
                  *             "attr": {"id": "home"},
                  *            },
                  *            { 
                  *              "title": "News",
                  *              "attr": {"id": "news"}
                  *            },
                  *            { 
                  *              "title": "Blogs",
                  *              "attr": {"id": "blogs"},
                  *              "children": [ { 
                  *                             "title": "Today",
                  *                             "attr": {"id": "today"}
                  *                            },
                  *                            { 
                  *                              "title": "Yesterday",
                  *                              "attr": {"id": "yesterday"}
                  *                            }
                  *                          ]
                  *            }
                  *          ]
                  *</code>
                  *
                  *@example <caption>Example 3:  Load the complete tree with remotely served JSON.</caption>
                  *<code>
                  *"data" : {
                  *            "ajax": {
                  *                     "type":"GET",
                  *                     "url": myurl    <-- url to full tree JSON
                  *                    }
                  *           
                  *          }  
                  *</code>
                  *
                  *@example <caption>Example 4:  Load the complete tree with remotely served JSON via a function.</caption>
                  *<code>
                  *"data" : {
                  *           
                  *           "ajax": {
                  *                     "type":"GET",
                  *                     "url": function() {
                  *                               return (a url) ;
                  *                            }
                  *                   }
                  *           
                  *          }  
                  * </code>
                  *
                  *@example <caption>Example 5:  Load a partial tree, and retrieve node data when a parent node is expanded and needs to be populated.</caption>
                  *<code>
                  *"data" : {
                  *           "ajax": {
                  *                     "type":"GET",
                  *                     "url": function(node) {
                  *                             if (node === -1) {                       // -1 indicates initial load
                  *                               return (url for for  partial json) ;   // the tree outline with parent nodes empty.
                  *                             }
                  *                             else {
                  *                               var id = node.attr("id") ;
                  *
                  *                               return (a url based on the node id to retrieve just the node children) ; 
                  *                             }
                  *                           }
                  *                   }
                  *           
                  *          }
                  *</code>
                  *
                  *@example <caption>Example 6:  Transform data received from server before passing to ojTree.</caption>
                  *<code>
                  *"data" : {
                  *           "ajax": {
                  *                     "type":"GET",
                  *                     "url": function(node) {
                  *                              . . .
                  *                            },
                  *                      "success" : function (data)  {
                  *                                    . . .    // transform the received data into node JSON format
                  *
                  *                                    return (transformed data) ;
                  *                                  },
                  *                      "error" : function () {
                  *                                   // ajax call failed.
                  *                                }
                  *                   } 
                  *           
                  *          }
                  *</code>
                  *
                  * @example <caption>Example 7:  Use own mechanism to load a partial tree and retrieve node data when a parent is expanded.</caption>
                  * <code>
                  * // Sample outline of a tree.  Note that the parent nodes "Node2" and "Node3" have
                  * // their "children" property specifed, but no children are actually defined.
                  *
                  *{
                  *  "title" : Node1",
                  *  "attr" : {"id" : "n1"}
                  *},
                  *{
                  *  "title" : Node2",
                  *  "attr" : {"id" : "n2"},
                  *  "children" : []
                  *},
                  *{
                  *  "title" : Node3",
                  *  "attr" : {"id" : "n3"},
                  *  "children" : []
                  *},
                  *
                  *
                  *"data" : {
                  *           "data": function(node, fn) {
                  *                     // node  =  the node whose children are to be retrieved
                  *                     // fn    =  the function to call with the retrieved node json 
                  *
                  *                     if (node === -1) {             // initial tree load
                  *                       fn( acquired node json for the tree) ;
                  *                     }
                  *                     else {                         // node lazy load
                  *                       var id = node.attr("id") ;   // get the node id, will be "n2" 
                  *                                                    // or "n3", in this example.  
                  *                       fn( acquired node json for the expanded node ) ;
                  *                     }
                  *                  }
                  *           
                  *          }
                  *}
                  * </code>
                  * @type {Object | Array | string | null}
                  * @default <code class="prettyprint">null</code>
                  * @expose
                  * @instance
                  * @memberof! oj.ojTree
                  */
                 data : null,

                /**
                 * The text to display when there are no data in the Tree. If not specified, 
                 * default text is extracted from the resource bundle.  Specify an empty string if
                 * this default behavior is not required.
                 * 
                 * @expose 
                 * @memberof! oj.ojTree
                 * @instance
                 * @type {string|null}
                 * @default <code class="prettyprint">"No data"</code>
                 * 
                 * @example <caption>Initialize the tree with text set to 'no data':</caption>
                 * $( ".selector" ).ojTree({ "data":data, "emptyText": "no data" });
                 */
                emptyText: null,

                //  Themes

                /**
                  * Specifies whether node icons are to be displayed.  Specify <span class="code-caption">true</span>
                  * to display icons, or <span class="code-caption">false </span> to suppress node icons.
                  * @type {boolean}
                  * @default <code class="prettyprint">true</code>
                  * @expose
                  * @instance
                  * @memberof! oj.ojTree
                  */
                icons : true,

                /*
                 *  Specifies whether hierarchy lines between nodes are displayed.
                 *  // not exposed in V1
                 */
                //dots" : false,


                /**
                  * The <span class="code-caption">'types'</span> option allow nodes to be classified and their appearance
                  * and behavior modified.</br></br>
                  * Typical uses are to define a specific icon for a particular node, or to inhibit certain
                  * operations on a particular type of folder (e.g. the root node cannot be deleted or moved).
                  * <p>
                  * A node <span class="code-caption">type</span> has the following properties:
                  * <ul>
                  *   <li><span class="code-caption">"image"</span> -  specifies the location of the icon to be used
                  *         (optional). May also be specified as <span class="code-caption">false</span> to suppress
                  *         the image.</br></br></li>
                  *   <li><span class="code-caption">"position"</span> - position of sprite in the image in the format 
                  *        <span class="code-caption">"left top"</span>, e.g. "-36px -16px".</br>
                  *        Optional - omit if icon is not contained within a multi-sprite image.</br></br></li>
                  *   <li><span class="code-caption">method name</span> - specify a function or a
                  *         boolean. Optional.</br>  Any node operation method (that
                  *         is, takes a node as its first argument) can be redefined (e.g. <span class="code-caption">select</span>,
                  *         <span class="code-caption">expand</span>, <span class="code-caption">collapse</span>, etc). 
                  *         Alternatively, the method can be defined as <span class="code-caption">true</span> or 
                  *         <span class="code-caption">false</span> to permit or inhibit the operation, or a
                  *         function that returns a boolean value. The default value
                  *         if omitted is <span class="code-caption">true</span> (i.e. the operation is permitted).</li>
                  * </ul>
                  * In the following example, three node types have been defined: <span class="code-caption">"myroot"</span>,
                  * <span class="code-caption">"myfolder"</span>, and <span class="code-caption">"myleaf"</span>.
                  * Any node that does not have one of these types defaults its behavior to the default type
                  * (whose properties can also be redefined).  The default <span class="code-caption">"default"</span>
                  * node type has no restrictions on the operations that can be performed on the node. In the following
                  * example, a modification to the default type properties have been made.  Also, for the
                  * <span class="code-caption">"myroot"</span> node type, the standard <span class="code-caption">select</span>,
                  * <span class="code-caption">remove</span> and <span class="code-caption">move</span> operations return false
                  * which inhibts those operations.
                  * been redefined to be no-ops.
                  * @example <caption>Example 1:  Add custom appearance and node behavior.</caption>
                  * <code>
                  *"types": {
                  *            "myroot" :   {
                  *                            "image"  : baseurl + "/img/root.png",
                  *                            "select" : function() { return false; },
                  *                            "remove" : function() { return false; },
                  *                            "move" :   function() { return false; },
                  *                         },
                  *            "myfolder" : {
                  *                            "image" : baseurl + "/img/folder.png"
                  *                         },
                  *            "myleaf" :   {
                  *                           "image" : "baseurl + "/img/leaf.png"
                  *                         },
                  *            "default" : {   <-- optional redefinition of the default behavior
                  *                           "image" : "baseurl + "/img/leaf.png",
                  *                           "remove" : function() { return false; }
                  *                        }
                  *
                  *          }
                  *}
                  *</code>
                  * User-defined types are specified as an attribute of the node.  The default
                  * node type attribute is <span class="code-caption">"type"</span>, but this could be changed if desired using
                  * the <span class="code-caption">"attr"</span> property. Thus, for the node types in example 1 above, the node
                  * type attribute values in the node definitions could be set as in example 2:
                  * @example <caption>Example 2:  Using node types in the tree JSON.</caption>
                  * <code>
                  *[
                  *   {                                    
                  *     "title": "Root",
                  *     "attr": {
                  *               "id": "root",                       
                  *               "type": "myroot"                      &lt;--- node type 
                  *             },
                  *     "children": [
                  *                   {
                  *                     "title": "Home",
                  *                     "attr": {"id": "home",
                  *                              "type": "myleaf"}      &lt;--- node type
                  *                   },
                  *                   { 
                  *                     "title": "News",
                  *                     "attr": {
                  *                               "id": "news",
                  *                               "type": "myleaf"      &lt;--- node type
                  *                             }
                  *                   },
                  *                   { 
                  *                     "title": "Blogs",
                  *                     "attr": {
                  *                               "id": "blogs",
                  *                               "type": "myfolder"    &lt;--- node type
                  *                             },
                  *                     "children": [ {
                  *                                     "title": "Today",
                  *                                     "attr": {
                  *                                               "id": "today",
                  *                                               "type": "myleaf"
                  *                                             }
                  *                                   },
                  *                                   {                 &lt;--- default node type
                  *                                     "title": "Yesterday",
                  *                                     "attr": {"id": "yesterday"}
                  *                                   }
                  *                                 ]
                  *                   }
                  *                 ] 
                  *  }
                  *]
                  *</code>
                  * As described above, the node type attribute used on the corresponding tree
                  * &lt;li&gt; element defaults to <span class="code-caption">"type"</span>, but this can be redefined using the <span class="code-caption">attr</span>
                  * property as in the following example:
                  * @example <caption>Example 2:  Using node types in the tree JSON.</caption>
                  * <code>
                  *"types": {
                  *           "attr" : "mytype",    &lt;--- node type attribute is now "mytype"
                  *           "types": {
                  *                      "myroot" : {
                  *                                   "image" : . . .
                  *                                    . . .
                  *                                 }
                  *          }
                  *</code>
                  * @type {Object | null}
                  * @default <code class="prettyprint">true</code>
                  * @expose
                  * @instance
                  * @memberof! oj.ojTree
                  */
                types: null,


                //---------------------------//
                //   Option Event callbacks  //
                //---------------------------//

				/**
				  * Triggered prior to an event.
				  *
				  * @expose 
				  * @event 
				  * @memberof! oj.ojTree
				  * @instance
				  * @property {Event} event <code class="prettyprint">jQuery</code> event object
				  * @property {Object} ui Parameters
				  * @property {string} ui.func the event causing this <code class="prettyprint">before</code> event to be triggered.
				  * 
				  * @example <caption>Initialize the Tree with the <code class="prettyprint">before</code> callback specified:</caption>
				  * $( ".selector" ).ojTree({
				  *     "before": function(event, ui)  {
				  *                                       console.log("Before event " + ui.func);
				  *               }
				  * });
			      *
				  *
				  * @example <caption>Bind an event listener to the <code class="prettyprint">ojbefore</code> event:</caption>
				  * $( ".selector" ).on( "ojbefore", function( event, ui ) {
				  *                                       console.log("Before event " + ui.func);
				  *                                  });
				  */
				before : null,

				/**
				  * Triggered when a tree node is collapsed.
				  *
				  * @expose 
				  * @event 
				  * @memberof! oj.ojTree
				  * @instance
				  * @property {Event} event <code class="prettyprint">jQuery</code> event object
				  * @property {Object} ui Parameters
				  * @property {Object} ui.item the node that has been collapsed
				  * 
				  * @example <caption>Initialize the Tree with the <code class="prettyprint">collapse</code> callback specified:</caption>
				  * $( ".selector" ).ojTree({
				  *     "collapse": function( event, ui ) {. . .}
				  * });
				  *
				  * @example <caption>Bind an event listener to the <code class="prettyprint">ojcollapse</code> event:</caption>
				  * $( ".selector" ).on( "ojcollapse", function(event, ui) {. . .}
				  *                    );
				  */
				collapse : null,

				/**
				  * Triggered when a tree node has been created and added to the tree.
				  *
				  * @expose 
				  * @event 
				  * @memberof! oj.ojTree
				  * @instance
				  * @property {Event} event <code class="prettyprint">jQuery</code> event object
				  * @property {Object} ui Parameters
				  * @property {Object} ui.item the node that has been created
				  * 
				  * @example <caption>Initialize the Tree with the <code class="prettyprint">create</code> callback specified:</caption>
				  * $( ".selector" ).ojTree({
				  *     "create": function( event, ui ) {. . .}
				  * });
				  *
				  * @example <caption>Bind an event listener to the <code class="prettyprint">ojcreate</code> event:</caption>
				  * $( ".selector" ).on( "ojcreate", function(event, ui) {. . .}
				  *                    );
				  */
				create : null,

				/**
				  * Triggered when all nodes of a parent node, or the complete tree, have been collapsed.
				  *
				  * @expose 
				  * @event 
				  * @memberof! oj.ojTree
				  * @instance
				  * @property {Event} event <code class="prettyprint">jQuery</code> event object
				  * @property {Object} ui Parameters
				  * @property {Object} ui.item the node(s) that were collapsed.
				  * @property {Object} ui.targ the node that was targeted for collapseAll, or -1 if the complete tree is collapsed.
				  * 
				  * @example <caption>Initialize the Tree with the <code class="prettyprint">collapseAll</code> callback specified:</caption>
				  * $( ".selector" ).ojTree({
				  *     "collapseAll": function( event, ui ) {. . .}
				  * });
				  *
				  * @example <caption>Bind an event listener to the <code class="prettyprint">ojcollapseall</code> event:</caption>
				  * $( ".selector" ).on( "ojcollapseall", function( event, ui ) {. . .} );
				  */
				collapseAll : null,

				/**
				  * Triggered when a tree node has been cut from the tree via the context menu.
				  *
				  * @expose 
				  * @event 
				  * @memberof! oj.ojTree
				  * @instance
				  * @property {Event} event <code class="prettyprint">jQuery</code> event object
				  * @property {Object} ui Parameters
				  * @property {Object} ui.item the node that was cut
				  * 
				  * @example <caption>Initialize the Tree with the <code class="prettyprint">cut</code> callback specified:</caption>
				  * $( ".selector" ).ojTree({
				  *     "cut": function( event, ui ) {. . .}
				  * });
				  *
				  * @example <caption>Bind an event listener to the <code class="prettyprint">ojcut</code> event:</caption>
				  * $( ".selector" ).on( "ojcut", function( event, ui ) {. . .} );
				  */
				cut : null,

				/**
				  * Triggered when a tree node is no longer hovered over.
				  *
				  * @expose 
				  * @event 
				  * @memberof! oj.ojTree
				  * @instance
				  * @property {Event} event <code class="prettyprint">jQuery</code> event object
				  * @property {Object} ui Parameters
				  * @property {Object} ui.item the node that is no longer hovered over
				  * 
				  * @example <caption>Initialize the Tree with the <code class="prettyprint">dehover</code> callback specified:</caption>
				  * $( ".selector" ).ojTree({
				  *     "dehover": function( event, ui ) {. . .}
				  * });
				  *
				  * @example <caption>Bind an event listener to the <code class="prettyprint">ojdehover</code> event:</caption>
				  * $( ".selector" ).on( "ojdehover", function( event, ui ) {. . .} );
				  */
				dehover : null,

				/**
				  * Triggered when a tree node has been removed.
				  *
				  * @expose 
				  * @event 
				  * @memberof! oj.ojTree
				  * @instance
				  * @property {Event} event <code class="prettyprint">jQuery</code> event object
				  * @property {Object} ui Parameters
				  * @property {Object} ui.item the node that has been removed.
				  * @property {Object} ui.parent the parent of the node that was removed.
				  * @property {Object} ui.prev the previous sibling, or if ui.item is the first child of
				  *                    its parent, the parent node.
				  * 
				  * @example <caption>Initialize the Tree with the <code class="prettyprint">remove</code> callback specified:</caption>
				  * $( ".selector" ).ojTree({
				  *     "remove": function( event, ui ) {. . .}
				  * });
				  *
				  * @example <caption>Bind an event listener to the <code class="prettyprint">ojremove</code> event:</caption>
				  * $( ".selector" ).on( "ojremove", function( event, ui ) {. . .} );
				  */
				remove : null,

				/**
				  * Triggered when a tree node is deselected.
				  *
				  * @expose 
				  * @event 
				  * @memberof! oj.ojTree
				  * @instance
				  * @property {Event} event <code class="prettyprint">jQuery</code> event object
				  * @property {Object} ui Parameters
				  * @property {Object} ui.item the node that has become de-selected.
				  * 
				  * @example <caption>Initialize the Tree with the <code class="prettyprint">deselect</code> callback specified:</caption>
				  * $( ".selector" ).ojTree({
				  *     "deselect": function( event, ui ) {. . .}
				  * });
				  *
				  * @example <caption>Bind an event listener to the <code class="prettyprint">ojdeselect</code> event:</caption>
				  * $( ".selector" ).on( "ojdeselect", function( event, ui ) {. . .} );
				  */
				deselect : null,

				/**
				  * Triggered when all nodes of a parent node, or the complete tree, have been de-selected.
				  *
				  * @expose 
				  * @event 
				  * @memberof! oj.ojTree
				  * @instance
				  * @property {Event} event <code class="prettyprint">jQuery</code> event object
				  * @property {Object} ui Parameters
				  * @property {Object} ui.item the node(s) that have become de-selected.
				  * @property {Object} ui.targ the context node that was targeted for deselectAll, or -1 if the complete tree is deselected.
				  * 
				  * @example <caption>Initialize the Tree with the <code class="prettyprint">deselectAll</code> callback specified:</caption>
				  * $( ".selector" ).ojTree({
				  *     "deselectAll": function( event, ui ) {. . .}
				  * });
				  *
				  * @example <caption>Bind an event listener to the <code class="prettyprint">ojdeselectall</code> event:</caption>
				  * $( ".selector" ).on( "ojdeselectall", function( event, ui ) {. . .} );
				  */
				deselectAll : null,

				/**
				  * Triggered when a tree is destroyed.
				  *
				  * @expose 
				  * @event 
				  * @memberof! oj.ojTree
				  * @instance
				  * @property {Event} event <code class="prettyprint">jQuery</code> event object
				  * @property {Object} ui Parameters
				  * 
				  * @example <caption>Initialize the Tree with the <code class="prettyprint">destroy</code> callback specified:</caption>
				  * $( ".selector" ).ojTree({
				  *     "destroy": function( event, ui ) {}
				  * });
				  *
				  * @example <caption>Bind an event listener to the <code class="prettyprint">ojdestroy</code> event:</caption>
				  * $( ".selector" ).on( "ojdestroy", function( event, ui ) {} );
				  */
				destroy : null,

				/**
				  * Triggered when a tree node is expanded.
				  *
				  * @expose 
				  * @event 
				  * @memberof! oj.ojTree
				  * @instance
				  * @property {Event} event <code class="prettyprint">jQuery</code> event object
				  * @property {Object} ui Parameters
				  * @property {Object} ui.item the node that has been expanded
				  * 
				  * @example <caption>Initialize the Tree with the <code class="prettyprint">expand</code> callback specified:</caption>
				  * $( ".selector" ).ojTree({
				  *     "expand": function( event, ui ) {. . .}
				  * });
				  *
				  * @example <caption>Bind an event listener to the <code class="prettyprint">ojexpand</code> event:</caption>
				  * $( ".selector" ).on( "ojexpand", function( event, ui ) {. . .} );
				  */
				expand : null,

				/**
				  * Triggered when all nodes of a parent node, or the complete tree, have been expanded.
				  *
				  * @expose 
				  * @event 
				  * @memberof! oj.ojTree
				  * @instance
				  * @property {Event} event <code class="prettyprint">jQuery</code> event object
				  * @property {Object} ui Parameters
				  * @property {Object} ui.item the node(s) that were expanded.
				  * @property {Object} ui.targ the node that was targeted for expandAll, or -1 if the complete tree is collapsed.
				  * 
				  * @example <caption>Initialize the Tree with the <code class="prettyprint">expandAll</code> callback specified:</caption>
				  * $( ".selector" ).ojTree({
				  *     "expandAll": function( event, ui ) {. . .}
				  * });
				  *
				  * @example <caption>Bind an event listener to the <code class="prettyprint">ojexpandall</code> event:</caption>
				  * $( ".selector" ).on( "ojexpandall", function( event, ui ) {. . .} );
				  */
				expandAll : null,

				/**
				  * Triggered when a tree node is hovered over.
				  *
				  * @expose 
				  * @event 
				  * @memberof! oj.ojTree
				  * @instance
				  * @property {Event} event <code class="prettyprint">jQuery</code> event object
				  * @property {Object} ui Parameters
				  * @property {Object} ui.item the node that is hovered over
				  * 
				  * @example <caption>Initialize the Tree with the <code class="prettyprint">hover</code> callback specified:</caption>
				  * $( ".selector" ).ojTree({
				  *     "hover": function( event, ui ) {. . .}
				  * });
				  *
				  * @example <caption>Bind an event listener to the <code class="prettyprint">ojhover</code> event:</caption>
				  * $( ".selector" ).on( "ojhover", function( event, ui ) {. . .} );
				  */
				hover : null,

				/**
				  * Triggered when a tree has been loaded and the node data has been applied.
				  *
				  * @expose 
				  * @event 
				  * @memberof! oj.ojTree
				  * @instance
				  * @property {Event} event <code class="prettyprint">jQuery</code> event object
				  * @property {Object} ui Parameters
				  * 
				  * @example <caption>Initialize the Tree with the <code class="prettyprint">loaded</code> callback specified:</caption>
				  * $( ".selector" ).ojTree({
				  *     "loaded": function( event, ui ) {}
				  * });
				  *
				  * @example <caption>Bind an event listener to the <code class="prettyprint">ojloaded</code> event:</caption>
				  * $( ".selector" ).on( "ojloaded", function( event, ui ) {} );
				  */
				loaded : null,

				/**
				  * Triggered when a tree node has been moved within the tree.
				  *
				  * @expose 
				  * @event 
				  * @memberof! oj.ojTree
				  * @instance
				  * @property {Event} event <code class="prettyprint">jQuery</code> event object
				  * @property {Object} ui Parameters
				  * @property {Object} ui.item the node that was moved
				  * @property {string} ui.position the moved node's new position relative to the reference node.
				  *                    Can be "before", "after", or "inside".
				  * @property {Object} ui.reference the reference node that ui.position refers to.
				  * 
				  * @example <caption>Initialize the Tree with the <code class="prettyprint">move</code> callback specified:</caption>
				  * $( ".selector" ).ojTree({
				  *     "move": function(event, ui) {. . .}
				  * });
				  *
				  * @example <caption>Bind an event listener to the <code class="prettyprint">ojmove</code> event:</caption>
				  * $( ".selector" ).on( "ojmove", function(event, ui) {. . .} );
				  */
				move : null,

				/**
				  * Triggered when a tree node has been pasted into the tree via the context menu.
				  *
				  * @expose 
				  * @event 
				  * @memberof! oj.ojTree
				  * @instance
				  * @property {Event} event <code class="prettyprint">jQuery</code> event object
				  * @property {Object} ui Parameters
				  * @property {Object} ui.item the node that was pasted
				  * 
				  * @example <caption>Initialize the Tree with the <code class="prettyprint">paste</code> callback specified:</caption>
				  * $( ".selector" ).ojTree({
				  *     "paste": function( event, ui ) {. . .}
				  * });
				  *
				  * @example <caption>Bind an event listener to the <code class="prettyprint">ojpaste</code> event:</caption>
				  * $( ".selector" ).on( "ojpaste", function( event, ui ) {. . .} );
				  */
				paste : null,

				/**
				  * Triggered when a tree node, or the complete tree, has been refreshed.
				  *
				  * @expose 
				  * @event 
				  * @memberof! oj.ojTree
				  * @instance
				  * @property {Event} event <code class="prettyprint">jQuery</code> event object
				  * @property {Object} ui Parameters
				  * @property {Object} ui.item the node that has been refreshed, or -1 if the whole tree has been refreshed.
				  * 
				  * @example <caption>Initialize the Tree with the <code class="prettyprint">refresh</code> callback specified:</caption>
				  * $( ".selector" ).ojTree({
				  *     "refresh": function( event, ui ) {. . .}
				  * });
				  *
				  * @example <caption>Bind an event listener to the <code class="prettyprint">ojrefresh</code> event:</caption>
				  * $( ".selector" ).on( "ojrefresh", function( event, ui ) {. . .} );
				  */
				refresh : null,

				/**
				  * Triggered when a tree node has been renamed.
				  *
				  * @expose 
				  * @event 
				  * @memberof! oj.ojTree
				  * @instance
				  * @property {Event} event <code class="prettyprint">jQuery</code> event object
				  * @property {Object} ui Parameters
				  * @property {Object} ui.item the node that has been renamed
				  * @property {string} ui.title the new node text title.
				  * @property {string} ui.prevTitle the node title prior to the rename.
				  * 
				  * @example <caption>Initialize the Tree with the <code class="prettyprint">rename</code> callback specified:</caption>
				  * $( ".selector" ).ojTree({
				  *     "rename": function( event, ui ) {. . .}
				  * });
				  *
				  * @example <caption>Bind an event listener to the <code class="prettyprint">ojrename</code> event:</caption>
				  * $( ".selector" ).on( "ojrename", function( event, ui ) {. . .} );
				  */
				rename : null,

				/**
				  * Triggered when a tree node is selected.
				  *
				  * @expose 
				  * @event 
				  * @memberof! oj.ojTree
				  * @instance
				  * @property {Event} event <code class="prettyprint">jQuery</code> event object
				  * @property {Object} ui Parameters
				  * @property {Object} ui.item the node that has been selected.
				  * 
				  * @example <caption>Initialize the Tree with the <code class="prettyprint">select</code> callback specified:</caption>
				  * $( ".selector" ).ojTree({
				  *     "select": function( event, ui ) {. . .}
				  * });
				  *
				  * @example <caption>Bind an event listener to the <code class="prettyprint">ojselect</code> event:</caption>
				  * $( ".selector" ).on( "ojselect", function( event, ui ) {. . .} );
				  */
				select : null

     },   // end options


     /*---------------*/
     /* Public API's  */
     /*---------------*/

     /** Collapses an expanded node, so that its children are not visible.  Triggers a "collapse" event.
       *
       * @param {HTMLElement | Object | string} node - Can be a DOM element, a jQuery wrapped node, or a selector
       *                        pointing to the element to be collapsed.
       * @param {boolean=} skipAnim - Set to true to suppress node collapse animation (assuming
       *                        option property "animDuration" is defined or defaulted). Default is false.
       * @expose 
       * @public
       * @instance
       * @memberof! oj.ojTree 
       */
     collapse : function(node, skipAnim)
     {
        node = this._getNode(node);
        var s = skipAnim || this.options["animDuration"],
            t = this;

        if (!node.length || node === -1 || !node.hasClass(OJT_OPEN) ||
                            this._data.core.locked || node.hasClass("oj-disabled"))  {
          return false;
        }

        var rslt = this._emitEvent({"obj" : node, "func" : "collapse"}, "before") ;
        if (typeof rslt == "boolean" && (!rslt)) {
          return ;
        }

        if (s)  {
          node.children("ul").attr("style","display:block !important");
        }
        node.removeClass(OJT_OPEN).addClass(OJT_CLOSED).attr(WA_EXPANDED, "false");
        if (s) {
          node.children("ul").stop(true, true).slideUp(s, function ()
                                                          {
                                                            this.style.display = "";
//                                                          this["style"]["display"] = "";
                                                            t["after_close"](node);
                                                          });
        }
        else   {
          t["after_close"](node);
        }
        this._emitEvent({ "obj" : node }, "collapse");
     },


     /** Collapses a node and all its descendants.  Triggers a "collapseall" event.
       * @param {HTMLElement | Object | string} node - Can be a DOM element, a jQuery wrapped node, or a
       *                       selector pointing to the element whose descendants are to be collapsed. 
       *                       If omitted , or set to -1, all nodes in the tree are collapsed.
       * @param {boolean=} anim - Set to true (or omit) if all nodes are to collapsed with animation (assuming
       *                        option property "animDuration" is defined or defaulted). Default is true.
       * @expose 
       * @public
       * @instance
       * @memberof! oj.ojTree 
     */
     collapseAll : function(node, anim)
     {
        var origTarg = node? node : -1 ;
        var _this = this;

        if (this._data.core.locked) {
          return ;
        }

        node = node ? this._getNode(node) : this._$container;
        if (node && origTarg !== -1) {
          origTarg = node ;
        }
        if (!node || origTarg === -1)  {
          node = this._$container_ul;
        }

        if (node.hasClass("oj-disabled")) {
          return ;
        }

        var subject ;
        if (origTarg !== -1 && this["isExpanded"](node)) {
          subject = node[0] ;
        }

        var objs  =  node.find("li.oj-tree-open") ;  // open child nodes that are also parents
        if (objs.length)  {
          objs.each(function ()  {
                        _this["collapse"](this, !anim);
                    });
        }

        if (subject) {                               // if subject node is also expanded
          this["collapse"](subject, !anim) ;         // include it in the list
          objs.splice(0, 0, subject) ;
        }

        if (objs.length) {
          this._emitEvent({ "obj" : objs, "targ" : origTarg }, "collapseAll");
        }
     },


     /** Expands a collapsed parent node, so that its children are visible. Triggers an "expand" event.
       * @param {HTMLElement | Object | string} node - Can be a DOM element, a jQuery wrapped node, 
       *                        or a selector pointing to the element to be expanded.
       * @param {boolean=} skipAnim - Set to true to suppress node expansion animation (assuming
       *                        option property "animDuration" is defined or defaulted). Default is false.
       * @expose 
       * @public
       * @instance
       * @memberof! oj.ojTree 
       */
     expand : function(node, skipAnim)
     {
        this._expand(node, false, skipAnim) ;
     },

     /** May be used as a getter of setter.  If no argument is supplied, the method returns an
       * array of nodes currently expanded. (An empty array implies that no nodes are expanded.)  
       * If an array of nodes is supplied as an argument, the specified nodes are expanded.
       * @param {Array=} nodes - Omit to use as a getter, or specify an array of nodes to be
       *                 expanded.  Nodes may be defined as elements, id strings, jQuery wrapped nodes, or
       *                 selectors pointing to the elements to be expanded.
       * @param {boolean=} skipAnim - Set to true to suppress node expansion animation (assuming
       *                        option property "animDuration" is defined or defaulted). Default is false.
       * @return {Object | null} A jQuery wrapped array of nodes if used as a getter, else null
       *                        if used as a setter.
       * @expose 
       * @public
       * @instance
       * @memberof! oj.ojTree 
       */
     expanded : function(nodes, skipAnim)
     {
        var exlr,
            exlen,
            _this = this;

        if (nodes && $.type(nodes) === "array")  {    // setter

          if (this._data.core.locked) {
            return null ;
          }

          exlen = nodes.length ;
          $.each(nodes, function (i, val) {
                          _this._expand(val, false, skipAnim); 
          });
          return null ;
        }
        else  {     // getter

          nodes = this._$container_ul.find("li.oj-tree-open");
          exlen  = nodes.length ;
          exlr   = [] ;
          for (var n = 0; n < exlen; n++)  {
            exlr.push(nodes[n]);
          };
          return $(exlr) ;
        }
     },


     /** Expands a node and all its descendants.  Triggers an "expandall" event.
       * @param {HTMLElement | Object | string} node - Can be a DOM element, a jQuery wrapped node,
       *                        or a selector pointing to the element whose descendants are to be expanded.
       *                        If omitted , or set to -1, all nodes in the tree are expanded.
       * @param {boolean=} anim - Set to true (or omit) if all nodes are to expanded with animation (assuming
       *                        option property "animDuration" is greater than zero). Default is true.
       * @expose 
       * @public
       * @instance
       * @memberof! oj.ojTree 
       */
     expandAll : function(node, anim)
     {
        this._expandAll(node, anim) ;
     },

     /** Expands a node if collapsed, or collapses a node if expanded. Triggers an "expand" or "collapse" event.
       * @param {HTMLElement | Object | string} node - Can be a DOM element, a jQuery wrapped node, 
       *                        or a selector pointing to the element to be expanded/collapsed.
       * @expose 
       * @public
       * @instance
       * @memberof! oj.ojTree 
       */
     toggleExpand : function (node)
     {
        node = this._getNode(node);
        if (node === -1) {
          return ;
        }
        if (node.hasClass("oj-disabled") || this._data.core.locked) {
          return ;
        }

        if (node.hasClass(OJT_CLOSED))  {
          return this["expand"](node);
        }
        if (node.hasClass(OJT_OPEN))  {
          return this["collapse"](node);
        }
     },


     /** Deselects a node. Triggers a "deselect" event.
       * @param {HTMLElement | Object | string} node - Can be a DOM element, a jQuery wrapped node, 
       *                        or a selector pointing to the element to be deselected.
       * @expose 
       * @public
       * @instance
       * @memberof! oj.ojTree 
       */
     deselect : function (node)
     {
       node = this._getNode(node);
       if (!node.length)  {
         return false;
       }
       if (node.hasClass("oj-disabled") || this._data.core.locked) {
         return ;
       }

       if (this["isSelected"](node))  {
         node.children("a").removeClass(OJT_CLICKED);
         node.removeAttr(WA_SELECTED);
         this._data.ui.selected = this._data.ui.selected.not(node);

//Wed     if(this.data.ui.last_selected.get(0) === obj.get(0)) { this.data.ui.last_selected = this.data.ui.selected.eq(0); }

          if (this._data.ui.last_selected.get(0) === node.get(0))  {
            this._data.ui.last_selected = this._data.ui.selected.eq(0);
          }

          this._emitEvent({ "obj" : node }, "deselect");
       }

     },


     /** Deselects all selected nodes. If optional argument "context" is specified, only the selected
       * nodes within that context will be selected. Triggers a "deselectall" event.
       * @param {HTMLElement | Object | string=} context - Can be a DOM element, a jQuery wrapped node, 
       *                        or a selector pointing to an element within the tree.
       * @expose 
       * @public
       * @instance
       * @memberof! oj.ojTree 
       */
     deselectAll : function(context)
     {
       if (this._data.core.locked) {
         return ;
       }

       this._deselectAll(context, false) ;
     },

     /** Selects a node. Triggers a "select" event.
       * @param {HTMLElement | Object | string} node - Can be a DOM element, a jQuery wrapped node, 
       *                       or a selector pointing to the element to be deselected.
       * @expose 
       * @public
       * @instance
       * @memberof! oj.ojTree 
       */
     select : function (node)
     {
        this._select(node) ;
     },


     /** May be used as a getter of setter.  If no argument is supplied, the method returns a 
       * jqQery wrapped list of nodes currently selected. If an array or list (that is the argument
       * has a "length" property) of nodes is supplied as an argument, the specified nodes are selected.
       *
       * @param {Array | Object=} nodes - Omit to use as a getter, or specify an array or list of nodes to be
       *                 expanded.  Nodes may be defined as elements, jQuery wrapped nodes, or
       *                 selectors pointing to the elements to be expanded.
       * @return {Array | null} An array of nodes if used as a getter.
       * @expose 
       * @public
       * @instance
       * @memberof! oj.ojTree 
       */
     selected : function(nodes)
     {
        if (this._data.core.locked) {
          return null ;
        }

        if (nodes === undefined)  {
          return this._getSelected() ;
        }
        else  if (nodes.length !== undefined)     // setter
        {
          var _this = this;
          $.each(nodes, function (i, val) {
            if (val)  {
              _this._select(val, true);
            }
          });
        }
        return null ;
     },


     /** Selects a node if deselected, or deselects a node if selected. Triggers a "select" or "deselect" event.
       * 
       * @param {HTMLElement | Object | string} node - Can be a DOM element, a jQuery wrapped node, 
       *                        or a selector pointing to the element to be expanded/collapsed.
       * @expose 
       * @public
       * @instance
       * @memberof! oj.ojTree 
       */
     toggleSelect : function (node)
     {
        node = this._getNode(node) ;
        if (!node.length)  {
           return false;
        }

        if (node.hasClass("oj-disabled") || this._data.core.locked) {
          return ;
        }

        if (this["isSelected"](node))  {
          this["deselect"](node);
        }
        else  {
          this._select(node, true);
        }
     },

     /** Returns true if the node is collapsed, else false.
       *
	   * @param {HTMLElement | Object | string} node - Can be a DOM element, a jQuery wrapped node, 
	   *                        or a selector pointing to the element.
       * @return {boolean} true if the node is collapsed, else false.
       * @expose 
       * @public
       * @instance
 	   * @memberof! oj.ojTree 
       */
     isCollapsed : function(node)
     {
       node = this._getNode(node);
       return node && node !== -1 && node.hasClass(OJT_CLOSED);
     },

     /** Returns true if the node is expanded, else false.
       *
	   * @param {HTMLElement | Object | string} node - Can be a DOM element, a jQuery wrapped node, 
	   *                        or a selector pointing to the element.
       * @return {boolean} true if the node is expanded,  else false.
       * @expose 
       * @public
       * @instance
       * @memberof! oj.ojTree 
       */
     isExpanded : function(node)
     {
       node = this._getNode(node);
       return node && node !== -1 && node.hasClass(OJT_OPEN);
     },

     /** Returns true if the node is a leaf node (that is, it has no children), else false.
       *
       * @param {HTMLElement | Object | string} node - Can be a DOM element, a jQuery wrapped node, 
       *                        or a selector pointing to the element.
       * @return {boolean} true if the node is a leaf node, else false.
       * @expose 
       * @public
       * @instance
       * @memberof! oj.ojTree 
       */
     isLeaf : function(node)
     {
       return this._isLeaf(node) ;
     },

     /** Returns true if the node is selected, else false.
       *
       * @param {HTMLElement | Object | string} node - Can be a DOM element, a jQuery wrapped node, 
       *                        or a selector pointing to the element.
       * @return {boolean} true if the node is selected,  else false.
       * @expose 
       * @public
       * @instance
       * @memberof! oj.ojTree 
       */
     isSelected : function(node)
     {
       return this._data.ui.selected.index(this._getNode(node)) >= 0;
     },


     /** Creates a new node and adds it to the tree.  Triggers a createnode" event.
       *
       * @param {HTMLElement | Object | string} refnode - specifies the node that the new node will be
       *                       placed in, or next to, depending on the "position" argument. Can be a
       *                       DOM element, a jQuery wrapped node, or a selector pointing to the element.
       * @param {string | number} position - specifies the position of the newly created node in relation
       *                       to the "refnode" specified by the first argument.  Can be a string : "before",
       *                       "after", "inside", "first",, "last", or a zero-based index to position the
       *                       new node at a specific point among the childfren of "refnode".
       * @param {Object} data - An object literal containing data to create the new node.  The object properties
       *                       are:<br>
       *                       "attr" - an object of attribute name/value pairs (at least an "id" property should
       *                       be defined).<br>
       *                       "title" - a string used for the visible text of the node.<br><br>
       * <code>
       * var new Node = { "title" : "My Title", "attr" : { "id": "myid" } };
       * </code>
       * @expose 
       * @public
       * @instance
       * @memberof! oj.ojTree 
       */
     create : function(refnode, position, data)
     {
        return this._create_node(refnode, position, data);
     },

     /**  Removes a node. Triggers a "remove" event.
       *
       *  @param {HTMLElement | Object | string} node - Can be a DOM element, a jQuery wrapped node, 
       *                        or a selector pointing to the element.
       *  @return {Object | boolean}   The jQuery wrapped node used as an argument.
       *  @expose 
       *  @public
       *  @instance
       *  @memberof! oj.ojTree 
       */ 
     remove : function(node)
     {
       node = this._getNode(node);
       if (!node.length) {
         return false;
       }

       if (node.hasClass("oj-disabled") || this._data.core.locked) {
         return false;
       }

       var rslt = this._emitEvent({"obj" : node, "func" : "remove"}, "before") ;
       if (typeof rslt == "boolean" && (!rslt)) {
         return false ;
       }

       this.__rollback();
       var p    = this._getParent(node),
           prev = $([]),
           t = this,
           sib = this._getPrev(node) ;

       node.each(function () {
           prev = prev.add(t._getPrev(this));
       });

       node = node.detach();

       if (p !== -1 && p.find("> ul > li").length === 0)  {
         p.removeClass("oj-tree-open oj-tree-closed")
          .addClass(OJT_LEAF)
          .removeAttr(WA_EXPANDED);
       }

       this._clean_node(p);
       this._emitEvent({ "obj" : node, "prev" : sib, "parent" : p }, "remove");
       return node ;
     },


     /** Returns the title of the specified node
       *
       * @param {HTMLElement | Object | string} node - Can be a DOM element, a jQuery wrapped node, 
       *                       or a selector pointing to the element.
       * @return {string | boolean} The text string title of the node.
       * @expose 
       * @public
       * @instance
       * @memberof! oj.ojTree 
       */
     getText : function(node)
     {
       node = this._getNode(node) ;
       if (!node.length) {
          return false;
       }

       var ht = this._data.core.htmlTitles;
       node = node.children("a:eq(0)");

       if (ht)  {
          node = node.clone();
          node.children("INS").remove();
          return node.html();
       }
       else  {
//       node = node.contents().filter(function()
//                             {
//                               return this.nodeType == 3;
//                             })[0];
//       return node.nodeValue;
         node = node.find("span:eq(0)") ;
         return node[0].textContent;
       }

     },

     /** Renames a node title.
       *
       * @param {HTMLElement | Object | string} node - Can be a DOM element, a jQuery wrapped node, 
       *                        or a selector pointing to the element.
       * @param {string=} text - The new text string.
       * @expose 
       * @public
       * @instance
       * @memberof! oj.ojTree 
       */
     rename : function(node, text)
     {
       this._rename_node(node, text) ;
     },

     /** Sets the specifed node as the current node of interest (e.g. a mouse-over).  Triggers a "hover" event.
       *
       * @param {HTMLElement | Object | string} node - Can be a DOM element, a jQuery wrapped node, 
       *                        or a selector pointing to the element.
       * @expose 
       * @public
       * @instance
       * @memberof! oj.ojTree 
       */
     hover : function(node)
     {
       node = this._getNode(node);
       if (! node.length)  {
         return false;
       }

       if (node.hasClass("oj-disabled") || this._data.core.locked) {
         return ;
       }

       var rslt = this._emitEvent({"obj" : node, "func" : "hover"}, "before") ;
       if (typeof rslt == "boolean" && (!rslt)) {
         return ;
       }

       //if(this.data.ui.hovered && node.get(0) === this.data.ui.hovered.get(0)) { return; }
       if (! node.hasClass(OJT_HOVER))  {
          this["dehover"]();
       }

       this._data.ui.hovered = node.children("a").addClass(OJT_HOVER).parent();
       this._$container_ul.attr(WA_ACTIVEDESCENDANT, this._data.ui.hovered.attr("id")) ;
       this._fix_scroll(node);
       this._emitEvent({ "obj" : node }, "hover");
     },


     /** Removes the "hover" state of the currently hovered node.  Triggers a "dehover" event.
       *
       * @expose 
       * @public
       * @instance
       * @memberof! oj.ojTree 
       */
     dehover : function()
     {
       var obj = this._data.ui.hovered,
            p;
       if (!obj || !obj.length) {
         return false;
       }

       if (obj.hasClass("oj-disabled") || this._data.core.locked) {
         return ;
       }

       p = obj.children("a").removeClass(OJT_HOVER).parent();
       this._$container_ul.removeAttr(WA_ACTIVEDESCENDANT) ;

       if(this._data.ui.hovered[0] === p[0]) { 
           this._data.ui.hovered = null;
       }
       this._emitEvent({ "obj" : obj }, "dehover");
     },

     /** Returns the full path to a node, either as an array of ID's or node names, depending on
       * the value of the "idMode" argument.
       *
       * @param {HTMLElement | Object | string} node - Can be a DOM element, a jQuery wrapped node, 
       *                       or a selector pointing to the element.
       * @param {boolean=} idMode - Set to true (or omit) to return ID's from the node attribute
       *                       "id"), or false to return the names (i.e. text titles).  Default is true.
       *
       * @return {Array | boolean} An array of node ID's or names.
       * @expose 
       * @public
       * @instance
       * @memberof! oj.ojTree 
       */
     getPath : function(node, idMode)
     {
        var p     = [],
            _this = this;

        node = this._getNode(node);
        if (node === -1 || !node || !node.length)  {
          return false;
        }

        node.parentsUntil(".oj-tree", "li").each(function () {
               p.push( idMode ? this.id : _this["getText"](this) );
        });

        p.reverse();
        p.push( idMode ? node.attr("id") : this["getText"](node) );

        return p;
      },

     /** Returns the jQuery wrapped top outer &lt;ul&gt; element of the tree.
       *
       * @return {Object} The jQuery wrapped &lt;ul&gt; element of the tree.
       * @expose 
       * @public
       * @instance
       * @memberof! oj.ojTree 
       */
     getRoot : function()
     {
        return this._$container.children("ul:eq(0)");    // return the top <ul>
     },

     /**  Refreshes the tree or a node.
       *
       *  @param {HTMLElement | Object | string | number=} node - If -1 is specified (or the argument is omitted),
       *                   the whole tree is refreshed.  Alternatively, a specific node to be refreshed can be
       *                   supplied. Can be a DOM element, a jQuery wrapped node, or a selector pointing to the element.
       *  @expose 
       *  @public
       *  @instance
       *  @memberof! oj.ojTree 
       */
     refresh : function(node)
     {
       this._super() ;

        if (this._data.core.locked) {
          return ;
        }

       this._refresh(node) ;
     },


     /**  Moves a tree node.
       *
       *  @param {HTMLElement | Object | string | number} node  The node to be moved. Can be a DOM element,
       *            a jQuery wrapped node, or a selector pointing to the element.
       *  @param {HTMLElement | Object | string | number} refnode  The reference node for the move. Can be
       *            a DOM element, a jQuery wrapped node, or a selector pointing to the element. If -1 is 
       *            specified, the container element is used.
       *  @param {string | number} position  The position of the moved node relative to the reference node refnode.
       *            Can be "before", "after", "inside", "first", "last", or the zero-based index to position the node at a
       *            specific point among the reference node's current children.
       *  @param {boolean=} iscopy  Specify false for a move operation, or true for a copy.
       *  @expose 
       *  @public
       *  @instance
       *  @memberof! oj.ojTree 
       */
     move : function(node, refnode, position, iscopy)
     {
        this._move_node(node, refnode, position, iscopy);
     },

     /**
       *  Returns the user classified node type applied to the node in the
       *  <span class="code-caption">"types"</span> option. 
       *  @return {string}  The node's type.
       *  @expose 
       *  @public
       *  @instance
       *  @memberof! oj.ojTree 
       */
     getType : function(node)
     {
         return this._getType(node) ;
     },

     /**
       *  Sets the "type" attribute of the node.
       *  @return {boolean}  true if the change was successful, else false. 
       *  @expose 
       *  @public
       *  @instance
       *  @memberof! oj.ojTree 
       */
     setType : function(node, str)
     {
         return this._setType(node, str) ;
     },

     /**
       * Return the subcomponent node element represented by the locator object properties.</br></br>
       * This is under development!!
       * 
       * @expose 
       * @public
       * @instance
       * @memberof! oj.ojTree 
       * @param {Object} locator An Object containing at minimum a "subId" property whose value is a string.<p>
       * <table style="border-collapse:collapse;border:1px solid"><tr style="background-color:#eee"><th>Property</th><th>Value</th><th>Description</th></tr>
       *  <tr style="border-collapse:collapse;border:1px solid"><td>subId</td><td><em>"disclosure"</em></td><td>Returns the &lt;ins&gt; element for the disclosure (expand/collapse)
       *                                           icon of a parent node.</td></tr>
       *  <tr style="border-collapse:collapse;border:1px solid"><td>node</td><td>String | Object</td><td>Can be a selector
       *                 for the parent node (e.g. "#mynode"), a DOM element (a node &lt;li&gt; or any element contained within
       *                 the node &lt;li&gt;), a jQuery wrapped node (possibly from an event).  For any other string, an attempt
       *                 is made to find the node with the specified text value).</td></tr>
       * </table>
       * <p>
       * <table style="border-collapse:collapse;border:1px solid"><tr style="background-color:#eee;"><th>Property</th><th>Value</th><th>Description</th></tr>
       *  <tr><td>subId</td><td><em>"icon"</em></td><td>Returns the &lt;ins&gt; element for the node icon.</td></tr>
       *  <tr><td>node</td><td>String | Object</td><td>Can be a selector for the node (e.g. "#mynode"), a DOM
       *                 element (a node &lt;li&gt; or any element contained within the node &lt;li&gt;), a jQuery
       *                 wrapped node (possibly from an event). For any other string, an attempt is made to find
       *                 the node with the specified text value).</td></tr>
       </td></tr>
       * </table>
       * <p>
       * <table style="border-collapse:collapse;border:1px solid"><tr style="background-color:#eee;"><th>Property</th><th>Value</th><th>Description</th></tr>
       *  <tr><td>subId</td><td><em>"node"</em></td><td>Returns the &lt;li&gt; element for the node. </td></tr>
       *  <tr><td>node</td><td>String | Object</td><td>Can be a selector for the node (e.g. "#mynode"), a DOM element (a
       *                 node &lt;li&gt; or any element contained within the node &lt;li&gt;), a jQuery
       *                 wrapped node (possibly from an event). For any other string, an attempt is made to find
       *                 the node with the specified text value).</td></tr>
       * </table>
       * <p>
       * <table style="border-collapse:collapse;border:1px solid"><tr style="background-color:#eee;"><th>Property</th><th>Value</th><th>Description</th></tr>
       *  <tr><td>subId</td><td><em>"link"</em></td><td>Returns the &lt;a&gt; element for the node. </td></tr>
       *  <tr><td>node</td><td>String | Object</td><td>Can be a selector for the node (e.g. "#mynode"), a DOM
       *                 element (a node &lt;li&gt; or any element contained within the &lt;li&gt;), a jQuery
       *                 wrapped node (possibly from an event). For any other string, an attempt is made to find
       *                 the node with the specified text value).</td></tr>
       * </table>
       * <p>
       * <table style="border-collapse:collapse;border:1px solid"><tr style="background-color:#eee;"><th>Property</th><th>Value</th><th>Description</th></tr>
       *  <tr><td>subId</td><td><em>"disclosure"</em> |<em>"icon"</em> | <em>"node"</em> | <em>"link"</em></td><td>Returns
       *                 the element as described above, based on an attribute of a node &lt;li&gt; element.</td></tr>
       *  <tr><td>key</td><td>String</td><td>The name of an attribute on the node.</td></tr>
       *  <tr><td>value</td><td>String</td><td>The value of the attribute specified by "key".</td></tr>
       * </table>
       * <p>
       * <table style="border-collapse:collapse;border:1px solid"><tr style="background-color:#eee;"><th>Property</th><th>Value</th><th>Description</th></tr>
       *  <tr><td>subId</td><td><em>"parent"</em> |</br><em>"prevSib"</em> |</br> <em>"nextSib"</em> |</br> "first"</em> |</br><em>"last"</em></td><td>Returns a node &lt;li&gt; element
       *                 based on the "subId" value and the "node" value.
       *                 <ul><li>"parent" - returns the parent of the node specified by "node", or null if there is no parent</li></br>
       *                   <li>"prevSib" - returns the previous sibling of the node specified by "node", or null if there is no previous sibling</li></br>
       *                   <li>"nextSib" - returns the next sibling of the node specified by "node", or null if there is no next sibling</li></br>
       *                   <li>"first" - returns the first child of the parent node specified by "node". If "node"
       *                                 is -1 or omitted, the first node of the tree is returned.</li></br>
       *                   <li>"last" - returns the last child of the parent node specified by "node". If "node"
       *                                is -1 or omitted, the last node of the tree is returned</li></br>
       *                 </ul>
       *  <tr><td>node</td><td>String | Object</td><td>Can be a selector for the node (e.g. "#mynode"), a DOM
       *                 element (a node &lt;li&gt; or any element contained within the &lt;li&gt;), a jQuery
       *                 wrapped node (possibly from an event). For any other string, an attempt
       *                 is made to find the node with the specified text value).</td></tr>
       * </table>
       * @return {Element|null} the subcomponent located by the subId string passed in locator, if found.<p>
       */
     getNodeBySubId: function(locator)
     {
        if (! locator)  {
          return this.element ? this.element[0] : null;
        }

        return this._processSubId(locator)
     },

     /**
       *  Removes all traces of ojTree in the DOM (only the ones set using oj-tree*)
       *  and cleans out all events.  If the tree was constructed from original user
       *  markup found in the div, reinstate the markup.
       *  @expose 
       *  @public
       *  @instance
       *  @memberof! oj.ojTree 
       */
     destroy : function ()
     {
        this._emitEvent({ "obj" : -1}, "destroy"); 
        this._super() ;
     },



     //-----------------------------------------//
     //     Internal API's and data             //
     //-----------------------------------------//


     /**
       *  Called the first time the widget is called on an element.
       *  @private
       */
     _create: function ()
     {
        this._super() ;

        this._bCreate       = true ;                                // in _create()
        this._elemId        = "#" + this.element.attr("id") ;       // tree element id
        this._$container    = $(_sanitizeSelector(this._elemId)) ;  // the containing <div>
        this._$container_ul = null ;                                // the containing <ul>
        this._data          = {} ;                                  // working data
        this._tds           = null ;                                // Tree DataSource
        this._index         = this._newIndex() ;                    // index for this instance
        _aInstances.push(this) ;
        this._isRtl         = this._GetReadingDirection() === "rtl";
        this._initTree() ;
        this._bCreate       = false ;
     },

     /**
       *  Widget is being destroyed.
       *  @private
       */
     _destroy : function()
     {
        this._clearTree() ;    // Clean out the DOM.  After this, the tree markup has
                               // been removed from the div, and all event handlers
                               // removed.

        // If the tree was constructed from existing user markup found in the div,
        // reinstate that markup to reset the div to its original state pre tree create.
        if (this._data.html.useExistingMarkup) {
          if (this._data.html.cloneMarkup) {
            this._$container.append(this._data.html.cloneMarkup) ;
          }
        }
  
        this._super() ;
     },


     /**
       *  Handle an option changes.
       *  Called by $(selector).ojtree("options", "prop", value)
       *  @private
       */
     _setOption: function (key, newval)
     {
        var ret ;

        if (this._bCreate) {      // if in _create(), option already in this.options
          this._super(key, newval);
          return ;
        }

        var _this = this ;
        var prev  = this.options[key] ;
        var val ;

        if (key === "selectionMode") {
          if (newval === "none") {
            val = 0 ;
          }
          else if (newval === "single") {
            val = 1;
          }
          else if (newval === "multiple") {
            val = -1 ;
          }
          else {
            val = undefined ;
          }
          if (val != _this._data.core.selectMode) {
            _this._data.core.selectMode = val ;
          }
        }
        else if (key === "icons") {
           if ($.type(newval) == "boolean") {
             if (newval != _this._data.themes.icons) {
               _this._data.themes.icons = newval ;
               _this[newval? "show_icons" : "hide_icons"]() ;
             }
           }
        }                                // end "core/ui" options
        else if (key === "contextMenu") {
           this._clearMenu() ;
           if (newval) {  
             this._initMenuOpts() ;
             this._initMenu(newval) ;
           }
        }                                // end "contextMenu"
        else if (key === "disabled")  {
           ret = this._handleDisabledChanged(newval) ;
        }                            // end "disabled"
        else if (key === "data") {    //TDO
          this._super(key, newval);
          this._initDSOpts() ;
          this._initDataSource();
          this._load_node(-1, function ()  {
                              this._loaded();
                              this._reload_nodes();
                            });
          return ;
        }

        this._super(key, newval);
        return ret ;
     },

     /**
       *  Clears out the tree dom
       *  @private
       */
     _clearTree : function()
     {
        var  n = this._getIndex();

        this._$container
            .unbind(".oj-tree")
            .undelegate(".oj-tree")
            .removeData("oj-tree-instance-id")
            .find("[class^='oj-tree']")
            .addBack()
            .attr("class", function ()
                    {
                      return this["className"].replace(/oj-tree[^ ]*|$/ig,'');
                    });

        var cl = this._$container.attr("class") ;      // if jQuery has left us with a
        cl = cl.trim();                                // class of blanks, remove it.
        if (cl.length === 0) {
          this._$container.removeAttr("class") ;
        }

        _removeKeyFilter(this._$container_ul) ;        // remove keyboard listener because
                                                       // _$container_ul will be removed
        $(document)
            .unbind(".oj-tree-" + n)
            .undelegate(".oj-tree-" + n);

        // Remove the constructed tree from the DOM.
        this._$container_ul.remove() ;
        this._$container_ul = null ;
     },

     /**
       *  Returns a jQuery wrapped tree node.  obj can be a selector pointing 
       *  to an element within the tree, a DOM node, or a jQuery wrapped node.  If -1 is used
       *  (indicating the whole tree), -1 is returned.
       *  @private
       */
     _getNodeCore : function(obj) 
     {
         var $obj = $(obj, this._$container); 

         if ($obj.is(".oj-tree") || obj == -1)  {
            return -1;
         } 
         $obj = $obj.closest("li", this._$container);
         return $obj.length ? $obj : false; 
     },

     /**
       *  Returns a jQuery wrapped tree node.  obj can be a selector pointing 
       *  to an element within the tree, a DOM node, or a jQuery wrapped node.  If obj is -1
       *  (indicating the whole tree), -1 is returned.
       *  @private
       */
     _getNode :  function (obj, allow_multiple)
     {
       if (typeof obj === "undefined" || obj === null) {
         return allow_multiple ? this._data.ui.selected : this._data.ui.last_selected;
       }

       var $obj = $(obj, this._getContainer()); 

       if ($obj.is(".oj-tree") || obj === -1) {
          return -1;
       } 

       $obj = $obj.closest("li", this._getContainer()); 
       return $obj.length ? $obj : false; 
     },

     /**
       *  Returns the node previous to the supplied obj.  obj can be a selector pointing 
       *  to an element within the tree, a DOM node, or a jQuery wrapped node.  If -1 is used
       *  (indicating the whole tree), -1 is returned.  If arg strict is true, only immediate
       *  siblings are considered, else if the obj has no previous siblings (i.e is the first
       *  child of its parent), the parent is returned.
       *  @private
       */
     _getPrev  : function (obj, strict)
     {
        obj = this._getNode(obj);
        if (obj === -1) {
          return this._$container.find("> ul > li:last-child");
        }
        if (!obj.length) {
          return false;
        }
        if (strict) {
         return (obj.prevAll("li").length > 0) ? obj.prevAll("li:eq(0)") : false;
        }

        if (obj.prev("li").length) {
            obj = obj.prev("li").eq(0);
            while (obj.hasClass(OJT_OPEN)) {
               obj = obj.children("ul:eq(0)").children("li:last");
            }
           return obj;
        }
        else {
           var o = obj.parentsUntil(".oj-tree","li:eq(0)");
           return o.length ? o : false;
        }
     },

     /**  Returns the node after the supplied obj.  obj can be a selector pointing 
       *  to an element within the tree, a DOM node, or a jQuery wrapped node.  If -1 is used
       *  (indicating the whole tree), -1 is returned.  If arg strict is true, only immediate
       *  siblings are considered, else if the obj has no more siblings (i.e is the last
       *  child of its parent), the parent's next sibling is returned.
       *  @private
       */
     _getNext  : function (obj, strict)
     {
        obj = this._getNode(obj);
        if (obj === -1)  {
          return this._$container.find("> ul > li:first-child");
        }
        if (!obj.length) {
           return false;
         }
        if (strict)  {
           return (obj.nextAll("li").size() > 0) ? obj.nextAll("li:eq(0)") : false;
        }
        
        if (obj.hasClass(OJT_OPEN))  {
          return obj.find("li:eq(0)");
        }
        else if(obj.nextAll("li").size() > 0)  {
          return obj.nextAll("li:eq(0)");
        }
        else  {
           return obj.parentsUntil(".oj-tree","li").next("li").eq(0);
        }
     },


     /**
       *  Returns the parent node of the supplied obj.  obj can be a selector pointing 
       *  to an element within the tree, a DOM node, or a jQuery wrapped node.
       *  child of its parent), the parent is returned.
       *  @private
       */
     _getParent  : function (obj)
     {
        obj = this._getNode(obj);
        if (obj == -1 || !obj.length)  {
          return false;
        }
        var o = obj.parentsUntil(".oj-tree", "li:eq(0)");
        return o.length ? o : -1;
     },

     /**
       *  Returns the child nodes of the supplied obj, or false if no children or failure.
       *  obj can be a selector pointing to an element within the tree, a DOM node, or a
       *  jQuery wrapped node.  If -1 can be used to indicate the whole tree.
       *  @private
       */
     _getChildren   : function (obj)
     {
        obj = this._getNode(obj);
        if (obj === -1) {
          return this._$container.children("ul:eq(0)").children("li");
        }
        if (!obj.length) {
          return false;
        }
        return obj.children("ul:eq(0)").children("li");
     },

     _isLeaf : function(node)
     {
       node = this._getNode(node) ;
       return node && node !== -1 && node.hasClass(OJT_LEAF);
     },

     /**
       *  Returns the widget instance for the supplied node.  Not currently used.  TDO
       *  @private
       */
     _reference : function(node)
     {
        var div  = node.parents("div").eq(0) ;

        return this ;
     },

     /**
       *  Add default values to options, unless already defined in options.
       *  @private
       */
     _applyDefaults :  function(to, from)
     {
        if (to != undefined && from != undefined)  {
          $.each(from, function(prop, val) {
                                             if (to[prop] == undefined) {
                                               to[prop] = val ;
                                             }  
                                            });
        }
     },

     /**
          Handle change of the disabled option
       *  @private
       */
     _handleDisabledChanged  : function(newval)
     {
        var curState  = this._$container_ul.hasClass("oj-disabled") ;
        if (! curState) {
          curState = false ;      // in case undefined
        }

        if (typeof newval === "undefined")  {
          return curState ;
        }

        if (curState != newval) {
          if (newval) {
            this._$container_ul.addClass("oj-disabled") ;
            this._$container_ul.prop("disabled", "disabled");
          }
          else {
            this._$container_ul.removeClass("oj-disabled") ;
            this._$container_ul.removeAttr("disabled");
          }
          this._lock(newval) ;
        }
     },


     /**
       *  @private
       */
     _lock : function (lstate) {                // unpublished per Design Review

        lstate = lstate || false ;
        if (lstate) {
          this._data.core.locked = true;
          this._data.ui.opacity  = this._$container.children("ul").css("opacity") ;
          this._$container_ul.addClass("oj-tree-locked").css("opacity","0.9");
        }
        else {
          this._data.core.locked = false;
          this._$container_ul.removeClass("oj-tree-locked").css("opacity", this._data.ui.opacity);
        }
//      this._emitEvent({});
     },

     /**
       *  Creates a "move" object containing details of the impending move, and
       *  stores it in this._data.core.prepared_move
       *
       *  The object contains :
       *     .o   the node being moved
       *     .r   the reference node
       *     .p   the destination position relative to the reference node
       *     .np  the new parent
       *     .oc  the original node if there was a copy
       *     .cy  boolean indicating if the move was a copy
       *     .op  the former parent
       *     .or  the node that was previously in the position of the moved node
       *     .ot  the original tree instance
       *     .rt  the reference tree instance
       *     .cr  same as .np but if a root node is created this is -1
       *
       *   @private
       */
     _prepare_move :  function (o, r, pos, cb, is_cb)
     {
       var p = {};
             
       p.ot =  this;
       p.o  = p.ot._getNode(o);
       p.r  = r === - 1 ? -1 : this._getNode(r);
       p.p = (typeof pos === "undefined" || pos === false) ? "last" : pos; // TODO: move to a setting

       if (!is_cb && this._data.core.prepared_move.o && this._data.core.prepared_move.o[0] === p.o[0] 
                                                     && this._data.core.prepared_move.r[0] === p.r[0]
                                                     && this._data.core.prepared_move.p    === p.p)  {
          this._emitEvent(this._data.core.prepared_move);
          if (cb)  {
            cb.call(this, this._data.core.prepared_move);
          }
          return;
       }

       p.ot = this;
       p.rt = this; // r === -1 ? p.ot : $.jstree._reference(p.r) || this
 
       if (p.r === -1 || !p.r)  {
         p.cr = -1;

         switch(p.p)
         {
            case "first":
            case "before":
            case "inside":
                           p.cp = 0; 
                           break;
            case "after":
            case "last":
                           p.cp = p.rt._$container.find(" > ul > li").length; 
                           break;
            default:
                           p.cp = p.p;
                           break;
         }
       }
       else {
         if (!/^(before|after)$/.test(p.p) && !this._is_loaded(p.r)) {
           return this._load_node(p.r, function ()
                                                    {
                                                      this._prepare_move(o, r, pos, cb, true);
                                                    });
         }
          switch(p.p)
          {
             case "before":  p.cp = p.r.index();
                             p.cr = p.rt._getParent(p.r);
                             break;
             case "after":   p.cp = p.r.index() + 1;
                             p.cr = p.rt._getParent(p.r);
                             break;
             case "inside":
             case "first":
                             p.cp = 0;
                             p.cr = p.r;
                             break;
             case "last":
                             p.cp = p.r.find(" > ul > li").length; 
                             p.cr = p.r;
                             break;
             default: 
                             p.cp = p.p;
                             p.cr = p.r;
                             break;
          }
       }

       p.np  = p.cr == -1 ? p.rt._getContainer() : p.cr;
       p.op  = p.ot._getParent(p.o);
       p.cop = p.o.index();

       if (p.op === -1)  {
         p.op = p.ot ? p.ot._$container : this._$container;
       }
       if (!/^(before|after)$/.test(p.p) && p.op && p.np && p.op[0] === p.np[0] && p.o.index() < p.cp)
       {
         p.cp++;
       }

       //if(p.p === "before" && p.op && p.np && p.op[0] === p.np[0] && p.o.index() < p.cp) { p.cp--; }
       p.or = p.np.find(" > ul > li:nth-child(" + (p.cp + 1) + ")");
       this._data.core.prepared_move = p;
       this._emitEvent(this._data.core.prepared_move, "prepare_move");
       if (cb) {
         cb.call(this, this._data.core.prepared_move, "prepare_move");
       }
     },


     "check_move" : function ()
     {
       var obj  = this._data.core.prepared_move,
           ret  = true,
           r ;

       r = obj.r === -1 ? this._$container() : obj.r;

       if (!obj || !obj.o || obj.or[0] === obj.o[0]) {
         return false;
       }

       if (!obj.cy) {
         if (obj.op && obj.np && obj.op[0] === obj.np[0] && obj.cp - 1 === obj.o.index())  { 
           return false;
         }
         obj.o.each(function ()
                    { 
                      if (r.parentsUntil(".oj-tree", "li").addBack().index(this) !== -1)  {
                        ret = false; return false;
                      }
                    });
       }

       return ret;
     },

     /**
       *  Changes the text title of a node
       *  @private
       */
     _rename_node : function(node, text)
     {
       var  t ;

       node = this._getNode(node);
       this.__rollback();
       t  = this["getText"](node) ;

       if (node && node.length) {
          var rslt = this._emitEvent({"obj"  : node,
                                      "func" : "rename",
                                      "title" : text,
                                      "prevTitle": t}, "before") ;
          if (typeof rslt == "boolean" && (!rslt)) {
            return ;
          }
       }

       if (node && node.length && this._set_text.apply(this, Array.prototype.slice.call(arguments)))  {
         this._emitEvent({ "obj" : node, "title" : text, "prevTitle" : t}, "rename");
       }
     },

     /**
       *   Moves a node within the tree
       *   @private
       */ 
     _move_node : function (obj, ref, position, is_copy, is_prepared, skip_check)
     {
        if ((obj.hasClass && obj.hasClass("oj-disabled")) || this._data.core.locked) {
          return ;
        }

        if (!is_prepared)  { 
          return this._prepare_move(obj, ref, position, function (p)
                                                        {
                                                          this._move_node(p, false, false,
                                                                          is_copy, true, skip_check);
                                                        });
        }
        if (is_copy) { 
          this._data.core.prepared_move.cy = true;
        }
        if (!skip_check && !this["check_move"]())  {
          return false;
        }

        this.__rollback();
        var o = false;

        if (is_copy)  {
           o = obj.o.clone(true);
           o.find("*[id]").addBack().each(function () {
                                             if (this.id) {
                                               this.id = "copy_" + this.id;
                                             }
                                         });
        }
        else   {
          o = obj.o;
        }

        if (obj.or.length)  {
          obj.or.before(o);
        }
        else   { 
           if (!obj.np.children("ul").length)  {
             $("<ul />").appendTo(obj.np);
           }
           obj.np.children("ul:eq(0)").append(o); 
        }

        try { 
               obj.ot._clean_node(obj.op);
               obj.rt._clean_node(obj.np);
               if (!obj.op.find("> ul > li").length)  {
                obj.op.removeClass("oj-tree-open oj-tree-closed")
                      .removeAttr(WA_EXPANDED)
                      .addClass(OJT_LEAF)
                      .children("ul")
                      .remove();
               }
        } catch (e) { }

        if (is_copy)  { 
           this._data.core.prepared_move.cy = true;
           this._data.core.prepared_move.oc = o; 
        }
        var d = $.extend(true, {}, this._data.core.prepared_move) ;
        d["obj"] = obj.o ;  
//Fri28 this._emitEvent(this._data.core.prepared_move, "move");
        this._emitEvent(d, "move");
        return this._data.core.prepared_move;
     },


      /**
        *  Returns the "move" object created by a previous _prepare_move()
        *
        *  The object contains :
        *     .o   the node being moved
        *     .r   the reference node
        *     .p   the destination position relative to the reference node
        *     .np  the new parent
        *     .oc  the original node if there was a copy
        *     .cy  boolean indicating if the move was a copy
        *     .op  the former parent
        *     .or  the node that was previously in the position of the moved node
        *     .ot  the original tree instance
        *     .rt  the reference tree instance
        *     .cr  same as .np but if a root node is created this is -1
        *
        *  @private
        */
      _getMove  : function ()
      {
         return this._data.crrm.prepared_move;
      },


      /**
        *  Returns the "type" attribute of the node.  If not found, returns "default"
        *  @private
        */
      _getType : function (node)
      {
         node = this._getNode(node);

         return (!node || !node.length) ? false : node.attr(this.options["types"]["attr"]) || "default";
      },

      /**
        *  Sets the "type" attribute of the node.
        *  @return {boolean}  true if the change was successful, else false. 
        *  @private
        */
      _setType : function (str, node)
      {
         var  s   = this.options["types"], 
              ret = false ;

         node = this._getNode(node);

         if (s) {
           ret = (!node.length || !str) ? false : node.attr(this.options["types"]["attr"], str);
         }
         else {
           ret = false ;
         }

         if (ret)  {
           this._emitEvent({ "obj" : node, "type" : str}, "settype"); 
         }
         return ret;
      },


      /**
        *  @private
        */
      _check : function (rule, obj, opts)
      {
         obj = this._getNode(obj);

         var v     = false,
             ty    = this._getType(obj),
             d     = 0,
             _this = this,
             s     = this._getOptions()["types"],
             data  = false;

             if (obj === -1) { 
               if (!!s[rule])  {
                 v = s[rule];
                }
               else  {
                 return;
               }
             }
             else   {
               if (ty === false)  {
                 return;
               }

               data = this._data.types.defaults["useData"] ? obj.data("oj-tree") : false;
               if (data && data["types"] && typeof data["types"][rule] !== "undefined")  {
                 v = data["types"][rule];
               }
               else if(!!s["types"][ty] && typeof s["types"][ty][rule] !== "undefined") {
                   v = s["types"][ty][rule];
               }
               else if(!!s["types"]["default"] && typeof s["types"]["default"][rule] !== "undefined")  {
                   v = s["types"]["default"][rule]; }
               }

               if ($.isFunction(v))  {
                   v = v.call(this, obj);
               }

               var md = this._data.types.defaults["maxDepth"] ;

               if (rule === "maxDepth" && obj !== -1 && opts !== false && this._data.types.defaults["maxDepth"] !== -2 && v !== 0)  {
                 // also include the node itself - otherwise if root node it is not checked
                 obj.children("a:eq(0)").parentsUntil(".oj-tree","li").each(function (i)
                        {
                           // check if current depth already exceeds global tree depth
                           if ((md !== -1) && (md - (i + 1) <= 0))  {
                             v = 0;
                             return false;
                           }

                           d = (i === 0) ? v : _this._check(rule, this, false);

                           // Check if current node max depth is already matched or exceeded
                           if (d !== -1 && d - (i + 1) <= 0)  {
                             v = 0; return false;
                           }

                           // otherwise - set the max depth to the current value minus current depth
                           if (d >= 0 && (d - (i + 1) < v || v < 0) )  {
                             v = d - (i + 1);
                           }

                           // If the global tree depth exists and it minus the nodes calculated
                           // so far is less than `v` or `v` is unlimited
                           if ((md >= 0) && (md - (i + 1) < v || v < 0) )  {
                             v = md - (i + 1);
                           }
                        });
               }

               return v;
     },


     /**
       *  @private
       */
      _clean_node  : function (obj)
      {
         obj = obj && obj != -1 ? $(obj) : this._$container_ul;
         obj = obj.is("li") ? obj.find("li").addBack() : obj.find("li");

         obj.removeClass("oj-tree-last")
             .filter("li:last-child").addClass("oj-tree-last").end()
             .filter(":has(li)")
             .not(".oj-tree-open")
             .removeClass(OJT_LEAF)
             .addClass(OJT_CLOSED)
             .attr(WA_EXPANDED, "false");
//JRM        .not(".oj-tree-open").removeClass("oj-tree-leaf").addClass("oj-tree-closed");
         obj.not(".oj-tree-open, .oj-tree-closed").addClass(OJT_LEAF).children("ul").remove();

         this._emitEvent({ "obj" : obj }, "clean_node");
      },


      /**
        *  Creates a new node
        *  @private
        */
      _create_node :  function (obj, position, js, callback, is_loaded)
      {
         obj = this._getNode(obj);
         if (obj !== -1 && !obj.length) {
           return false;
         }

         position = typeof position === "undefined" ? "last" : position;
         var d = $("<li />"),
             s = this.options,
             tmp;

         if (!is_loaded && !this._is_loaded(obj)) {
           this._load_node(obj, function () 
                               {
                                 this._create_node(obj, position, js, callback, true);
                               });
           return false;
         }
           
         this.__rollback();
           
         if (typeof js === "string") {
            js = { "data" : js };
         }
         if (!js) {
            js = {};
         }
         if (js["attr"])  {
           d.attr(js["attr"]);
         }
         if (js["metadata"]) {
           d.data(js["metadata"]);
         }
         if (js["state"]) {
           d.addClass("oj-tree-" + ((js["state"] === "expanded")? "open" : "closed"));
         }
         if (!js["data"]) {
           js["data"] = (js["title"] !== undefined)? js["title"] :
                                                     this.getTranslatedString("m_newnode");
         }
           
         if (!$.isArray(js["data"]))  {
           tmp = js["data"];
           js["data"] = [];
           js["data"].push(tmp);
         }

         var _this = this ;
         $.each(js["data"], function (i, m) {
             tmp = $("<a />");
             if ($.isFunction(m)) {
                m = m.call(this, js);
             }
             if (typeof m == "string")  {
                tmp.attr('href','#')[ _this._data.core.htmlTitles? "html" : "text" ](m);
             }
             else  {
               if (! m["attr"])  {
                  m["attr"] = {};
               }
               if (! m["attr"]["href"])  {
                  m["attr"]["href"] = '#';
               }
               tmp.attr(m["attr"])[ _this._data.core.htmlTitles? "html" : "text" ](m["title"]);
               if (m["language"]) {
                 tmp.addClass(m["language"]);
               }
             }
             tmp.prepend("<ins class='oj-tree-icon'>&#160;</ins>");

             if (!m["icon"] && js["icon"]) {
               m["icon"] = js["icon"];
             }
             if (m["icon"]) { 
               if (m["icon"].indexOf("/") === -1)  {
                  tmp.children("ins").addClass(m["icon"]);
               }
               else  {
                  tmp.children("ins").css("background","url('" + m["icon"] + "') center center no-repeat");
               }
             }
             d.append(tmp);
         });

         d.prepend("<ins class='oj-tree-icon'>&#160;</ins>");
         if (obj === -1) {
           obj = this._$container;
           if (position === "before")  {
             position = "first";
           }
           if (position === "after") {
             position = "last";
           }
         }

         switch(position)
         {
           case "before":  obj.before(d);
                           tmp = this._getParent(obj);
                           break;
           case "after" :  obj.after(d);
                           tmp = this._getParent(obj);
                           break;
           case "inside":
           case "first" :  if (!obj.children("ul").length) {
                            obj.append("<ul />");
                           }
                           obj.children("ul").prepend(d);
                           tmp = obj;
                           break;
           case "last":    if (!obj.children("ul").length) {
                             obj.append("<ul />");
                           }
                           obj.children("ul").append(d);
                           tmp = obj;
                           break;
           default:        if (!obj.children("ul").length) {
                             obj.append("<ul />");
                           }
                           if (!position) {
                             position = 0;
                           }
                           tmp = obj.children("ul").children("li").eq(position);
                           if (tmp.length)  {
                             tmp.before(d);
                           }
                           else  {
                             obj.children("ul").append(d);
                           }
                           tmp = obj;
                           break;
         }

         if (tmp === -1 || tmp.get(0) === this._$container.get(0)) {
           tmp = -1;
         }
         this._clean_node(tmp);
         this._emitEvent({ "obj" : d, "parent" : tmp }, "create_node");

         if (callback) {
           callback.call(this, d);
         }

         return d;
      },


      /**
        *  Expands a collapsed node
        *  @private
        */
      _expand   : function (obj, callback, skip_animation)
      {
         obj = this._getNode(obj);
         if (! obj.length) {
           return false;
         }

         if (obj.hasClass("oj-disabled") || this._data.core.locked) {
           return ;
         }

         if (! obj.hasClass(OJT_CLOSED))  {
           if (callback)  {
             callback.call();
           }
           return false;
         }

         var rslt = this._emitEvent({"obj" : obj, "func" : "expand"}, "before") ;
         if (typeof rslt == "boolean" && (!rslt)) {
           return ;
         }

         var s = skip_animation || this.options["animDuration"],
             t = this;

         if (! this._is_loaded(obj))  {
           obj.children("a").addClass("oj-tree-loading");
           this._load_node(obj, function () {
                                   t["expand"](obj, callback, skip_animation);
                                }, callback) ;
         }
         else    {
           if (this.options["expandParents"])  {
             obj.parentsUntil(".oj-tree",".oj-tree-closed").each(function ()
                                   {
                                     t["expand"](this, false, true);
                                    });
           }
           if (s)  {
             obj.children("ul").css("display","none");
           }
           obj.removeClass(OJT_CLOSED).addClass(OJT_OPEN)
                                      .attr(WA_EXPANDED, "true")
                                      .children("a")
                                      .removeClass("oj-tree-loading");

           if (s)  {
             obj.children("ul").stop(true, true).slideDown(s, function ()
                                                               {
                                                                 this.style.display = ""; 
//                                                               this["style"]["display"] = ""; 
                                                                 t["after_open"](obj);
                                                                });
           }
           else  {
              t["after_open"](obj);
           }

           this._emitEvent({ "obj" : obj }, "expand");
           if (callback)  {
             callback.call();
           }
         }
    },


    /**
      *  Expands all collapsed nodes
      *  @private
      */
    _expandAll  : function (obj, do_animation, original_obj)
    {
      var origTarg = obj? obj : -1 ;

      obj = obj ? this._getNode(obj) : -1;
      if (!obj || obj === -1) {
        obj = this._$container_ul;
      }
      else {
        origTarg = obj ;
      }

      if (original_obj)  { 
        obj = obj.find("li.oj-tree-closed");
      }
      else   {
        original_obj = obj;
        if (obj.is(".oj-tree-closed"))
        {
          obj = obj.find("li.oj-tree-closed").addBack();
        }
        else  {
          obj = obj.find("li.oj-tree-closed");
        }
      }

      var _this = this;
      obj.each(function ()
           { 
             var __this = this; 

             if (!_this._is_loaded(this))   {
               _this["expand"](this, function()
                                     {
                                       _this._expandAll(__this, do_animation, original_obj);
                                     }, !do_animation);
             }
             else  {
               _this._expand(this, false, !do_animation);
             }
           });

      // so that callback is fired AFTER all nodes are open
      if (original_obj.find('li.oj-tree-closed').length === 0)  {
        this._emitEvent({ "obj" : obj, "targ" : origTarg }, "expandAll");
      }
   },


    /**
      *  Selects a node
      *  @private
      */
    _select : function (node, check, e)
    {
       if (this._data.core.selectMode == 0) {
         return false ;
       }

       node = this._getNode(node);

       if (node == -1 || !node || !node.length)  {
         return false;
       }

       if (node.hasClass("oj-disabled") || this._data.core.locked) {
         return ;
       }

       var rslt = this._emitEvent({"obj" : node, "func":"select"}, "before") ;
       if (typeof rslt == "boolean" && (!rslt)) {
         return ;
       }

       var s = this.options ;
       var selMultMod     = this._data.ui.defaults["selectMultipleModifier"] ;  // not published yet
       var selRangeMod    = this._data.ui.defaults["selectRangeModifier"] ;     // not yet published
       var disSelChildren = this._data.ui.defaults["disableSelectingChildren"] ; // not yet published 
       var is_multiple    = (selMultMod == "on" || (selMultMod !== false && e && (e[selMultMod + "Key"]))),
           is_range       = ((selRangeMod !== false) && (e &&  (e[selRangeMod + "Key"]))  &&
                            this._data.ui.last_selected && this._data.ui.last_selected[0] !== node[0] &&
                            (this._data.ui.last_selected.parent()[0] === node.parent()[0])),
           is_selected    = this["isSelected"](node),
           proceed        = true,
           t              = this;

       if (check)   {
          if (disSelChildren && is_multiple && 
              ((node.parentsUntil(".oj-tree","li").children("a.oj-tree-clicked").length) ||
               (node.children("ul").find("a.oj-tree-clicked:eq(0)").length)))  {
             return false;
          }
          proceed = false;
          switch(!0)  {
             case (is_range):
                 this._data.ui.last_selected.addClass("oj-tree-last-selected");
                 node = node[ node.index() < this._data.ui.last_selected.index() ? "nextUntil" : "prevUntil" ](".oj-tree-last-selected").addBack();

                 if (this._data.core.selectMode == -1 || node.length < this._data.core.selectMode)  {
                   this._data.ui.last_selected.removeClass("oj-tree-last-selected");
                   this._data.ui.selected.each(function ()
                                           {
                                              if (this !== t._data.ui.last_selected[0])  {
                                                t["deselect"](this);
                                              }
                                         });
                   is_selected = false;
                   proceed     = true;
                 }
                 else {
                   proceed = false;
                 }
                 break;

             case (is_selected && !is_multiple): 
                 this["deselectAll"]();
                 if (!this._data.ui.spacebar) {  // only kbd toggles selected status
                   is_selected = false;
                 }
                 proceed     = true;
                 break;

             case (! is_selected && !is_multiple): 
                 if (e) {                                         // if mouse click
                   if (this._data.ui.selected && (this._data.ui.selected.length == 1)) {
                     this["deselect"](this._data.ui.selected) ;  // clear the selection
                   }
                   else {
                     this["deselectAll"](this._data.ui.selected) ;  // clear all selections
                   }
                 }
                 else  //if (this._data.core.selectMode == -1 || this._data.core.selectMode > 0)  {
                       if (this._data.core.selectMode === 1)  {
                   this["deselect"](this._data.ui.selected) ;
                 }
                 else if (this._data.core.selectMode > 1)  {  // TDO check if the selected count will exceed the
                   this["deselectAll"]();                     // the selectMode count. Do we veto this select?
                 }
                 proceed = true;
                 break;

             case (is_selected && is_multiple): 
                 this["deselect"](node);
                 break;

             case (! is_selected && is_multiple): 
                 if (this._data.core.selectMode == -1 || this._data.ui.selected.length + 1 <= this._data.core.selectMode)  { 
                   proceed = true;
                 }
                 break;
          }
       }

       if (proceed && !is_selected)  {
          if (!is_range)  {
            this._data.ui.last_selected = node;
          }
          node.children("a").addClass(OJT_CLICKED);
          node.attr(WA_SELECTED, "true");

          if (s["selectedParentExpand"])  {
             node.parents(".oj-tree-closed").each(function () {
                                                   t["expand"](this, false, true);
                                            });
          }
          this._data.ui.selected = this._data.ui.selected.add(node);
          this._fix_scroll(node.eq(0));

           this._emitEvent({ "obj" : node, "e" : e }, "select");
        }

     },


      /**
        *  Deselect all nodes.  Nodes can be deselected all together with a "deselectAll" event,
        *  or separately with "deselect" events.
        *  @private
        */
     _deselectAll : function(context, bSeparate)
     {
       if (this._data.core.locked) {
         return ;
       }

       if (! bSeparate) {
         var origTarg = context? context : -1 ;
         var ret = context ? $(context).find("a.oj-tree-clicked").parent() :
                             this._$container.find("a.oj-tree-clicked").parent();

         if (ret.hasClass("oj-disabled")) {
           return ;
         }

         ret.children("a.oj-tree-clicked").removeClass(OJT_CLICKED);
         ret.removeAttr(WA_SELECTED);
         this._data.ui.selected = $([]);
         this._data.ui.last_selected = false;

         if (ret.length) {
           this._emitEvent({ "obj" : ret, "targ": origTarg}, "deselectAll");
         }
       }
       else {
         var origTarg = context? context : -1 ;
         var ret = context ? $(context).find("a.oj-tree-clicked").parent() :
                             this._$container.find("a.oj-tree-clicked").parent();

         if (ret.hasClass("oj-disabled")) {
           return ;
         }

         var _this = this ;
         $.each(ret, function() {
            _this["deselect"](this) ;
         }) ;
       }
     },


      /**
        *  Placeholder for a more specific refresh action. It is replaced
        *  by refresh_json() for json_data, or _refresh_ui() for html_data.
        *  @private
        */
     _refresh : function(node) {
        this._refresh_core(node) ;
     },


     /**
       *  Base _refresh action
       *  @private
       */
     _refresh_core : function(node)
     {
       var origTarg = node? node : -1 ;
       var _this    = this;
       
       this._save_opened();
       if (!node) {
          node = -1;
       }
       node = this._getNode(node);
       if (!node)  {
         node = -1;
       }
       else {
         origTarg = node
       }

       if (node !== -1)  {
         node.children("UL").remove();
       }
       else  {
         this._$container_ul.empty();
       }
       this._load_node(node, function ()
                           {
                             _this._emitEvent({ "obj" : origTarg}, "refresh");
                             _this._reload_nodes();
                            }
                      );
     },


     /**
       *  Ui _refresh action 
       *  @private
       */
     _refresh_ui : function (obj)
     {
        this["save_selected"]();
//wed5  return this.__call_old();
        this._refresh_core(obj) ;
     },


    /**
      *  Emits an "after_open" event for internal use only.
      *  @private
      */
    "after_open"  : function (obj)
    { 
       this._emitEvent({ "obj" : obj }, "after_open");
    },


    /**
      *  Emits an internal "after_close" event for internal use only.
      *  @private
      */
    "after_close" : function (obj)
    { 
       this._emitEvent({ "obj" : obj }, "after_close");
    },


    /**
      *  Expand any nodes that have been specified to be expanded.
      *  Emits an internal "reopen" event.
      *  @private
      */
    _reopen : function ()
    {
       var _this = this;

       if (this._data.core.toExpand.length) {
         $.each(this._data.core.toExpand, function (i, val)
                                          {
                                             _this._expand(val, false, true); 
                                          });
       }
       this._emitEvent({}, "reopen");
     },


     /**
       *  Returns an array of currently selected nodes.
       *  @private
       */
     _getSelected : function (context)
     { 
         return context ? $(context).find("a.oj-tree-clicked").parent() : this._data.ui.selected ; 
     },


     /**
       *  Changes the text title of the node's <a>
       *  @private
       */
     _set_text  : function (obj, val)
     {
        obj = this._getNode(obj);
        if (!obj.length)  {
          return false;
        }

        obj = obj.children("a:eq(0)");
        if (this._data.core.htmlTitles)  {
           var tmp = obj.children("INS").clone();
           obj.html(val).prepend(tmp);
           this._emitEvent({ "obj" : obj, "name" : val }, "set_text");
           return true;
        }
        else
        {
//         obj = obj.contents().filter(function() {
//                                 return this.nodeType == 3;
//                              })[0];

           obj = obj.find("span:eq(0)") ;
           this._emitEvent({ "obj" : obj, "name" : val }, "set_text");
           return (obj[0].textContent = val);
        }
     },


    /**
      *  @private
      */ 
     _load_node : function(obj, success_callback, error_callback)     // Dummy function overriden by data methods
     {
        this._emitEvent({ "obj" : obj }, "load_node");

     },

     /**
       *  Returns whether a node is current loaded. This is a dummy function
       *  overriden by data methods (such as_load_node_J()).
       *  @private
       */
     _is_loaded  : function (obj)                 // Dummy function overriden by data methods
     {
       return true;
     },


     /*
      *  TreeDataSource's _load_node
      *  @private
      */
     _load_node_DS : function (obj, s_call, e_call)
     {
        var _this = this;
        this._load_node_tree(obj, function ()  {
                                      _this._emitEvent({ "obj" : _this._getNode(obj) }, "load_node");
                                      s_call.call(this);
                                  }, e_call);
     },


     /*
      *   JsonTreeDataSource's _is_loaded()
      *   @return {boolean}
      *   @private
      */
     _is_loaded_DS : function (obj)
     { 
//     var s = this.options["data"]["json"];

       obj = this._getNode(obj); 

//     return (obj === -1 || !obj ) || (!s["ajax"] && !this._data.ds.progressiveRender && !$.isFunction(s["data"]))
       return (obj === -1 || !obj ) || obj.is(".oj-tree-open, .oj-tree-leaf")
                                    || obj.children("ul").children("li").length > 0;
     },


     /**
      *   JsonTreeDataSource's _refreshDS
       *  @private
       */
     _refresh_DS  : function (obj)
     {
        obj = this._getNode(obj);

//      var s = this.options["data"]["json"];
//      if (obj && obj !== -1 && this._data.ds.progressiveUnload && ($.isFunction(s["data"]) || !!s["ajax"]))  {
        if (obj && obj !== -1)  {
          obj.removeData("oj-tree-children");
        }
//Wed5  return this.__call_old();
        return this._refresh_ui(obj);
     },


     /*
      *  json_data's _load_node
      *  @private
      */
     _load_node_J : function (obj, s_call, e_call)
     {
        var _this = this;
        this._load_node_json(obj, function ()  {
                                      _this._emitEvent({ "obj" : _this._getNode(obj) }, "load_node");
                                      s_call.call(this);
                                  }, e_call);
     },

     /*
      *   json_data's _is_loaded
      *   @private
      */
     _is_loaded_J : function (obj)
     { 
       var s = this.options["data"];

       obj = this._getNode(obj); 
       return obj == -1 || !obj || (!s["ajax"] && !this._data.ds.progressiveRender && !$.isFunction(s["data"]))
                        || obj.is(".oj-tree-open, .oj-tree-leaf")
                        || obj.children("ul").children("li").length > 0;
     },


     /*
      *   html_data's _load_node
      *   @private
      */
     _load_node_H : function (obj, s_call, e_call)
     {
       var _this = this;
       this._load_node_html(obj, function ()  {
                                   _this._emitEvent({ "obj" : _this._getNode(obj)}, "load_node") ;
                                   s_call.call(this);
                                 }, e_call);
     },

     /*
      *  html_data's _load_node
      *  @private
      */
     _is_loaded_H : function (obj)
     { 
       var s    = this.options["data"],
           data = null,
           ajax = null ;

      if (s) {
        data  = s["data"] || null ;
        ajax  = s["ajax"] || null ;
      }

       obj = this._getNode(obj); 

       return obj == -1 || !obj || (!ajax && !$.isFunction(data)) ||
                           obj.is(".oj-tree-open, .oj-tree-leaf") || obj.children("ul").children("li").size() > 0;
     },


     "reselect" : function ()
     {
        var _this = this,
            s      = this._data.ui.to_select;

        s = $.map($.makeArray(s), function (n) {
                           return "#" + n.toString().replace(/^#/,"")
                                                    .replace(/\\\//g,"/").replace(/\//g,"\\\/").replace(/\\\./g,".").replace(/\./g,"\\.").replace(/\:/g,"\\:"); });
        // this.deselect_all(); WHY deselect, breaks plugin state notifier?
        $.each(s, function (i, val)
                   {
                      if (val && val !== "#")  {
                        _this["select"](val);
                      }
              });

        this._data.ui.selected = this._data.ui.selected.filter(function ()
                                           {
                                             return this["parentNode"];
                                            });
        this._emitEvent(null, "reselect");
     },

     "save_selected" : function ()
     {
        var _this = this;

        this._data.ui.to_select = [];
        this._data.ui.selected.each(function ()
                  {
                    if (this.id) {
                      _this._data.ui.to_select.push("#" + this.id.toString().replace(/^#/,"").replace(/\\\//g,"/").replace(/\//g,"\\\/").replace(/\\\./g,".").replace(/\./g,"\\.").replace(/\:/g,"\\:")); 
                     }
                  });
        this._emitEvent(this._data.ui.to_select, "save_selected");
     },


     /*
      *      Not documented
      */
     "rollback" : function (rb)
     {
        if (rb)  {
          if (!$.isArray(rb))  {
            rb = [ rb ];
          }
          $.each(rb, function (i, val)
                     {
//                       instances[val.i]["set_rollback"](val.h, val.d);     //TDO
                     });
        }
    },


    "get_rollback" : function ()
    { 
       this._emitEvent(null, "get_rollback");
       return {
                i : this._getIndex(),
                h : this._$container.children("ul").clone(true),
                d : this["data"]                    // TDO ???
              }; 
    },
           
    "set_rollback" : function (html, data)
    {
       if (this._$container && this._$container_ul)   {
         this._$container_ul.empty().append(html);
       }

       this["data"] = data;                       // TDO ???
       this._emitEvent(null, "set_rollback");
    },


    /*
     *  Load json for a particular node (or the whole tree)
     *  @private
     */
    _load_node_tree : function (obj, s_call, e_call)
    {
       var rslt = this._JsonDSToJson(obj) ;

       if (! rslt.success) {
         return ; // TDO
       }

       if (! rslt.js) {
         return ;       // TDO
       }

       var  bTree = ((! obj) || (obj === -1)) ;
       var  s     = this.options["data"] ;
       var  d ;

       if ((!!s["data"] && !s["ajax"]) || (!!s["data"] && !!s["ajax"] && bTree))  {
         if (bTree)  {
           d = this._parseJson(rslt.js, obj) ;
           if (d)  {
             this._$container_ul.empty().append(d.children());
             this._clean_node();
           }
           else  { 
              if (this._data.ds.correctState) {
                  this._$container_ul.empty();
               }
           }
         }
         if (s_call) {
            s_call.call(this);
         }
       }
       else if  ((!s["data"] && !!s["ajax"]) || (!!s["data"] && !!s["ajax"] && (! bTree))) {
          d = this._parseJson(rslt.js, obj);
          if (d)  {
            if (bTree)  {
              var $u =  this._$container_ul;
              $u.empty().append(d.children());
              $u.attr(WA_ROLE, WA_TREE).attr("tabindex", "0").css("outline", "none") ;
              if (this._data.core.selectMode === -1)  {
                $u.attr("aria-multiselectable", true) ;
              }
            }
            else  {
              obj.append(d).children("a.oj-tree-loading").removeClass("oj-tree-loading");
              obj.removeData("oj-tree-is-loading");
            }
   
            this._clean_node(obj);
            if (s_call)  {
              s_call.call(this);
            }
          }
          else  {
            if (bTree) {
              if (this._data.ds.correctState)  { 
                this._$container_ul.empty(); 
                if (s_call) {
                  s_call.call(this);
                }
              }
            }
            else  {
               obj.children("a.oj-tree-loading").removeClass("oj-tree-loading");
               obj.removeData("oj-tree-is-loading");
               if (s["correct_state"]) { 
                 this._correct_state(obj);
                 if (s_call)  {
                   s_call.call(this);
                 } 
               }
            }
          }
       }

     },


    /**
      * Process a JsonTreeDataSource to a Json array ready for parsing.
      * This is temporary - it assumes that all nodes are available in the Json;
      * that is, there is no lazy-loading.   TDO
      * @private
      * @return {Object} contains "success" (boolean) and "js" (the json nodes)
      */
     _JsonDSToJson : function (parentKey, node)
     {
        var arJson = [],
            ds = this._tds,
            cc,
            range = {},
            rslt  = {success : false, js : null} ;

        if (parentKey == -1) {
          parentKey = null ;
          range["start"] = 0 ;
        }
        else {
          // TDO
        }

        cc = ds.getChildCount(parentKey) ;   
        if (cc > 0) {
          range["count"] = cc ;
          ds.fetchChildren(parentKey, range,              // get the JsonNodeSet 
              {
                "success" : $.proxy(function(jns) {
                     var c = jns.getCount(),
                         attr,
                         n ;

                     for (var i = 0; i < c; i++) {
                        node = {} ;
                        attr = jns.getData(i) ;           // get the attribute list to be applied 
                        if (attr) {
                          node["attr"] = attr ;
                        }
                       node["title"] = jns.m_nodes[i].title ;         // hack, wait for chadwick
                       if (attr.metadata) {
                         node["metadata"] = jns.m_nodes[i].metadata ; // hack, wait for chadwick
                       }

                       var key  = node["attr"]["id"] ;

                       n = ds.getChildCount(key) ;
                       if (n > 0) {
                          var r = this._JsonDSToJson(key, node) ;
                          node["children"] = r.js ;
                       }

                       arJson.push(node) ;
                     }
  
                     rslt.success = true ;
                     rslt.js      = arJson ;
                   }, this),

                "error" :  function(status) {
                              rslt.success = false ;
                           }
              }) ;
        }
        return rslt ;
     },


     /**
       *  @private
       */
     _refresh_json  : function (obj)
     {
        obj = this._getNode(obj);

        if (this._data.core.locked) {
          return ;
        }

        var bTree = (!obj || obj !== -1 || !obj.length) ;
        if (!bTree && obj.hasClass("oj-disabled")) {
          return ;
        }

        var s = this.options["data"]["json"];

        if (! bTree && this._data.ds.progressiveUnload && ($.isFunction(s["data"]) || !!s["ajax"]))  {
          obj.removeData("oj-tree-children");
        }
//Wed5  return this.__call_old();
        return this._refresh_ui(obj);
     },


     /*
      *  Load json for a particular node (or the whole tree)
      *  @private
      */
     _load_node_json : function (obj, s_call, e_call)
     {
       var s = this._getOptions()["data"],        // work on a copy of the options to avoid
           d,                                     // endless loop in calling success/error funcs
           error_func   = function () {},
           success_func = function () {},
           data         = (s && s["data"]) || null,
           ajax         = (s && s["ajax"]) || null;

       if (s && !data && !ajax) {
         data = s ;                               // we just have data, no data() ajax() methods defined
       }

       obj = this._getNode(obj);

       if (obj && obj !== -1 && (this._data.ds.progressiveRender || this._data.ds.progressiveUnload)
                             && !obj.is(".oj-tree-open, .oj-tree-leaf")
                             && obj.children("ul").children("li").length === 0 && obj.data("oj-tree-children")) {
          d = this._parseJson(obj.data("oj-tree-children"), obj);
          if (d)  {
            obj.append(d);
            if (! this._data.ds.progressiveUnload) {
              obj.removeData("oj-tree-children");
            }
          }

          this._clean_node(obj);
          if (s_call)  {
            s_call.call(this);
          }
          return;
       }

       if (obj && obj !== -1) {
         if (obj.data("oj-tree-is-loading"))  {
            return;
         }
         else  {
            obj.data("oj-tree-is-loading",true);
         }
       }

       switch (!0)
       {
          case (!data && !ajax) : throw "ojTree - neither data nor ajax settings supplied.";

          // function option added here for easier model integration (also supporting async - see callback)

          case ($.isFunction(data)):
                       data.call(this, obj, $.proxy(function (d) {
                           d = this._parseJson(d, obj);
                           if (!d) { 
                              if (obj === -1 || !obj)  {
                                if (this._data.ds.correctState)  {
                                  this._$container_ul.empty();
                                }
                              }
                              else  {
                                 obj.children("a.oj-tree-loading").removeClass("oj-tree-loading");
                                 obj.removeData("oj-tree-is-loading");

                                 if (this._data.ds.correctState) {
                                   this._correct_state(obj);
                                 }
                              }
                              if (e_call) {
                                e_call.call(this);
                              }
                           }
                           else  {
                              if (obj === -1 || !obj)  {
                                 this._$container_ul.empty().append(d.children());
                              }
                              else  {
                                 obj.append(d).children("a.oj-tree-loading").removeClass("oj-tree-loading");
                                 obj.removeData("oj-tree-is-loading");
                              }
                              this._clean_node(obj);
                              if (s_call)  {
                                s_call.call(this);
                              }
                           }
                       }, this));
                       break;

          case (!!data && !ajax) || (!!data && !!ajax && (!obj || obj === -1)):

                       if (!obj || obj == -1)  {
                         d = this._parseJson(data, obj) ;
                         if (d)  {
                           this._$container_ul.empty().append(d.children());
                           this._clean_node();
                         }
                         else  { 
                            if (this._data.ds.correctState) {
                              this._$container_ul.empty();
                             }
                         }
                       }
                       if (s_call) {
                          s_call.call(this);
                       }
                       break;

          case (!data && !!ajax) || (!!data && !!ajax && obj && obj !== -1):

                       error_func = function (x, t, e)
                       {
                         var ef = this._getOptions()["data"]["ajax"]["error"];  // reget the options       
                         if (ef) {                                              // without our updated ajax
                           ef.call(this, t, e, x);                              // changes to avoid forever loop
                         }
                         if (obj != -1 && obj.length)  {
                            obj.children("a.oj-tree-loading").removeClass("oj-tree-loading");
                            obj.removeData("oj-tree-is-loading");
                            if (t === "success" && this._data.ds.correctState)  {
                              this._correct_state(obj);
                            }
                         }
                         else   {
                           if (t === "success" && this._data.ds.correctState)  {
                             this._$container_ul.empty();
                           }
                         }
                         if (e_call)  {
                           e_call.call(this);
                         }
                       };

                       success_func = function (d, t, x)
                       {
                         var sf = this._getOptions()["data"]["ajax"]["success"];  // reget the options
                         if (sf) {                                                // without our updated ajax
                           d = sf.call(this, d, t, x) || d;                       // changes to avoid forever loop
                         }

                         if (d === "" || (d && d.toString && d.toString().replace(/^[\s\n]+$/,"") === "") || (!$.isArray(d) && !$.isPlainObject(d)))  {
                           return error_func.call(this, x, t, "");
                         }

                         d = this._parseJson(d, obj);
                         if (d)  {
                            if (obj === -1 || !obj)  {
                               var $u =  this._$container_ul;
                               $u.empty().append(d.children());
                               $u.attr(WA_ROLE, WA_TREE).attr("tabindex", "0").css("outline", "none") ;
                               if (this._data.core.selectMode === -1)  {
                                 $u.attr("aria-multiselectable", true) ;
                               }
                             }
                             else   {
                                obj.append(d).children("a.oj-tree-loading").removeClass("oj-tree-loading");
                                obj.removeData("oj-tree-is-loading");
                             }

                             this._clean_node(obj);
                             if (s_call)  {
                               s_call.call(this);
                             }
                         }
                         else  {
                           if (obj === -1 || !obj) {
                              if (this._data.ds.correctState)  { 
                                 this._$container_ul.empty(); 
                                 if (s_call) {
                                   s_call.call(this);
                                 }
                              }
                           }
                           else  {
                              obj.children("a.oj-tree-loading").removeClass("oj-tree-loading");
                              obj.removeData("oj-tree-is-loading");
                              if (this._data.ds.correctState) { 
                                this._correct_state(obj);
                                if (s_call)  {
                                  s_call.call(this);
                                } 
                              }
                           }
                         }
                       };

                       //  Prepare for an ajax op. (note: we are updating a copy of the options)
                       s["ajax"]["context"] = this;
                       s["ajax"]["error"]   = error_func;
                       s["ajax"]["success"] = success_func;

                       if (! s["dataType"])  {
                         s["ajax"]["dataType"] = "json";
                       }
                       if ($.isFunction(s["ajax"]["url"]))  {
                         s["ajax"]["url"] = s["ajax"]["url"].call(this, obj);
                       }
                       if ($.isFunction(s["ajax"]["data"]))  {
                         s["ajax"]["data"] = s["ajax"]["data"].call(this, obj);
                       }
                       $.ajax(s["ajax"]);
                       break;
               }                       // end switch

     },


     /*
      *  Parse a JSON representation of the tree into a jQUery wrapped <ul> structure
      *  @private
      */
     _parseJson : function (js, obj, isRecurse)
     {
        var d = false, 
            tmp, i, j, ul1, ul2, title;

        if (!js) {
          return d;
        }

        if (this._data.ds.progressiveUnload && obj && obj !== -1)  { 
          obj.data("oj-tree-children", d);
        }

        if (typeof js == "string")  {
          try {
                js = $.parseJSON(js) ;
              } catch(err) {js = [];}     // have nothing useful to display
        }

        if ($.isArray(js))  {
          d = $('<ul>');
          if (! js.length)  {
            return false;
          }

          for (i = 0, j = js.length; i < j; i++)  {
             tmp = this._parseJson(js[i], obj, true);
             if (tmp.length)  {
               d = d.append(tmp);
             }
          }

          d = d.children();
        }
        else  {
           //  We have an individual node object

           if (typeof js == "string")  {
             js = { "data" : js };
           }

           // jstree wants js.data to be an object or a string (for the title).
           // If not object,  we expect a title property.

//         if (! js["data"] && js["data"] !== "")  {
//           if (js["title"] !== undefined)  {
//             js["data"] = js["title"];
//             delete js["title"];
//           }
//           else  {
//              return d;
//           }
//         }


//JRM      if(!js.data && js.data !== "") { return d; }

           title = (typeof js["title"] == "string")?  js["title"] : " " ;

           d = $("<li role='" + WA_TREEITEM + "' />");

           if (js["attr"])  {
             if (this._data.types.defType && (! js["attr"]["type"])) {  // if no type and "default" type
               js["attr"]["type"] = "oj-tree-deftype" ;                 // defined, add default type
             }
             d.attr(js["attr"]);       // apply attr's to the <li>
           }
           if (js["metadata"])  {      // and any user defined arbitrary data
             d.data(js["metadata"]);
           }

           // js.state     // not published - per Design Review

           if (js["state"] || (js["children"] && js["children"].length === 0)) {    // length zero means lazy load
             d.addClass("oj-tree-" + ((js["state"] === "expanded")? "open" : "closed"));
           }

//         if (!$.isArray(js["data"])) {
//           tmp = js["data"];
//           js["data"] = [];
//           js["data"].push(tmp);
//         }
           
           if (! js["data"]) {
             js["data"] = {"dummy": 0} ;
           }

           var ht   = this._data.core.htmlTitles ;
           var bIns = false ;

           tmp = $("<a tabindex='-1' />");
           $.each(js["data"], function (i, m)   {
//                    tmp = $("<a role=presentation tabindex=-1 />");
                      if ($.isFunction(m)) {
                        m = m.call(this, js);
                      }
                      if (typeof m == "string")  {
//                      tmp.attr('href','#')[ ht? "html" : "text" ](title);
                      }
                      else  {
//                      if (!m["attr"]) {
//                        m["attr"] = {};
//                      }

//                      for (var x in m) {
//                         if (x !== "attr") {
//                           m["attr"][x] = m[x] ;
//                         }
//                      }

//                        if (!m["attr"]["href"]) {
//                          m["attr"]["href"] = '#';
//                        }

//                       tmp.attr(m["attr"]);                // apply attr's to the <a>
                       if (i == "attr") {
                         tmp.attr(m) ;
                       }
                       else if (i == "style") {
                         tmp.css(m) ;
                       }
//                     tmp[ ht? "html" : "text" ](m["title"]? m["title"] : js["title"]);
//                      if (m["language"]) {
                        if (i == "language") {
                          tmp.addClass(m);
                        }
                      }

//                    tmp.prepend("<ins class='oj-tree-icon'>&#160;</ins>");
                      if (! bIns) {
                         tmp.prepend("<ins class='oj-tree-icon'>&#160;</ins><span class='" + OJT_TITLE + "'>" + title + "</span>");
                         bIns = true ;
                      }
                      if (!m["icon"] && js["icon"])  {
                        m["icon"] = js["icon"];
                      }
                      if (m["icon"])  { 
                        if (m["icon"].indexOf("/") === -1)  {
                          tmp.children("ins").addClass(m["icon"]);
                        }
                        else  {
                          tmp.children("ins").css("background","url('" + m["icon"] + "') center center no-repeat");
                        }
                      }
//                    d.append(tmp);
           });

           d.append(tmp);
           d.prepend("<ins class='oj-tree-icon'>&#160;</ins>");

           if (js["children"])  { 
             if (this._data.ds.progressiveRender && js["state"] !== "expanded")  {
               d.addClass(OJT_CLOSED).attr(WA_EXPANDED, "false")
                                     .data("oj-tree-children", js["children"]);
             }
             else  {
               if (this._data.ds.progressiveUnload)  {
                 d.data("oj-tree-children", js["children"]);
               }
               if ($.isArray(js["children"]) && js["children"].length) {
                 tmp = this._parseJson(js["children"], obj, true);
                 if (tmp.length)  {
                   ul2 = $("<ul role='" + WA_GROUP + "' />");
                   ul2.append(tmp);
                   d.append(ul2);
                 }
               }
             }
           }
        }  // end else

        if (! isRecurse)  {
          ul1 = $("<ul />");
          ul1.append(d);
          d = ul1;
        }

        return d;
     },

     /*
      *   Returns a Json representation of a node
      *   @private
      */
     _getJson : function (obj, li_attr, a_attr, is_callback)
     {
       var result = [], 
           s      = this.options, 
           _this  = this,
           tmp1,
           tmp2,
           li,
           a,
           t,
           lang;

       obj = this._getNode(obj);

       if (!obj || obj === -1)  {
         obj = this._$container.find("> ul > li");
       }
       li_attr = $.isArray(li_attr) ? li_attr : [ "id", "class" ];

       if (!is_callback && s["types"])  {
         li_attr.push(s["types"]["attr"]);
       }
       a_attr = $.isArray(a_attr) ? a_attr : [ ];

       obj.each(function () {
                  li = $(this);
                  tmp1 = { data : [] };

                  if (li_attr.length)  {
                    tmp1.attr = { };
                  }
                  $.each(li_attr, function (i, v)  { 
                                    tmp2 = li.attr(v); 
                                    if (tmp2 && tmp2.length && tmp2.replace(/oj-tree[^ ]*/ig,'').length)  {
                                      tmp1.attr[v] = (" " + tmp2).replace(/ oj-tree[^ ]*/ig,'')
                                                                 .replace(/\s+$/ig," ")
                                                                 .replace(/^ /,"").replace(/ $/,""); 
                                    }
                  });

                  if (li.hasClass(OJT_OPEN))  {
                    tmp1.state = "open";
                  }
                  if (li.hasClass(OJT_CLOSED))  {
                    tmp1.state = "closed";
                  }
                  if (li.data())  {
                    tmp1.metadata = li.data();
                  }
                  a = li.children("a");
                  a.each(function ()  {
                          t = $(this);

                          if ( a_attr.length || $.inArray("languages", s["plugins"]) !== -1 || 
//wed3                         t.children("ins").get(0).style.backgroundImage.length || 
                               t.children("ins").get(0)["style"]["backgroundImage"].length || 
//wed3                        (t.children("ins").get(0).className && t.children("ins").get(0).className.replace(/oj-tree[^ ]*|$/ig,'').length))
                              (t.children("ins").get(0)["className"] && t.children("ins").get(0)["className"].replace(/oj-tree[^ ]*|$/ig,'').length))
                          { 
                            lang = false;
                            if ($.inArray("languages", s["plugins"]) !== -1 && $.isArray(s["languages"]) && s["languages"].length)  {
//                            $.each(s.languages, function (l, lv)   {
                              $.each(s["languages"], function (l, lv)   {

                                                     if (t.hasClass(lv))  {
                                                       lang = lv;
                                                       return false;
                                                     }
                              });
                            }

                            tmp2 = { "attr" : { }, "title" : _this.getText(t, lang) }; 
                            $.each(a_attr, function (k, z) {
                                tmp2.attr[z] = (" " + (t.attr(z) || "")).replace(/ oj-tree[^ ]*/ig,'')
                                                                        .replace(/\s+$/ig," ")
                                                                        .replace(/^ /,"")
                                                                        .replace(/ $/,"");
                            });
                            if ($.inArray("languages", s["plugins"]) !== -1 && $.isArray(s["languages"]) && s["languages"].length) {
                               $.each(s["languages"], function (k, z)  {
                                  if (t.hasClass(z))  {
                                    tmp2.language = z;
                                    return true;
                                  }
                               });
                            }

                            if (t.children("ins").get(0)["className"].replace(/oj-tree[^ ]*|$/ig,'').replace(/^\s+$/ig,"").length)
                            {
                              tmp2.icon = t.children("ins").get(0)["className"].replace(/oj-tree[^ ]*|$/ig,'').replace(/\s+$/ig," ").replace(/^ /,"").replace(/ $/,"");
                            }
                            if (t.children("ins").get(0)["style"]["backgroundImage"].length)
                            {
                              tmp2.icon = t.children("ins").get(0)["style"]["backgroundImage"].replace("url(","").replace(")","");
                            }
                          }
                          else   {
                             tmp2 = _this["getText"](t);
                          }

                          if (a.length > 1)  {
                            tmp1.data.push(tmp2);
                          }
                          else   {
                            tmp1.data = tmp2;
                         }
                  });

                  li = li.find("> ul > li");
                  if (li.length)  {
                     tmp1.children = _this._getJson(li, li_attr, a_attr, true);
                  }
                  result.push(tmp1);
       });

       return result;
     },

     /**
       *  @private
       */
     _correct_state   : function (obj)
     {
         obj = this._getNode(obj);
         if (!obj || obj === -1) {
           return false;
         }
         obj.removeClass("oj-tree-closed oj-tree-open")
            .removeAttr(WA_EXPANDED)
            .addClass(OJT_LEAF)
            .children("ul")
            .remove();
         this._emitEvent({ "obj" : obj }, "correct_state");
     },


     /**
       *  @private
       */
     _core_notify : function (n, data)
     {
        if (data.opened)  {
          this._expand(n, false, true);
        }
     },


     /*
      *  Dummy function to fire after the first load (so that there is a loaded event)
      *  @private
      */
     _loaded  : function ()
     { 
        this._emitEvent(null, "loaded"); 
      },


     /**
       *   Process the user tree <ul> list placed in the tree div, or loaded via ajax.
       *   @private
       */
     _load_node_html : function (obj, s_call, e_call)
     {
       var s = this._getOptions()["data"],        // work on a copy of the options to avoid
           d,                                     // endless loop in calling success/error funcs
           error_func   = function () {},
           success_func = function () {},
           data         = (s && s["data"]) || null,
           ajax         = (s && s["ajax"]) || null;

       obj = this._getNode(obj);
       if (obj && obj !== -1)  {
         if (obj.data("oj-tree-is-loading")) {
           return;
         }
         else  {
           obj.data("oj-tree-is-loading", true);
         }
       }

       switch(!0)
       {
          case ((!data && !ajax) && (s && (typeof s === "string"))) :
                    this._loadHtmlString(s, obj, s_call, e_call) ;
                    break ;

          case $.isFunction(data):
                    data.call(this, obj, $.proxy(function (d)
                              {
                                 this._loadHtmlString(d, obj, s_call, e_call) ;
                              }, this));
                    break;

          case (!data && !ajax):
                    if (!obj || obj == -1 )  {
                      this._$container_ul
                              .empty()
                              .append(this._data.html.markup)
                              .find("li, a")
                              .filter(function () {
                                               return (!this.firstChild || !this.firstChild.tagName ||
                                                       this.firstChild.tagName !== "INS");
                                                   })
                              .prepend("<ins class='oj-tree-icon'>&#160;</ins>").end()
                              .filter("a").children("ins:first-child")
                              .not(".oj-tree-icon")
                              .addClass(OJT_ICON);

                      //  No point in checking for empty parent <ul> because we don't have a
                      //  "data" option in the first place, so no lazy loading posssible.

                      //  Add the <a> text <span> for hover/click styling
                      this._insertHtmlTextSpan(this._$container_ul) ;

                      if (this._data.types.defType) {             // if "default" type defined
                        this._addDefType(this._$container_ul) ;   // apply to nodes with no asooc type
                      }

                      this._clean_node();
                      this._$container_ul.find("ul").attr(WA_ROLE, WA_GROUP) ;
                      this._$container_ul.find("li").attr(WA_ROLE, WA_TREEITEM) ;
                      this._$container_ul.find("a").attr("tabindex", -1) ;
                    }
                    if (s_call)  {
                      s_call.call(this);
                    }
                    break;

          case (!!data && !ajax) || (!!data && !!ajax && (!obj || obj === -1)):
                    if (!obj || obj == -1) {
                           d = $(data);
                           if (!d.is("ul")) {
                             d = $("<ul />").append(d);
                           }
                           this._$container_ul
                               .empty()
                               .append(d
                               .children())
                               .find("li, a")
                               .filter(function ()
                                           {
                                              return (!this.firstChild || !this.firstChild.tagName ||
                                                      this.firstChild.tagName !== "INS");
                                           })
                               .prepend("<ins class='oj-tree-icon'>&#160;</ins>").end()
                               .filter("a")
                               .children("ins:first-child")
                               .not(".oj-tree-icon")
                               .addClass(OJT_ICON);

                           //  Add the <a> text <span> for hover/click styling
                           this._insertHtmlTextSpan(this._$container_ul) ;

                           if (this._data.types.defType) {             // if "default" type defined
                             this._addDefType(this._$container_ul) ;   // apply to nodes with no asooc type
                           }

                           this._clean_node();
                           this._$container_ul.find("ul").attr(WA_ROLE, WA_GROUP) ;
                           this._$container_ul.find("li").attr(WA_ROLE, WA_TREEITEM) ;
                           this._$container_ul.find("a").attr("tabindex", "-1") ;
                    }
                    if (s_call)  {
                         s_call.call(this);
                    }
                    break;

          case (!data && !!ajax) || (!!data && !!ajax && obj && obj !== -1):
                    obj = this._getNode(obj);
                    error_func = function (x, t, e)
                         {
                           var ef = this._getOptions()["data"]["ajax"]["error"];  // reget the options
                           if (ef) {                                              // without our updated ajax
                             ef.call(this, x, t, e);                              // changes to avoid forever loop
                           }

                           if (obj != -1 && obj.length)  {
                             obj.children("a.oj-tree-loading").removeClass("oj-tree-loading");
                             obj.removeData("oj-tree-is-loading");
                             if (t === "success" && this._data.ds.correctState) {
                                this._correct_state(obj);
                             }
                           }
                           else  {
                             if (t === "success" && this._data.ds.correctState) {
                               this._$container_ul.empty();
                             }
                           }
                           if (e_call)  {
                             e_call.call(this);
                           }
                        };
                    success_func = function (d, t, x)
                        {
                          var parent, lazy ;
                          var sf = this._getOptions()["data"]["ajax"]["success"];  // reget the options
                          if (sf) {                                                // without our updated ajax
                            d = sf.call(this, d, t, x) || d;                       // changes to avoid forever loop
                          }

                          if (d === "" || (d && d.toString && d.toString().replace(/^[\s\n]+$/,"") === "")) {
                            return error_func.call(this, x, t, "");
                          }

                          if (d)  {
                            d = $(d);
                            if (!d.is("ul")) {
                              d = $("<ul />").append(d);
                            }
                            if (obj == -1 || !obj) {
                              this._$container_ul.empty()
                                                 .append(d.children())
                                                 .find("li, a")
                                                 .filter(function ()
                                                    {
                                                      return !this.firstChild || !this.firstChild.tagName ||
                                                                                 this.firstChild.tagName !== "INS";
                                                    })
                                                 .prepend("<ins class='oj-tree-icon'>&#160;</ins>")
                                                 .end()
                                                 .filter("a")
                                                 .children("ins:first-child")
                                                 .not(".oj-tree-icon")
                                                 .addClass(OJT_ICON);

                              parent = this._$container_ul ;

                            }
                            else  {
                               obj.children("a.oj-tree-loading")
                                  .removeClass("oj-tree-loading");

                               this._removeEmptyUL(obj) ;

                               obj.append(d)
                                  .children("ul")
                                  .find("li, a")
                                  .filter(function () {
                                             return (!this.firstChild || !this.firstChild.tagName ||
                                                                         this.firstChild.tagName !== "INS");
                                          })
                                  .prepend("<ins class='oj-tree-icon'>&#160;</ins>")
                                  .end()
                                  .filter("a")
                                  .children("ins:first-child")
                                  .not(".oj-tree-icon")
                                  .addClass(OJT_ICON);
                               obj.removeData("oj-tree-is-loading");
                               parent = obj ;
                            }

                            //  Look for parents with empty children <ul> list (lazy loading),
                            //  and add the closed class to make it a parent.
                            this._handleHtmlParentNoChildren(parent) ;

                            //  Add the <a> text <span> for hover/click styling
                            this._insertHtmlTextSpan(parent) ;

                            // If "default" type defined, apply to nodes with no assoc type
                            if (this._data.types.defType && parent)  {
                              this._addDefType(this._$container_ul) ;
                            }

                            this._clean_node(obj);
                            if (s_call)  {
                              s_call.call(this);
                            }
                          }
                          else  {
                            if (obj && obj !== -1)  {
                               obj.children("a.oj-tree-loading").removeClass("oj-tree-loading");
                               obj.removeData("oj-tree-is-loading");
                               if (this._data.ds.correctState)  { 
                                  this._correct_state(obj);
                                  if (s_call) {
                                    s_call.call(this);
                                  } 
                               }
                              }
                              else  {
                                if (this._data.ds.correctState)  { 
                                   this._$container_ul.empty();
                                   if (s_call) {
                                     s_call.call(this);
                                   } 
                                }
                              }
                              this._$container_ul.find("ul").attr(WA_ROLE, WA_GROUP) ;
                              this._$container_ul.find("li").attr(WA_ROLE, WA_TREEITEM) ;
                          }
                        };

                        //  Prepare for an ajax op. (note: we are updating a copy of the options)
                        s["ajax"]["context"] = this;
                        s["ajax"]["error"]   = error_func;
                        s["ajax"]["success"] = success_func;

                        if (!s["ajax"]["dataType"]) {
                          s["ajax"]["dataType"] = "html";
                        }
                        if ($.isFunction(s["ajax"]["url"])) {
                          s["ajax"]["url"] = s["ajax"]["url"].call(this, obj);
                        }
                        if ($.isFunction(s["ajax"]["data"])) {
                          s["ajax"]["data"] = s["ajax"]["data"].call(this, obj);
                        }
                        $.ajax(s["ajax"]);
                        break;
       }
     },


     /**
       *   Look for parents with empty children <ul> list (lazy loading), and add the closed
       *   class to make it a parent.
       *   @private
       */
     _handleHtmlParentNoChildren : function (parent)
     {
        var lazy = parent
                     .find(parent.is("ul")?  "li ul" : "ul")
                     .filter(function () {
                                return (!this.firstChild ||
                                        this.childNodes.length == 0 ||
                                        (this.childNodes.length == 1 && this.firstChild.nodeType ==3));
                                       }) ;
        $.each(lazy, function() {
                                  $(this).closest("li")
                                         .addClass(OJT_CLOSED) ;
                                }) ;
     },


     /**
       *   Remove an empty <ul> in a node (lazy loading).
       *   @private
       */
     _removeEmptyUL : function(parent)
     {
        var l = parent.find("ul")
                     .filter(function () {
                                return (!this.firstChild ||
                                        this.childNodes.length == 0 ||
                                        (this.childNodes.length == 1 && this.firstChild.nodeType ==3));
                                       }) ;
       if (l.length > 0) {
         l.remove() ;
       }
     },




     /**
       *   Load an HTML <ul><li>...</ul> markup string
       *   @private
       */
     _loadHtmlString : function (s, obj, s_call, e_call)
     {
        var parent ;

        if (s && s !== "" && s.toString && s.toString().replace(/^[\s\n]+$/,"") !== "") {
          s = $(s);
          if (! s.is("ul")) {
            s = $("<ul />").append(s);
          }

          if (obj == -1 || !obj) {
            this._$container_ul.empty()
                               .append(s.children())
                               .find("li, a")
                               .filter(function () {
                                         return (!this.firstChild || !this.firstChild.tagName ||
                                                 this.firstChild.tagName !== "INS");
                                       })
                               .prepend("<ins class='oj-tree-icon'>&#160;</ins>")
                               .end().filter("a")
                               .children("ins:first-child")
                               .not(".oj-tree-icon")
                               .addClass(OJT_ICON);

            parent = this._$container_ul ;

            //  No point in checking for empty parent <ul> because we don't have a
            //  "data" option in the first place, so no lazy loading posssible.

            //  If the "default" node type has been defined, add the def type to any nodes
            //  that have not been given an explicit type
            this._addDefType(this._$container_ul) ;
          }
          else  {
            obj.children("a.oj-tree-loading").removeClass("oj-tree-loading");
            obj.append(s)
               .children("ul")
               .find("li, a")
               .filter(function ()
                          {
                             return !this.firstChild || !this.firstChild.tagName ||
                                                         this.firstChild.tagName !== "INS";
                          })
               .prepend("<ins class='oj-tree-icon'>&#160;</ins>")
               .end().filter("a")
               .children("ins:first-child")
               .not(".oj-tree-icon")
               .addClass("oj-tree-icon");
            obj.removeData("oj-tree-is-loading");

            parent = obj ;

            //  If the "default" node type has been defined, add the def type to
            //  any nodes that have not been given an explicit type
            this._addDefType(this.obj) ;
          }

            //  Add the <a> text <span> for hover/click styling
          if (parent) {
            this._insertHtmlTextSpan(parent) ;
          }

          this._clean_node(obj);
          if (s_call)  {
            s_call.call(this);
          }
        }
        else  {
          if (obj && obj !== -1)  {
            obj.children("a.oj-tree-loading").removeClass("oj-tree-loading");
            obj.removeData("oj-tree-is-loading");
            if (this._data.ds.correctState) { 
              this._correct_state(obj);
              if (s_call) {
                s_call.call(this);
              } 
            }
          }
          else  {
            if (this._data.ds.correctState)
            { 
              this._$container_ul.empty();
              if (s_call) {
                s_call.call(this);
              } 
            }
          }
        }
     },

     /**
       *  Insert the <a> text <span> for hover/click styling
       *  @private
       */
     _insertHtmlTextSpan : function(elem)
     {
        $.each(elem.find("li a"), function (i, val) {
        	 var ih = val.innerHTML ;
             ih = ih.replace("ins>", "ins><span class='" + OJT_TITLE + "'>") ;
             ih += "</span>" ;
        	 val.innerHTML = ih ;
        });
     },

     /**
       *  Add the "default" type attr to all nodes that do not have an explicit type defined.
       *  @private
       */
     _addDefType : function(obj)
     {
        var s, typeAttr ;
        if (this._data.types.defType) {
          s = this.options["types"];
          typeAttr = s? s["attr"] : this._data.types.defaults["attr"];

          $.each(obj.find("li"), function (i, val) {
                  val = $(val)
                  if (! val.attr(typeAttr)) {
                    val.attr(typeAttr, "oj-tree-deftype") ;
                  }
            });
        }
     },


     /*
      *
      *   @private
      */
     _dnd_prepare : function ()
     {
       var  vars = this._data.dnd.vars ;

       if (! vars.r || ! vars.r.length) {
         return;
       }
       this._data.dnd.off = vars.r.offset();

       if (this._isRtl) {
         this._data.dnd.off.right = this._data.dnd.off.left + vars.r.width();
       }

       if (this._data.dnd.foreign)  {

         var a = this.options["dnd"]["drag_check"].call(this, { "o" : vars.o, "r" : vars.r });

         this._data.dnd["after"]   = a["after"];
         this._data.dnd["before"]  = a["before"];
         this._data.dnd["inside"]  = a["inside"];
         this._data.dnd.prepared   = true;
         return this._dnd_show();
       }

       this._prepare_move(vars.o, vars.r, "before");
       this._data.dnd["before"] = this["check_move"]();
       this._prepare_move(vars.o, vars.r, "after");
       this._data.dnd["after"]  = this["check_move"]();

       if (this._is_loaded(vars.r)) {
         this._prepare_move(vars.o, vars.r, "inside");
         this._data.dnd["inside"] = this["check_move"]();
       }
       else  {
         this._data.dnd["inside"] = false;
       }

       this._data.dnd.prepared = true;
       return this._dnd_show();
     },


     /*
      *
      *   @private
      */
     _dnd_show : function ()
     {
        var  dnd = this._data.dnd ;

        if (! dnd.prepared)  {
          return;
        }

        var o     =  ["before","inside","after"],
            r     =  false,
            pos,
            ctl   =  dnd.ctl,
            vars  =  dnd.vars ;

        if (dnd.w < this._data.core.li_height/3)  {
           o = ["before","inside","after"];
        }
        else if (dnd.w <= this._data.core.li_height * 2/3)  {
          o = dnd.w < this._data.core.li_height/2 ? ["inside","before","after"] :
                                                    ["inside","after","before"] ;
        }
        else {
          o = ["after","inside","before"];
        }
 
        $.each(o, $.proxy(function (i, val)
           { 
             if (this._data.dnd[val])  {
               ctl.helper.children("ins").removeClass(OJT_DRAG_INVALID).addClass(OJT_DRAG_OK);
               r = val;
               return false;
             }
        }, this));

        if (r === false)  {
           ctl.helper.children("ins").removeClass(OJT_DRAG_OK).addClass(OJT_DRAG_INVALID);
        }
        
        pos = this._isRtl ? (this._data.dnd.off.right - 18) : (this._data.dnd.off.left + 10);
        switch(r)
         {
            case "before":
                vars.m.css({ "left" : pos + "px",
//mon20                      "top"  : (this._data.dnd.off.top - 6) + "px" }).show();
                             "top"  : (this._data.dnd.off.top - 8) + "px" }).show();
                if (vars.ml) {
                  vars.ml.css({ "left" : (pos + 8) + "px",
//mon20                         "top"  : (this._data.dnd.off.top - 1) + "px" }).show();
                                "top"  : (this._data.dnd.off.top - 3) + "px" }).show();
                }
                break;

            case "after":
                vars.m.css({ "left" : pos + "px",
                             "top"  : (this._data.dnd.off.top +
//mon20                                this._data.core.li_height - 6) + "px" }).show();
                                       this._data.core.li_height - 8) + "px" }).show();
                if (vars.ml) {
                  vars.ml.css({ "left" : (pos + 8) + "px",
                                "top" : (this._data.dnd.off.top +
//mon20                                  this._data.core.li_height - 1) + "px" }).show();
                                         this._data.core.li_height - 3) + "px" }).show();
                }
                break;

            case "inside":
                vars.m.css({ "left" : pos + ( this._isRtl ? -4 : 4) + "px",
                             "top" : (this._data.dnd.off.top + this._data.core.li_height/2 - 5) + "px" }).show();
                if (vars.ml)  {
                  vars.ml.hide();
                }
                break;

            default:
                vars.m.hide();
                if (vars.ml) {
                  vars.ml.hide();
                }
                break;
        }

        vars.last_pos = r;

        return  r;

     },



     /*
      *
      *   @private
      */
     _dnd_enter : function (obj)
     {
        var dnd = this._data.dnd,
            vars = dnd.vars ;

        if (dnd.mto)  { 
          clearTimeout(dnd.mto);
          dnd.mto = false;
        }

        dnd.prepared = false;
        vars.r = this._getNode(obj);

        var s             = this.options["dnd"];
        var checkTimeout  = s["check_timeout"] ;

        if (checkTimeout)  { 

           // do the calculations after a minimal timeout (users tend to drag quickly to the desired location)

           if (dnd.to1)  {
             clearTimeout(dnd.to1);
           }
           dnd.to1 = setTimeout($.proxy(this._dnd_prepare, this), checkTimeout); 
        }
        else { 
            this._dnd_prepare(); 
        }

        var openTimeout  = s["open_timeout"] ;
        if (openTimeout)  { 
          if (dnd.to2)  {
            clearTimeout(dnd.to2);
          }
          if (vars.r && vars.r.length && vars.r.hasClass(OJT_CLOSED))  { 
            // if the node is closed - open it, then recalculate
            dnd.to2 = setTimeout($.proxy(this._dnd_open, this), openTimeout);
          }
        }
        else   {
          if (vars.r && vars.r.length && vars.r.hasClass(OJT_CLOSED))  { 
             this._dnd_open();
          }
        }
  
     },


     /*
      *
      *   @private
      */
     _dnd_leave : function (e)
     {
        var dnd  = this._data.dnd,
            vars = this._data.dnd.vars ;

        dnd["after"]   = false;
        dnd["before"]  = false;
        dnd["inside"]  = false;

        this._data.dnd.ctl.helper.children("ins").removeClass(OJT_DRAG_OK).addClass(OJT_DRAG_INVALID);

        vars.m.hide();

        if (vars.ml) {
          vars.ml.hide();
        }
        if (vars.r && vars.r[0] === e.target.parentNode)
        {
          if (dnd.to1) {
            clearTimeout(dnd.to1);
            dnd.to1 = false;
          }
          if (dnd.to2)  {
            clearTimeout(dnd.to2);
            dnd.to2 = false;
          }
        }

     },


     /**
       *  Expand the node hovered over while dragging so the user can drop inside a folder.
       *  @private
       */
     _dnd_open : function ()
     {
        var  vars = this._data.dnd.vars ;

        this._data.dnd.to2 = false;
        this["expand"](vars.r, $.proxy(this._dnd_prepare, this), true);
     },


     /**
       *  Drag is complete - move the node.
       *  @private
       */
     _dnd_finish : function (e)
      {
         var dnd  = this._data.dnd,
             vars = this._data.dnd.vars ;

         if (dnd.foreign)   {
           if (dnd["after"] || dnd["before"] || dnd["inside"])  {
              this.options["dnd"]["drag_finish"].call(this, { "o" : vars.o, "r" : vars.r, "p" : vars.last_pos });
           }
         }
         else  {
           this._dnd_prepare();
           this._move_node(vars.o, vars.r, vars.last_pos, e[this.options["dnd"]["copy_modifier"] + "Key"]);
         }

         vars.o = false;
         vars.r = false;
         vars.m.hide();

         if (vars.ml) {
           vars.ml.hide();
         }
     },


     /**
       *  Mouse is down on an <a>, prepare for drag and drop
       *  @private
       */
     _start_drag : function (obj, e)
     {
        var  dnd  = this._data.dnd,
             vars = this._data.dnd.vars ;

        vars.o = this._getNode(obj);

        if (vars.o.hasClass("oj-disabled") || this._data.core.locked) {
          return ;
        }

        if (this._data.ui && this["isSelected"](vars.o))  {
          vars.o = this._getNode(null, true);
        }

        var dt  = vars.o.length > 1 ? this.getTranslatedString("m_multisel") : this["getText"](vars.o),
            cnt = this._getContainer();

        if (!this._data.core.htmlTitles) {
          dt = dt.replace(/</ig,"&lt;").replace(/>/ig,"&gt;");
        }
        this._drag_start(e, { jstree : true,
                              obj    : vars.o
                            }, "<ins class='oj-tree-icon'></ins>" + dt);

        if (this._data.themes) {
          if (vars.m) {
             vars.m.addClass("oj-tree-" + this._data.themes.theme);
          }
          dnd.ctl.helper.addClass("oj-tree-dnd-helper oj-tree-" + this._data.themes.theme); 
        }

        dnd.cof    = cnt.offset();
        dnd.cw     = parseInt(cnt.width(),10);
        dnd.ch     = parseInt(cnt.height(),10);
        dnd.active = true;
     },


     /**
       *  Start drag/drop process
       *  @private
       */
     _drag_start : function (e, data, html)
     {  
         var ctl = this._data.dnd.ctl ;

         if (ctl.is_drag)  {
           this._drag_stop() ;
         }
         try {
               e.currentTarget.unselectable = "on";
               e.currentTarget.onselectstart = function()  { return false; };

               if (e.currentTarget.style)  {
                e.currentTarget.style.MozUserSelect = "none";
               }
         } catch(err) { }

         ctl.init_x    = e.pageX;
         ctl.init_y    = e.pageY;
         ctl.user_data = data;
         ctl.is_down   = true;
         ctl.helper    = $("<div class='ojtreeu-dragged' />").html(html); //.fadeTo(10,0.25);

         // Listen for mouse drag and mouse up events
         $(document).bind("mousemove", this._drag.bind(this));
         $(document).bind("mouseup",   this._drag_stop.bind(this));

         return false;
     },


     /**
       *  Mouse is down and we are dragging 
       *  @private
       */
     _drag :  function (e)
     { 
        var ctl  = this._data.dnd.ctl,
            vars = this._data.dnd.vars ;

        if (! ctl.is_down) {
          return;
        }
        if (! ctl.is_drag)  {
          if (Math.abs(e.pageX - ctl.init_x) > 5 || Math.abs(e.pageY - ctl.init_y) > 5)  { 
            ctl.helper.appendTo("body");
            ctl.is_drag = true;
            $(document).triggerHandler("drag_start.ojtreeu", [{
                                                                 "event" : e,
                                                                 "data"  : ctl.user_data
                                                              }]);
          }
          else  {
            return;
          }
        }


        // maybe use a scrolling parent element instead of document?
        if (e.type === "mousemove")
        {   // thought of adding scroll in order to move the helper, but mouse position is n/a
           var d = $(document),
               t = d.scrollTop(),
               l = d.scrollLeft();

           if (e.pageY - t < 20)  { 
             if (vars.sti && vars.dir1 === "down") {
                clearInterval(vars.sti);
                vars.sti = undefined;
             }
             if (! vars.sti)  {
               vars.dir1 = "up";
               vars.sti = setInterval(function ()
                            {
                              $(document).scrollTop( $(document).scrollTop() - ctl.scroll_spd );
                            }, 150);
             }
           }
           else  { 
              if (vars.sti && vars.dir1 === "up")   {
                clearInterval(vars.sti);
                vars.sti = undefined;
              }
           }

           if ($(window).height() - (e.pageY - t) < 20)   {
             if (vars.sti && vars.dir1 === "up")  {
                clearInterval(vars.sti);
                vars.sti = undefined;
             }
             if (! vars.sti)  {
               vars.dir1 = "down";
               vars.sti = setInterval(function ()
                         {
                           $(document).scrollTop( Number($(document).scrollTop()) + ctl.scroll_spd );
                           // above Number() is for the closure compiler!!
                         }, 150);
             }
           }
           else   { 
              if (vars.sti && vars.dir1 === "down")  {
                clearInterval(vars.sti);
                vars.sti = undefined;
              }
           }

           if (e.pageX - l < 20)   {
             if (vars.sli && vars.dir2 === "right")  {
                clearInterval(vars.sli);
                vars.sli = undefined;
             }
             if (! vars.sli)  {
                vars.dir2 = "left";
                vars.sli = setInterval(function ()
                       {
                         $(document).scrollLeft( $(document).scrollLeft() - ctl.scroll_spd );
                       }, 150);
             }
           }
           else   { 
             if (vars.sli && vars.dir2 === "left")   {
               clearInterval(vars.sli);
               vars.sli = undefined;
             }
           }

           if ($(window).width() - (e.pageX - l) < 20)   {
             if (vars.sli && vars.dir2 === "left")  {
                clearInterval(vars.sli);
                vars.sli = undefined;
             }
             if (! vars.sli)   {
               vars.dir2 = "right";
               vars.sli = setInterval(function ()
                        {
//                        Number() is for the closure compiler!!
                          $(document).scrollLeft(Number($(document).scrollLeft()) + ctl.scroll_spd);
                        }, 150);
             }
           }
           else  { 
             if (vars.sli && vars.dir2 === "right")  {
               clearInterval(vars.sli);
               vars.sli = undefined;
             }
           }
        }

        ctl.helper.css({ left : (e.pageX + ctl.helper_left) + "px", top : (e.pageY + ctl.helper_top) + "px" });
        $(document).triggerHandler("drag.ojtreeu", [{
                                                      "event" : e,
                                                      "data"  : ctl.user_data
                                                    }]);
     },


     /**
       *  @private
       */
     _drag_stop  : function (e)
     {
        var vars = this._data.dnd.vars,
            ctl  = this._data.dnd.ctl ;

        if (vars.sli)  {
          clearInterval(vars.sli);
        }
        if (vars.sti)   {
          clearInterval(vars.sti);
        }

        $(document).unbind("mousemove", this._drag.bind(this));
        $(document).unbind("mouseup",   this._drag_stop.bind(this));
        $(document).triggerHandler("drag_stop.ojtreeu", [{
                                                           "event" : e? e: {},
                                                           "data"  : ctl.user_data
                                                         }]);
        ctl.helper.remove();
        ctl.init_x    = 0;
        ctl.init_y    = 0;
        ctl.user_data = {};
        ctl.is_down   = false;
        ctl.is_drag   = false;
    },


     /**
       *  @private
       */
     _save_opened : function ()
     {
        var _this = this;
        this._data.core.toExpand = [];
        this._$container_ul.find("li.oj-tree-open").each(function () { 
            if (this.id)  { 
              _this._data.core.toExpand.push("#" + this.id.toString().replace(/^#/,"").replace(/\\\//g,"/").replace(/\//g,"\\\/").replace(/\\\./g,".").replace(/\./g,"\\.").replace(/\:/g,"\\:"));
            }
        });

        this._emitEvent(_this._data.core.toExpand, "save_opened");
     },


     /*
      *   Reload tree nodes
      *   @private
      */
      _reload_nodes : function (is_callback)
      {
         var _this     = this,
             done      = true,
             current   = [],
             remaining = [],
             ea,
             bExpandAll ;
     
         if (!is_callback)  { 
            this._data.core.reopen     = false; 
            this._data.core.refreshing = true; 

            bExpandAll = this._data.core.toExpand === "all" ;
            if (bExpandAll) {
              this._data.core.toExpand  = [];
            }
            else  if (($.type(this._data.core.toExpand) === "array") && (this._data.core.toExpand.length > 0) &&
                                                                        (this._data.core.toExpand[0] === "all")) {
              this._data.core.toExpand.length = 0 ;
              bExpandAll = true ;
            }

            if (bExpandAll) {
              ea = this._$container_ul.find("li.oj-tree-closed").each(function() {
                     var id = $(this).attr("id") ;
                     _this._data.core.toExpand.push('#' + $(this).attr("id")) ;
                   }) ;
            }
     
            this._data.core.toExpand = 
                     $.map(
                            $.makeArray(this._data.core.toExpand),
                                function (n) {
                                   return "#" + n.toString().replace(/^#/, "")
                                                            .replace(/\\\//g, "/")
                                                            .replace(/\//g, "\\\/")
                                                            .replace(/\\\./g, ".")
                                                            .replace(/\./g, "\\.")
                                                            .replace(/\:/g, "\\:");
                                }
                          );
     
            this._data.core.toLoad = 
                       $.map(
                              $.makeArray(this._data.core.toLoad),
                                  function (n)  {
                                     return "#" + n.toString().replace(/^#/,"")
                                                              .replace(/\\\//g,"/")
                                                              .replace(/\//g,"\\\/")
                                                              .replace(/\\\./g,".")
                                                              .replace(/\./g,"\\.")
                                                              .replace(/\:/g,"\\:");
                            }
                       );
     
            if (this._data.core.toExpand.length)  {
              this._data.core.toLoad  = this._data.core.toLoad.concat(this._data.core.toExpand);
            }
         }
     
         if (this._data.core.toLoad.length) {
            $.each(this._data.core.toLoad, function (i, val) {
                if (val == "#") {
                  return true;
                }
                if ($(val).length) {
                  current.push(val);
                }
                else {
                  remaining.push(val);
                }
            });
     
            if (current.length) {
               this._data.core.toLoad  =  remaining;
               $.each(current, function (i, val) { 
                   if (! _this._is_loaded(val))  {
                      _this._load_node(val, function ()  {
                                               _this._reload_nodes(true);
                                             }, function ()  {
                                                 _this._reload_nodes(true);
                                                }
                                      );
                      done = false;
                   }
               });
            }
         }

         if (this._data.core.toExpand.length)
         {
            $.each(this._data.core.toExpand, function (i, val) {
                 _this["expand"](val, false, true); 
            });
         }

         if (done)  { 
            // TODO: find a more elegant approach to syncronizing returning requests

            if (this._data.core.reopen)  {
              clearTimeout(this._data.core.reopen);
            }
            this._data.core.reopen = setTimeout(function ()  {
                                                   _this._emitEvent({}, "reload_nodes");
                                               }, 50);

            this._data.core.refreshing = false;
            this._reopen();
         }
    },


     /*
      *   TDO   replace with Jet theming.
      *   @private
      */
    "set_theme" : function (theme_name, theme_url)
    {
       if (! theme_name)  {
         return false;
       }

       if (! theme_url)  {
          theme_url = this._data.themes._themes + theme_name + '/style.css';
       }

       if ($.inArray(theme_url, this._data.themes.themes_loaded) == -1)  {
         _addSheet({ url : theme_url });
         this._data.themes.themes_loaded.push(theme_url);
       }

       if (this._data.themes.theme != theme_name)  {
         this._$container.removeClass('oj-tree-' + this._data.themes.theme);
         this._data.themes.theme = theme_name;
       }

       this._$container.addClass('oj-tree-' + theme_name);

       if (! this._data.themes.dots) {
         this["hide_dots"]();
       }
       else  {
          this["show_dots"]();
       }

       if (! this._data.themes.icons)  {
         this["hide_icons"]();
       }
       else  {
         this["show_icons"]();
       }
 
       this._emitEvent(null, "set_theme");

    },


    /*
     *   Shows the hierarchy lines.  Not used in V1
     *   @private
     */
    "show_dots"  : function ()
    {
      this._data.themes.dots = true;
      this._$container.children("ul").removeClass("oj-tree-no-dots");
    },

    /*
     *   Hides the hierarchy lines.  Not used in V1
     *   @private
     */
    "hide_dots"   : function ()
    {
      this._data.themes.dots = false;
      this._$container.children("ul").addClass("oj-tree-no-dots");
    },

    /*
     *   Toggles the current hierarchy line state.  Not used in V1
     *   @private
     */
    "toggle_dots" : function ()
    {
       if (this._data.themes.dots) {
         this["hide_dots"]();
       }
       else  {
         this["show_dots"]();
       }
    },

    /*
     *   Returns true if node icons are currently displayed.  Users can find this state from options.
     *   @private
     */
    "isIcons"  : function ()
    {
       return this._data.themes.icons ;
    },


    /*
     *   Displays node icons. Users can set this state from options.
     *   @private
     */
    "show_icons"  : function ()
    {
       this._data.themes.icons = true;
       this._$container.children("ul").removeClass("oj-tree-no-icons");
    },

    /*
     *   Hides node icons. Users can set this state from options.
     *   @private
     */
    "hide_icons"  : function ()
    {
       this._data.themes.icons = false;
       this._$container.children("ul").addClass("oj-tree-no-icons");
    },

    /*
     *   Toggles the display state of node icons. User can set this state from options.
     *   @private
     */
    "toggle_icons" : function ()
    {
       if (this.data.themes.icons) {
         this["hide_icons"]();
       }
       else  {
         this["show_icons"]();
       }
    },

    /**
      *   Enables keyboard support
      *   @private
      */
    _enableKeys : function ()
    {
       this._data.keys.enabled = true;
    },

    /**
      *   Disables keyboard support
      *   @private
      */
    _disableKeys : function ()
    {
       this._data.keys.enabled = false;
    },


    /**
      *   Initializes the widget, examining options and setting up
      *   internal data structures.
      *   @private
      */
     _initTree : function()
     {
        this._initData() ;
        this._initCoreOpts() ;
        this._initUIOpts() ;
        this._initCrrmOpts() ;
        this._initThemeOpts()
        this._initDSOpts() ;
        this._initTypeOpts()
        this._initDnDOpts() ;
        this._initMenuOpts() ;

        this._initCore() ;
        this._initUI() ;
        this._initThemes() ;
        this._initDataSource() ;
//        this._initCrrm() ;
        this._initTypes() ;
        this._initDnD() ;
        this._initKeys() ;
        this._initMenu() ;

        this._start() ;
     },


     /**
       *   Emit events
       *   @param {Object} data an object containing details about the event.
       *   @param {string} eventname the raw event name (e.g. "select", or "expandAll".
       *                             When the event is fired, it is "ojselect" and "ojexpandall",
       *                             but also the options "select" and "expandAll" are called.
       *   @private
       */
     _emitEvent : function (data, eventname) 
     { 
        if ((! eventname) || $.type(eventname) !== "string"){
          return ;
        } 

        var rslt,
            func,
            args     = Array.prototype.slice.call(arguments),
            rlbk     = false,
            evname   = eventname,
            inst     = this._$container,
            isBefore = (eventname === "before"),
            isPublic = false,
            item ;

        if ((this._data.core.locked === true) && (eventname !== "unlock")
                                              && (eventname !== "isLocked")
                                              && (eventname !== "lock")) {
          return;
        }

        evname   =  _convertEventName(eventname) ;
        isPublic = _isPublicEvent(evname) ;
        if (! isPublic)  {
          evname = "tree" + evname ;        // internal event
        }

        item = (data? data["obj"] : undefined) ;
        if (evname === "loaded") {
          item = -1 ;
        }

        //  Trigger the event

        var eventdata = {} ;                       // build the "ui" argument
        eventdata["item"] = item ;
        eventdata["inst"] = inst ;

        if (isBefore) {
          func               = data["func"] ;      // target method
          eventdata["func"]  = func ;
          eventdata["args"]  = args ;
          if (func === "rename") {
            eventdata["title"]     = data["title"] ;
            eventdata["prevTitle"] = data["prevTitle"] ;
          }
        }
        else  if (isPublic) {
          if (evname == "move") {
            eventdata["position"]  = data.p ;      // position relative to the reference node
            eventdata["reference"] = data.r ;      // the reference node
            eventdata["data"]      = data ;        // (req'd internally)
          }
          else if (evname == "rename") {
            eventdata["title"]     = data["title"] ;      // the new node title to be
            eventdata["prevTitle"] = data["prevTitle"] ;  // the current title
          }
          else if (evname == "remove") {            // node was deleted via context menu
            eventdata["parent"]  = data["parent"] ; // parent node
            eventdata["prev"]    = data["prev"] ;   // the "previous" node
          }
          else if (evname == "delete") {            // node was deleted via context menu
            eventdata["prev"]   = data["prev"] ;    // (req'd internally) - the "previous" node
            eventdata["parent"] = data["parent"] ;  // parent node
          }
          else if (evname === "expandAll" || evname === "collapseAll" || evname === "deselectAll") {         
            eventdata["targ"]   = data["targ"] ;    // the target of the op (node or -1)
          }
        }

        // console.log("Event (" + eventname + ")  " + evname + " isPublic=" + isPublic +
        //                            (isBefore? (" isBefore=true - " + eventdata["func"]) : ""));

        if (isPublic) {
          rslt = this._trigger(evname, new $.Event("oj" + evname), eventdata) ;

          if (isBefore) {
            //  console.log("Event (" + eventname + ") " + eventdata["func"] + " returned " + rslt);
            if (typeof rslt != "undefined") {
              rslt = rslt? true : false ;         // returns true/false/undefined
            }
            return rslt ;
          }
        }
        else {
          this._$container.trigger(evname, eventdata) ;    // internal event
        }
        
     },


     /**
       *  TDO _not currently used in V1
       *  @private
       */
     __rollback : function ()
     { 
         var
         rlbk = this["get_rollback"]();
         return rlbk;
     },


     /**
       *   To Be Removed  TDO 
       *   @private
       */
     __call_old : function (replace_arguments)
     {
//       return func.old.apply(this, (replace_arguments ? Array.prototype.slice.call(arguments, 1) : args ) );
     },


     /*
      *  Tree initialization is complete.  Build and render the tree.
      *  @private
      */
     _start : function()
     {
       this.set_focus(); 

       if (this._isRtl) {
         this._$container.addClass("oj-tree-rtl").css("direction", "rtl");
       }

       //  Create the outer <ul> with a temporary <li> saying "Loading..."

       this._$container.html("<ul role='tree' tabindex='0' class='oj-tree-list' style='outline:none'" + 
                    ((this._data.core.selectMode === -1)? " aria-multiselectable='true'" : "") +
                    "><li class='oj-tree-last oj-tree-leaf'><ins>&#160;</ins><a class='oj-tree-loading' href='#'><ins class='oj-tree-icon'>&#160;</ins>" + this.getTranslatedString("m_loading") + "</a></li></ul>");

       this._$container_ul = this._$container.children("ul:eq(0)");
       this._$container.data("oj-tree-instance-id", this._getIndex());

       this._data.core.li_height = this._$container_ul.find("li.oj-tree-closed, li.oj-tree-leaf").eq(0).height() || 18;

       this._$container
              .delegate(".oj-tree-list li > ins", "click.ojtree", $.proxy(function (event)  {
                     var trgt = $(event.target);
                     // if(trgt.is("ins") && event.pageY - trgt.offset().top < this.data.core.li_height) { this.toggle_node(trgt); }
                     this["toggleExpand"](trgt);
                }, this))
              .bind("mousedown.ojtree", $.proxy(function ()  { 
                     this.set_focus(); // This used to be setTimeout(set_focus,0) - why?
                }, this))
              .bind("dblclick.ojtree", function (event)  { 
                     var sel;
                     if (document.selection && document.selection.empty) {
                       document.selection.empty();
                     }
                     else  {
                       if (window.getSelection)  {
                         sel = window.getSelection();
                         try { 
                               sel.removeAllRanges();
                               sel["collapse"](document.getElementsByTagName("body")[0], 0);
                             } catch (err) { }
                       }
                     }
                });
       this._$container_ul
               .focus($.proxy(function(e) {
                        this._data.ui.focused = true ;
                      }, this)
               )
               .blur($.proxy(function(e) {
                        this._data.ui.focused = false ;
                     }, this)
               );

       if (this._data.core.notify_plugins)  {          // TDO is it needed
         this._$container
             .bind("treeload_node", $.proxy(function (e, ui)  { 
                  var o = this._getNode(ui["item"]),
                      t = this;
                  if (o === -1)  {
                    o = this._$container_ul;
                  }
                  if (! o.length)  {
                    return;
                  }

                  o.find("li").each(function ()  {
                       var th = $(this);
                       if (th.data("oj-tree"))
                       {
                         $.each(/** @type {Array} */(th.data("oj-tree")), function (plugin, values)
//COD                    $.each(th.data("oj-tree"), function (plugin, values)
                            {
//Fri                          if (t.data[plugin] && $.isFunction(t["_" + plugin + "_notify"]))
//Sat22                        if (t["data"][plugin] && $.isFunction(t["_" + plugin + "_notify"]))
                               if (th["data"][plugin] && $.isFunction(t["_" + plugin + "_notify"]))   //TDO
                               {
                                 t["_" + plugin + "_notify"].call(t, th, values);
                               }
                            });
                       }
                  });

             }, this));
       }

       if (this._data.core.load_open)   {

         this._$container
            .bind("treeload_node", $.proxy(function (e, ui)  { 
                 var o = this._getNode(ui["item"]),
                     t = this;
                 if (o === -1)  {
                   o = this._$container_ul;
                 }
                 if (!o.length)  {
                   return;
                 }
                 o.find("li.oj-tree-open:not(:has(ul))").each(function ()
                     {
                        this._load_node(this, $.noop, $.noop);
                 });
            }, this));
       }

       this._emitEvent({}, "init");      // Tree is now init'd (but nodes have not yet been added)

       if (this._data.ds.type !== DS_NONE && this._data.ds.type !== DS_ERROR) {
         this._load_node(-1, function ()  {                  //  Construct and add the nodes
                               this._loaded();
                               this._reload_nodes();
                             });
       }
       else {
          this._applyEmptyText() ;     //  Use emptyText option if defined.
       }

       //  Tree div is now constructed, note if context menu has been set.
       if (this._data.menu.usermenu) {
         this._applyMenu() ;
       }

       // Add this tree's keyboard combination handler
       _addKeyFilter( {
                        _handler : this._keyHandler,
                        _selector: this._$container_ul,
                        _this    : this
                      }) ;
       this._enableKeys();
     },


     /*
      *  Initialize the Core section
      *  @private
      */ 
     _initCore : function()
     {
       this._data.core.locked   = false;

       this._$container.addClass("oj-tree oj-tree-" + this._getIndex()) ;     //TDO TDO

       this._$container.css("outline", "none");
       this._$container.css("MozUserSelect", "none");
       this._$container.css("WebkitTouchCallout", "none");
       this._$container.css("WebkitUserSelect", "none");
       this._$container.css("WebkitTapHighlightColor", "rgba(0,0,0,0)");
     },


    /*
     *  Initialize the UI section
     *  @private
     */
     _initUI : function() 
     {
         this._data.ui.selected      = $(); 
         this._data.ui.last_selected = false; 
         this._data.ui.hovered       = null;
//       this._data.ui.to_select     = this.options["initSelected"];  // removed per Design Review

        // Bind to events
        this._$container
             .delegate(".oj-tree-list a", "click.ojtree", $.proxy(function (event)
                {
                  event.preventDefault();
                  event.currentTarget.blur();
                  if (!$(event.currentTarget).hasClass("oj-tree-loading"))  {
                    this.set_focus();
                    this._select(event.currentTarget, true, event);
                  }
                }, this))
             .delegate(".oj-tree-list a", "mouseenter.ojtree", $.proxy(function (event)
                {
                  if (! $(event.currentTarget).hasClass("oj-tree-loading"))  {
                     this["hover"](event.target);
                  }
                }, this))
             .delegate(".oj-tree-list a", "mouseleave.ojtree", $.proxy(function (event)
               {
                  if (! $(event.currentTarget).hasClass("oj-tree-loading"))  {
                    this["dehover"](event.target);
                  }
               }, this))
             .bind("treereopen", $.proxy(function ()
               { 
                 this["reselect"]();
               }, this))
             .bind("treeget_rollback", $.proxy(function ()
               { 
                  this["dehover"]();
                  this["save_selected"]();
               }, this))
             .bind("treeset_rollback", $.proxy(function ()
               { 
                  this["reselect"]();
               }, this))
             .bind("ojcollapse", $.proxy(function (event, ui)
              { 
                var obj   = this._getNode(ui["item"]),
                    clk   = (obj && obj.length) ? obj.children("ul").find("a.oj-tree-clicked") : $(),
                    _this = this;
                if (this.options["selectedParentCollapse"] === false || (! clk.length))  {
                  return;
                }
                clk.each(function ()  { 
                               this["deselect"](this);
                               if (this.options["selectedParentCollapse"] === "selectParent")  {
                                  this["select"](obj);
                               }
                         });
                 }, this))
             .bind("ojremove", $.proxy(function (event, ui)         // node delete 
                { 
                   var s     = this.options["selectPrevOnDelete"],
                       obj   = this._getNode(ui["item"]),
                       clk   = (obj && obj.length) ? obj.find("a.oj-tree-clicked") : [],
                       _this = this;

                     clk.each(function ()
                                {
                                   _this["deselect"](this);
                                });
                     if (s && clk.length)
                     { 
                       ui["prev"].each(function ()
                          { 
//Wed3                      if(this.parentNode)
                            if (this["parentNode"])
                            {
                              _this["select"](this);
                              return false;   // if return false is removed all prev nodes will be selected 
                            }
                         });
                     }
                 }, this))
             .bind("ojmove", $.proxy(function (event, ui)
                { 
                   var data = ui["data"] ;
                   if (data["cy"])  { 
                     data["oc"].find("a.oj-tree-clicked").removeClass(OJT_CLICKED);
                     data["oc"].removeAttr(WA_SELECTED);
                   }
                 }, this));

     },

     /*
      *  Initialize the data source
      *  @private
      */
     _initDataSource : function()
     {
        this._initTreeData() ;
        this._initJsonData() ;
        this._initHtmlData() ;
     },

     /*
      *  Initialize the tree data source
      *  @private
      */
     _initTreeData : function()
     {
        if (this._data.ds.type === DS_TREE) {
          this._tds        = (this.options["data"] || null) ;     // the tree data source
          this._load_node  = this._load_node_DS ;
          this._is_loaded  = this._is_loaded_DS ;
          this._refresh    = this._refresh_DS ;
       }
     },

     /*
      *  Initialize the json_data section if requested
      *  @private
      */
     _initJsonData : function()
     {
        if (this._data.ds.type === DS_JSON) {
          if (this._data.ds.progressiveUnload)  {
            this._$container.bind("treeafter_close", function (e, ui)  {
                                     ui["item"].children("ul").remove();
                                   });
          }

          this._load_node  = this._load_node_J ;
          this._is_loaded  = this._is_loaded_J ;
          this._refresh    = this._refresh_json ;
        }
     },


     /**
       *  Initialize html_data support if requested.
       *  @private
       */
     _initHtmlData : function()
     {
       if (this._data.ds.type !== DS_HTML) {
         return ;
       }

       if (this._data.html.useExistingMarkup) {
         // this used to use html() and clean the whitespace, but this way any attached data was lost
         this._data.html.markup      = this._$container.find(" > ul > li");
         this._data.html.cloneMarkup = this._data.html.markup.clone(true);

         // remove white space from LI node - otherwise nodes appear a bit to the right
//         this._data.html.originalContainerHtml.find("li").addBack()
//                                                         .contents()
//                                                         .filter(function()
//                                                             {
//                                                                return this.nodeType == 3;
//                                                             }).remove();
         this._data.html.markup.find("li").addBack()
                                          .contents()
                                          .filter(function()
                                              {
                                                 return this.nodeType == 3;
                                              }).remove();
       }

       this._load_node = this._load_node_H ;
       this._is_loaded = this._is_loaded_H ;
       this._refresh   = this._refresh_ui ;
     },


     /*
      *  Initialize the Themes section   -  TDO replace with Jet functionality
      *  @private
      */
     _initThemes : function()
     {
        // autodetect themes path
        if (this._data.themes._themes === false)  {
           $("script").each(function ()
            { 
              if( this.src.toString().match(/jquery\.oj-tree[^\/]*?\.js(\?.*)?$/))  { 
                 this._data.themes._themes = this.src.toString().replace(/jquery\.oj-tree[^\/]*?\.js(\?.*)?$/, "") + 'themes/'; 
                 return false; 
              }
            });
        }
        if (this._data.themes._themes === false)    {
          this._data.themes._themes = "themes/";
        }

        this._$container
             .bind("treeinit", $.proxy(function ()
                {
                   var s = this.options ;

                   this._data.themes.dots  = s["dots"]; 
                   this._data.themes.icons = s["icons"]; 
                   this["set_theme"](this._data.themes.theme, this._data.themes.url);

                }, this))

             .bind("ojloaded", $.proxy(function ()
                {
                   // bound here too, as simple HTML tree's won't honor dots & icons otherwise
                   if (! this._data.themes.dots)  {
                     this["hide_dots"]();
                   }
                   else  {
                     this["show_dots"]();
                   }
                   if (!this._data.themes.icons)  {
                     this["hide_icons"]();
                   }
                   else  {
                     this["show_icons"]();
                   }
                }, this));

     },


     /*
      *  Initialize the icon type functionality
      *  @private
      */
     _initTypes : function()
     {
        var s = this.options["types"];
        if (! s) {
          return ;
        }

        this._$container
               .bind("treeinit", $.proxy(function ()
                  { 
                    var types     = $.extend(true, {}, s["types"]),
                        attr      = s["attr"] || this._data.types.defaults["attr"],
                        icons_css = "", 
                        _this     = this;

                    $.each(types, function (i, tp)
                       {
                         $.each(tp, function (k, v)
                            { 
                              if (!/^(maxDepth|maxChildren|icon|validChildren)$/.test(k))  {
                                _this._data.types.attachTo.push(k);
                              }
                            });

                         // For ojTree we allow image and position props to not
                         // have to be in an icon object like jsTree.
                         var ot = (typeof tp["icon"]) ;
                         if (ot === "undefined") {
                           ot = (typeof tp["image"]) ;
                           if ((ot === "boolean") && (!tp["image"])) {
                             tp["image"] = "ojt$none" ;
                           }
                           else if ((! tp["image"]) && (! tp["position"])) {
                             return true;
                           }

                           tp["icon"] = {} ;
                           if (tp["image"])  {
                             tp["icon"]["image"] = tp["image"]; 
                             delete tp["image"] ;
                           } 

                           if (tp["position"] !== undefined)  {
                             tp["icon"]["position"] = tp["position"] ;
                             delete tp["position"] ;
                           }
                         }    

                         if ( tp["icon"]["image"] || tp["icon"]["position"])  {
                           if (i == "default")  {
                             _this._data.types.defType = true ;     // note that the "default" type has been defined                             icons_css += '.oj-tree-' + _this._getIndex() + ' a > .oj-tree-icon { ';
                             icons_css += '.oj-tree-' + _this._getIndex() + ' .oj-tree-list a > .oj-tree-icon { ';
                             icons_css += _this._addTypeCss(tp, icons_css) ;
                             icons_css += '} ';
                             icons_css += '.oj-tree-' + _this._getIndex() + ' .oj-tree-list li[' + attr + '="oj-tree-deftype"] > a .oj-tree-icon { ';
                           }
                           else if (tp["icon"]["image"]) {
                             icons_css += '.oj-tree-' + _this._getIndex() + ' .oj-tree-list li[' + attr + '="' + i + '"] > a > ins.oj-tree-icon { ';
                           }

                           icons_css += _this._addTypeCss(tp, icons_css) ;
                           icons_css += '} ';
                         }
                    });

                    if (icons_css !== "")  {
                      _addSheet({ str : icons_css, title : "oj-tree-types" });
                    }
                   }, this))
               .bind("ojbefore", $.proxy(function (e, data)
                  { 
                     var s,
                         ty, 
                         func = data["func"],
                         item = data["item"],
                         o = this._data.types.defaults["useData"] ? this._getNode(item) : false, 
                         d = (o && o !== -1 && o.length)? o.data("oj-tree") : false;

                     if (d && d["types"] && d[func] === false)
                     {
                       e.stopImmediatePropagation();
                       return false;
                     }

                     if ($.inArray(func, this._data.types.attachTo) !== -1)  {
                       if (!data["item"] || (!data["item"]["tagName"] && !data["item"]["jquery"]))  {
                         return;
                       }
                       s   = this.options["types"]["types"];
                       ty  = this._getType(item);             // get "type" attr name for node

                       if (( (s[ty] && typeof s[ty][func] !== "undefined") || 
                             (s["default"] && typeof s["default"][func] !== "undefined") 
                            ) && this._check(func, item) === false)  {
                         e.stopImmediatePropagation();
                         return false;
                       }
                     }

                  }, this));
     },

     /**
       *  Add css for the type.
       *  @private
       */
     _addTypeCss : function(tp)
     {
         var css = "" ;

         if (tp["icon"]["image"] !== "ojt$none")  {
           css += ' background-image:url(' + tp["icon"]["image"] + '); ';
         }
         else  {
           css += " background-image:none; ";
         }

         if (tp["icon"]["position"])  {
           css += ' background-position:' + tp["icon"]["position"] + '; ';
         }
         else  {
           css += ' background-position:0 0; ';
         }
         return css ;
     },

     /*
      *  Initialize Drag and Drop functionality.  TDO - this will change when the JET support is available.
      *  @private
      */
     _initDnD : function()
     {
        if (! this._data.dnd.reorder) {          // only handling a temporary version
          return ;                               // of Dnd for reorder within the tree.
        }
  
        var vars = this._data.dnd.vars ;

        vars.m = $("<div />").addClass(OJT_MARKER).hide().html("&raquo;")   // dnd marker div
            .bind("mouseleave mouseenter", $.proxy(function (e) { 

                var vars = this._data.dnd.vars ;
                vars.m.hide();
                vars.ml.hide();
                e.preventDefault(); 
                e.stopImmediatePropagation(); 
                return false; 
            }, this))
            .appendTo("body");

        vars.ml = $("<div />").addClass(OJT_MARKER_LINE).hide()             // dnd marker line
            .bind("mouseup", function (e) { 

               var vars = this._data.dnd.vars ;

               if (vars.r && vars.r.length) { 
                  vars.r.children("a").trigger(e); 
                  e.preventDefault(); 
                  e.stopImmediatePropagation(); 
                  return false; 
               } 
            })
            .bind("mouseleave", $.proxy(function (e)  { 

                var vars = this._data.dnd.vars ;
                var rt = $(e.relatedTarget);

                if (rt.is(".oj-tree") || rt.closest(".oj-tree").length === 0) {
                    if (vars.r && vars.r.length) { 
                        vars.r.children("a").trigger(e); 
                        vars.m.hide();
                        vars.ml.hide();
                        e.preventDefault(); 
                        e.stopImmediatePropagation(); 
                        return false; 
                    }
                }
            }, this))
            .appendTo("body");

        $(document).bind("drag_start.ojtreeu", $.proxy(function (e, data)
            {
             var vars = this._data.dnd.vars ;

             if (data.data.jstree)  {
                vars.m.show();
                if (vars.ml)  {
                   vars.ml.show();
                 }
             }
           }, this));

        $(document).bind("drag_stop.ojtreeu", $.proxy(function (e, data)
           {
              var vars = this._data.dnd.vars ;

              if (data.data.jstree)  {
                vars.m.hide();
                if (vars.ml) {
                  vars.ml.hide();
                }
              }
           }, this));

        this._getContainer()
            .bind("mouseenter.ojtree", $.proxy(function (e)
                {
                  var  ctl  = this._data.dnd.ctl,
                       vars = this._data.dnd.vars ;

                  if (ctl.is_drag && ctl.user_data.jstree)  {
                    if (this.options["themes"]) {
                      vars.m.addClass("oj-tree-" + this._data.themes.theme); 
                      if (vars.ml) {
                        vars.ml.addClass("oj-tree-" + this._data.themes.theme);
                      }
                      ctl.helper.addClass("oj-tree-dnd-helper oj-tree-" + this._data.themes.theme);
                    }
                      //if($(e.currentTarget).find("> ul > li").length === 0) {
                    if (e.currentTarget === e.target && ctl.user_data.obj &&
                        $(ctl.user_data.obj).length && $(ctl.user_data.obj).parents(".oj-tree:eq(0)")[0] !== e.target)
                    {
                      // node should not be from the same tree
                      var tr = this._reference(e.target),   //TDO
                          dc;

                      if (tr.data.dnd.foreign) {
                        dc = tr.options["dnd"]["drag_check"].call(this, { "o" : vars.o, "r" : tr._getContainer(), "is_root" : true });
                         if (dc === true || dc["inside"] === true || dc["before"] === true || dc["after"] === true)  {
                           ctl.helper.children("ins").removeClass(OJT_DRAG_INVALID).addClass(OJT_DRAG_OK);
                         }
                      }
                      else {
                         tr._prepare_move(vars.o, tr._getContainer(), "last");
                         if (tr["check_move"]()) {
                           ctl.helper.children("ins").removeClass(OJT_DRAG_INVALID).addClass(OJT_DRAG_OK);
                         }
                      }
                    }
                  }
                 }, this))
            .bind("mouseup.ojtree", $.proxy(function (e)
               {
                  var vars = this._data.dnd.vars,
                      ctl = this._data.dnd.ctl ;       // jsTree helper class

                  if (ctl.is_drag && ctl.user_data.jstree && e.currentTarget === e.target  &&
                                     ctl.user_data.obj    && $(ctl.user_data.obj).length   &&
                                     $(ctl.user_data.obj).parents(".oj-tree:eq(0)")[0] !== e.target)
                  {  // node should not be from the same tree
                      var tr = this._reference(e["currentTarget"]),
                          dc;
                      if (tr["data"]["dnd"]["foreign"])  {
                        dc = tr._getOptions()["dnd"]["drag_check"].call(this, { "o" : vars.o, "r" : tr._getContainer(), "is_root" : true });
                        if (dc === true || dc["inside"] === true || dc["before"] === true || dc["after"] === true)
                        {
                           tr._getOptions()["dnd"]["drag_finish"].call(this, { "o" : vars.o, "r" : tr._getContainer(), "is_root" : true });
                        }
                      }
                      else  {
                         tr._move_node(vars.o, tr._getContainer(), "last", e[tr.options["dnd"]["copy_modifier"] + "Key"]);
                      }
                  }
                 }, this))
            .bind("mouseleave.ojtree", $.proxy(function (e)
               {
                  var ctl = this._data.dnd.ctl ;       // jsTree helper class

                  if (e.relatedTarget && $(e.relatedTarget).hasClass(OJT_MARKER_LINE))  {
                    return false; 
                  }
                  if (ctl.is_drag && ctl.user_data.jstree)  {
                    if (this._data.dnd.i1) {
                       clearInterval(this._data.dnd.i1);
                    }
                    if (this._data.dnd.i2) {
                      clearInterval(this._data.dnd.i2);
                    }
                    if (this._data.dnd.to1)  {
                      clearTimeout(this._data.dnd.to1);
                    }
                    if (this._data.dnd.to2) {
                      clearTimeout(this._data.dnd.to2);
                    }
                    if (ctl.helper.children("ins").hasClass(OJT_DRAG_OK))  {
                      ctl.helper.children("ins").removeClass(OJT_DRAG_OK).addClass(OJT_DRAG_INVALID);
                    }
                  }
                }, this))
            .bind("mousemove.ojtree", $.proxy(function (e)
               {
                  var ctl = this._data.dnd.ctl ;       // jsTree helper class

                  if (ctl.is_drag && ctl.user_data.jstree) {
                    var cnt = this._getContainer()[0];

                    // Horizontal scroll
                    if (e.pageX + 24 > this._data.dnd.cof.left + this._data.dnd.cw) {
                      if (this._data.dnd.i1) {
                        clearInterval(this._data.dnd.i1);
                      }
                      this._data.dnd.i1 = setInterval($.proxy(function () {
                                                   this.scrollLeft += ctl.scroll_spd;
                                                 }, cnt), 100);
                    }
                    else if (e.pageX - 24 < this._data.dnd.cof.left)  {
                      if (this._data.dnd.i1) {
                        clearInterval(this._data.dnd.i1);
                      }
                      this._data.dnd.i1 = setInterval($.proxy(function () {
                                                this.scrollLeft -= ctl.scroll_spd;
                                              }, cnt), 100);
                    }
                    else   {
                      if (this._data.dnd.i1)  {
                        clearInterval(this._data.dnd.i1);
                      }
                    }

                    // Vertical scroll
                    if (e.pageY + 24 > this._data.dnd.cof.top + this._data.dnd.ch)  {
                      if (this._data.dnd.i2)  {
                        clearInterval(this._data.dnd.i2);
                      }
                      this._data.dnd.i2 = setInterval($.proxy(function () {
                                                this.scrollTop += ctl.scroll_spd;
                                             }, cnt), 100);
                    }
                    else if (e.pageY - 24 < this._data.dnd.cof.top) {
                        if (this._data.dnd.i2)  {
                          clearInterval(this._data.dnd.i2);
                        }
                        this._data.dnd.i2 = setInterval($.proxy(function () {
                                                 this.scrollTop -= ctl.scroll_spd;
                                               }, cnt), 100);
                    }
                    else   {
                       if (this._data.dnd.i2) {
                         clearInterval(this._data.dnd.i2);
                       }
                    }

                  }
                }, this))
            .bind("scroll.ojtree", $.proxy(function (e)
               { 
                  var ctl  = this._data.dnd.ctl,        // jsTree helper class
                      vars = this._data.dnd.vars ; 

                  if (ctl.is_drag && ctl.user_data.jstree && vars.m && vars.ml)  {
                     vars.m.hide();
                     vars.ml.hide();
                  }
                }, this))
            .delegate(".oj-tree-list a", "mousedown.ojtree", $.proxy(function (e)
                { 
                  if (e.which === 1) {
                    this._start_drag(e.currentTarget, e);
                    return false;
                  }
                }, this))
            .delegate(".oj-tree-list a", "mouseenter.ojtree", $.proxy(function (e)
                { 
                  var ctl = this._data.dnd.ctl ;       // jsTree helper class

                  if (ctl.is_drag && ctl.user_data.jstree)  {
                    this._dnd_enter(e.currentTarget);
                  }
                }, this))
            .delegate(".oj-tree-list a", "mousemove.ojtree", $.proxy(function (e)
                { 
                  var  ctl  = this._data.dnd.ctl,       // jsTree helper class
                       vars = this._data.dnd.vars ;

                  if (ctl.is_drag && ctl.user_data.jstree)  {
                     if (! vars.r || ! vars.r.length || vars.r.children("a")[0] !== e.currentTarget) {
                         this._dnd_enter(e.currentTarget);
                     }
                     if (typeof this._data.dnd.off.top === "undefined") {
                       this._data.dnd.off = $(e.target).offset();
                     }
                     if (typeof this._data.dnd.off.top === "undefined")  {
                       this._data.dnd.off = $(e.target).offset();
                     }

                     this._data.dnd.w = (e.pageY - (this._data.dnd.off.top || 0)) % this._data.core.li_height ;

                     if (this._data.dnd.w < 0)   {
                       this._data.dnd.w += this._data.core.li_height;
                     }
                     this._dnd_show();
                  }
                }, this))
            .delegate(".oj-tree-list a", "mouseleave.ojtree", $.proxy(function (e)
                { 
                  var ctl  = this._data.dnd.ctl,        // jsTree helper class
                      vars = this._data.dnd.vars ;

                  if (ctl.is_drag && ctl.user_data.jstree)  {
                     if (e.relatedTarget && $(e.relatedTarget).hasClass(OJT_MARKER_LINE))  {
                       return false; 
                     }
                     if (vars.m) {
                        vars.m.hide();
                     }
                     if (vars.ml) {
                       vars.ml.hide();
                     }
                     /*
                     var ec = $(e.currentTarget).closest("li"), 
                         er = $(e.relatedTarget).closest("li");
                     if(er[0] !== ec.prev()[0] && er[0] !== ec.next()[0]) {
                         if(m) { m.hide(); }
                         if(ml) { ml.hide(); }
                     }
                     */

                     this._data.dnd.mto = setTimeout( (function (t) {
                                                         return function () {
                                                                   t._dnd_leave(e);
                                                                };
                                                       })(this), 0);
                  }
                }, this))
            .delegate(".oj-tree-list a", "mouseup.ojtree", $.proxy(function (e)
                { 
                  var ctl = this._data.dnd.ctl ;       // jsTree helper class

                  if (ctl.is_drag && ctl.user_data.jstree)  {
                    this._dnd_finish(e);
                  }
                }, this));

            $(document)
                .bind("drag_stop.ojtreeu", $.proxy(function ()
                   {
                     var dnd  = this._data.dnd,
                         vars = this._data.dnd.vars ;

                     if (dnd.to1) {
                       clearTimeout(dnd.to1);
                     }
                     if (dnd.to2) {
                       clearTimeout(dnd.to2);
                     }
                     if (dnd.i1)  {
                       clearInterval(dnd.i1);
                     }
                     if (dnd.i2)  {
                       clearInterval(dnd.i2);
                     }

                     dnd["after"]   = false;
                     dnd["before"]  = false;
                     dnd["inside"]  = false;
                     dnd.off        = false;
                     dnd.prepared   = false;
                     dnd.w          = false;
                     dnd.to1        = false;
                     dnd.to2        = false;
                     dnd.i1         = false;
                     dnd.i2         = false;
                     dnd.active     = false;
                     dnd.foreign    = false;

                     if (vars.m) {
                       vars.m.css({ "top" : "-2000px" });
                     }
                     if (vars.ml) {
                       vars.ml.css({ "top" : "-2000px" });
                     }
                   }, this))
                .bind("drag_start.ojtreeu", $.proxy(function (e, data)
                   {
                      if (data.data.jstree) { 
                        var et = $(data.event.target);
                        if (et.closest(".jstree").hasClass("oj-tree-" + this._getIndex())) {
                          this._dnd_enter(et);
                        }
                      }
                   }, this));

                /*
                .bind("keydown.jstree-" + this.get_index() + " keyup.jstree-" + this.get_index(), $.proxy(function(e) {
                        if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree && !this.data.dnd.foreign) {
                            var h = $.vakata.dnd.helper.children("ins");
                            if(e[this._get_settings().dnd.copy_modifier + "Key"] && h.hasClass("jstree-ok")) {
                                h.parent().html(h.parent().html().replace(/ \(Copy\)$/, "") + " (Copy)");
                            } 
                            else {
                                h.parent().html(h.parent().html().replace(/ \(Copy\)$/, ""));
                            }
                        }
                    }, this)); */



            var s = this.options["dnd"];
            if (s["drag_target"])
            {
               $(document)
                   .delegate(s["drag_target"], "mousedown.ojtree-" + this._getIndex(), $.proxy(function (e) {

                       var ctl  = this._data.dnd.ctl,
                           dnd  = this._data.dnd,
                           vars = this._data.dnd.vars ;

                       vars.o = e.target;

                       this._drag_start(e, { jstree : true,
                                             obj    : e.target
                                         }, "<ins class='oj-tree-icon'></ins>" + $(e.target).text());
                       if (this._data.themes) { 
                         if (vars.m) {
                            vars.m.addClass("oj-tree-" + this._data.themes.theme);
                         }
                         if (vars.ml) {
                           vars.ml.addClass("oj-tree-" + this._data.themes.theme);
                         }
                         ctl.helper.addClass("oj-tree-dnd-helper oj-tree-" + this._data.themes.theme); 
                       }

                       ctl.helper.children("ins").removeClass(OJT_DRAG_OK).addClass(OJT_DRAG_INVALID);

                       var cnt     = this._getContainer();
                       dnd.cof     = cnt.offset();
                       dnd.cw      = parseInt(cnt.width(),10);
                       dnd.ch      = parseInt(cnt.height(),10);
                       dnd.foreign = true;
                       e.preventDefault();
                   }, this));
            }

            if (s["drop_target"])
            {
                $(document)
                    .delegate(s["drop_target"], "mouseenter.ojtreex-" + this._getIndex(), $.proxy(function (e)
                         {
                           var dnd  = this._data.dnd,
                               vars = this._data.dnd.vars ;

                           if (dnd.active && this.options["dnd"]["drop_check"].call(this, { "o" : vars.o, "r" : $(e.target), "e" : e }))  {
                              dnd.ctl.helper.children("ins").removeClass(OJT_DRAG_INVALID).addClass(OJT_DRAG_OK);
                            }
                        }, this))
                    .delegate(s["drop_target"], "mouseleave.ojtree-" + this._getIndex(), $.proxy(function (e)
                        {
                           if (this._data.dnd.active)  {
                             this._data.dnd.ctl.helper.children("ins").removeClass(OJT_DRAG_OK).addClass(OJT_DRAG_INVALID);
                            }
                        }, this))
                    .delegate(s["drop_target"], "mouseup.ojtreex-" + this._getIndex(), $.proxy(function (e)
                       {
                         var vars = this._data.dnd.vars ;

                         if (this._data.dnd.active && this._data.dnd.ctl.helper.children("ins").hasClass(OJT_DRAG_OK))  {
                           this.options["dnd"]["drop_finish"].call(this, { "o" : vars.o, "r" : $(e.target), "e" : e });
                         }
                        }, this));
            }

          // TDO

     },


     /**
       *  Process Drag and Drop options.
       *  @private
       */
     _initDnDOpts : function()
     {
        var opts = this.options["dnd"],
            ot   = typeof opts ;

        if (ot !== "undefined")  {
          if (ot === "boolean"  && opts) {
              this._data.dnd.reorder = true ;
          }
          else if (ot === "object") {
            if (typeof opts["reorder"] === "boolean")  {
              this._data.dnd.reorder = opts["reorder"] ;
            }
          }
          else if (ot == "string" && opts == "reorder") {
              this._data.dnd.reorder = true ;
          }

          if (this._data.dnd.reorder) {
            //  Add our default requirements until these are made public and can be
            //  defined in options.
            this.options["dnd"] = {} ;
            this._applyDefaults(this.options["dnd"], this._data.dnd.defaults) ;
          }
        }

     },


     /*
      *  Initialize the context menu cut/copy/paste/remove/rename support.
      *  @private
      */
     _initCrrm :  function()
     {
        this._$container
                .bind("ojmove",
                     $.proxy(function (e, data)
                               {
                                 //if (this.options["crrm"]["move"]["openOnMove"])
                                 if (this._data.crrm.defaults["move"]["openOnMove"]) {
                                   var t = this;
/*  Tue4
                                   data.rslt.np.parentsUntil(".oj-tree").addBack()
                                                                        .filter(".oj-tree-closed")
                                                                        .each(function ()
                                                                          {
                                                                           t["expand"](this, false, true);
                                                                          });
*/  //Tue4
                                 }
                               }, this));

     },


     /**
       *  Initialize keyboard support
       *  @private
       */
     _initKeys  :  function()
     {
        //  HotKeys plugin no longer used.
/*
        this._$container()
               .bind("treelock", $.proxy(function ()
                  {
                    if (this._data.hotkeys.enabled)  {
                      this._data.hotkeys.enabled = false;
                      this._data.hotkeys.revert  = true;
                    }
                  }, this))
               .bind("treeunlock", $.proxy(function () 
                  {
                    if (this._data.hotkeys.revert)  {
                      this._data.hotkeys.enabled = true;
                    }
                  }, this));
*/
     },


     /**
       *  Initialize the context menu.  This is called on startup, or on option
       *  "contextMenu" change.
       *  @param {Object=} newVal   true if called because of an option change.
       *  @private
       */
     _initMenu : function(newVal)
     {
       var  menu, t, html, $html ;

       if ((! newVal) && (! this.options["contextMenu"])) {
         return ;
       }

       menu =  newVal || this.options["contextMenu"] ;
       t = $.type(menu) ;
       if (t == "function") {
         try {
            menu = menu() ;             // call user's method to get the context menu
         }
         catch (e) {
            menu = null;
         }
         t = $.type(menu) ;
       }

       if (t !== "string") {
         return ;      // unknown
       }

       var $m = $(menu) ;                    // get the user's <ul> list   
       if ($m) {
         $m.css("display", "none") ;         // ensure it's not visible
         var  dm       = this._data.menu ;
         dm.$container = $m ;
         dm.usermenu   = true ;              // have a context menu
       }
       
       if (this._data.menu.usermenu) {       // if we have a context menu
         if (newVal) {                       // and it is it being changed
           this._applyMenu() ;               // complete menu creation/attachnment
         }
       }

       //  If not a new val from options, Menu will be noted at the end of initialization in _start()
     },


     /**
       *  Note the tree node that the menu has just been activated on.  Also note
       *  the associated Tree Id in case the app has multiple Tree's and is
       *  sharing a context menu with all of them.
       *  @private
       */
     _handleContextMenuBeforeShow: function(e, ui)
     {
        var ev = e['originalEvent']['originalEvent'];

        if (ev['type'] === 'keydown') {
          this._data.menu.node   = this._data.ui.hovered ;
        }
        else  {
           this._data.menu.node  = $(e.originalEvent.target.parentNode) ;
        }
        this._data.menu.treeDivId = this._data.menu.node.closest("div").attr("id") ;

        this._data.menu.$container.ojMenu("option", "menuPosition", {"my" : "left top",
                                                                     "at" : "left bottom",
                                                                     "of" : this._data.menu.node[0]});

        // Set menu "Paste" disable state, depending on whether there's been a
        // previous "cut"/"copy"
        if (this._data.menu.usermenu && this._data.menu.$elemPaste) {

          var state         = this._data.menu.$elemPaste.hasClass("oj-disabled") ;
          var disabledState = (! this._data.crrm.ct_nodes && !this._data.crrm.cp_nodes) ;

          if (! state) {
            state = false ;      // in case undefined
          }
          if (state != disabledState) {
            if (disabledState) {
              this._data.menu.$elemPaste.addClass("oj-disabled") ;
            }
            else {
              this._data.menu.$elemPaste.removeClass("oj-disabled") ;
            }
            this._data.menu.$container.ojMenu("refresh") ;
          }
        }

     },

     /**
       *   Check menu selected to see if it one of our predefined remove/cut/copy/paste id's
       *   @private
       */
     _handleContextMenuSelect: function(ev, ui)
     {
        //  Make sure its a menu ojselect and not from ojTree
        if (ui["inst"]) {
          return ;
        }

        // There may be multiple trees sharing (and thereby listening to) the same 
        // context menu.  Check that this tree is the same as the tree on which the
        // menu was invoked on.
        if (this._data.menu.treeDivId != this._elemId.substr(1)) {
          return ;
        }

        var  id = ui? ui.item.attr("id") : undefined ;

        if (id === "ojtreecopy") {
          this._crrm_copy(this._data.menu.node);
        }
        else if (id === "ojtreecut") {
          this._crrm_cut(this._data.menu.node);
        }
        else if (id === "ojtreepaste") {
          this._crrm_paste(this._data.menu.node);
        }
        else if (id === "ojtreeremove") {
          if (this["isSelected"](this._data.menu.node)) {
            this._crrm_remove();
          }
          else {
           this._crrm_remove(this._data.menu.node);
          }
        }
        else if (id === "ojtreerename") {
          this._crrm_rename(this._data.menu.node);
        }
        else if (id === "ojtreecreate") {
          this._crrm_create(this._data.menu.node);
        }
     },

     /*
       *  Ensure that focus returns to the tree if the menu is dismissed in
       *  some way via the keyboard.  This is temporary and is awaiting the general
       *  proposal from Pavitra re each component having a .focus() method.
       */
     _showContextMenu: function(menu, event)
     {
       menu.show(event, {"launcher": this._$container_ul, "focus": "menu"});
     },


     /**
       *  Process Core options
       *  @private
       */
     _initCoreOpts : function()
     {
        var val = this.options["selectionMode"] ;

        val = (val == undefined)? "single" : val ;
        if (val === "none") {
          val = 0 ;
        }
        else if (val === "single") {
          val = 1;
        }
        else if (val === "multiple") {
          val = -1 ;
        }
        this._data.core.selectMode = val ;

        this._data.themes.icons = this.options["icons"] ;

        this._data.core.toExpand = this.options["initExpanded"];  
        if (this._data.core.toExpand == null) {
          this._data.core.toExpand = [] ;
        }
        this._data.core.toLoad   = this.options["initLoaded"];
     },


     /**
       *  Process UI type options
       *  @private
       */
     _initUIOpts : function()
     {
     },

     /**
       *  Process data source options
       *  @private
       */
     _initDSOpts : function()
     {
        var s = this.options["data"],
            dt,
            ot ;

        this._data.ds.type = DS_NONE ;               // clear in case this is a "data" option change
        this._data.html.useExistingMarkup = false ;

        if (s) {
          ot = $.type(s) ;
          if (ot === "string") {
           if (this._isHtml(s)) {
             this._data.ds.type = DS_HTML ;          // we have an non-Tree DS html source
           }
           else {
             this._data.ds.type = DS_JSON ;          // we have a non-tree DS json source
             this._initJsonOpts() ;
           }
          }
          else if (ot === "array") {
             //  we have an array of local json objects
             this._data.ds.type = DS_JSON ;           // we have a non-tree DS json source
          }
          else if (ot === "object") { 
             try
             {                                           // don't crash if no ojdatacollection-common
               if (s instanceof oj.JsonTreeDataSource) {
                 this._data.ds.type = DS_TREE ;          // we have a tree DS source
               }
             }
             catch(e)
             {
                this._data.ds.type = DS_ERROR
             } ;
             if (this._data.ds.type !== DS_TREE) {
               try
               {                                         // don't crash if no ojtree-model
                  if (s instanceof oj.CollectionTreeDataSource) {
                    this._data.ds.type = DS_COLLECTION ;   // we have a tree DS source
                  }
               }
               catch(e)
               {
                  this._data.ds.type = DS_ERROR
               } ;
             }
             if ((this._data.ds.type === DS_TREE)   ||
                 (this._data.ds.type === DS_COLLECTION))  {
               this._initTreeDSOpts() ;
             }
             else {
               if (s["data"] || s["ajax"])  {
                 dt = s["dataType"] ;
                 if (dt) {
                   if (dt === "json") {
                     this._data.ds.type = DS_JSON ;    // we have a non-tree DS json source
                     this._initJsonOpts() ;
                   }
                   else if (dt === "html") {
                     this._data.ds.type = DS_HTML ;    // we have a non-tree DS html source
                     this._initHtmlOpts() ;
                   }
                 }
                 else {
                   s["dataType"]      = "json" ;
                   this._data.ds.type = DS_JSON ;      // we have a non-tree DS json source
                   this._initJsonOpts() ;
                 }
               }
             }
          }
        }

        //  If no data defined, see if there is user markup in the div
        if (this._data.ds.type == DS_NONE) {
          if (this._$container.find("ul").length > 0) {
            this._data.ds.type                = DS_HTML ; // note we have an non-Tree DS html source
            this._data.html.useExistingMarkup = true ;
          }
        }
     },

     /**
       *  Process Tree DataSource options
       *  @private
       */
     _initTreeDSOpts : function()
     {
     },

     /**
       *  Process json_data options
       *  @private
       */
     _initJsonOpts : function()
     {
     },


     /**
       *  Process html_data options
       *  @private
       */
     _initHtmlOpts : function()
     {
     },

     /**
       *  Process cut/copy/paste/rename/remove options
       *  @private
       */
     _initCrrmOpts : function()
     {
       //if (this.options["crrm"] == undefined)  {
         //  Will use our defaults until these are made public and can be
         //  defined in options.
         //  this._applyDefaults(this.options["crrm"], this._data.crrm.defaults) ;
       //}

     },

     /**
       *  Process context menu options
       *  @private
       */
     _initMenuOpts : function()
     {
     },

     /**
       *  Process theme options
       *  @private
       */
     _initThemeOpts : function()
     {
       //  Themes support not yet published
     },


     /**
       *  Process node type options
       *  @private
       */
     _initTypeOpts  : function()
     {
       var opts ;
       var o = this.options["types"] ;

//     For V1, there are no default options that we publish
//     if (typeof o === "object") {
//       //  Add our default requirements until these are made public and can be
//       //  defined in options.
//       this._applyDefaults(this["options"]["types"], this._data.types.defaults) ;
//     }
       if (typeof o === "object") {
         this._applyDefaults(o, {"attr" : this._data.types.defaults["attr"]}) ;
       }
     },


     /**
       *  Set up tree instance data
       *  @private
       */
     _initData : function()
     {
        //  Establish working values, and define default values

        var data = this._data ;
         
        //  Core
        data.core  =  {
                        htmlTitles     : false,      // this option not currently exposed
                        initLoaded     : [],
                        selectMode     : 1,          //  0, 1, 2 ... or -1 for unlimited
                        load_open      : false,
                        li_height      : 0,
                        notify_plugins : true,       // TDO is it needed, this is jstree default
                        toExpand       : false,
                        toLoad         : false,
                        prepared_move  : {}          // for the move_node function
                      };

        // UI
        data.ui =  {
                      selected          :  $(),       // selected node jquery list
                      last_selected     :  false,
                      hovered           :  null,
                      to_select         :  null,      // removed per Design Review
                      opacity           : 1,          // used by disable/_lock()
                      spacebar          : false,      // true if select caused by keybd (toggles)
                      focused           : false       // tree has focus
                   };

        data.ui.defaults = {                          // default values not yet published or suppressed
                                                      // design committee 
                             "selectMultipleModifier"  :  "ctrl" ,      // on, or ctrl, shift, alt
                             "selectRangeModifier"     :  "shift" ,
                             "disableSelectingChildren" :  false
                           } ;


        //  Creating/renaming/removing/moving via context menu

        data.crrm = {} ;
        data.crrm.cp_nodes = false;     // nodes that have been copy'd
        data.crrm.ct_nodes = false;     // node(s) that have been cut
        data.crrm.defaults = {
                               "inputWidthLimit" : 200,
                               "move"            : {
                                                     "alwaysCopy"       : false, // false, true or "multitree"
                                                     "openOnMove"       : true,
                                                     "defaultPosition"  : "last",
                                                     "checkMove"        : function (m) {
                                                                             return true;
                                                                          }
                                                   }
                             };
        data.crrm.prepared_move = {} ;   // for the move node function

        // Data Source

        data.ds = {} ;
        data.ds.progressiveRender = false ;       // options not currently exposed
        data.ds.progressiveUnload = false ;
        data.ds.correctState      = true ;

        data.ds.type              = DS_NONE ;     // type of data source (DS_TREE, DS_JSON, DS_HTML)

        //  json data source

        data.json = {} ;
        data.json.defaults = {
                               "data"  : false,   // `data` can be a function:
                                                  //  accepts two arguments - node being loaded
                                                  //  and a callback to pass the result to,
                                                  //  & ajax won't be supported
                               "ajax"  : false
                             } ;

        // html data source

       data.html = {} ;
       data.html.defaults = {
                              "data"   : false,   // `data` can be a function:
                              "ajax"   : false
                            };

       data.html.useExistingMarkup  = false ;  // true == use existing div markup
       data.html.markup             = false ;  // the user's markup 
       data.html.cloneMarkup        = false ;  // clone of user's orig markup

        //  Themes

        data.themes       = {} ;
        data.themes.icons = true ;
        data.themes.dots  = false ;
        data.themes.theme = "default" ;
        data.themes.url   = false ;

        data.themes.themes_loaded = [];
        data.themes._themes = false;   //  path to themes folder - if false - it will be autodetected

        //  Types

        data.types           = {} ;
        data.types.attachTo  = [];
        data.types.defType   = false ;                    // true if "default" type defined
        data.types.defaults  = {                                 //  Options not published in V1
                                 "maxChildren"         : -1,     // defines max number of root nodes
                                                                 // (-1 = unlimited, -2 = disable maxChildren checking)
                                 "maxDepth"            : -1,     //  maximum depth of the tree
                                 "validChildren"       : "all",  // defines valid node types for the root nodes
                                 "useData"             : false,  // whether to use $.data     TDO
                                 "attr"                : "type", // attr name in <li> where type is stored
                                 "types" : {                     // a list of types
                                             "default" : {       // the default type
                                                           "maxChildren"   : -1,
                                                           "maxDepth"      : -1,
                                                           "validChildren" : "all"
                                       
                                                           // Bound functions - you can bind any other function here
                                                           // (using boolean or function)
                                                           //"select_node" : true
                                                         }
                                           }
                               } ;

        //  Context menu

        data.menu              = {} ;
        data.menu.usermenu     = false ;   // user has supplied an ojMenu id if true
        data.menu.$container   = false ;   // the menu <ul>
        data.menu.$elemPaste   = false ;   // the menu "Paste" element
        data.menu.node         = false ;   // the tree node the menu was activated on


        //  Keyboard support

        data.keys         = {} ;
        data.keys.enabled = true ;
        data.keys.bound   = [];

        // Drag and Drop

        data.dnd            = {} ;
        data.dnd.reorder    = false ;

        data.dnd.active     = false ;
        data.dnd["after"]   = false ;
        data.dnd["inside"]  = false ;
        data.dnd["before"]  = false ;
        data.dnd.off        = false ;
        data.dnd.prepared   = false ;
        data.dnd.w          = 0,
        data.dnd.to1        = false ;
        data.dnd.to2        = false ;
        data.dnd.cof        = false ;
        data.dnd.cw         = false ;
        data.dnd.ch         = false ;
        data.dnd.i1         = false ;
        data.dnd.i2         = false ;
        data.dnd.mto        = false ;
  
        data.dnd.defaults = {
                              "copy_modifier"  : "ctrl",
                              "check_timeout"  : 100,
                              "open_timeout"   : 500,
                              "drop_target"    : ".oj-tree-drop",
                              "drop_check"     : function (data) { return true; },
                              "drop_finish"    : $.noop,
                              "drag_target"    : ".oj-tree-draggable",
                              "drag_finish"    : $.noop,
                              "drag_check"     : function (data)
                                                  {
                                                     return {
                                                              "after"  : false,
                                                              "before" : false,
                                                              "inside" : true
                                                            };
                                                  }
                            } ;


        data.dnd.vars          = {}
        data.dnd.vars.o        = false ;
        data.dnd.vars.r        = false ;
        data.dnd.vars.m        = false ;     // marker pointer div
        data.dnd.vars.ml       = false ;     // marker line div
        data.dnd.vars.sli      = undefined ;
        data.dnd.vars.sti      = undefined ;
        data.dnd.vars.dir1     = false ;
        data.dnd.vars.dir2     = false ;
        data.dnd.vars.last_pos = false ;

        data.dnd.ctl             = {} ;      //  this was the old ojtreeu helper
        data.dnd.ctl.is_down     = false,
        data.dnd.ctl.is_drag     = false,
        data.dnd.ctl.helper      = false,
        data.dnd.ctl.scroll_spd  = 10,
        data.dnd.ctl.init_x      = 0,
        data.dnd.ctl.init_y      = 0,
        data.dnd.ctl.threshold   = 5,
        data.dnd.ctl.helper_left = 5,
        data.dnd.ctl.helper_top  = 10,
        data.dnd.ctl.user_data   = {}
     },

     /**
       *  @private
       */
     _fix_scroll : function (obj)
     {
        var c = this._$container[0],
            t;
       
       if (c.scrollHeight > c.offsetHeight)
       {
          obj = this._getNode(obj);
          if (!obj || obj === -1 || !obj.length || !obj.is(":visible"))  {
             return;
          }

          t = obj.offset().top - this._$container.offset().top;

          if (t < 0)  { 
            c.scrollTop = c.scrollTop + t - 1; 
          }

         if (t + this._data.core.li_height + (c.scrollWidth > c.offsetWidth ? scrollbar_width : 0) > c.offsetHeight)  { 
           c.scrollTop = c.scrollTop + (t - c.offsetHeight + this._data.core.li_height + 1 + (c.scrollWidth > c.offsetWidth ? scrollbar_width : 0)); 
          }
       }
     },

     /**
       *  @private
       */
     set_focus   : function ()            // undocumented per Design Review
     { 
       if (this._isFocused()) {
          return;
       }
       var f = this._focused();
       if (f) {
         this.unset_focus();
       }
           
       this._$container.addClass("oj-tree-focused"); 
       if (this._$container_ul) {
         this._$container_ul.focus() ;
       }
       this._data.ui.focused = true ;
       this._emitEvent(null, "set_focus");
     },

     /**
       *  Return true if this tree has focus.
       *  @private
       */
     _isFocused  : function ()            // undocumented per Design Review
     { 
        return this._data.ui.focused ;
     },

     /**
       *  @private
       */
     unset_focus : function ()            // undocumented per Design Review
     {
        if (this._isFocused()) {
          this._$container.removeClass("oj-tree-focused"); 
          this._data.ui.focused = false ;
          if (this._$container_ul) {
            this._$container_ul.blur() ;
          }
        }
        this._emitEvent(null, "unset_focus");
      },

     /**
       *  Return the "this of the tree that currently has focus, or null.
       *  @private
       */
     _focused : function ()
     {
        var ret = null ;
        $.each(_aInstances, function(i, _this) {
            if (_this._data.ui.focused) {
              ret = _this ;
              return false ;
            }
        });

        return ret ;
     },

     /**
       *  Returns the next instance index to use.
       *  @private
       */
     _newIndex: function()
     {
       return ++_instance
     },

     /**
       *  Returns the current instance index.
       *  @private
       */
     _getIndex : function()
     {
        return this._index ;
     },

     /**
       *  Returns a copy of the options.
       *  @private
       */
     _getOptions : function()
     {
        return ($.extend(true, {}, this.options)) ;
     },

     /**
       *  Returns the tree containig div
       *  #private
       */ 
     _getContainer : function()
     {
        return this._$container ;
     },

     /**
       *   Handle keystroke and combination keystrokes.
       *   The return value is passed to the jQuery keydown handler.
       *   @private
       */
     _keyHandler : {

         "up" : function ()
         { 
            var o = this._data.ui.hovered || this._data.ui.last_selected || -1;
            this["hover"](this._getPrev(o));
            return false; 
         },

         "ctrl+up" : function ()
         { 
            var o = this._data.ui.hovered || this._data.ui.last_selected || -1;
            this["hover"](this._getPrev(o));
            return false; 
         },

         "shift+up" : function (t)
         { 
            var o = this._data.ui.hovered || this._data.ui.last_selected || -1;
            this["select"](this._getPrev(o), (this._data.ui.selectMode !== -1));
            return false; 
         },

         "down" : function ()
         { 
            var o = this._data.ui.hovered || this._data.ui.last_selected || -1;
            this["hover"](this._getNext(o));
            return false;
         },

         "ctrl+down" : function ()
         { 
            var o = this._data.ui.hovered || this._data.ui.last_selected || -1;
            this["hover"](this._getNext(o));
            return false;
         },

         "shift+down" : function ()
         { 
           var o = this._data.ui.hovered || this._data.ui.last_selected || -1;
           this["select"](this._getNext(o), (this._data.ui.selectMode !== -1));
           return false;
         },

         "left" : function ()
         { 
            var o = this._data.ui.hovered || this._data.ui.last_selected;
            if (o) {
              if (o.hasClass(OJT_OPEN))  {
                this["collapse"](o);
              }
              else  {
                this["hover"](this._getPrev(o));
              }
            }
            return false;
         },

         "ctrl+left" : function ()
         { 
           var o = this._data.ui.hovered || this._data.ui.last_selected;
           if (o)  {
             if (o.hasClass(OJT_OPEN))  {
                this["collapse"](o);
             }
             else  {
               this["hover"](this._getPrev(o));
             }
           }
           return false;
         },

         "shift+left" : function ()
         { 
           var o = this._data.ui.hovered || this._data.ui.last_selected;
            if (o) {
              if (o.hasClass(OJT_OPEN)) {
                this["collapse"](o);
              }
              else  {
                this["hover"](this._getPrev(o));
              }
            }
            return false;
         },

         "right" : function ()
         { 
            var o = this._data.ui.hovered || this._data.ui.last_selected;
            if (o && o.length) {
               if (o.hasClass(OJT_CLOSED))  {
                  this["expand"](o);
               }
               else  {
                  this["hover"](this._getNext(o));
               }
            }
            return false;
         },

         "ctrl+right" : function ()
         { 
            var o = this._data.ui.hovered || this._data.ui.last_selected;
            if (o && o.length) {
               if (o.hasClass(OJT_CLOSED)) {
                 this["expand"](o);
               }
               else   {
                 this["hover"](this._getNext(o));
               }
            }
            return false;
         },

         "shift+right" : function ()
         { 
            var o = this._data.ui.hovered || this._data.ui.last_selected;
            if (o && o.length) {
              if (o.hasClass(OJT_CLOSED))  {
                this["expand"](o);
              }
              else  {
                this["hover"](this._getNext(o));
              }
            }
            return false;
         },

         "space" : function ()              // toggle hovered node select status
         { 
            if (this._data.ui.hovered)  {
              this._data.ui.spacebar = true ;      // note keyboard - so click will toggle
              this._data.ui.hovered.children("a:eq(0)").click();
              this._data.ui.spacebar = false ;
            } 
            return false; 
         },

         "home" : function ()               // move hover to top node
         { 
           this["hover"](this._$container_ul.find("li:first"));
           return false; 
         },

         "end" : function ()                // move hover to last visible node
         { 
           var a = this._$container_ul.find("li.oj-tree-last:visible");
           this["hover"](a[a.length-1]) ;
           return false; 
         },

         "*" : function ()                  // expand all nodes
         { 
           var l = this._$container_ul.find("a") ;
           this._expandAll(-1, false) ;
           return false; 
         },

         "ctrl+space" : function (event)    // toggle the select state
         { 
           if (this._data.ui.hovered)  { 
             var ev = $.Event("click") ;
             ev.ctrlKey = true;
             this._data.ui.hovered.children("a:eq(0)").trigger(ev);
           } 
           return false; 
         },

         "shift+space" : function (event)   // select to the hovered node
         { 
           if (this._data.ui.hovered)  {
             var ev = $.Event("click") ;
             ev.shiftKey = true;
             this._data.ui.hovered.children("a:eq(0)").trigger(ev);
           } 
           return false; 
         },

         "shift+home" : function (event)   // extend selection to top node
         { 
           var hover  = this._data.ui.hovered;

           if (hover)  {
             var bContinue  = true,
                 _this      = this,
                 nodes      = this._$container_ul.find("li:visible");

             hover = hover[0] ;
             $.each(nodes, function(i, node) {
                  if (node == hover) {
                    bContinue = false ;
                  }
                  _this._select(node, true) ; 
                  return bContinue ;
             });
           } 
           return false; 
         },

         "shift+pgdn" : function (event)   // extend selection to last node
         { 
           var hover  = this._data.ui.hovered;
           if (hover)  {
             var bFound = false,
                 _this  = this,
                 l      = this._$container_ul.find("li:visible");

             hover = hover[0] ;
             $.each(l, function(i, node) {
                if (! bFound) {
                  if (node == hover) {
                    bFound = true ;
                  }
                }
                if (bFound) {
                  _this._select(node, true) ; 
                }
                return true ;
             });
           } 
           return false; 
         },

         "f2" : function ()
         {
           this["rename"](this._data.ui.hovered || this._data.ui.last_selected);
           return false ;
         },

         "del" : function ()
         {
           this["remove"](this._data.ui.hovered || this._getNode(null));
           return false ;
         }
     },

     /**
       *   Attach the user menu <ul> list to the tree div, and set up listeners on it.
       *   @private
       */
     _applyMenu : function()
     {
       if (! this._data.menu.usermenu) {
         return ;
       }

       // Add our listeners so that we can handle build-in cut/copy/paste, etc
       var $menuContainer = this._data.menu.$container ;
       var _this          = this ;

       $menuContainer.on("ojselect",     $.proxy(this._handleContextMenuSelect,     this));
       $menuContainer.on("ojbeforeshow", $.proxy(this._handleContextMenuBeforeShow, this));

       // If there are any ojTree built in menu item ids, construct the menu items
       var listItems = $menuContainer.find("[data-oj-command]");
       var bChanged  = false ;

       listItems.each(function()  {
              var cmd;
              if ($(this).children('a').length === 0)  {
                cmd = $(this).attr('data-oj-command').split("-");
                $(this).replaceWith(_this._buildContextMenuItem(cmd[cmd.length-1]));
                if ($(this).hasClass("oj-menu-divider")) {
                  $(this).removeClass("oj-menu-divider")
                  $(this).addClass("oj-menu-item")
                }
                bChanged = true ;
              }
          });

       if (bChanged) {
         $menuContainer.ojMenu('refresh');
       }

       //  Note "paste" element for disabling if no prev cut/copy
       this._data.menu.$elemPaste = $menuContainer.find("#ojtreepaste") ;
       
     },

     /**
       *  Clear out any contextMenu data.
       *  @private
       */
     _clearMenu : function() {

       var um = this._data.menu ;

       if (um.usermenu)  {
         um.usermenu   = false ;
         um.$container.off("ojselect") ;
         um.$container.off("beforeshow") ;
         um.$container = null ;
       }
     },

     /**
       * Builds a menu for a command, takes care of submenus where appropriate
       * @param {string} cmd
       * @private	 
       */            
     _buildContextMenuItem : function(cmd)
     {
        return $(this._buildContextMenuListItem(cmd)) ;
     },

     /**
       * Builds a context menu list item from a command
       * @param {string} cmd the string to look up command value for as well as translation
       * @return {string} an HTML string containing a list item and a  
       * @private	 
       */
     _buildContextMenuListItem: function(cmd)
     {
        var id = _arMenuCmdMap[cmd] ;
        return '<li id=' + id + '>' + this._buildContextMenuLabel(cmd) + '</li>';
     },

     /**
       * Builds a context menu anchor element with translated text
       * @param {string} cmd the command string whose label translated label should be used.
       * @return {string} an HTML anchor element string containing the translated label  
       * @private	 
       */
     _buildContextMenuLabel: function(cmd)
     {
         return '<a href="#">' + this.getTranslatedString("m_" + cmd) + '</a>';
     },        


     /**
       *  Menu "cut" functionality
       *  @private
       */
     _crrm_cut : function (obj)
     {
        obj = this._getNode(obj, true);
        if (!obj || !obj.length)  {
          return false;
        }

        this._data.crrm.cp_nodes = false;
        this._data.crrm.ct_nodes = obj;

        this._emitEvent({ "obj" : obj }, "cut");
     },

     /**
       *  Menu "copy" functionality
       *  @private
       */
     _crrm_copy : function (obj)
     {
        obj = this._getNode(obj, true);
        if (!obj || !obj.length)  {
          return false;
        }
        this._data.crrm.ct_nodes = false;
        this._data.crrm.cp_nodes = obj;
        this._emitEvent({ "obj" : obj }, "copy");
     },

     /**
       *  Menu "paste" functionality
       *  @private
       */
     _crrm_paste : function (obj)
     { 
        obj = this._getNode(obj);
        if (!obj || !obj.length) {
          return false;
        }
        var nodes = this._data.crrm.ct_nodes ? this._data.crrm.ct_nodes : this._data.crrm.cp_nodes;

        if (! this._data.crrm.ct_nodes && !this._data.crrm.cp_nodes)  {
           return false;
         }
         if (this._data.crrm.ct_nodes)  {
//         this.move_node(this._data.crrm.ct_nodes, obj);
           this._crrm_move_node(this._data.crrm.ct_nodes, obj);
           this._data.crrm.ct_nodes = false;
         }
         if (this._data.crrm.ct_nodes)
         {
//         this.move_node(this._data.crrm.ct_nodes, obj);
           this._crrm_move_node(this._data.crrm.ct_nodes, obj);
           this._data.crrm.ct_nodes = false;
         }
         if (this._data.crrm.cp_nodes)  {
//         this.move_node(this._data.crrm.cp_nodes, obj, false, true);
           this._crrm_move_node(this._data.crrm.cp_nodes, obj, false, true);
         }
         this._emitEvent({ "obj" : obj, "nodes" : nodes}, "paste");
     },

    /**
      *  Menu move node support for paste
      * @private
      */
     _crrm_move_node : function (obj, ref, position, is_copy, is_prepared, skip_check)
     {
        //var s = this.options["crrm"]["move"];
        var s = this._data.crrm.defaults["move"];
        if (! is_prepared)  { 
          if (typeof position === "undefined")  {
            position = s["defaultPosition"];
          }
          if (position === "inside" && !s["defaultPosition"].match(/^(before|after)$/))  {
            position = s["defaultPosition"];
          }
//Wed5      return this.__call_old(true, obj, ref, position, is_copy, false, skip_check);
            return this._move_node(obj, ref, position, is_copy, false, skip_check);
        }

        // if the move is already prepared
        if (s["alwaysCopy"] === true || (s["alwaysCopy"] === "multitree" && obj.rt._getIndex() !== obj.ot._getIndex() ))  { 
          is_copy = true;
        }
//Wed5  this.__call_old(true, obj, ref, position, is_copy, true, skip_check);
        this._move_node(obj, ref, position, is_copy, true, skip_check);
     },

     /**
       *  Menu "remove" (i.e. delete) functionality
       *  @private
       */
     _crrm_remove : function (obj)
     {
        obj = this._getNode(obj, true);

//      var p   = this._getParent(obj),
//          prev = this._getPrev(obj);

         this.__rollback();
         obj = this["remove"](obj);
//         if (obj !== false) {
//           this._emitEvent({ "obj" : obj, "prev" : prev, "parent" : p }, "remove");
//         }
     },

     /**
       *  Menu rename a node functionality
       *  @private
       */
     _crrm_rename  :  function (obj)
     {
        var f = this._emitEvent;

        obj = this._getNode(obj);
        this.__rollback();
        this._crrm_showInput(obj, function (obj, new_name, old_name)
                                  { 
                                    //  Emit rename event
//                                    f.call(this, {
//                                                   "obj"       : obj,
//                                                   "title"     : new_name,
//                                                   "prevTitle" : old_name 
//                                                 },  "rename");
                                  });
     },

     /**
       *  Turn node into an input field to allow the user to rename the node.
       *  @private
       */
     _crrm_showInput : function (obj, callback)
     {
        obj = this._getNode(obj);

        var rtl = this._isRtl,
//          w   = this.options["crrm"]["inputWidthLimit"],       // applyDefaults() not done for V1
            w   = this._data.crrm.defaults["inputWidthLimit"],
            w1  = obj.children("ins").width(),
            w2  = obj.find("> a:visible > ins").width() * obj.find("> a:visible > ins").length,
            t   = this["getText"](obj),
_this = this,

            h1  = $("<div />", { css : { "position"   : "absolute",
                                         "top"        : "-200px",
                                         "left"       : (rtl ? "0px" : "-1000px"),
                                         "visibility" : "hidden"
                                       }
                               }).appendTo("body"),

            h2  = obj.css("position", "relative").append(
                $("<input />", { 
                    "value" : t,
                    "class" : "oj-tree-rename-input",
                    // "size" : t.length,
                    "css" : {
                              "padding"  : "0",
                              "border"   : "1px solid silver",
                              "position" : "absolute",
                              "left"     : (rtl ? "auto" : (w1 + w2 + 4) + "px"),
                              "right"    : (rtl ? (w1 + w2 + 4) + "px" : "auto"),
                              "top"      : "0px",
                              "height"   : (this._data.core.li_height - 2) + "px",
                              "lineHeight" : (this._data.core.li_height - 2) + "px",
                              "width"    : "150px" // will be set a bit further down
                             },
                    "blur" : $.proxy(function ()
                      {
                        var i = obj.children(".oj-tree-rename-input"),
                            v = i.val();
                        if (v === "")  {
                          v = t;
                        }
                        h1.remove();
                        i.remove();                    // rollback purposes
                        this._set_text(obj, t);        // rollback purposes
                        this._rename_node(obj, v);
                        callback.call(this, obj, v, t);
                        obj.css("position","");
                    }, this),

                    "keyup" : function (event)
                      {
                        var key = event.keyCode || event.which;
// ignore first enter, it appears to be left
// over from hitting enter on the menu rename item????!!!
if (! _this._done) {
  _this._done=true ;
  return false;
}
                        if(key == 27)  {
_this._done = false ;
                           this.value = t;
                           this.blur();
                           return;
                        }
                        else if(key == 13)  {
_this._done = false ;
                           this.blur();
                           return;
                        }
                        else  {
                           h2.width(Math.min(h1.text("pW" + this.value).width(),w));
                        }
                    },

                    "keypress" : function(event)
                    {
                      var key = event.keyCode || event.which;
                      if (key == 13)  {
                        return false;
                      }
                    }
                })
            ).children(".oj-tree-rename-input"); 
            this._set_text(obj, "");
            h1.css({
                    fontFamily      : h2.css('fontFamily')      || '',
                    fontSize        : h2.css('fontSize')        || '',
                    fontWeight      : h2.css('fontWeight')      || '',
                    fontStyle       : h2.css('fontStyle')       || '',
                    fontStretch     : h2.css('fontStretch')     || '',
                    fontVariant     : h2.css('fontVariant')     || '',
                    letterSpacing   : h2.css('letterSpacing')   || '',
                    wordSpacing     : h2.css('wordSpacing')     || ''
            });
//Fri2      h2.width(Math.min(h1.text("pW" + h2[0].value).width(),w))[0].select();
            h2.width(Math.min(h1.text("pW" + h2[0].value).width(),w))[0]["select"]();
     },

     /**
       *  @private
       */
     _crrm_create : function (obj, position, js, callback, skip_rename)
     {
        var t, _this = this;
        obj = this._getNode(obj);
        if (!obj) {
           obj = -1;
        }
        this.__rollback();
        t = this._create_node(obj, position, js, function (t)
             {
                var p = this._getParent(t),
                    pos = $(t).index();

                if (callback)  {
                   callback.call(this, t);
                }
                if (p.length && p.hasClass(OJT_CLOSED))  {
                   this["expand"](p, false, true);
                }
                if (!skip_rename)  { 
                  this._crrm_showInput(t, function (obj, new_name, old_name)
                         { 
                            _this._emitEvent({ "obj"      : obj,
                                               "name"     : new_name,
                                               "parent"   : p,
                                               "position" : pos
                                              });
                         });
                }
                else  {
                   _this._emitEvent({ "obj"      : t, 
                                      "name"     : this["getText"](t),
                                      "parent"   : p,
                                      "position" : pos 
                                    });
                }
             });

        return t;
     },

     /**
       *  @private
       */
     _crrm_check_move : function ()
     {
        if (! this.__call_old())  {
          return false;
        }
        //var s = this.options["crrm"]["move"];
        var s = this._data.defaults.crrm["move"];
        if (! s["checkMove"].call(this, this._getMove()))  {
          return false;
        }
        return true;
     },

     /**
       *  @private
       */
     _isHtml : function(s)
     {
        if (!s || s.length < 3) {
          return false ;
        }

        s = s.trim() ;
        return (s.charAt(0) === "<") ;
     },


     /**
       *  Use emptyText option if defined.
       *  @private
       */
     _applyEmptyText : function()
     {
        var txt = this.option.emptyText ;

        if (typeof txt !== "string") {
          txt = this.getTranslatedString("m_emptyText");
        }
        if (txt && txt.length > 0)  {

          var $u =  this._$container_ul;
          var d  = "<li class='oj-tree-empty'>" + txt + "</li>" ;   // no <a>, not interactive 
          $u.empty().append(d);
        }
      },

     /**
       *  Return the HTMLElement based on the locator object properties.
       *  @private
       */
     _processSubId : function(locator)
     {
        // Parent node
        // <li role="treeitem" id="blogs" class="oj-tree-open">
        //    <ins class="oj-tree-icon"> </ins>               <-- disclosure icon
        //    <a tabindex="-1" href="#">
        //       <ins class="oj-tree-icon"> </ins>            <-- node icon
        //       <span class="oj-tree-title">Blogs</span>     <-- node title
        //       <ul role="group"> 
        //          <li . . .child nodes...
        //       </ul>
        //    </a>
        // </li>
        //
        //  Leaf node
        // <li role="treeitem" id="home" myattr1="Hello" class="oj-tree-leaf">
        //    <ins class="oj-tree-icon"> </ins>
        //    <a tabindex="-1" href="#">
        //       <ins class="oj-tree-icon"> ;</ins>           <-- node icon
        //       <span class="oj-tree-title">Home</span>      <-- node title
        //    </a>
        // </li>

        var  subId      = locator["subId"],
             origNode   = locator["node"],
             node       = (origNode? this._getNode(origNode) : null),
//           index      = ((typeof locator["index"] === "number")?  locator["index"] : -1),
//           vis        = ((typeof locator["visible"] === "boolean")?  locator["index"] : false),
             key        = ((typeof locator["key"]   === "string")?  locator["key"] : null),
             val        = ((typeof locator["value"] === "string")?  locator["value"] : null),
             $elem,
             txt,
             l ;

        switch (subId) {
           case "disclosure" :         // returns the disclosure icon element for the parent node
                      if (origNode === -1 || node === -1) {
                        return (this._$container_ul? this._$container_ul[0] : null) ;
                      }

                      if (key) {                                // we ignore node and find by attr
                        l = this._$container_ul.find("li") ;
                        $.each(l, function(i, v) {
                                     v = $(v)
                                     if (v.attr(key) && (v.attr(key) === val))  {
                                       node = v ;
                                       return false ;
                                     }
                                  }) ;
                      }

                      else if ( (!node) && typeof origNode === "string") {
                        // node not found, see if we can locate by text
                        txt = origNode.trim() ;
                        l = this._$container_ul.find("a") ;
                        $.each(l, function(i, v) {
                                     if (v.text.trim() === txt)  {
                                       $elem = $(v) ;
                                       return false ;
                                     }
                                  }) ;
                        if (! $elem) {
                          return null ;               // not found by text
                        }

                        node = $elem.closest("li")
                      }

                      else if (node) {                // did _getNode() resolve to a node
                          if (this._isLeaf(node)) {   // we have a node and
                            return null ;             // not a parent
                          }
                      }


                      // Search complete, did we find the node?
                      if (node) {
                        if (! this._isLeaf(node)) {
                          // Have a parent node
                          return  node.find(" > ins:eq(0)") ;
                        }
                      }
                      return null ;                 // unsuccessful
                      break ;

           case "icon" :              // returns the icon element for the node
                      if (origNode === -1 || node === -1) {
                        return (this._$container_ul? this._$container_ul[0] : null) ;
                      }

                      if (key) {                                // we ignore node and find by attr
                        l = this._$container_ul.find("li") ;
                        $.each(l, function(i, v) {
                                     v = $(v)
                                     if (v.attr(key) && (v.attr(key) === val))  {
                                       node = v ;
                                       return false ;
                                     }
                                  }) ;
                        if (node) {
                          node = node.find(" > a").closest("ins") ;
                        }
                        return node ;
                      }

                      else if ( (!node) && typeof origNode === "string") {
                        // node not found, see if we can locate by text
                        txt = origNode.trim() ;
                        l = this._$container_ul.find("a") ;
                        $.each(l, function(i, v) {
                                     if (v.text.trim() === txt)  {
                                       $elem = $(v) ;
                                       return false ;
                                     }
                                  }) ;
                        return $elem ;
                      }

                      // Search complete, did we find the node?
                      if (node && node.length) {
                        return  node.find(" > a > ins:eq(0)") ;
                      }
                      return null ;                 // unsuccessful
                      break ;

           case "link" :              // returns the <a> element for the node
                      if (origNode === -1 || node === -1) {
                        return (this._$container_ul? this._$container_ul[0] : null) ;
                      }

                      if (key) {                                // we ignore node and find by attr
                        l = this._$container_ul.find("li") ;
                        $.each(l, function(i, v) {
                                     v = $(v)
                                     if (v.attr(key) && (v.attr(key) === val))  {
                                       node = v ;
                                       return false ;
                                     }
                                  }) ;
                        if (node) {
                          node = node.find(" > a:eq(0)") ;
                          if (node) {
                            return node ;
                          }
                        }
                        return false ;
                      }

                      else if ( (!node) && typeof origNode === "string") {
                        // node not found, see if we can locate by text
                        txt = origNode.trim() ;
                        l = this._$container_ul.find("a") ;
                        $.each(l, function(i, v) {
                                     if (v.text.trim() === txt)  {
                                       $elem = $(v) ;
                                       return false ;
                                     }
                                  }) ;
                        return $elem ;
                      }


                      // Search complete, did we find the node?
                      if (node && node.length) {
                        return  node.find(" a:eq(0)") ;
                      }
                      return null ;                 // unsuccessful
                      break ;

           case "parent" :
                      if (node && (origNode !== -1)) {
                        node =  this._getParent(node) ;
                      }
                      node = (node && (node != -1))? node : null ;
                      return  node ;
                      break ;

           case "first" :
                      if ((! node) || (node == -1) || (origNode == -1)) {
                        node = this._$container_ul
                      }
                      return  node.find("li:eq(0)") ;
                      break ;

           case "last" :
                      if ((! node) || (node == -1) || (origNode == -1)) {
                        node = this._$container_ul
                      }
                      return  node.find("li:last-child").last() ;
                      break ;

           case "prevSib" :
                      if (node !== -1) {
                        node = this._getPrev(node, true) ;
                        node = node ? node[0] : null;
                      }
                      else {
                        node = null ;
                      }
                      return  node ;
                      break ;

           case "nextSib" :
                      if (node !== -1) {
                        node = this._getNext(node, true) ;
                        node = node ? node[0] : null;
                      }
                      else {
                        node = null ;
                      }
                      return  node ;
                      break ;

        }

        return null ;
     }

  }) ;    // end    $.widget("oj.ojTree", ...


/*
   // load the css when DOM is ready  -  need to remove this  - TDO
   $(function() {
       var  css = '' + 
           '.oj-tree-list, .oj-tree-list ul, .oj-tree-list li { display:block; margin:0 0 0 0; padding:0 0 0 0; list-style-type:none; } ' + 
           '.oj-tree-list li { display:block; min-height:18px; line-height:18px; white-space:nowrap; margin-left:18px; min-width:18px; } ' + 
           '.oj-tree-rtl li { margin-left:0; margin-right:18px; } ' + 
           '.oj-tree-list > ul > li { margin-left:0px; } ' + 
           '.oj-tree-rtl > ul > li { margin-right:0px; } ' + 
           '.oj-tree-list ins { display:inline-block; text-decoration:none; width:18px; height:18px; margin:0 0 0 0; padding:0; } ' + 
           '.oj-tree-list a { display:inline-block; line-height:16px; height:16px; color:black; white-space:nowrap; text-decoration:none; padding:1px 2px; margin:0; } ' + 
           '.oj-tree-list a:focus { outline: none; } ' + 
           '.oj-tree-list a > ins { height:16px; width:16px; } ' + 
           '.oj-tree-list a > .oj-tree-icon { margin-right:3px; } ' + 
           '.oj-tree-rtl a > .oj-tree-icon { margin-left:3px; margin-right:0; } ' + 
           'li.oj-tree-open > ul { display:block; } ' + 
           'li.oj-tree-closed > ul { display:none; } ';
       // the default stylesheet
       _addSheet({ str : css, title : "oj-tree" });
   });
*/

})();

/*!
 * JET Checkboxset @VERSION
 * http://jqueryui.com
 *
 * Copyright 2013 jQuery Foundertion and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * Depends:
 *  jquery.ui.widget.js
 */
/**
 * @class
 * @name oj.ojCheckboxset
 * @augments oj.editableValue
 * @classdesc
 * <p>
 * The JET Checkboxset component (ojCheckboxset) enhances a group of <code class="prettyprint">input type="checkbox"</code> elements and 
 * manages the selected values of the group. It also adds and removes the correct
 * oj-* styles to the dom elements so it has the JET styling and is themable.
 * </p>
 * <p>To use an ojCheckboxset, group all the inputs and their labels within a container dom element, e.g., div. 
 *   For accessibility, set <code class="prettyprint">aria-labelledby</code> on this container dom element.
 *   Also set each input's <code class="prettyprint">id</code> attribute, and refer to that in the input's label's <code class="prettyprint">for</code> attribute.
 *   Then create the ojCheckboxset on this container dom element.  
 * </p>
 * <p>
 *  Checkboxset is used by selecting a container element which contains the 
 *  checkbox input elements and calling <code class="prettyprint">ojCheckboxset()</code>. You can enable and disable a checkbox set, 
 *  which will enable and disable all contained checkboxes. 
 * </p>
 * <p>
 *  Checkboxset does not have a readOnly option since HTML does not support
 *  readonly on radios and checkboxes.
 * </p>
 * <h3 id="keyboard-section">
 *   Keyboard interaction
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
 * </h3>
 * 
 * <p>The checkboxset does not add any extra keyboard navigation to the input checkboxes. 
 * The keyboard interaction comes from the native browser.
 * </p>
 * <h3 id="a11y-section">
 *   Accessibility
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
 * </h3>
 * 
 * <p>JET Checkboxset takes care of setting <code class="prettyprint">role="group"</code> on the checkboxset element.  
 * 
 * <p>As shown in the online demos, the application is responsible for applying <code class="prettyprint">aria-labelledby</code>
 * to point to the main label element for the group of checkboxes.
 * <h3 id="eventHandling-section">
 *   Event Handling
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#eventHandling-section"></a>
 * </h3>
 * <ul>
 *  <li>optionChange(event, ui) - Type: ojoptionchange
 *  <p>
 *   Triggered if the value changes when the user interacts with the component 
 *   (clicking on one of the checkboxe buttons); or if the value has 
 *   changed programmatically via the value option. 
 *  </li>
 * </ul>
 * <h3 id="jqui2jet-section">
 *   JET for jQuery UI developers
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#jqui2jet-section"></a>
 * </h3>
 * 
 * <p>
 *   All JQUI and JET components inherit <code class="prettyprint">disable()</code> and <code class="prettyprint">enable()</code> methods from the base class.  This API 
 *       duplicates the functionality of the <code class="prettyprint">disabled</code> option.  In JET, to keep the API as lean as possible, we 
 *       have chosen not to document these methods outside of this section.
 * </p>
 * <!-- - - - - Above this point, the tags are for the class.
 *              Below this point, the tags are for the constructor (initializer). - - - - - - -->
 * 
 * @desc Creates or re-initializes a JET Checkboxset.  For JET components, re-initing 
 * is generally like a hard refresh, meaning it typically does everything 
 * <code class="prettyprint">refresh()</code> does, plus potentially a bit more. 
 *  For JET Checkboxset, if the DOM changes (for example, you add/remove a checkbox), you should refresh.
 * 
 * <p>Don't confuse the re-initializer with the <code class="prettyprint">option()</code> method, 
 * which (in one overload) also accepts a map of option-value pairs
 * to set on the component, but does not re-init.  
 * 
 * @param {Object=} options a map of option-value pairs to set on the component
 * 
 * @example <caption>Initialize the checkboxset with no options specified:</caption>
 * $(".selector").ojCheckboxset();
 * 
 * @example <caption>Initialize the checkboxset with some options and callbacks specified:</caption>
 * $( ".selector" ).ojCheckboxset( { "value": ["copy"], "valuechange": 
 * function( event, ui ) {alert("valuechanged from " + ui.previousValue + " to " + ui.value);} } );             
 * @example <caption>Initialize component using widget API</caption>
 * &lt;label id="grouplabel">Greetings&lt;/label>
 * &lt;div id="checkboxset" aria-labelledby="grouplabel">
 *   &lt;input id="helloid" value="hello" type="checkbox" name="greetings"/&gt;
 *   &lt;label for="helloid"/&gt;Hello&lt;/label>
 *   &lt;input id="bonjourid" value="bonjour" type="checkbox" name="greetings"/&gt;
 *   &lt;label for="bonjourid"/&gt;Bonjour&lt;/label>
 *   &lt;input id="ciaoid" value="ciao" type="checkbox" name="greetings"/&gt;
 *   &lt;label for="ciaoid"/&gt;Ciao&lt;/label>
 * &lt;div>
 * <br/>
 * // set the value to "ciao". (The 'ciao' checkbox will be checked)
 * $("#checkboxset").ojCheckboxset({'option', 'value', ['ciao']});
 * 
 * @example <caption>Initialize a checkboxset via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;label id="grouplabel">Time&lt;/label>
 * &lt;div id="checkboxset" data-bind="ojComponent: {component: 'ojCheckboxset', value: ['night']} 
 *   aria-labelledby="grouplabel" >
 *   &lt;input id="morningid" value="morning" type="checkbox" name="time"/&gt;
 *   &lt;label for="morningid"/&gt;Morning&lt;/label>
 *   &lt;input id="nightid" value="night" type="checkbox" name="time"/&gt;
 *   &lt;label for="nightid"/&gt;Night&lt;/label>
 * &lt;div>
 * <br/>
  * @example <caption>Using knockout, value bind to observable:</caption>
 * &lt;label id="grouplabel">Time&lt;/label>
 * &lt;div id="checkboxset" data-bind="ojComponent: {component: 'ojCheckboxset', value: currentTime} 
 *   aria-labelledby="grouplabel" >
 *   &lt;input id="morningid" value="morning" type="checkbox" name="time"/&gt;
 *   &lt;label for="morningid"/&gt;Morning&lt;/label>
 *   &lt;input id="nightid" value="night" type="checkbox" name="time"/&gt;
 *   &lt;label for="nightid"/&gt;Night&lt;/label>
 * &lt;div>
 * <br/>
 * // in the model, make the currentTime variable a knockout observable.
 * // The model and the component's value option will stay in sync. Change the
 * // component's value option and the model will change. Change the model,
 * // and the component's value option will change. Click on a checkbox, and both
 * // will change.
 * self.currentTime = ko.observable(["night"]);
 * @constructor
 */
oj.__registerWidget("oj.ojCheckboxset", $['oj']['editableValue'],
{
  version : "1.0.0",  
  defaultElement : "<div>", 
  widgetEventPrefix : "oj", 
  options : 
  {
 
  },
  /**** start Public APIs ****/
      
   /**
   * Refreshes the checkboxset
   * <p>A <code class="prettyprint">refresh()</code> or re-init is required 
   * when a checkboxset is programatically changed, like in the following circumstances:
   * <ul>
   *   <li>After checkboxes are added or removed or modified (without using ojCheckboxset) in the DOM.</li>
   * </ul>    
   * @expose 
   * @memberof! oj.ojCheckboxset
   * @instance
   * @example <caption>Invoke the <code class="prettyprint">refresh</code> method:</caption>
   * $( ".selector" ).ojCheckboxset( "refresh" );
   */
  refresh: function() 
  {
    this._super();
    // refresh the ojCheckbox's that exist, and  of the type=checkbox inputs that 
    // are not yet ojcheckboxes, make them ojcheckboxes.
    this.$checkboxes = this._findCheckboxesWithMatchingName()
                    .filter( ".oj-checkbox" )
                    ._ojRadioCheckbox("refresh")
                    .end()                  
                    // Create ojCheckbox out of any 'new' checkboxes.

                     // the END is key here. It makes it so that 
                     // this.$checkboxes has ALL the checkboxes.

                     // .not if a filter, it removes elements that do not have the
                     // oj-checkbox style class from the list of all input[type=checkbox]s.
                    .not( ".oj-checkbox" )

                    ._ojRadioCheckbox()
                    .end();
         
    this._setup();
  },
  /**
   * Returns a jQuery object containing the element visually representing the checkboxset. 
   * 
   * <p>This method does not accept any arguments.
   * 
   * @expose
   * @memberof! oj.ojCheckboxset
   * @instance
   * @return {jQuery} the checkbox
  */
  widget : function ()
  {
    return this.uiCheckboxset;
  },
          
   /**** end Public APIs ****/         
          
  /**** start internal widget functions ****/   
       
  /**
   * After _ComponentCreate and _AfterCreate, 
   * the widget should be 100% set up. this._super should be called first.
   * @override
   * @protected
   */
  _ComponentCreate : function ()
  {
    this._super();
    // turn each checkbox into ojCheckbox. Do this first, since we need it
    // in calls from 'create'.
    this.$checkboxes = this._findCheckboxesWithMatchingName()._ojRadioCheckbox();
    this.uiCheckboxset = this.element.addClass("oj-checkboxset oj-component")
                                  .attr( "role", "group" );
    this._on(this._events);
    this._setup();
    
  },
  /**
   * Returns a jquery object that is a set of elements that are input type checkbox
   * and have the name of the first checkbox found.
   * 
   * @return {Object} jquery object of all the checkboxes within the root dom element
   * that have the same 'name' attribute as the first checkbox found.
   * @private
   */
  _findCheckboxesWithMatchingName : function ()

  {
    //return this.element.find('input[type=checkbox]'); // simplest thing to do.
    
    var first = this.element.find("input[type=checkbox]:first");
    if (first.length === 0)
    {
      oj.Logger.warn("Could not find any input type=checkbox within this element");
    }
    // get the name attribute of the first input checkbox
    var name = first.attr("name");
    // find all input checkboxes with matching name
    if (name === undefined)
    {
    	// search for all checkboxes with no name
      var allcheckboxes = this.element.find("input[type=checkbox]");
      // now loop and find the ones without 'name' attribute
      return allcheckboxes.not("[name]");
    }
    else
    {
    	// search for all checkboxes with the name
      var selector = "input[type=checkbox][name=" + name + "]";
      return this.element.find(selector);
    	
    }
  },
  /* 
   * Component developers: This API and functionality is subject to change pending architectural review!
   * See the baseComponent method for preliminary API doc.
   */
  _showContextMenu: function(menu, event)
  {
    // TODO: confirm this logic
    var checkboxes = this.element.find("input[type=checkbox]");
    var checked = checkboxes.filter(":checked");
    var launcher = checked.length ? checked : checkboxes.first(); 
    menu.show(event, {"launcher": launcher, "focus": "menu"});
  },
  _setup: function() 
  {

    // disable checkbox if element was already disabled
    if (this.options.disabled)
    {
      // calls _setOption disable is true, which in turn disables all checkboxs.
      this.disable();
    }
  },   
  _events : 
  {
    'change' : function (event)
    {
      
      this._HandleChangeEvent(event);
    }
  },

  /**
   * @param {Event} event DOM event 
   * @override
   * @protected
   * @memberof! oj.ojCheckboxset
   */
  _HandleChangeEvent: function(event)
  {
    // TODO make sure the target is an input checkbox?
    // TODO any more checks I need to do?
    //alert("XYZ In _changeSetValue target is " + event.target + " And the value of the input is " + event.target.value);

    // should I double check that the event.target is the same as the 'checked'?
    // if (event.target === this.$checkboxes.filter(":checked"))???
    // _SetValue triggers valuechange event
    this._super(event);
  },
                  
  /**
   * Returns the display value that is ready to be passed to the converter.
   * 
   * @param {Object} value the stored value if available that needs to be formatted for display
   * @override
   * @protected
   * @memberof! oj.ojCheckboxset
   */
  _GetDisplayValue : function (value) 
  {
    // return the value of the 'checked' checkboxes
    return this._GetElementValue();
  },
  /**
   * Called when the display value on the element needs to be updated 
   * as a result of a value change. 
   * ojCheckboxset stores an Array value, and this value matches the values
   * of the currently checked checkboxes. So, if we need to set the display value,
   * what this means is we need to 'check' the checkboxes whose values match the
   * displayValue.
   * 
   * @param {String} checkedBoxes of the new string to be displayed
   * @override
   * @protected
   * @memberof! oj.ojCheckboxset
  */  
 _SetDisplayValue : function (checkedBoxes) 
  {
    this.$checkboxes._ojRadioCheckbox("option", "checked", false);
    if (checkedBoxes != null)
    {
      // Uncheck all the checkboxes then iterate through and checkoff any matching checkboxes from the value
      for(var i = 0; i < checkedBoxes.length; i++) {

      var displayValue = checkedBoxes[i];
      var valueFilter = "[value='" + displayValue + "']"; 
      if (valueFilter !== undefined && this.$checkboxes !== undefined)
      {
        var checkboxWithMatchingValue = 
            this.$checkboxes.filter(valueFilter);
        // found a checkbox with a matching value


        if (checkboxWithMatchingValue !== undefined && checkboxWithMatchingValue.length > 0)
        {
          // if not already checked, then mark as checked.
          if (!checkboxWithMatchingValue.prop('checked'))

          {
            checkboxWithMatchingValue._ojRadioCheckbox("option", "checked", true);
          }
        }
      }
      }
      // TODO Do I need to refresh
    } 
  },
  /**
   * Returns the element's value. Normally, this is a call to this.element.val(),
   * but in the case of ojCheckboxset, the element's value is really the value
   * of the checked checkboxes in the set.
   * @override
   * @protected
   * @memberof! oj.ojCheckboxset
   */
  _GetElementValue : function () 
  {
    // "input:checked" selects checkboxes that are currently checked as 
    // reflected in their boolean (true or false) checked property, 
    // which is affected when the user clicks the checkbox for example.
    // for checkbox, there will be one or none checked; 
    // if none are checked, return null (selectedCheckbox.val() is undefined if nothing is checked)
    var checkedValues=new Array();
    var selectedCheckbox = this.$checkboxes.filter(":checked");
    if (selectedCheckbox.length === 0)
      return null;
    else 
    { 
      selectedCheckbox.each(function(){checkedValues.push($(this).val());});
      return checkedValues;
    }
  },
  
  /**
   * Overridden to set the default value for options.value when it's null or undefined.
   * 
   * @memberof! oj.ojCheckboxset
   * @instance
   * @protected
   */  
  _InitOptions : function ()
  {
    var checkboxes, checkedValues = new Array(), selectedCheckbox, result;
    this._super();
    
    if (this.options["value"] == null) // null or undefined
    {
      // return the checked values by looking at DOM nodes
      // TODO: Jeanne review needed
      
      checkboxes = this._findCheckboxesWithMatchingName();
      selectedCheckbox = checkboxes.filter(":checked");
      if (selectedCheckbox.length === 0)
      {
        result = null;
      }
      else 
      { 
        selectedCheckbox.each(function(){
          checkedValues.push($(this).val());
        });
        result = checkedValues;
      }
      this.options["value"] = result;
    }
  },
  
  /**
   * Returns the default styleclass for the component. Currently this is 
   * used to pass to the _ojLabel component, which will append -label and 
   * add the style class onto the label. This way we can style the label
   * specific to the input component. For example, for inline labels, the
   * checkboxset/checkboxset components need to have margin-top:0, whereas all the
   * other inputs need it to be .5em. So we'll have a special margin-top style 
   * for .oj-label-inline.oj-checkboxset-label
   * All input components must override
   * 
   * @return {string}
   * @memberof! oj.ojCheckboxset
   * @override
   * @protected
   */
  _GetDefaultStyleClass : function ()
  {
    return "oj-checkboxset";
  },
  /**
   * Returns a jquery object of the elements representing the content nodes (checkboxes/labels).
   * @protected
   * @override
   * @memberof! oj.ojCheckboxset
   */
  _GetContentElement : function ()
  {
    return this._findCheckboxesWithMatchingName();
  },
  /**
   * Called when a aria-required attribute needs to be set or removed. 
   * Most inputs/selects need aria-required on the input element (aka 'content')
   * But it is not legal to have aria-required on radio/checkboxes.
   * Subclasses can override to put aria-required where they want.
   * 
   * @param {Object=} value the current value of the required option
   * @memberof! oj.ojCheckboxset
   * @instance
   * @protected
   */
  _RefreshAriaRequired : function (value)
  {
    var ariaValue, rootNode = this.uiCheckboxset;

    ariaValue = (value == "required") ? true : false;
    if (ariaValue && rootNode) 
    {
      rootNode.attr("aria-required", ariaValue);
    }
    else
    {
      rootNode.removeAttr("aria-required");
    }
  },
  /**
   * @override
   * @private
   */
  _setOption : function (key, value)
  {
    this._super(key, value);

    if ( key === "disabled" ) {
      // disables all the checkboxs
      this.$checkboxes._ojRadioCheckbox( "option", key, value );
    }
  },
/**
   * Return the subcomponent node represented by the documented locator attribute values.
   * Test authors should target spinner sub elements using the following names:
   * <ul>
   * <li><b>oj-checkboxset-inputs</b>: the checkboxset's input elements</li>
   * </ul>
   * 
   * @expose
   * @override
   * @memberof! oj.ojCheckboxset
   * @instance
   * @param {Object} locator An Object containing at minimum a subId property 
   * whose value is a string, documented by the component, that allows the component to 
   * look up the subcomponent associated with that string.  It contains:
   * <ul>
   * <li>
   * component: optional - in the future there may be more than one component 
   *   contained within a page element
   * </li>
   * <li>
   * subId: the string, documented by the component, that the component expects 
   * in getNodeBySubId to locate a particular subcomponent 
   * </li>
   * </ul>  
   * @returns {Element|null} the subcomponent located by the subId string 
   * passed in locator, if found.
   */
  getNodeBySubId: function(locator)
  {
    if (locator == null)
    {
      return this.element ? this.element[0] : null;
    }
    
    var subId = locator['subId'];
    if (subId === "oj-checkboxset-inputs") {
      return this.$checkboxes;
    }
    
    // Non-null locators have to be handled by the component subclasses
    return null;
  }, 
  /**
   * TODO: What is our 'destroy' strategy with regards to html attributes that 
   * they have initially on their dom, but we change? like disabled? Do we store 
   * on data at the beginning, then restore from this data, and then call removeData?
   * @override
   * @private
   */
  _destroy : function ()
  {  
    this._super();
    // base class removes oj-disabled
    this.element.removeClass("oj-checkboxset oj-enabled oj-component")
                .removeAttr( "role" );
    if (this.$checkboxes)
    {
      this.$checkboxes._ojRadioCheckbox( "destroy" );
    }
  }
  /**** end internal widget functions ****/ 
 
});
/**
 * @class 
 * @name oj.ojTreemap
 * @augments oj.baseComponent
 * 
 * @classdesc
 * <h3 id="treemapOverview-section">
 *   JET Treemap Component
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#treemapOverview-section"></a>
 * </h3>
 * 
 * <p>Treemap component for JET. Treemaps are used to display hierarchical data across two dimensions, represented by 
 * the size and color of the treemap nodes. Treemaps are generally preferred over sunbursts when emphasizing the data
 * for the leaf nodes.</p>
 * 
 * <p>This component should be bound to an HTML div element, and the SVG DOM that it generates should be treated as a 
 * black box, as it is subject to change.  This component should not be extended.</p>
 * 
 * <pre class="prettyprint">
 * <code>
 * &lt;div data-bind="ojComponent: {
 *   component: 'ojTreemap',
 *   nodes: [{value: 100, color: "#FFFF00", label: "Total Sales", 
 *            nodes: [{value: 75, color: "#00FF00", label: "Candy"},
 *                    {value: 20, color: "#FFFF00", label: "Fruit"},
 *                    {value: 15, color: "#FF0000", label: "Vegetables"}]}]
 * }"/>
 * </code>
 * </pre>
 * 
 * <h3 id="treemapOptions-section">
 *   Options
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#treemapOptions-section"></a>
 * </h3>
 * 
 * <p>Full documentation for the options method, including APIs for data, style properties, and interactivity, is 
 * available <a title="Options Documentation" href="dvt/treemap.xml">here</a>.</p>
 * 
 * @desc Creates a JET Treemap.
 * @example <caption>Initialize the Treemap with no options specified:</caption>
 * $(".selector").ojTreemap();
 * 
 * @example <caption>Initialize the Treemap with some options:</caption>
 * $(".selector").ojTreemap({nodes: [{value: 75, color: "#00FF00", label: "Candy"}, {value: 20, color: "#FFFF00", label: "Fruit"}, {value: 15, color: "#FF0000", label: "Vegetables"}]});
 * 
 * @example <caption>Initialize the Treemap via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;div data-bind="ojComponent: {component: 'ojTreemap'}">
 */
oj.__registerWidget('oj.ojTreemap', $['oj']['dvtBaseComponent'], 
{
  version : "1.0.0", 
  widgetEventPrefix : "oj", 
  options: {
    /**
     * Triggered when node isolation is turned on or off.
     * 
     * @property {Object} ui event payload
     * @property {Object} ui.item an object with the following properties
     * @property {string} ui.items.id the id of the node
     * @property {string} ui.type specifies whether the node isolation is being turned 'on' or 'off'
     * 
     * @example <caption>Initialize the component with the <code class="prettyprint">isolate</code> callback specified:</caption>
     * $(".selector").ojTreemap({
     *   "isolate": function(event, ui){}
     * });
     *
     * @example <caption>Bind an event listener to the <code class="prettyprint">ojisolate</code> event:</caption>
     * $(".selector").on("ojisolate", function(event, ui){});
     * 
     * @expose 
     * @event 
     * @memberof! oj.ojTreemap
     * @instance
     */
    isolate : null,
    
    /**
     * Triggered after data items are selected or de-selected.
     * 
     * @property {Object} ui event payload
     * @property {Array} ui.items an array containing objects describing the selected nodes
     * @property {string} ui.items.id the id of the node
     * 
     * @example <caption>Initialize the component with the <code class="prettyprint">select</code> callback specified:</caption>
     * $(".selector").ojTreemap({
     *   "select": function(event, ui){}
     * });
     *
     * @example <caption>Bind an event listener to the <code class="prettyprint">ojselect</code> event:</caption>
     * $(".selector").on("ojselect", function(event, ui){});
     * 
     * @expose 
     * @event 
     * @memberof! oj.ojTreemap
     * @instance
     */
    select : null
  },
  
  /**
   * @override
   */
  _CreateComponent : function(context, callback, callbackObj) {
    return DvtTreemap.newInstance(context, callback, callbackObj);
  },
  
  /**
   * @override
   */
  _GetComponentStyleClasses : function() {
    var styleClasses = this._super();
    styleClasses.push('oj-treemap');
    return styleClasses;
  },
  
  /**
   * @override
   */
  _GetChildStyleClasses : function() {
  	var styleClasses = this._super();
   	styleClasses['oj-treemap-isolate-icon'] = {'path' : '_resources/isolate', 'property' : 'CSS_URL'};
   	styleClasses['oj-treemap-isolate-icon oj-hover'] = {'path' : '_resources/isolateOver', 'property' : 'CSS_URL'};
   	styleClasses['oj-treemap-isolate-icon oj-active'] = {'path' : '_resources/isolateDown', 'property' : 'CSS_URL'};
    
   	styleClasses['oj-treemap-restore-icon'] = {'path' : '_resources/restore', 'property' : 'CSS_URL'};
   	styleClasses['oj-treemap-restore-icon oj-hover'] = {'path' : '_resources/restoreOver', 'property' : 'CSS_URL'};
   	styleClasses['oj-treemap-restore-icon oj-active'] = {'path' : '_resources/restoreDown', 'property' : 'CSS_URL'};
    
    styleClasses['oj-treemap-attribute-type-text'] = {'path' : 'styleDefaults/_attributeTypeTextStyle', 'property' : 'CSS_TEXT_PROPERTIES'};
    styleClasses['oj-treemap-attribute-value-text'] = {'path' : 'styleDefaults/_attributeValueTextStyle', 'property' : 'CSS_TEXT_PROPERTIES'};
    // TODO HZHANG add this once drilling is supported
//    styleClasses['oj-treemapCurrentText '] = {'path' : '', 'property' : 'CSS_TEXT_PROPERTIES'};
    styleClasses['oj-treemap-node'] = {'path' : 'nodeDefaults/labelStyle', 'property' : 'CSS_TEXT_PROPERTIES'};
    styleClasses['oj-treemap-node oj-hover'] = {'path' : 'nodeDefaults/hoverColor', 'property' : 'border-top-color'};
    styleClasses['oj-treemap-node oj-selected'] = [
      {'path' : 'nodeDefaults/selectedOuterColor', 'property' : 'border-top-color'},
      {'path' : 'nodeDefaults/selectedInnerColor', 'property' : 'border-bottom-color'}
    ];
    styleClasses['oj-treemap-node-header'] = [
      {'path' : 'nodeDefaults/header/backgroundColor', 'property' : 'background-color'},
      {'path' : 'nodeDefaults/header/borderColor', 'property' : 'border-top-color'},
      {'path' : 'nodeDefaults/header/labelStyle', 'property' : 'CSS_TEXT_PROPERTIES'}
    ];
    styleClasses['oj-treemap-node-header oj-hover'] = [
      {'path' : 'nodeDefaults/header/hoverBackgroundColor', 'property' : 'background-color'},
      {'path' : 'nodeDefaults/header/hoverOuterColor', 'property' : 'border-top-color'},
      {'path' : 'nodeDefaults/header/hoverInnerColor', 'property' : 'border-bottom-color'}
    ];
    styleClasses['oj-treemap-node-header oj-selected'] = [
      {'path' : 'nodeDefaults/header/selectedBackgroundColor', 'property' : 'background-color'},
      {'path' : 'nodeDefaults/header/selectedOuterColor', 'property' : 'border-top-color'},
      {'path' : 'nodeDefaults/header/selectedInnerColor', 'property' : 'border-bottom-color'}
    ];
    return styleClasses;
  },
  
  /**
   * @override
   */
  _GetTranslationMap: function() {
    var superMap = this._super();
    var selfMap = {
      'DvtTreemapBundle.COLOR': this._GetTranslatedResource('labelColor'),
      'DvtTreemapBundle.SIZE': this._GetTranslatedResource('labelSize')
    };
    
    // Combine with the map from the superclass
    var ret = {};
    for(var key in superMap) { ret[key] = superMap[key]; }
    for(var key in selfMap) { ret[key] = selfMap[key]; }
    
    return ret;
  },
  
  /**
   * @override
   */
  _HandleEvent : function(event) {
    var type = event && event.getType ? event.getType() : null, selectedItems, selection, i, selectedItem,
        isolatedNodes, isolatedNode, isolateType;
    if(type === DvtSelectionEvent.TYPE) {
      selectedItems = [];
      selection = event.getSelection();
      for(i=0; i<selection.length; i++) {
        selectedItem = {'id': selection[i]};
        selectedItems.push(selectedItem);  
      }
      this._trigger('select', null, {'items': selectedItems});
    }
//    else if(type === DvtTreemapIsolateEvent.TYPE) {
//      // Keep track of all isolated nodes
//      isolatedNodes = this.options._isolatedNodes;
//      if(!isolatedNodes) {
//        this.options._isolatedNodes = [];
//        isolatedNodes = this.options._isolatedNodes;
//      }
//    
//      // If event has id, it's an isolate.  If null id, then restore.      
//      isolatedNode = event.getId();
//      if(isolatedNode) {
//        isolateType = "on";
//        isolatedNodes.push(isolatedNode);
//        this.options['isolatedNode'] = isolatedNode;
//      }
//      else {
//        isolateType = "off";
//        isolatedNode = isolatedNodes.pop();
//        this.options['isolatedNode'] = (isolatedNodes.length > 0) ? isolatedNodes[isolatedNodes.length] : null;
//      }
//    
//      this._trigger('isolate', null, {'item': {'id': isolatedNode}, 'type': isolateType});
//    }
    else {
      this._super(event);
    }
  }
});
/*jslint browser: true, devel: true*/

/**
 * An extension to oj.ComponentBinding, properties exposed on this binding are available 
 * to jet components that extend from oj.editableValue. 
 * 
 * @class oj.ValueBinding 
 * 
 * @constructor
 * @class
 * @export
 * @see oj.ComponentBinding
 * @see oj.editableValue
 */
oj.ValueBinding = function(){};


/** 
 * An array of objects containing the following properties <br>
 * <ul>
 * <li>'component' - the component instance </li>
 * <li>'valid' - whether the component is valid or not. </li>
 * </ul>
 * 
 * When this attribute is present, the binding registers a default handler for the 'optionChange' 
 * event fired by jet value holder components whenever its validity (i.e. 'messages' option) changes. 
 * The handler pushes the current validity of the component into the tracker. The same array 
 * instance can be used across multiple component binding declarations. E.g., <br/>
 * @example <caption>Track validity of multiple components using the same array for the <code class="prettyprint">invalidComponentTracker</code> attribute:</caption>
 * &lt;input id="username" type="text" name="username" required 
 *   data-bind="ojComponent: {component: 'ojInputText', value: userName, 
 *                            invalidComponentTracker: invalidComponents}">
 * &lt;input id="password" type="password" name="password" required 
 *   data-bind="ojComponent: {component: 'ojInputPassword', value: password, 
 *   invalidComponentTracker: invalidComponents}"/>
 *   
 * // The viewModel that defines the invalidComponents array 
 * &lt;script>
 * function MemberViewModel() 
 * { 
 *   var self = this;
 *   
 *   self.invalidComponents = ko.observableArray([]);
 *   self.userName = ko.observable();   
 *   self.password = ko.observable();
 * }
 * &lt;/script>
 * 
 * @export
 * @access public
 * @name invalidComponentTracker
 * @instance
 * @memberof! oj.ValueBinding

 */
oj.ValueBinding._ATTRIBUTE_INVALID_COMPONENT_TRACKER = 'invalidComponentTracker';

oj.ValueBinding._ATTRIBUTE_MESSAGES = 'messages';

/** 
 * The optionChange attribute is managed in order to wrap an existing callback or register a 
 * default invalidComponentTracker writeback, when the 'messages' option changes. 
 * The registered callback is called when the optionChange event is triggered.
 * 
 * @private
 * @const
 */
oj.ValueBinding._ATTRIBUTE_OPTIONCHANGE = "optionChange";

oj.ValueBinding._init = function (property, value, element, component, valueAccessor) 
{
  var initProps = {}, options = valueAccessor.call(), 
      optionChangeProp = oj.ValueBinding._ATTRIBUTE_OPTIONCHANGE,
      optionChangeObs = options[optionChangeProp], 
      optionChangeFunc = oj.ComponentBinding._toJS(optionChangeObs);
  
  if (property === oj.ValueBinding._ATTRIBUTE_INVALID_COMPONENT_TRACKER)
  {
    // register a writeback for invalidComponentTracker property by registering an event handler for 
    // the optionChange event.
    if (!optionChangeFunc)
    {
      oj.ValueBinding._registerInvalidComponentTrackerWriteback(options, initProps, component);
    }
    // initProps[property] = value; // we don't really need to initialize this property on component
  }
  else if (property === oj.ValueBinding._ATTRIBUTE_OPTIONCHANGE)
  {
    oj.ValueBinding._registerInvalidComponentTrackerWriteback(options, initProps, component);
  }
 
  return initProps;
};

/**
 * Register a default callback for the 'optionChange' event. The callback writes the component and 
 * its validity to the invalidComponentTracker observable.
 * 
 * @param {Object} options
 * @param {Object} initProps
 * @param {Object} component
 * @private
 */
oj.ValueBinding._registerInvalidComponentTrackerWriteback = function(options, initProps, component)
{
  var optionChangeProp = oj.ValueBinding._ATTRIBUTE_OPTIONCHANGE, 
      optionChangeObs = options[optionChangeProp], oldOptionChangeFunc, newMessages,
      invalidComponentTrackerObs = options[oj.ValueBinding._ATTRIBUTE_INVALID_COMPONENT_TRACKER], 
      items, index, item, matched = -1, newData = {};


  oldOptionChangeFunc = oj.ComponentBinding._toJS(optionChangeObs);
  
  // we don;t push to invalidComponentTracker if the observable is not set.
  if (invalidComponentTrackerObs !== null)
  {
    // Register a default callback for the (oj)'optionChange' event. The callback writes the 
    // validity payload to 'invalidComponentTracker' observable
    if (!oldOptionChangeFunc || oldOptionChangeFunc instanceof Function)
    {
      // The anonymous inner function listener will be delegating to the original listener if there 
      // is one. 
      initProps[optionChangeProp] = function(event, data)
      {
        if (oldOptionChangeFunc)
        {
          oldOptionChangeFunc.call(this, event, data);
        }
        
        // optionChange can be triggered for various options; we are interested in changes to 
        // messages
        if (data['option'] === oj.ValueBinding._ATTRIBUTE_MESSAGES)
        {
          // remove component if it's valid but an entry is present in the tracker or add a new entry 
          // to the invalidComponentTracker
          if (ko.isWriteableObservable(invalidComponentTrackerObs))
          {
            items = ko.utils.unwrapObservable(invalidComponentTrackerObs);
            oj.Assert.assertArray(items);
            newMessages = data['value'];

            $.each(items, function (index, item)
            {
              if (matched < 0 && item['component'] === component)
              {
                matched = index;
                return;
              }
            });

            // add/update/remove from array as the case may be
            if (newMessages)
            {
              newData['component'] = component;
              if (component.call(component, "isValid"))
              {
                newData['valid'] = true;
                if (matched >= 0)
                {
                  invalidComponentTrackerObs.splice(matched, 1, newData);
                }
                else
                {
                  // push component into array
                  invalidComponentTrackerObs.push(newData);
                }
              }
              else
              {
                // if component continues to be invalid
                newData['valid'] = false;
                if (matched >= 0)
                {
                  // update tracker
                  invalidComponentTrackerObs.splice(matched, 1, newData);
                }
                else
                {
                  // add new invalid component to tracker
                  invalidComponentTrackerObs.push(newData);
                }
              }
            }
          }
        }
      };
    }
  }
};

/**
 * ojValue Behavior Definition and Injection
 */
oj.ComponentBinding.getDefaultInstance().setupManagedAttributes(
{
  'for': 'ojValue',
  
  'attributes': [oj.ValueBinding._ATTRIBUTE_INVALID_COMPONENT_TRACKER,
                 oj.ValueBinding._ATTRIBUTE_OPTIONCHANGE],
               
  'init': oj.ValueBinding._init
});

/**
 * Default declaration for ojInputText
 */
oj.ComponentBinding.getDefaultInstance().setupManagedAttributes(
{
  'for': 'ojInputText',
  'use': 'ojValue'
});

/**
 * Default declaration for ojInputNumber
 */
oj.ComponentBinding.getDefaultInstance().setupManagedAttributes(
{
  'for': 'ojInputNumber',
  'use': 'ojValue'
});

/**
 * Default declaration for ojRadioCheckbox
 */
oj.ComponentBinding.getDefaultInstance().setupManagedAttributes(
{
  'for': 'ojRadioCheckbox',
  'use': 'ojValue'
});

oj.ComponentBinding.getDefaultInstance().setupManagedAttributes(
{
  'for': 'ojRadioset',
  'use': 'ojValue'
});

oj.ComponentBinding.getDefaultInstance().setupManagedAttributes(
{
  'for': 'ojCheckboxset',
  'use': 'ojValue'
});
/**
 * Default declaration for ojInputDateTime
 */
oj.ComponentBinding.getDefaultInstance().setupManagedAttributes(
{
  'for': 'ojInputDateTime',
  'use': 'ojValue'
});

/**
 * Default declaration for ojInputDate
 */
oj.ComponentBinding.getDefaultInstance().setupManagedAttributes(
{
  'for': 'ojInputDate',
  'use': 'ojValue'
});

/**
 * Default declaration for ojInputTime
 */
oj.ComponentBinding.getDefaultInstance().setupManagedAttributes(
{
  'for': 'ojInputTime',
  'use': 'ojValue'
});

/**
 * Default declaration for ojInputPassword
 */
oj.ComponentBinding.getDefaultInstance().setupManagedAttributes(
{
  'for': 'ojInputPassword',
  'use': 'ojValue'
});

/**
 * Default declaration for ojTextArea
 */
oj.ComponentBinding.getDefaultInstance().setupManagedAttributes(
{
  'for': 'ojTextArea',
  'use': 'ojValue'
});

/**
 * Default declaration for ojCombobox
 */
oj.ComponentBinding.getDefaultInstance().setupManagedAttributes(
{
  'for': 'ojCombobox',
  'use': 'ojValue'
});

/**
 * Default declaration for ojSelect
 */
oj.ComponentBinding.getDefaultInstance().setupManagedAttributes(
{
  'for': 'ojSelect',
  'use': 'ojValue'
});
/*!
 * jQuery UI Accordion 1.10.3
 * http://jqueryui.com
 *
 * Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/accordion/
 *
 * Depends:
 *  jquery.ui.core.js
 *  jquery.ui.widget.js
 */
/**
 * @class 
 * @name oj.ojAccordion
 * @augments oj.baseComponent
 * 
 * @classdesc
 * <h3 id="collapsibleOverview-section">
 *   JET Accordion Component
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#collapsibleOverview-section"></a>
 * </h3>
 * 
 * <p>Description: Themeable, WAI-ARIA-compliant collapsible with mouse and keyboard interactions for navigation.
 * 
 * <p>A JET Accordion can be created from any valid markup as long as the root element has one or more child elements and 
 * each child element must have two children: the first element for the header and the second element for the content.
 * 
 * <pre class="prettyprint">
 * <code>
 * &lt;div id="accordion">
 *   &lt;div id="c1">
 *     &lt;h3>
 *       &lt;img src="images/default.png"/>
 *       &lt;span>Header 1&lt;/span>
 *     &lt;/h3>
 *     &lt;p>Content 1.&lt;/p>
 *   &lt;/div>
 *   &lt;div id="c2" class="oj-disabled">
 *     &lt;h3>Disabled Header&lt;/h3>
 *     &lt;p>I'm disabled.&lt;/p>
 *   &lt;/div>
 *   &lt;div id="c3" data-bind="ojComponent: {component: 'ojCollapsible', expanded:true}">
 *     &lt;h3>Header 3&lt;/h3>
 *     &lt;p>Content 3&lt;/p>
 *   &lt;/div>
 * &lt;/div>
 * </code></pre>
 * 
 * <h3 id="keyboard-section">
 *   Keyboard interaction
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
 * </h3>
 * 
 * <p>
 * <h5>When the focus is on a collapsible header</h5>
 * </p>
 * 
 * <table class="keyboard-table">
 *   <thead>
 *     <tr>
 *       <th>Key</th>
 *       <th>Use</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td><kbd>Tab</kbd></td>
 *       <td> Navigate to next collapsible header and if none then the next component on page.</tr>
 *     <tr>
 *       <td><kbd>Shift+Tab</kbd></td>
 *       <td> Navigate to previous collapsible header and if none then the previous component on page.</tr>
 *     <tr>
 *       <td><kbd>UpArrow or LeftArrow</kbd> (<kbd>RightArrow</kbd> in RTL)</td>
 *       <td> Move focus to the previous collapsible header with wrap around.</tr>
 *     <tr>
 *       <td><kbd>DownArrow or RightArrow</kbd> (<kbd>LeftArrow</kbd> in RTL)</td>
 *       <td> Move focus to the next collapsible header with wrap around.</tr>
 *     <tr>
 *       <td><kbd>Home</kbd></td>
 *       <td> Move focus to the first collapsible header.</tr>
 *     <tr>
 *       <td><kbd>End</kbd></td>
 *       <td> Move focus to the last collapsible header.</tr>
 *   </tbody>
 *  </table>
 *
 * <p>Disabled items can receive keyboard focus, but do not allow any other interaction.
 * 
 * 
 * <h3 id="rtl-section">
 *   Reading direction
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#rtl-section"></a>
 * </h3>
 * 
 * <p>As with any JET component, in the unusual case that the directionality (LTR or RTL) changes post-init, the collapsible must be <code class="prettyprint">refresh()</code>ed.
 * 
 * 
 * <h3 id="pseudos-section">
 *   Pseudo-selectors
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#pseudos-section"></a>
 * </h3>
 * 
 * <p>The <code class="prettyprint">:oj-collapsible</code> pseudo-selector can be used in jQuery expressions to select JET Accordion.  For example:
 * 
 * <pre class="prettyprint">
 * <code>$( ":oj-collapsible" ) // selects all JET Accordion on the page
 * $myEventTarget.closest( ":oj-collapsible" ) // selects the closest ancestor that is a JET Accordion
 * </code></pre>
 * 
 * 
 * <h3 id="jqui2jet-section">
 *   JET for jQuery UI developers
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#jqui2jet-section"></a>
 * </h3>
 * 
 * <ol>
 *   <li>JET Accordion supports clickable option: specifies where to click to toggle disclosure. Default is "disclosureIcon", however if a collapsible is inside an Accordion, default is "header"</li>
 * </ol>
 * 
 * <p>Also, event names for all JET components are prefixed with "oj", instead of component-specific prefixes like "collapsible".  
 * 
 * <!-- - - - - Above this point, the tags are for the class.
 *              Below this point, the tags are for the constructor (initializer). - - - - - - -->
 * 
 * @desc Creates a JET Accordion. 
 * @example <caption>Initialize the collapsible with no options specified:</caption>
 * $( ".selector" ).ojAccordion();
 * 
 * @example <caption>Initialize the collapsible with some options and callbacks specified:</caption>
 * $( ".selector" ).ojAccordion( { "disabled": true, "create": function( event, ui ) {} } );
 * 
 * @example <caption>Initialize the collapsible via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;div id="collapsible" data-bind="ojComponent: { component: 'ojAccordion', 
 *                                                    multiple: false}">
 */
(function ()
{
  oj.__registerWidget("oj.ojAccordion", $['oj']['baseComponent'], 
  {
    version : "1.0.0", 
    widgetEventPrefix : "oj", 
    options : 
    {
      /** 
       * Allow multiple collapsible(s) to be open at the same time. 
       *
       * @expose 
       * @memberof! oj.ojAccordion
       * @instance
       * @type {boolean}
       * @default <code class="prettyprint">false</code>
       *
       * @example <caption>Initialize the accordion with the <code class="prettyprint">multiple</code> option specified:</caption>
       * $( ".selector" ).ojAccordion( { "multiple": true } );
       * 
       * @example <caption>Get or set the <code class="prettyprint">multiple</code> option, after initialization:</caption>
       * // getter
       * var multiple = $( ".selector" ).ojAccordion( "option", "multiple" );
       * 
       * // setter
       * $( ".selector" ).ojAccordion( "option", "multiple", true );
       */
      multiple : false,

      // callbacks
      /**
       * Triggered immediately before any collapsible in the accordion is expanded.
       * The beforeExpand can be cancelled by calling <code class="prettyprint">event.preventDefault()</code>.
       *
       * @expose 
       * @event 
       * @memberof! oj.ojAccordion
       * @instance
       * @property {Event} event <code class="prettyprint">jQuery</code> event object
       * @property {Object} ui Parameters
       * @property {jQuery} ui.newCollapsible The collapsible that is about to be expanded.
       * @property {jQuery} ui.oldCollapsible The collapsible that is about to be collapsed. Only available if multiple is false.
       * 
       * @example <caption>Initialize any collapsible in the accordion with the <code class="prettyprint">beforeExpand</code> callback specified:</caption>
       * $( ".selector" ).ojAccordion({
       *     "beforeExpand": function( event, ui ) {}
       * });
       *
       * @example <caption>Bind an event listener to the <code class="prettyprint">ojbeforeexpand</code> event:</caption>
       * $( ".selector" ).on( "ojbeforeexpand", function( event, ui ) {} );
       */
      beforeExpand : null,

      /**
       * Triggered after the accordion has been expanded (after animation completes).
       * The afterExpand can be cancelled by calling <code class="prettyprint">event.preventDefault()</code>.
       *
       * @expose 
       * @event 
       * @memberof! oj.ojAccordion
       * @instance
       * @property {Event} event <code class="prettyprint">jQuery</code> event object
       * @property {Object} ui Parameters
       * @property {jQuery} ui.newCollapsible The collapsible that was just expanded.
       * @property {jQuery} ui.oldCollapsible The collapsible that was just collapsed. Only available if multiple is false.
       * 
       * @example <caption>Initialize the accordion with the <code class="prettyprint">afterExpand</code> callback specified:</caption>
       * $( ".selector" ).ojAccordion({
       *     "afterExpand": function( event, ui ) {}
       * });
       *
       * @example <caption>Bind an event listener to the <code class="prettyprint">ojafterexpand</code> event:</caption>
       * $( ".selector" ).on( "ojafterexpand", function( event, ui ) {} );
       */
      afterExpand : null, 

      /**
       * Triggered immediately before any collapsible in the accordion is collapsed.
       * The beforeCollapse can be cancelled by calling <code class="prettyprint">event.preventDefault()</code>.
       *
       * @expose 
       * @event 
       * @memberof! oj.ojAccordion
       * @instance
       * @property {Event} event <code class="prettyprint">jQuery</code> event object
       * @property {Object} ui Parameters
       * @property {jQuery} ui.newCollapsible The collapsible that is about to be collapsed.
       * @property {jQuery} ui.oldCollapsible The collapsible that is about to be expanded. Only available if multiple is false.
       * 
       * @example <caption>Initialize any collapsible in the accordion with the <code class="prettyprint">beforeCollapse</code> callback specified:</caption>
       * $( ".selector" ).ojAccordion({
       *     "beforeCollapse": function( event, ui ) {}
       * });
       *
       * @example <caption>Bind an event listener to the <code class="prettyprint">ojbeforecollapse</code> event:</caption>
       * $( ".selector" ).on( "ojbeforecollapse", function( event, ui ) {} );
       */
      beforeCollapse : null,

      /**
       * Triggered after any collapsible in the accordion has been collapsed (after animation completes).
       * The afterCollapse can be cancelled by calling <code class="prettyprint">event.preventDefault()</code>.
       *
       * @expose 
       * @event 
       * @memberof! oj.ojAccordion
       * @instance
       * @property {Event} event <code class="prettyprint">jQuery</code> event object
       * @property {Object} ui Parameters
       * @property {jQuery} ui.newCollapsible The collapsible that was just collapsed.
       * @property {jQuery} ui.oldCollapsible The collapsible that was just expanded. Only available if multiple is false.
       * 
       * @example <caption>Initialize any collapsible in the accordion with the <code class="prettyprint">afterCollapse</code> callback specified:</caption>
       * $( ".selector" ).ojAccordion({
       *     "afterCollapse": function( event, ui ) {}
       * });
       *
       * @example <caption>Bind an event listener to the <code class="prettyprint">ojaftercollapse</code> event:</caption>
       * $( ".selector" ).on( "ojaftercollapse", function( event, ui ) {} );
       */
      afterCollapse : null

    },

    _ComponentCreate : function ()
    {
      this._super();
      //Bug 18633679 - Stop using ui-helper-reset in the layout widgets.
      this.element
        .addClass("oj-accordion oj-component")
        //aria
        .attr("role", "group");

      this._refresh();
    },

  /* 
   * Component developers: This API and functionality is subject to change pending architectural review!
   * See the baseComponent method for preliminary API doc.
   */
  _showContextMenu: function(menu, event)
  {
    // TODO: is this the right logic for this component?
    menu.show(event, {"launcher": this.element.find(".oj-collapsible-header-icon").first(), "focus": "menu"});
  },
    
    _destroy : function ()
    {
      // clean up main element
      this.element
        .removeClass("oj-accordion oj-component")
        .removeAttr("role");

      this.element.children()
        .removeClass("oj-accordion-collapsible");

      //remove collapsibles created by accordion
      this.element.children(".oj-accordion-created")
        .removeClass("oj-accordion-created")
        .ojCollapsible("destroy");
    },

    _setOption : function (key, value)
    {
      if (key === "multiple")
      {
        // Transition multiple to single.
        // Keep the first expanded one expanded and collapse the rest.
        if (value == false && this.options.multiple == true)
        {
          this.colllapsibles
//TODO:
//            .filter(".oj-collapsible-expanded")
            .not(".oj-collapsible-collapsed")
            .first().siblings(".oj-collapsible")
            .trigger("ojcollapse");
        }
      }

      this._super(key, value);

      if (key === "disabled")
      {
        value = !!value;

        if (value) {
          this.colllapsibles.each(function ()
          {
            //TODO: Don't override if collapsible has disabled set
            if ($(this).ojCollapsible("option", key) == null)
              $(this).ojCollapsible("option", key, value);
          });
        }
        this.element.toggleClass("oj-disabled", value);
      }
    },

    /**
     * Refreshes the visual state of the accordion. JET components require a <code class="prettyprint">refresh()</code> or re-init after the DOM is 
     * programmatically changed underneath the component.
     * 
     * <p>This method does not accept any arguments.
     * 
     * @expose 
     * @memberof! oj.ojAccordion
     * @instance
     * 
     * @example <caption>Invoke the <code class="prettyprint">refresh</code> method:</caption>
     * $( ".selector" ).ojAccordion( "refresh" );
     */
    refresh : function ()
    {
      this._super();
      this._refresh();
    },

    _refresh : function ()
    {
      this._makeCollapsible();
      this._setOption("disabled", this.options.disabled);

      this._setupEvents();
    },

    _makeCollapsible : function ()
    {
      this.element.children(":oj-collapsible")
        .each(function ()
        {
          $(this).ojCollapsible("option", "clickable", "header");
        });

      this.colllapsibles = 
        this.element.children()
          .not(":oj-ojCollapsible")
            .ojCollapsible(
            {
              clickable : "header"
            })
            .addClass("oj-accordion-created")
          .end()
          .addClass("oj-accordion-collapsible");
    },

    _setupEvents : function ()
    {
      var events = 
      {
        "keydown" : this._keydown, 
        "ojbeforeexpand" : this._beforeExpandHandler, 
        "ojafterexpand" : this._expandHandler,
        "ojbeforecollapse" : this._beforeCollapseHandler, 
        "ojaftercollapse" : this._collapseHandler
      };

      this._off(this.colllapsibles);
      this._on(this.colllapsibles, events);
    },

    _keydown : function (event)
    {
      if (event.altKey || event.ctrlKey)
        return;

      //ignore event if target is not a header
//TODO:
//      if ($(event.target).parentsUntil(event.currentTarget)[0] !== 
//          $(event.currentTarget).children()[0])
      if (! ($(event.target).hasClass("oj-collapsible-header")) &&
          ! ($(event.target).hasClass("oj-collapsible-header-icon")))
        return;

      //TODO: add "showDisclsoure"?
      var keyCode = $.ui.keyCode, 
          enabledCollapsibles = this.colllapsibles.not(".oj-disabled"), 
          length = enabledCollapsibles.length, 
          target = $(event.target).closest(".oj-collapsible"), 
          currentIndex = enabledCollapsibles.index(target), 
          toFocus = false;

      if (currentIndex >= 0)
      {
        switch (event.keyCode)
        {
          case keyCode.RIGHT:
          case keyCode.DOWN:
            toFocus = enabledCollapsibles[(currentIndex + 1) % length];
            break;
          case keyCode.LEFT:
          case keyCode.UP:
            toFocus = enabledCollapsibles[(currentIndex - 1 + length) % length];
            break;
          case keyCode.HOME:
            toFocus = enabledCollapsibles[0];
            break;
          case keyCode.END:
            toFocus = enabledCollapsibles[length - 1];
            break;
        }
      }

      if (toFocus)
      {
        if (target)
        {
          $(target).trigger("ojfocusout");
        }
        $(toFocus).trigger("ojfocus");

        event.preventDefault();
      }
    },

/*
  _activate: function( index, value )
  {
    var collapsible = this.colllapsibles[ index ];

    if (collapsible)
    {
      $(collapsible).trigger(value ? "ojafterexpand" : "ojcollapse");
    }
  },
*/

    /* 
     * For single expansion
     *   returns a list of expanded collapsible widgets that are sibling 
     *   of the current event target
     * For multiple expansion
     *   returns an empty set.
     */
    _findTargetSiblings : function (event)
    {
      if (! this.options.multiple)
      {
        var closestCollapsible = $(event.target).closest(".oj-collapsible");

        if (closestCollapsible.parent().is(":oj-ojAccordion"))
          return closestCollapsible
            .siblings(".oj-collapsible:not(.oj-collapsible-collapsed)")
            .map(function()
            {
              return $(this).data("oj-ojCollapsible");
            });
      }
      return $();
    },

    /* 
     * Trigger "beforeCollapse" on all expanded siblings in
     * the before expand handler
     */
    _beforeExpandHandler : function (event, eventData)
    {
      var result, self = this;
      var newData;

        this._findTargetSiblings(event).each(function()
        {
          newData = self._initEventData(event, this.element);

          var beforeCollapsedData = 
          {
            /** @expose */
            newCollapsible : newData.oldCollapsible, 
            /** @expose */
            oldCollapsible : newData.newCollapsible
          };

          result = this._trigger("beforeCollapse", event, beforeCollapsedData);
          return result;
        });

      if (! newData)
      {
        newData = self._initEventData(event, null);
      }

      //oldCollapsible: currently expanded
      //newCollapsible: event.target
      this._trigger("beforeExpand", event, newData);
      return result;
    },

    /* 
     * Collapse all expanded siblings and don't allow cancel
     */
    _expandHandler : function (event, eventData)
    {
      var newData;
      var self = this;

        this._findTargetSiblings(event).each(function ()
        {
          this.collapse(false, event, eventData);

          //oldCollapsible: currently expanded
          //newCollapsible: event.target
          newData = self._initEventData(event, this.element);
        });

      if (! newData)
      {
        newData = self._initEventData(event, null);
      }

      this._trigger("afterExpand", event, newData);
    },

    /* 
     * Trigger "beforecollapse" on all collapsed siblings in
     * the before collapse handler
     */
    _beforeCollapseHandler : function (event, eventData)
    {
      var newData;
      if (eventData.newCollapsible)
      {
        newData = eventData;
      }
      else
      {
        newData = this._initEventData(event, null);
      }

      return this._trigger("beforeCollapse", event, newData);
    },

    /* 
     * Collapse all collapsed siblings and don't allow cancel
     */
    _collapseHandler : function (event, eventData)
    {
      var newData;
      if (eventData.newCollapsible)
      {
        newData = eventData;
      }
      else
      {
        if (event.originalEvent && event.originalEvent.target)
        {
          var collapsible = $(event.originalEvent.target);
          if (collapsible.hasClass("oj-collapsible"))
            newData = this._initEventData(event, collapsible);
        }
        if (! newData)
          newData = this._initEventData(event, null);
      }
      this._trigger("afterCollapse", event, newData);
    },

    _initEventData : function (event, oCollapsible)
    {
      var eventData = 
        {
          /** @expose */
          oldCollapsible : oCollapsible,
          /** @expose */
          newCollapsible : $(event.target)
        };
      return eventData;
    },

    /**
     * Return the subcomponent node represented by the documented locator 
     * attribute values.
     *
     * To lookup a header the locator object should have the following:
     *          subId: 'oj-accordion-header'
     *          index: number
     *
     * To lookup a disclosure icon the locator object should have the following:
     *          subId: 'oj-accordion-header-icon'
     *          index: number
     *
     * To lookup a panel content the locator object should have the following:
     *          subId: 'oj-accordion-content'
     *          index: number
     *
     * To lookup a collapsible the locator object should have the following:
     *          subId: 'oj-accordion-collapsible'
     *          index: number
     *
     * @expose
     * @memberof! oj.ojAccordion
     * @instance
     * @override
     * @param {Object} locator An Object containing at minimum a subId property 
     *        whose value is a string, documented by the component, that allows 
     *        the component to look up the subcomponent associated with that 
     *        string.  It contains:<p>
     *        component: optional - in the future there may be more than one 
     *        component contained within a page element<p>
     *        subId: the string, documented by the component, that the component 
     *        expects in getNodeBySubId to locate a particular subcomponent
     * @returns {Element|null} the subcomponent located by the subId string passed
     *          in locator, if found.<p>
     */
    getNodeBySubId: function(locator)
    {
      if (locator == null)
      {
        return this.element ? this.element[0] : null;
      }

      var subId = locator['subId'],
          index = locator['index'],
          collapsible = this.colllapsibles[index];

      switch (subId)
      {
      case 'oj-accordion-content':
        subId = 'oj-collapsible-content';
        break;

      case 'oj-accordion-header':
        subId = 'oj-collapsible-header';
        break;

      case 'oj-accordion-header-icon':
        subId = 'oj-collapsible-header-icon';
        break;

      case 'oj-accordion-collapsible':
        return collapsible;

      default:
        // Non-null locators have to be handled by the component subclasses
        return null;
      }

      return $(collapsible).ojCollapsible("getNodeBySubId", {subId: subId});
    }


  });
}
());
/**
 * An object used for automation verification of chart axes
 * Applications should not create this object.
 * @param {Object} data An object containing verification data
 * @constructor
 * @export
 */  
oj.ChartAxis = function(data) {
  this._data = data;
};

/**
 * Returns the title of an axis
 * @return {String} The axis title
 * @export
 */
oj.ChartAxis.prototype.getTitle = function() {
  return this._data ? this._data['title'] : null;
};

/**
 * Returns the bounds of an axis
 * @return {Object} An object containing the x, y coordinates and width and height of the axis
 * @export
 */
oj.ChartAxis.prototype.getBounds = function() {
  return this._data ? this._data['bounds'] : null;
};

/**
 * @class 
 * @name oj.ojChart
 * @augments oj.baseComponent
 * 
 * @classdesc
 * <h3 id="chartOverview-section">
 *   JET Chart Component
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#chartOverview-section"></a>
 * </h3>
 * 
 * <p>Chart component for JET with support for bar, line, area, combination, pie, scatter, bubble, and funnel
 * charts.</p>
 * 
 * <p>This component should be bound to an HTML div element, and the SVG DOM that it generates should be treated as a 
 * black box, as it is subject to change.  This component should not be extended.</p>
 * 
 * <pre class="prettyprint">
 * <code>
 * &lt;div data-bind="ojComponent: {
 *   component: 'ojChart',
 *   type: 'bar',
 *   series: [{name: 'Q1 Sales', items: [50, 60, 20]}],  
 *   groups: ['Phones', 'Tablets', 'Laptops']
 * }"/>
 * </code>
 * </pre>
 * 
 * <h3 id="chartOptions-section">
 *   Options
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#chartOptions-section"></a>
 * </h3>
 * 
 * <p>Full documentation for the options method, including APIs for data, style properties, and interactivity, is 
 * available <a title="Options Documentation" href="dvt/chart.xml">here</a>.</p>
 * 
 * @desc Creates a JET Chart.
 * @example <caption>Initialize the Chart with no options specified:</caption>
 * $(".selector").ojChart();
 * 
 * @example <caption>Initialize the Chart with some options:</caption>
 * $(".selector").ojChart({type: 'bar'});
 * 
 * @example <caption>Initialize the Chart via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;div data-bind="ojComponent: {component: 'ojChart'}">
 */
oj.__registerWidget('oj.ojChart', $['oj']['dvtBaseComponent'], 
{
  version : "1.0.0", 
  widgetEventPrefix : "oj", 
  options: {
    /**
     * Triggered when a category of data items is hidden or shown. TODO: This event is in development and may change.
     * 
     * @property {Object} ui event payload
     * @property {Object} ui.category the category that was filtered on
     * @property {string} ui.type specifies whether the category is being filtered 'in' or 'out'
     * 
     * @example <caption>Initialize the component with the <code class="prettyprint">categoryFilter</code> callback specified:</caption>
     * $(".selector").ojChart({
     *   "categoryFilter": function(event, ui){}
     * });
     *
     * @example <caption>Bind an event listener to the <code class="prettyprint">ojcategoryfilter</code> event:</caption>
     * $(".selector").on("ojcategoryfilter", function(event, ui){});
     * 
     * @expose 
     * @event 
     * @memberof! oj.ojChart
     * @instance
     */
    categoryFilter : null,
    
    /**
     * Triggered when a category of data items is highlighted. TODO: This event is in development and may change.
     * 
     * @property {Object} ui event payload
     * @property {Array} ui.categories the categories that are being highlighted
     * @property {string} ui.type specifies whether highlighting is being turned 'on' or 'off'
     * 
     * @example <caption>Initialize the component with the <code class="prettyprint">categoryHighlight</code> callback specified:</caption>
     * $(".selector").ojChart({
     *   "categoryHighlight": function(event, ui){}
     * });
     *
     * @example <caption>Bind an event listener to the <code class="prettyprint">ojcategoryhighlight</code> event:</caption>
     * $(".selector").on("ojcategoryhighlight", function(event, ui){});
     * 
     * @expose 
     * @event 
     * @memberof! oj.ojChart
     * @instance
     */
    categoryHighlight : null,
    
    /**
     * Triggered after data items are selected or de-selected.
     * 
     * @property {Object} ui event payload
     * @property {Array} ui.items an array containing objects describing the selected data items
     * @property {string} ui.items.id the id of the data item, if one was specified
     * @property {string} ui.items.group the group of the data item
     * @property {string} ui.items.series the series of the data item
     * @property {string} ui.endGroup the end group of a marquee selection on a chart with categorical axis
     * @property {string} ui.startGroup the start group of a marquee selection on a chart with categorical axis
     * @property {number} ui.xMax the maximum x value of a marquee selection 
     * @property {number} ui.xMin the minimum x value of a marquee selection 
     * @property {number} ui.yMax the maximum y value of a marquee selection 
     * @property {number} ui.yMin the minimum y value of a marquee selection 
     * 
     * @example <caption>Initialize the component with the <code class="prettyprint">select</code> callback specified:</caption>
     * $(".selector").ojChart({
     *   "select": function(event, ui){}
     * });
     *
     * @example <caption>Bind an event listener to the <code class="prettyprint">ojselect</code> event:</caption>
     * $(".selector").on("ojselect", function(event, ui){});
     * 
     * @expose 
     * @event 
     * @memberof! oj.ojChart
     * @instance
     */
    select : null,
    
    /**
     * Triggered after the viewport is changed due to a zoom or scroll operation.
     * 
     * @property {Object} ui event payload
     * @property {string} ui.endGroup the end group of the new viewport on a chart with categorical axis
     * @property {string} ui.startGroup the start group of the new viewport on a chart with categorical axis
     * @property {number} ui.xMax the maximum x value of the new viewport
     * @property {number} ui.xMin the minimum x value of the new viewport
     * @property {number} ui.yMax the maximum y value of the new viewport
     * @property {number} ui.yMin the minimum y value of the new viewport
     * 
     * @example <caption>Initialize the component with the <code class="prettyprint">viewportChange</code> callback specified:</caption>
     * $(".selector").ojChart({
     *   "viewportChange": function(event, ui){}
     * });
     *
     * @example <caption>Bind an event listener to the <code class="prettyprint">ojviewportchange</code> event:</caption>
     * $(".selector").on("ojviewportchange", function(event, ui){});
     * 
     * @expose 
     * @event 
     * @memberof! oj.ojChart
     * @instance
     */
    viewportChange : null
  },
  
  /**
   * @override
   */
  _CreateComponent : function(context, callback, callbackObj) {
    return DvtChart.newInstance(context, callback, callbackObj);
  },
  
  /**
   * @override
   */
  _GetComponentStyleClasses : function() {
    var styleClasses = this._super();
    styleClasses.push('oj-chart');
    return styleClasses;
  },
  
  /**
   * @override
   */
  _GetChildStyleClasses : function() {
    var styleClasses = this._super();
    styleClasses['oj-chart-footnote'] = {'path' : 'footnote/style', 'property' : 'CSS_TEXT_PROPERTIES'};
    styleClasses['oj-chart-subtitle'] = {'path' : 'subtitle/style', 'property' : 'CSS_TEXT_PROPERTIES'};
    styleClasses['oj-chart-title'] = {'path' : 'title/style', 'property' : 'CSS_TEXT_PROPERTIES'};
    styleClasses['oj-chart-xaxis-tick-label'] = {'path' : 'xAxis/tickLabel/style', 'property' : 'CSS_TEXT_PROPERTIES'};
    styleClasses['oj-chart-xaxis-title'] = {'path' : 'xAxis/titleStyle', 'property' : 'CSS_TEXT_PROPERTIES'};
    styleClasses['oj-chart-yaxis-tick-label'] = {'path' : 'yAxis/tickLabel/style', 'property' : 'CSS_TEXT_PROPERTIES'};
    styleClasses['oj-chart-yaxis-title'] = {'path' : 'yAxis/titleStyle', 'property' : 'CSS_TEXT_PROPERTIES'};
    styleClasses['oj-chart-y2axis-tick-label'] = {'path' : 'y2Axis/tickLabel/style', 'property' : 'CSS_TEXT_PROPERTIES'};
    styleClasses['oj-chart-y2axis-title'] = {'path' : 'y2Axis/titleStyle', 'property' : 'CSS_TEXT_PROPERTIES'};
    styleClasses['oj-legend'] = {'path' : 'legend/textStyle', 'property' : 'CSS_TEXT_PROPERTIES'};
    styleClasses['oj-legend-title'] = {'path' : 'legend/titleStyle', 'property' : 'CSS_TEXT_PROPERTIES'};
    
    // Images
    styleClasses['oj-chart-pan-icon'] = {'path' : '_resources/panUp', 'property' : 'CSS_URL'};
   	styleClasses['oj-chart-pan-icon oj-active'] = {'path' : '_resources/panDown', 'property' : 'CSS_URL'};
    styleClasses['oj-chart-select-icon'] = {'path' : '_resources/selectUp', 'property' : 'CSS_URL'};
   	styleClasses['oj-chart-select-icon oj-active'] = {'path' : '_resources/selectDown', 'property' : 'CSS_URL'};
    styleClasses['oj-chart-zoom-icon'] = {'path' : '_resources/zoomUp', 'property' : 'CSS_URL'};
   	styleClasses['oj-chart-zoom-icon oj-active'] = {'path' : '_resources/zoomDown', 'property' : 'CSS_URL'};
    return styleClasses;
  },
    
  /**
   * @override
   */
  _GetTranslationMap: function() {
    var superMap = this._super();   
    var selfMap = {
      'DvtChartBundle.DEFAULT_GROUP_NAME': this._GetTranslatedResource('labelDefaultGroupName', ['groupName']),
      'DvtChartBundle.EMPTY_TEXT': this._GetTranslatedResource('msgNoData'),
      'DvtChartBundle.LABEL_SERIES': this._GetTranslatedResource('labelSeries', ['seriesName']),
      'DvtChartBundle.LABEL_GROUP': this._GetTranslatedResource('labelGroup', ['groupName']),
      'DvtChartBundle.LABEL_VALUE': this._GetTranslatedResource('labelValue', ['value']),
      'DvtChartBundle.LABEL_TARGET_VALUE': this._GetTranslatedResource('labelTargetValue', ['targetValue']),
      'DvtChartBundle.LABEL_X': this._GetTranslatedResource('labelX', ['x']),
      'DvtChartBundle.LABEL_Y': this._GetTranslatedResource('labelY', ['y']),
      'DvtChartBundle.LABEL_Z': this._GetTranslatedResource('labelZ', ['z']),
      'DvtChartBundle.LABEL_LOW': this._GetTranslatedResource('labelLow', ['low']),
      'DvtChartBundle.LABEL_HIGH': this._GetTranslatedResource('labelHigh', ['high']),
      'DvtChartBundle.LABEL_OTHER': this._GetTranslatedResource('labelOther'),
      'DvtChartBundle.PAN': this._GetTranslatedResource('tooltipPan'),
      'DvtChartBundle.MARQUEE_SELECT': this._GetTranslatedResource('tooltipSelect'),
      'DvtChartBundle.MARQUEE_ZOOM': this._GetTranslatedResource('tooltipZoom')
    }
    
    // TODO Workaround for inheritance of resource from parent not working
    selfMap['DvtChartBundle.EMPTY_TEXT'] = oj.Translations.getResource('oj-dvtBaseComponent.msgNoData');
    
    // Combine with the map from the superclass
    var ret = {};
    for(var key in superMap) { ret[key] = superMap[key]; }
    for(var key in selfMap) { ret[key] = selfMap[key]; }
    
    return ret;
  },
  
  /**
   * @override
   */
  _HandleEvent : function(event) {
    var type = event && event.getType ? event.getType() : null;
    if(type === DvtSelectionEvent.TYPE) {
      var selection = event.getSelection();
      if(selection) {
        // Convert the graph selection context into the JET context
        var selectedItems = [];
        for(var i=0; i<selection.length; i++) {
          var selectedItem = {'id': selection[i].getId(),
                              'series': selection[i].getSeries(),
                              'group': selection[i].getGroup()};
          selectedItems.push(selectedItem);  
        }
        
        // TODO PANGUS: ADD THE MARQUEE SELECT CONTEXT
        
        this._trigger('select', null, {'items': selectedItems});
      }
    }
    else if(type === DvtCategoryHideShowEvent.TYPE_HIDE || type === DvtCategoryHideShowEvent.TYPE_SHOW) {
      var filterType = (type === DvtCategoryHideShowEvent.TYPE_HIDE) ? 'out' : 'in';
      this._trigger('categoryFilter', null, {'category': event.getCategory(), 'type': filterType});
    }
    else if(type === DvtCategoryRolloverEvent.TYPE_OVER || type === DvtCategoryRolloverEvent.TYPE_OUT) {
      var highlightType = (type === DvtCategoryRolloverEvent.TYPE_OVER) ? 'on' : 'off';
      this._trigger('categoryHighlight', null, {'categories': [event.getCategory()], 'type': highlightType});
    }
    else {
      this._super(event);
    }
  },
   
  /**
   * @override
   */
  _LoadResources : function() {
    // Ensure the resources object exists
    if(this.options['_resources'] == null)
      this.options['_resources'] = {};
      
    var resources = this.options['_resources'];
      
    // Add images
    resources['overviewGrippy'] = oj.Config.getResourceUrl('resources/internal-deps/dvt/chart/drag_horizontal.png');
    
    // Add cursors
    resources['panCursorDown'] = oj.Config.getResourceUrl('resources/internal-deps/dvt/chart/hand-closed.cur');
    resources['panCursorUp'] = oj.Config.getResourceUrl('resources/internal-deps/dvt/chart/hand-open.cur');
  },
  
   /**
   * Test authors should target chart sub elements using the following locators:
   * dataItem[seriesIndex][groupIndex] - A data item indexed by its series index and group index. 
   *                                        [groupIndex] is not required for pie and funnel chart types
   * series[seriesIndex] - A legend item that represents the series with the given seriesIndex
   * group[groupIndex] - A categorical axis label that represents the group with the given groupIndex 
   * @override
   * @expose
   */
  getNodeBySubId : function(locator) {
    return this._super(locator);
  },
  
  /**
   * Returns the locator attribute values represented by the subcomponent node.
   * @param {Element} node The subcomponent node used by the component to lookup the subId string
   * @return {Object} An Object containing at minimum a subId property
   * whose value is a string and allows the component to
   * look up the subcomponent associated with that string.  Valide chart subIds include:
   * dataItem[seriesIndex][groupIndex] - A data item indexed by its series index and group index. 
   *                                        [groupIndex] is not required for pie and funnel chart types
   * series[seriesIndex] - A legend item that represents the series with the given seriesIndex
   * group[groupIndex] - A categorical axis label that represents the group with the given groupIndex 
   * @expose
   */
  getSubIdByNode:function(node) {
    return this._super(node);  
  }, 
  
  /**
   * Returns the chart title. 
   * @return {String} The chart title
   * @expose
   */
  getTitle: function() {
    var auto = this._component.getAutomation();
    return auto.getTitle();
  },
  
  /**
   * Returns the group corresponding to the given index
   * @param {String} groupIndex the group index
   * @return {String} The group name corresponding to the given group index
   * @expose
   */
  getGroup: function(groupIndex) {
    var auto = this._component.getAutomation();
    return auto.getGroup(groupIndex);
  },
  
  /**
   * Returns the series corresponding to the given index
   * @param {String} seriesIndex the series index
   * @return {String} The series name corresponding to the given series index
   * @expose
   */
  getSeries: function(seriesIndex) {
    var auto = this._component.getAutomation();
    return auto.getSeries(seriesIndex);
  },
  
  /**
   * Returns number of groups in the chart data
   * @return {Number} The number of groups
   * @expose
   */
  getGroupCount: function() {
    var auto = this._component.getAutomation();
    return auto.getGroupCount();
  },
  
  /**
   * Returns number of series in the chart data
   * @return {Number} The number of series
   * @expose
   */
  getSeriesCount: function() {
    var auto = this._component.getAutomation();
    return auto.getSeriesCount();
  },
  
  /**
   * Returns a ChartDataItem object for automation testing verification.
   * @param {String} seriesIndex The series index
   * @param {String} groupIndex The group index
   * @return {Object} The chart data item with the given series index and group index 
   *                             or null if none exists
   * @expose
   */
  getDataItem : function(seriesIndex, groupIndex) {
    var auto = this._component.getAutomation();
    return new oj.ChartDataItem(auto.getDataItem(seriesIndex, groupIndex));
  },
  
  /**
   * Returns a ChartLegend object for automation testing verification.
   * @return {Object} The legend for this chart
   * @expose
   */
  getLegend : function() {
    var auto = this._component.getAutomation();
    return new oj.ChartLegend(auto.getLegend());
  },
  
  /**
   * Returns a ChartPlotArea object for automation testing verification.
   * @return {Object} The plot area for this chart
   * @expose
   */
  getPlotArea : function() {
    var auto = this._component.getAutomation();
    return new oj.ChartPlotArea(auto.getPlotArea());
  },
  
  /**
   * Returns a ChartAxis object for automation testing verification.
   * @return {Object} The xAxis for this chart or null if it doesn't exist
   * @expose
   */
  getXAxis : function() {
    var auto = this._component.getAutomation();
    return new oj.ChartAxis(auto.getXAxis());
  },
  
  /**
   * Returns a ChartAxis object for automation testing verification.
   * @return {Object} The yAxis for this chart or null if it doesn't exist
   * @expose
   */
  getYAxis : function() {
    var auto = this._component.getAutomation();
    return new oj.ChartAxis(auto.getYAxis());
  },
  
  /**
   * Returns a ChartAxis object for automation testing verification.
   * @return {Object} The y2Axis for this chart or null if it doesn't exist
   * @expose
   */
  getY2Axis : function() {
    var auto = this._component.getAutomation();
    return new oj.ChartAxis(auto.getY2Axis());
  }
});
/**
 * An object used for automation verification of a chart plot area
 * Applications should not create this object.
 * @param {Object} data An object containing verification data
 * @constructor
 * @export
 */  
oj.ChartPlotArea = function(data) {
  this._data = data;
};

/**
 * Returns the bounds of the plot area
 * @return {Object} An object containing the x, y coordinates and width and height of the plotarea
 * @export
 */
oj.ChartPlotArea.prototype.getBounds = function() {
  return this._data ? this._data['bounds'] : null;
};

/**
 * An object used for automation verification of a chart legend
 * Applications should not create this object.
 * @param {Object} data An object containing verification data
 * @constructor
 * @export
 */  
oj.ChartLegend = function(data) {
  this._data = data;
};

/**
 * Returns the title of a legend
 * @return {String} The legend title
 * @export
 */
oj.ChartLegend.prototype.getTitle = function() {
  return this._data ? this._data['title'] : null;
};

/**
 * Returns the bounds of a legend
 * @return {Object} An object containing the x, y coordinates and width and height of the legend
 * @export
 */
oj.ChartLegend.prototype.getBounds = function() {
  return this._data ? this._data['bounds'] : null;
};

/**
 * @class 
 * @name oj.ojSparkChart
 * @augments oj.baseComponent
 * 
 * @classdesc
 * <h3 id="sparkChartOverview-section">
 *   JET Spark Chart Component
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#sparkChartOverview-section"></a>
 * </h3>
 * 
 * <p>Spark Chart component for JET with support for bar, line, area, and floating bar subtypes.  Spark Charts are
 * designed to visualize the trend of a data set in a compact form factor.</p>
 * 
 * <p>This component should be bound to an HTML div element, and the SVG DOM that it generates should be treated as a 
 * black box, as it is subject to change.  This component should not be extended.</p>
 * 
 * <pre class="prettyprint">
 * <code>
 * &lt;div data-bind="ojComponent: {
 *   component: 'ojSparkChart', 
 *   type: 'line', 
 *   items: [5, 8, 2, 7, 0, 9]
 * }"/>
 * </code>
 * </pre>
 * 
 * <h3 id="sparkChartOptions-section">
 *   Options
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#sparkChartOptions-section"></a>
 * </h3>
 * 
 * <p>Full documentation for the options method, including APIs for data, style properties, and interactivity, is 
 * available <a title="Options Documentation" href="dvt/sparkChart.xml">here</a>.</p>
 * 
 * @desc Creates a JET Spark Chart. 
 * @example <caption>Initialize the Chart with no options specified:</caption>
 * $(".selector").ojSparkChart();
 * 
 * @example <caption>Initialize the Spark Chart with some options:</caption>
 * $(".selector").ojSparkChart({type: 'line', items: [5, 8, 2, 7, 0, 9]});
 * 
 * @example <caption>Initialize the Spark Chart via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;div data-bind="ojComponent: {component: 'ojSparkChart'}">
 */
oj.__registerWidget('oj.ojSparkChart', $['oj']['dvtBaseComponent'], 
{
  version : "1.0.0", 
  widgetEventPrefix : "oj", 
  
  /**
   * @override
   */
  _CreateComponent : function(context, callback, callbackObj) {
    return DvtSparkChart.newInstance(context, callback, callbackObj);
  },  
  
  /**
   * @override
   */
  _GetComponentStyleClasses : function() {
    var styleClasses = this._super();
    styleClasses.push('oj-sparkchart');
    return styleClasses;
  },
  
  /**
   * @override
   */
  _Render : function() {
    // Display the title of the surrounding div as the tooltip
    this.options['shortDesc'] = this.element.attr('title');
  
    // Call the super to render
    this._super();
  }
});
/**
 * An object used for automation verification of chart data items
 * Applications should not create this object.
 * @param {Object} data An object containing verification data
 * @constructor
 * @export
 */  
oj.ChartDataItem = function(data) {
  this._data = data;
};

/**
 * Returns the group of a chart data item
 * @returns {String} The data item group
 * @export
 */
oj.ChartDataItem.prototype.getGroup = function() {
  return this._data ? this._data['group'] : null;
};

/**
 * Returns the series of a chart data item
 * @returns {String} The data item series
 * @export
 */
oj.ChartDataItem.prototype.getSeries = function() {
  return this._data ? this._data['series'] : null;
};

/**
 * Returns the border color of a chart data item
 * @returns {String} The data item border color
 * @export
 */
oj.ChartDataItem.prototype.getBorderColor = function() {
  return this._data ? this._data['borderColor'] : null;
};

/**
 * Returns the color of a chart data item
 * @returns {String} The data item color
 * @export
 */
oj.ChartDataItem.prototype.getColor = function() {
  return this._data ? this._data['color'] : null;
};

/**
 * Returns the label of a chart data item
 * @returns {String} The data item label
 * @export
 */
oj.ChartDataItem.prototype.getLabel = function() {
  return this._data ? this._data['label'] : null;
};

/**
 * Returns the value of a chart data item.
 * @returns {Number} The data item value
 * @export
 */
oj.ChartDataItem.prototype.getValue = function() {
  return this._data ? this._data['value'] : null;
};

/**
 * Returns the target value of a chart data item. Only applies to funnel chart types.
 * @returns {Number} The data item target value
 * @export
 */
oj.ChartDataItem.prototype.getTargetValue = function() {
  return this._data ? this._data['targetValue'] : null;
};

/**
 * Returns the tooltip of a chart data item.
 * @returns {String} The data item tooltip
 * @export
 */
oj.ChartDataItem.prototype.getTooltip = function() {
  return this._data ? this._data['tooltip'] : null;
};

/**
 * Returns the x value of a chart data item.
 * @returns {Number} The data item x value
 * @export
 */
oj.ChartDataItem.prototype.getX = function() {
  return this._data ? this._data['x'] : null;
};

/**
 * Returns the y value of a chart data item.
 * @returns {Number} The data item y value
 * @export
 */
oj.ChartDataItem.prototype.getY = function() {
  return this._data ? this._data['y'] : null;
};

/**
 * Returns the z value of a chart data item.
 * @returns {Number} The data item z value
 * @export
 */
oj.ChartDataItem.prototype.getZ = function() {
  return this._data ? this._data['z'] : null;
};

/**
 * Returns whether or not the data item is selected
 * @returns {Boolean} The data item selection state
 * @export
 */
oj.ChartDataItem.prototype.getSelected = function() {
  return this._data ? this._data['selected'] : null;
};
/**
 * oj.Collection based implementation of TreeDataSource
 * @param {Object} options an object containing the following options:<p>
 * root: an oj.Collection specifying the root level Collection<p>
 * childCollectionCallback: a function(oj.Collection,oj.Model):oj.Collection callback to return a child collection given a root and model representing the parent<p>
 * parseMetadata: a function(oj.Model):Object callback to return key, leaf, depth metadata from a given Model<p>
 * @constructor
 * @export
 * @extends oj.DataSource
 */
oj.CollectionTreeDataSource = function(options)
{
    options = options || {};
    this.rootCollection = options['root'];
    this.childCollectionCallback = options['childCollectionCallback'];
    this.parseMetadata = options['parseMetadata'];
    this.sortkey = null;
    this.sortdir = "none";
    // This is a parent->collection cache
    this.cache = {};
    oj.CollectionTreeDataSource.superclass.constructor.call(this);
};

// Default implementation
oj.CollectionTreeDataSource.prototype.parseMetadata = function(model) {    
    return {'key':model['idAttribute']+"="+model['id']};
};

// Subclass from oj.TreeDataSource
oj.Object.createSubclass(oj.CollectionTreeDataSource, oj.TreeDataSource, "oj.CollectionTreeDataSource");

/**
 * Initializes the data source.
 * @export
 */
oj.CollectionTreeDataSource.prototype.Init = function()
{
    // super
    oj.CollectionTreeDataSource.superclass.Init.call(this);
};


/**
 * Returns the number of children for a specified parent.  If the value returned is not >= 0 then it is automatically assumed
 * that the child count is unknown.
 * @param {Object} parent the parent key.  Specify null if inquiring child count of the root.
 * @return {number} the number of children for the specified parent.
 * @export
 */
oj.CollectionTreeDataSource.prototype.getChildCount = function(parent)
{
    var childColl = this.cache[parent];    
    if (childColl) {
        if (childColl.length > 0) {
            return childColl.length;
        }
    }
    this.getChildCollection(parent, {'success': function(coll) {
                return coll.length;
        }});
                                       
    return -1;
};

/**
 * Gets a collection representing the specified parent key's children.
 * @param {Object} key the parent key in which to create an OJ collection for.
 * @param {Object} callbacks success and error callbacks.  The success callback will provide the child collection as the first argument
 * @export
 */
oj.CollectionTreeDataSource.prototype.getChildCollection = function(key, callbacks) {
    this.fetchChildren(key, null, {'success':function(nodeSet) {
            callbacks['success'](nodeSet._getCollection());
    }, 'error':callbacks['error']});
};

/**
 * Fetch the children
 * @param {Object} parent the parent key.  Specify null if fetching children from the root.
 * @param {Object} range information about the range, it must contain the following properties: start, count.<p>
 * range.start the start index of the range in which the children are fetched.<p>
 * range.count the size of the range in which the children are fetched.  <p>
 * @param {Object} callbacks the callbacks to be invoke when fetch children operation is completed.  The valid callback
 *        types are "success" and "error".<p>
 * {function(oj.NodeSet)} callbacks.success the callback to invoke when fetch completed successfully.<p>
 * {function({status: Object})} callbacks.error the callback to invoke when fetch children failed.<p>
 * @param {Object=} options optional parameters for this operation. <p>
 * {boolean=} options.queueOnly true if this fetch request is to be queued and not execute yet.  The implementation must maintain 
 *        the order of the fetch operations.  When queueOnly is false/null/undefined, any queued fetch operations are then
 *        flushed and executed in the order they are queued.  This flag is ignored if the datasource does not support batching.
 * @export
 */
oj.CollectionTreeDataSource.prototype.fetchChildren = function(parent, range, callbacks, options)
{
    range = range || {};
    var start = range['start'] ? range['start'] : 0;
    var count = range['count'] ? range['count'] : -1;
    
    if (parent === null) {
        // Do root
        this.FetchCollection(null, start, count, callbacks, null);
        return;
    }
    // Use child collection callback to set up child collection, then fetch it
    var self = this;
    this._getModelForId(this.rootCollection, parent, 0).done(function(parentModel) {
                                                        if (parentModel) {
                                                            var collection = self.GetChildCollection(parentModel.model);
                                                            self.FetchCollection(collection, start, count, callbacks, parent);
                                                        }
                                                        else {
                                                            // Couldn't find a model for the given Id: call the error if present
                                                            if (callbacks && callbacks['error']) {
                                                                callbacks['error'](parent);
                                                            }
                                                        }
                                                     });
};


// Called by common model when a model is added to a collection
oj.CollectionTreeDataSource.prototype.ModelAdded = function(model, collection, options) {
    var index = 0;
    if (options && options['at']) {
        index = options['at'];
    }
    var event = this._createEvent(this, "insert", index, this._getParentChain(collection), this._putModelInRowset(model));
    this.handleEvent("insert", event);
};

// Called by common model when a model is removed from a collection
oj.CollectionTreeDataSource.prototype.ModelRemoved = function(model, collection, options) {
    var index = 0;
    if (options && options['index']) {
        index = options['index'];
    }
    this._removeCollectionFromCache(model);
    var event = this._createEvent(this, "delete", index, this._getParentChain(collection), null);
    this.handleEvent("delete", event);
};

// Called by common model when a model is updated
oj.CollectionTreeDataSource.prototype.ModelUpdated = function(model, options) {
    var collectionForModel = this._getCollectionForModel(model);
    var index = null;
    var parents = null;
    if (collectionForModel) {
        // If this model's collection is found, get the index where it was found and its parent chain from the actual collection
        index = collectionForModel.index;
        parents = this._getParentChain(collectionForModel.collection);
    }
    var event = this._createEvent(this, "update", index, parents, this._putModelInRowset(model));
    this.handleEvent("update", event);
};

// Called if a collection is refreshed
oj.CollectionTreeDataSource.prototype.CollectionRefreshed = function(collection, resp, options) {
    var event = this._createEvent(this, "refresh", null, this._getParentChain(collection), null);
    this.handleEvent("refresh", event);
};

oj.CollectionTreeDataSource.prototype._putModelInRowset = function(model) {
    var rows = [];
    rows.push(model.attributes);
    var options = {};
    options['idAttribute'] = model['idAttribute'];    
    var rowset = new oj.ArrayRowSet(rows, options);
    rowset.fetch();
    return rowset;
};

// Return an array of parent keys representing the parentage of the given collection.  Relies on cached collection fetches.  Array is from
// child key of root on down to collection's parent
oj.CollectionTreeDataSource.prototype._getParentChain = function(collection) {
    var parents = [];
    var parent = null;
    var coll = collection;
    do {
        parent = this._getParentOfCollection(coll);
        if (parent !== null) {
            if (parent !== oj.CollectionTreeDataSource.ROOT_CACHE_KEY) {
                parents.unshift(parent);
            }
            coll = this._getCollectionOfKey(parent);
        }
    } while (parent != null);
    return parents;
};

// Generate the cache key
oj.CollectionTreeDataSource.ROOT_CACHE_KEY = "%!@ROOT%#@!";
oj.CollectionTreeDataSource.prototype._getCacheKey = function(model) {
    // If model (parent) is null, look for the root
    // If model is not an oj.Model, just use it as the key
    var key = model instanceof oj.Model ? this.parseMetadata(model)['key'] : model;
    return model ? key : oj.CollectionTreeDataSource.ROOT_CACHE_KEY;
};

// Return a cached collection given a parent Model.  Null if not cached
oj.CollectionTreeDataSource.prototype.__getParentsChildCollectionFromCache = function(model) {
    return this.cache[this._getCacheKey(model)];
};

// Put a collection into the cache whose parent is represented by model
oj.CollectionTreeDataSource.prototype._setCollectionInCache = function(model, collection) {
    // Tack on listeners
    collection.on(oj.Events.EventType['ADD'], this.ModelAdded, this);
    collection.on(oj.Events.EventType['REMOVE'], this.ModelRemoved, this);
    collection.on(oj.Events.EventType['CHANGE'], this.ModelUpdated, this);
    collection.on(oj.Events.EventType['SYNC'], this.CollectionRefreshed, this);
    this.cache[this._getCacheKey(model)] = collection;
};

// Remove any collections with the given model as a parent
oj.CollectionTreeDataSource.prototype._removeCollectionFromCache = function(model) {
    var key = this._getCacheKey(model);
    for (var prop in this.cache) {
        if (this.cache.hasOwnProperty(prop)) {
            if (prop === key) {
                // Found it: remove listeners and delete it
                this.cache[key].off(null, null, this);
                delete this.cache[key];
                return;
            }
        }
    }
};

// Determine if a model representing a given parent key is found in the given collection
oj.CollectionTreeDataSource.prototype._keyInCollection = function(key, collection) {
    var count = collection.length;
    for (var i = 0; i < count; i++) {
        var currKey = this._getCacheKey(collection.at(i));
        if (key === currKey) {
            return true;
        }
    }
    return false;
};

// Get the collection and index of the given model
oj.CollectionTreeDataSource.prototype._getCollectionForModel = function(model) {
    // Search the cache for the parent key
    for (var prop in this.cache) {
        if (this.cache.hasOwnProperty(prop)) {
            var collection = this.cache[prop];
            for (var i = 0; i < collection.length; i++) {
                if (collection.at(i) === model) {
                    return {index:i, collection:collection};
                }
            }
        }
    }
    return null;    
    
};

// Get the collection containing the given key
oj.CollectionTreeDataSource.prototype._getCollectionOfKey = function(key) {
    // Search the cache for the parent key
    for (var prop in this.cache) {
        if (this.cache.hasOwnProperty(prop)) {
            var collection = this.cache[prop];
            if (this._keyInCollection(key, collection)) {
                return collection;
            }
        }
    }
    return null;    
};

// Get the parent key for the given collection from the cache, if found
oj.CollectionTreeDataSource.prototype._getParentOfCollection = function(collection) {
    // Search the cache for the parent key
    for (var prop in this.cache) {
        if (this.cache.hasOwnProperty(prop)) {
            if (this.cache[prop] === collection) {
                return prop;
            }
        }
    }
    return null;
};

// Return an object giving the child collection for the given model along with a boolean indicating whether the collection was found 
// in cache. 
oj.CollectionTreeDataSource.prototype.GetChildCollection = function(parentModel) {    
    // Is it in the cache?
    var cached = true;
    var collection = this.__getParentsChildCollectionFromCache(parentModel);
    if (!collection) {
        // Nothing found at all yet
        cached = false;
        // Ask the app for the child collection for the given model
        collection = this.childCollectionCallback(this.rootCollection, parentModel);
        if (collection != null) {
            // Make sure we transfer sorting properties...
            this._applySortToCollection(collection);
            // And put it in the cache
            this._setCollectionInCache(parentModel, collection);
        }
    }
    
    return {collection:collection,cached:cached};
};

oj.CollectionTreeDataSource.prototype._createEvent = function(source, operation, index, parent, data) {
    return {'source':source, 'operation':operation, 'index':index, 'parent':parent, 'data':data};
};

// Call to fetch models for an already-created collection
oj.CollectionTreeDataSource.prototype.FetchCollection = function(collection, start, count, callbacks, parent) {
    var self = this;
    if (collection === null) {
        // Fetch the root
        // Check for the root in the cache
        collection = this.__getParentsChildCollectionFromCache(null);
        if (!collection) {
            // Not found, put a representation in there
            collection = {collection:self.rootCollection,cached:false};
            self._setCollectionInCache(null, this.rootCollection);
        }
        else {
            // Root was found precached: set up its information
            collection = {collection:collection, cached:true};
        }
    }
    if (collection) {
        self._fetch(collection, function (coll) {
                                    if (callbacks['success']) {
                                        // return a nodeset version of this fetched collection via the callback
                                        callbacks['success'](self._getNodeSet(coll, parent, start, count));
                                    }
                                }, callbacks['error']);    
    }
};

// Turn collection into a CollectionNodeSet
oj.CollectionTreeDataSource.prototype._getNodeSet = function(collection, parent, start, count) {
    return new oj.CollectionNodeSet(parent, collection, this, start, count);
};

// Do any of the models in this collection or its children have the given key
oj.CollectionTreeDataSource.prototype._scanForKey = function(collection, key) {
    // Search collection for key
    var dfd = $.Deferred();
    var self = this;
    
    function checkNext(index, collection, key) {
        if (index < collection.length) {
            // Get the model at location index
            collection.at(index, {'deferred':true}).done(function (model) {
                                                        // Does the retrieved model match the key when parsed out?  If so return it
                                                        if (model) {
                                                            var parse = self.parseMetadata(model);
                                                            if (key === parse['key']) {
                                                                dfd.resolve(model);
                                                                return dfd;
                                                            }
                                                        }
                                                        // No model or no match: go to the next model in the collection
                                                        index++;
                                                        checkNext(index, collection, key);
                                                     });
        }
        else {
            // Hit the end: not found
            dfd.resolve(null);
            return;
        }
    }
    // Start checking at the 0th model in the collection
    checkNext(0, collection, key);
    return dfd;
};

// Returns a promise with an object giving the model that corresponds to the given key, and the depth in the hierarchy at which it was found
oj.CollectionTreeDataSource.prototype._getModelForId = function(collection, key, depth) {
    var dfd = $.Deferred();
    
    var self = this;
    // Does the starting collection contain the key?
    this._scanForKey(collection, key).done(function (model) {
        // Yes, resolve (return it)
        if (model) {
            dfd.resolve({model:model, depth: depth});
            return dfd;
        }
        // It does not
        // Wrong collection: search each model's child collections, and check recursively
        var max = collection.length;

        // Check each model in collection now for key
        function getNextCollection(index, tds) {
            if (index < max) {
                // Return an object containing the child collection of the current collection + whether its cached
                var childColl = tds.GetChildCollection(collection.at(index));
                if (!childColl.collection) {
                    // No child collection found: move on to the next model in the current collection
                    index++;
                    getNextCollection(index, tds);
                } else {
                    // Fetch the child collection if necessary
                    tds._fetch(childColl, function(fetchColl) {
                                    // Now check the child collection recursively for the key, moving depth down 1
                                    tds._getModelForId(fetchColl, key, depth+1).done(function(childModel) {
                                                                                // Found the model in this collection: unwind
                                                                                if (childModel) {
                                                                                    // Found somewhere down this tree
                                                                                    dfd.resolve(childModel);
                                                                                    return;
                                                                                } else {
                                                                                    // Not found down that tree
                                                                                    // Move to the next model
                                                                                    index++;
                                                                                    getNextCollection(index, tds);
                                                                                }
                                                                            });                                
                                }, null);
                }
            }
            else {
                // Hit the end
                dfd.resolve(null);
            }
        }
        // Start checking the collection at the 0th model
        getNextCollection(0, self);
    });
    
    return dfd.promise();
};

// Do a fetch or just return the collection if it came from cache
oj.CollectionTreeDataSource.prototype._fetch = function(collectionCacheObj, success, error) {
    var cached = collectionCacheObj.cached;
    if (cached) {
        // If it's cached, it's fetched
        success(collectionCacheObj.collection);
    }
    else {
        // apply sorting if necessary
        if (this.sortkey && this.sortkey !== "none") {
            collectionCacheObj.collection.comparator = this.sortkey;
            collectionCacheObj.collection.sortDirection = this.sortdir;
        }
        if (collectionCacheObj.collection.length > 0) {
            // Already fetched: just return
            success(collectionCacheObj.collection);
            return;
        }
        // Do a real fetch from the collection's url
        collectionCacheObj.collection.fetch({'success':function(fetchColl) {
                // Tack on handlers
                success(fetchColl);
        }, 'error':error});
    }
};

/**
 * Fetch all children and their children recursively from a specified parent.
 * @param {Object} parent the parent key.  Specify null to fetch everything from the root (i.e. expand all)
 * @param {Object} callbacks the callbacks to be invoke when fetch children operation is completed.  The valid callback
 *        types are "success" and "error".<p>
 * {function(oj.CollectionNodeSet)} success the callback to invoke when fetch completed successfully.<p>
 * {function({status: Object})} error the callback to invoke when fetch children failed.<p>
 * @param {Object=} options optional parameters for this operation.<p>
 *  {number=} start the index related to parent in which to begin fetching descendents from.  If this is not specified, then <p>
 *  {number=} maxCount the maximum number of children to fetch.  If a non-positive number is specified, then the value is ignored and
 *        there is no maximum fetch count.
 * @export
 */
oj.CollectionTreeDataSource.prototype.fetchDescendents = function(parent, callbacks, options)
{
    var self = this;
    if (parent === null) {
        // Do root
        this.FetchCollection(null, 0, -1, {'success':function(nodeSet) {
                                                    nodeSet.FetchDescendants({'success':function() {
                                                            if (callbacks['success']) {
                                                                callbacks['success'](nodeSet);
                                                            }
                                                    }});
        }}, null);
        return;
    }
    // Use child collection callback to set up child collection, then fetch it
    this._getModelForId(this.rootCollection, parent, 0).done(function(parentModel) {
                                                        if (parentModel) {
                                                            var collection = self.GetChildCollection(parentModel.model);
                                                            self.FetchCollection(collection, 0, -1, {'success':function(nodeSet) {
                                                                    nodeSet.FetchDescendants({'success':function() {
                                                                            if (callbacks['success']) {
                                                                                callbacks['success'](nodeSet);
                                                                            }
                                                                    }});                                                                    
                                                            }}, parent);
                                                        }
                                                     });
};

/**
 * Performs a sort operation on the tree data.
 * @param {Object} criteria the sort criteria.  It must contain the following properties: key, direction<p>
 * criteria.key the key identifying the attribute (column) to sort on<p>
 * criteria.direction the sort direction, valid values are "ascending", "descending", "none" (default)<p>
 * @param {function({status: Object})} callbacks.success the callback to invoke when the sort completed successfully.<p>
 * callbacks.error the callback to invoke when sort failed.
 * @export
 */
oj.CollectionTreeDataSource.prototype.sort = function(criteria, callbacks)
{
    var key = criteria['key'];
    var dir = criteria['direction'];
    var needSort = false;
    if (key !== this.sortkey) {
        this.sortkey = key;
        needSort = true;
    }
    if (dir !== this.sortdir) {
        this.sortdir = dir;
        needSort = true;
    }
    if (needSort) {
        // If clearing, clear the cache
        if (this.sortdir === "none") {
            this.cache = {};
        }
        // Go off and sort each collection, as long as it has "criteria" as one of its attributes
        for (var prop in this.cache) {
            if (this.cache.hasOwnProperty(prop)) {
                var collection = this.cache[prop];
                this._applySortToCollection(collection);
            }
        }
    }
    if (callbacks && callbacks['success']) {
        callbacks['success']();
    }
};

oj.CollectionTreeDataSource.prototype._applySortToCollection = function(collection) {
    collection['comparator'] = this.sortkey;
    collection['sortDirection'] = (this.sortdir === "ascending") ? 1 : -1;
    collection.sort();    
};

/**
 * Returns the current sort criteria of the tree data.
 * @return {Object} the current sort criteria.  It should contain the following properties: key, direction where
 *         criteria.key the key identifying the attribute (column) to sort on.  Value is null if it's not sorted.
 *         criteria.direction the sort direction, valid values are "ascending", "descending", "none" (default)
 * @export
 */
oj.CollectionTreeDataSource.prototype.getSortCriteria = function()
{
    return {'key': this.sortkey, 'direction': this.sortdir};
};

/**
 * Moves a row from one location to another (different position within the same parent or a completely different parent)
 * @param {Object} rowToMove the key of the row to move
 * @param {Object} referenceRow the key of the reference row which combined with position are used to determine 
 *        the destination of where the row should moved to.
 * @param {number|string} position The position of the moved row relative to the reference row.  
 *        This can be a string: "before", "after", "inside", "first", "last", or the zero based index to position 
 *        the element at a specific point among the reference row's current children.
 * @param {function()} callbacks.success the callback to invoke when the move completed successfully.  
 * @param {function({status: Object})} callbacks.error the callback to invoke when move failed.
 * @export
 */ 
oj.CollectionTreeDataSource.prototype.move = function(rowToMove, referenceRow, position, callbacks)
{
    oj.Assert.failedInAbstractFunction();
};

/**
 * Checks whether a move operation is valid.
 * @param {Object} rowToMove the key of the row to move
 * @param {Object} referenceRow the key of the reference row which combined with position are used to determine 
 *        the destination of where the row should moved to.
 * @param {number|string} position The position of the moved row relative to the reference row.  
 *        This can be a string: "before", "after", "inside", "first", "last", or the zero based index to position 
 *        the element at a specific point among the reference row's current children.
 * @return {string} returns "valid" if the move is valid, "invalid" otherwise.
 * @export
 */ 
oj.CollectionTreeDataSource.prototype.moveOK = function(rowToMove, referenceRow, position)
{
    return "invalid";
};

/**
 * Determines whether this CollectionTreeDataSource supports the specified feature.
 * @param {string} feature the feature in which its capabilities is inquired.  Currently the valid features "sort", 
 *        "move", "fetchDescendents", "batchFetch"
 * @return {string|null} the name of the feature.  Returns null if the feature is not recognized.
 *         For "sort", the valid return values are: "default", "none".  
 *         For "fetchDescendents", the valid return values are: "enable", "disable", "suboptimal".  
 *         For "move", the valid return values are: "default", "none".  
 *         For "batchFetch", the valid return values are: "enable", "disable".  
 * @export
 */
oj.CollectionTreeDataSource.prototype.getCapability = function(feature)
{
    if (feature === "sort") {
        return "default";
    }
    if (feature === "move") {
        return "none";
    }
    if (feature === "batchFetch") {
        return "disable";
    }
    if (feature === "fetchDescendants") {
        return "disable";
    }
    return null;
};


/**
 * A CollectionNodeSet represents a collection of nodes.  The CollectionNodeSet is an object returned by the success callback
 * of the fetchChildren method on CollectionTreeDataSource.  
 * @constructor
 * @export
 */
oj.CollectionNodeSet = function(parentKey, collection, treeDataSource, start, count)
{
    this.parentKey = parentKey;
    this.collection = collection;
    this.childNodeSet = [];
    this.treeDataSource = treeDataSource;
    // Can't have start exceeding valid indices
    this.start = start < collection.length ? start : collection.length-1;
    // Unknown count: we'll assign it.  Also can't have count exceeding collection size
    this.count = count === -1 ? collection.length : Math.min(collection.length, count);
};

oj.CollectionNodeSet.prototype.FetchDescendants = function(callbacks) {
    this._fetchDescendants(this, true).done(function () {
        if (callbacks['success']) {
            callbacks['success']();
        }
    });
};

oj.CollectionNodeSet.prototype._fetchDescendants = function(nodeSet, topLevel) {  
    var dfd = $.Deferred();
    var count = nodeSet.getCount();

    // Walk over each node in this node set, and fetch all the descendants of each
    function nextNode(index) {
        if (index < count) {
            nodeSet.FetchChildNodeSet(index, {'success':function(childNodeSet) {
                                                        if (childNodeSet !== null) {
                                                            nodeSet._fetchDescendants(childNodeSet, false).done(function() {
                                                                nextNode(index+1);
                                                            });
                                                        }
                                                        else {
                                                            nextNode(index+1);
                                                        }
                                                    }});
        }
        else {
            dfd.resolve();
        }
    }
    nextNode(0);
    
    return dfd.promise();
};

oj.CollectionNodeSet.prototype.FetchChildNodeSet = function(index, callbacks) {
    var model = this.collection.at(index);
    var parse = this.treeDataSource.parseMetadata(model);
    if (parse['leaf']) {
        // We're at the leaf: don't fetch any more
        this.childNodeSet[index] = null;
        callbacks['success'](null);
        return;
    }
    
    var collection = this.treeDataSource.GetChildCollection(model);
    var parentKey = this.treeDataSource.parseMetadata(model)['key'];
    var self = this;
    this.treeDataSource.FetchCollection(collection, 0, -1, {'success':function(nodeSet) {
            self.childNodeSet[index] = nodeSet;
            callbacks['success'](nodeSet);
    }}, parentKey); 
};

oj.CollectionNodeSet.prototype._getCollection = function() {
    return this.collection;
};

/**
* Gets the parent key for this result set.  
* @return {Object} the parent key for this result set. 
* @export
*/
oj.CollectionNodeSet.prototype.getParent = function()
{
    return this.parentKey;
};

/**
* Gets the start index of the result set.  
* @return {number} the start index of the result set.
* @export	
*/
oj.CollectionNodeSet.prototype.getStart = function()
{
    return this.start;
};

/**
* Gets the actual count of the result set.  
* @return {number} the actual count of the result set.
* @export	
*/
oj.CollectionNodeSet.prototype.getCount = function()
{
    return this.count;
};

/**
* Gets the data of the specified index.  An error is throw when 1) the range is not yet available and
* 2) the index specified is out of bounds. 
* @param {number} index the index of the node/row in which we want to retrieve the data from.  
* @return {Object} the data for the specified index.  oj.RowData should be returned for data that represents a row
*         with a number of columns.
* @export
*/
oj.CollectionNodeSet.prototype.getData = function(index)
{
    this._checkRange(index);
    return this.collection.at(index).attributes;
};

oj.CollectionNodeSet.prototype._checkRange = function(index) {
    if (index < this.start || index > this.start+this.count) {
        // Out of range
        throw "Out of range";
    }
};

/**
* Gets the metadata of the specified index.  An error is throw when 1) the range is not yet available and 
* 2) the index specified is out of bounds. 
* The metadata that the data source must return are:
*  1) key - Object, the key of the node/row.
*  2) leaf - boolean, true if it's a leaf, false otherwise. 
*  3) depth? - number, the depth of the node/row. (or should the caller just calculate it?)
* @param {number} index the index of the node/row in which we want to retrieve the metadata from.  
* @return {Object} the metadata object for the specific index.
* @export
*/	
oj.CollectionNodeSet.prototype.getMetadata = function(index)
{
    this._checkRange(index);
    
    var metadata = {};

    var model = this.collection.at(index);
    
    var parse = this.treeDataSource.parseMetadata(model);
    metadata['key'] = parse['key'];
    metadata['leaf'] = parse['leaf'];
    metadata['depth'] = parse['depth'];

    return metadata;
};


/**
 * Gets the node set child of the specified index.
 * @param {number} index the index of the node/row in which we want to retrieve the child node set
 * @return {oj.CollectionNodeSet|null} the child node set representing the child collection.
 * @export
 */
oj.CollectionNodeSet.prototype.getChildNodeSet = function(index) {
    this._checkRange(index);
    
    return this.childNodeSet[index];
};
/*!
 * jQuery UI Accordion 1.10.3
 * http://jqueryui.com
 *
 * jQuery Mobile 1.3.2
 * http://jquerymobile.com
 (
 * Copyright 2010, 2013 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/accordion/
 *
 * Depends:
 *  jquery.ui.core.js
 *  jquery.ui.widget.js
 */
/**
 * @class 
 * @name oj.ojCollapsible
 * @augments oj.baseComponent
 * 
 * @classdesc
 * <h3 id="collapsibleOverview-section">
 *   JET Collapsible Component
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#collapsibleOverview-section"></a>
 * </h3>
 * 
 * <p>Description: Themeable, WAI-ARIA-compliant collapsible with mouse and keyboard interactions for navigation.
 * 
 * <p>A JET Collapsible can be created from any valid markup as long as the root element has at least two children: the first element for the header and the second element for the content.
 * 
 * <pre class="prettyprint">
 * <code>
 * &lt;div id="collapsible">
 *   &lt;h3>Header 1&lt;/h3>
 *   &lt;p>Content 1&lt;/p>
 * &lt;/div>
 * </code></pre>
 * 
 * <h3 id="keyboard-section">
 *   Keyboard interaction
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
 * </h3>
 * 
 * <p>
 * <h5>When the focus is on the header</h5>
 * </p>
 * 
 * <table class="keyboard-table">
 *   <thead>
 *     <tr>
 *       <th>Key</th>
 *       <th>Use</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td><kbd>Space or Enter</kbd></td>
 *       <td> Toggle disclosure state.</tr>
 *   </tbody>
 *  </table>
 *
 * <p>Disabled items can receive keyboard focus, but do not allow any other interaction.
 * 
 * 
 * <h3 id="rtl-section">
 *   Reading direction
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#rtl-section"></a>
 * </h3>
 * 
 * <p>As with any JET component, in the unusual case that the directionality (LTR or RTL) changes post-init, the collapsible must be <code class="prettyprint">refresh()</code>ed.
 * 
 * 
 * <h3 id="pseudos-section">
 *   Pseudo-selectors
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#pseudos-section"></a>
 * </h3>
 * 
 * <p>The <code class="prettyprint">:oj-collapsible</code> pseudo-selector can be used in jQuery expressions to select JET Collapsible.  For example:
 * 
 * <pre class="prettyprint">
 * <code>$( ":oj-collapsible" ) // selects all JET Collapsible on the page
 * $myEventTarget.closest( ":oj-collapsible" ) // selects the closest ancestor that is a JET Collapsible
 * </code></pre>
 * 
 * 
 * <h3 id="jqui2jet-section">
 *   JET for jQuery UI developers
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#jqui2jet-section"></a>
 * </h3>
 * 
 * <ol>
 *   <li>JET Collapsible supports expandArea option: specifies where to click to toggle disclosure. Default is "disclosureIcon", however if a collapsible is inside an Accordion, default is "header"</li>
 * </ol>
 * 
 * <p>Also, event names for all JET components are prefixed with "oj", instead of component-specific prefixes like "collapsible".  
 * 
 * <!-- - - - - Above this point, the tags are for the class.
 *              Below this point, the tags are for the constructor (initializer). - - - - - - -->
 * 
 * @desc Creates a JET Collapsible. 
 * @example <caption>Initialize the collapsible with no options specified:</caption>
 * $( ".selector" ).ojCollapsible();
 * 
 * @example <caption>Initialize the collapsible with some options and callbacks specified:</caption>
 * $( ".selector" ).ojCollapsible( { "disabled": true, "create": function( event, ui ) {} } );
 * 
 * @example <caption>Initialize the collapsible via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;div id="collapsible" data-bind="ojComponent: { component: 'ojCollapsible', 
 *                                             expandArea: "header", 
 *                                             expanded: true }">
 */
(function ()
{
  var uid = 0, 
      OPEN_ICON = "oj-collapsible-open-icon", 
      CLOSE_ICON = "oj-collapsible-close-icon";

  oj.__registerWidget("oj.ojCollapsible", $['oj']['baseComponent'], 
  {
    version : "1.0.0", 
    widgetEventPrefix : "oj",
    options : 
    {
      /** 
       * Specifies if the content is expanded initially.
       *
       * @expose 
       * @memberof! oj.ojCollapsible
       * @instance
       * @type {boolean}
       * @default <code class="prettyprint">true</code>
       *
       * @example <caption>Initialize the collapsible with the <code class="prettyprint">expanded</code> option specified:</caption>
       * $( ".selector" ).ojCollapsible( { "expanded": false } );
       * 
       * @example <caption>Get or set the <code class="prettyprint">expanded</code> option, after initialization:</caption>
       * // getter
       * var expanded = $( ".selector" ).ojCollapsible( "option", "expanded" );
       * 
       * // setter
       * $( ".selector" ).ojCollapsible( "option", "expanded", true );
       */
      expanded : false, 

      /** 
       * Disables the collapsible if set to <code class="prettyprint">true</code>.
       * @name disabled
       * @memberof! oj.ojCollapsible
       * @instance
       * @type {boolean|null}
       * @default <code class="prettyprint">false</code>
       * @example <caption>Initialize the collapsible with the <code class="prettyprint">disabled</code> option specified:</caption>
       * $( ".selector" ).ojCollapsible( { "disabled": true } );
       * 
       * @example <caption>Get or set the <code class="prettyprint">disabled</code> option, after initialization:</caption>
       * // getter
       * var disabled = $( ".selector" ).ojCollapsible( "option", "disabled" );
       * 
       * // setter
       * $( ".selector" ).ojCollapsible( "option", "disabled", true );
       */
      disabled: null,

      /** 
       * The type of event to expand/collapse the collapsible
       * To expand the collapsible on hover, use "mouseover".
       *
       * @expose 
       * @memberof! oj.ojCollapsible
       * @instance
       * @type {string}
       * @default <code class="prettyprint">"click"</code>
       *
       * @example <caption>Initialize the collapsible with the <code class="prettyprint">expandOn</code> option specified:</caption>
       * $( ".selector" ).ojCollapsible( { "expandOn": "mouseover" } );
       * 
       * @example <caption>Get or set the <code class="prettyprint">expandOn</code> option, after initialization:</caption>
       * // getter
       * var expandOn = $( ".selector" ).ojCollapsible( "option", "expandOn" );
       * 
       * // setter
       * $( ".selector" ).ojCollapsible( "option", "expandOn", "mouseover" );
       */
      expandOn : "click", 

      /** 
       * Where in the header to click to toggle disclosure. Valid values: disclosureIcon or header
       *
       * @expose 
       * @memberof! oj.ojCollapsible
       * @instance
       * @type {string}
       * @default <code class="prettyprint">"disclosureIcon"</code>
       *
       * @example <caption>Initialize the collapsible with the <code class="prettyprint">expandArea</code> option specified:</caption>
       * $( ".selector" ).ojCollapsible( { "expandArea": "header" } );
       * 
       * @example <caption>Get or set the <code class="prettyprint">expandArea</code> option, after initialization:</caption>
       * // getter
       * var expandArea = $( ".selector" ).ojCollapsible( "option", "expandArea" );
       * 
       * // setter
       * $( ".selector" ).ojCollapsible( "option", "expandArea", "header" );
       */
      expandArea : "disclosureIcon",

      // callbacks
      /**
       * Triggered immediately before the collapsible is expanded.
       * The beforeExpand can be cancelled by calling <code class="prettyprint">event.preventDefault()</code>.
       *
       * @expose 
       * @event 
       * @memberof! oj.ojCollapsible
       * @instance
       * @property {Event} event <code class="prettyprint">jQuery</code> event object
       * @property {Object} ui Parameters
       * @property {jQuery} ui.header The header that is about to be expanded.
       * @property {jQuery} ui.content The content that is about to be expanded.
       * 
       * @example <caption>Initialize the collapsible with the <code class="prettyprint">beforeExpand</code> callback specified:</caption>
       * $( ".selector" ).ojCollapsible({
       *     "beforeExpand": function( event, ui ) {}
       * });
       *
       * @example <caption>Bind an event listener to the <code class="prettyprint">ojbeforeexpand</code> event:</caption>
       * $( ".selector" ).on( "ojbeforeexpand", function( event, ui ) {} );
       */
      beforeExpand : null,

      /**
       * Triggered after the collapsible has been expanded (after animation completes).
       * The afterExpand can be cancelled by calling <code class="prettyprint">event.preventDefault()</code>.
       *
       * @expose 
       * @event 
       * @memberof! oj.ojCollapsible
       * @instance
       * @property {Event} event <code class="prettyprint">jQuery</code> event object
       * @property {Object} ui Parameters
       * @property {jQuery} ui.header The header that was just expanded.
       * @property {jQuery} ui.content The content that was just expanded.
       * 
       * @example <caption>Initialize the collapsible with the <code class="prettyprint">afterExpand</code> callback specified:</caption>
       * $( ".selector" ).ojCollapsible({
       *     "afterExpand": function( event, ui ) {}
       * });
       *
       * @example <caption>Bind an event listener to the <code class="prettyprint">ojafterExpand</code> event:</caption>
       * $( ".selector" ).on( "ojafterExpand", function( event, ui ) {} );
       */
      afterExpand : null, 

      /**
       * Triggered immediately before the collapsible is collapsed.
       * The beforeCollapse can be cancelled by calling <code class="prettyprint">event.preventDefault()</code>.
       *
       * @expose 
       * @event 
       * @memberof! oj.ojCollapsible
       * @instance
       * @property {Event} event <code class="prettyprint">jQuery</code> event object
       * @property {Object} ui Parameters
       * @property {jQuery} ui.header The header that is about to be collapsed.
       * @property {jQuery} ui.content The content that is about to be collapsed.
       * 
       * @example <caption>Initialize the collapsible with the <code class="prettyprint">beforeCollapse</code> callback specified:</caption>
       * $( ".selector" ).ojCollapsible({
       *     "beforeCollapse": function( event, ui ) {}
       * });
       *
       * @example <caption>Bind an event listener to the <code class="prettyprint">ojbeforecollapse</code> event:</caption>
       * $( ".selector" ).on( "ojbeforecollapse", function( event, ui ) {} );
       */
      beforeCollapse : null,

      /**
       * Triggered after the collapsible has been collapsed (after animation completes).
       * The afterCollapse can be cancelled by calling <code class="prettyprint">event.preventDefault()</code>.
       *
       * @expose 
       * @event 
       * @memberof! oj.ojCollapsible
       * @instance
       * @property {Event} event <code class="prettyprint">jQuery</code> event object
       * @property {Object} ui Parameters
       * @property {jQuery} ui.header The header that was just collapsed.
       * @property {jQuery} ui.content The content that was just collapsed.
       * 
       * @example <caption>Initialize the collapsible with the <code class="prettyprint">afterCollapse</code> callback specified:</caption>
       * $( ".selector" ).ojCollapsible({
       *     "afterCollapse": function( event, ui ) {}
       * });
       *
       * @example <caption>Bind an event listener to the <code class="prettyprint">ojafterCollapse</code> event:</caption>
       * $( ".selector" ).on( "ojafterCollapse", function( event, ui ) {} );
       */
      afterCollapse : null, 

      /**
       * Fired whenever a supported component option changes, whether due to user interaction or programmatic
       * intervention.  If the new value is the same as the previous value, no event will be fired.
       *
       * Currently there is one supported option, <code class="prettyprint">"expanded"</code>.  Additional
       * options may be supported in the future, so listeners should verify which option is changing
       * before taking any action.
       *
       * @expose
       * @event
       * @memberof! oj.ojCollapsible
       * @instance
       * @property {Event} event <code class="prettyprint">jQuery</code> event object
       * @property {Object} ui Parameters
       * @property {string} ui.option the name of the option that is changing
       * @property {boolean} ui.previousValue the previous value of the option
       * @property {boolean} ui.value the current value of the option
       * @property {Object} ui.optionMetadata information about the option that is changing
       * @property {string} ui.optionMetadata.writeback <code class="prettyprint">"shouldWrite"</code> or
       *           <code class="prettyprint">"shouldNotWrite"</code>.  For use by the JET writeback mechanism.
       *
       */
      optionChange: null

    },

    _ComponentCreate : function ()
    {
      this._super();
      this.activatable = $();
      //Bug 18633679 - Stop using ui-helper-reset in the layout widgets.
      this.element.addClass("oj-collapsible oj-component")

      this._processPanels();
      this._refresh();
    },

    /* 
     * Component developers: This API and functionality is subject to change pending architectural review!
     * See the baseComponent method for preliminary API doc.
     */
    _showContextMenu: function(menu, event)
    {
      // TODO: is this the right logic for this component?
      menu.show(event, {"launcher": this.element.find(".oj-collapsible-header-icon").first(), "focus": "menu"});
    },

    _createIcons : function ()
    {
      var options = this.options;
      var icon = (options.expanded ? OPEN_ICON : CLOSE_ICON);
      var iconTag = this._isDisabled() ? $("<span>") : $("<a href='#'>");

      iconTag.addClass("oj-component-icon oj-clickable-icon oj-collapsible-header-icon " + icon)
        .attr("aria-labelledby", this.header.attr( "id" ))
        .prependTo(this.header);

      this.header.addClass("oj-collapsible-icons ");
    },

    _destroyIcons : function ()
    {
      this.header
        .removeClass("oj-collapsible-icons")
        .children(".oj-collapsible-header-icon")
        .remove();
    },

    _destroy : function ()
    {
      this._cleanup();

      // clean up main element
      this.element
        .removeClass("oj-collapsible oj-component oj-collapsible-collapsed oj-disabled");

      // clean up headers
      if (this._isDisabled())
        this._findFocusables(this.header).removeAttr("tabIndex");

      this.header
        .removeClass("oj-collapsible-header")
        .each(function ()
        {
          if (/^oj-collapsible/.test(this.id))
          {
            this.removeAttribute("id");
          }
        });

      //aria
      var focusable = this._findFirstFocusableInHeader();
      focusable.removeAttr("role")
        .removeAttr("aria-controls")
        .removeAttr("aria-expanded")
        .removeAttr("aria-disabled");

      this._destroyIcons();

      this._findFocusables(this.content).removeAttr("tabIndex");

      // clean up content panels
      this.content
        .css("display", "")
        .removeAttr("aria-hidden")
        .removeAttr("tabIndex")
        .removeClass("oj-component-content oj-collapsible-content")
        .each(function ()
        {
          if (/^oj-collapsible/.test(this.id))
          {
            this.removeAttribute("id");
          }
        });
    },

    _cleanup : function ()
    {
      //remove listeners
      this._tearDownEvents();

      //remove wrapper
      if (this.content)
      {
        this.content.unwrap();
        this.wrapper = null;
      }
      //TODO: remove oj-disabled

    },

    _isDisabled : function ()
    {
      //TODO: should we added "showDisclosure" option?
      return this.element.hasClass("oj-disabled");
    },

    _getExpandAreaSelector : function ()
    {
      if (this.options.expandArea == "header")
        return "> .oj-collapsible-header";
      else //disclosureIcon
        return "> .oj-collapsible-header > .oj-collapsible-header-icon";
    },

    _setOption : function (key, value)
    {
      if (key === "expanded")
      {
        this._setCollapsed(value);
        return;
      }

      if (key === "expandOn" || key === "expandArea")
      {
        this._tearDownEvents();
        this._super(key, value);
        this._setupEvents();
      }
      else 
      {
        this._super(key, value);
      }

      // #5332 - opacity doesn't cascade to positioned elements in IE
      // so we need to add the disabled class to the headers and panels
      if (key === "disabled")
      {
        this.header
          .add(this.header.next());
        this.element.toggleClass("oj-disabled", !!value);
      }
    },

    _keydown : function (event)
    {
      if (event.altKey || event.ctrlKey)
      {
        return;
      }
      var keyCode = $.ui.keyCode;

      switch (event.keyCode)
      {
        case keyCode.SPACE:
        case keyCode.ENTER:
          this._toggleHandler(event);
          break;
      }
    },

    /**
     * Refreshes the visual state of the collapsible. JET components require a <code class="prettyprint">refresh()</code> or re-init after the DOM is 
     * programmatically changed underneath the component.
     * 
     * <p>This method does not accept any arguments.
     * 
     * @expose 
     * @memberof! oj.ojCollapsible
     * @instance
     * 
     * @example <caption>Invoke the <code class="prettyprint">refresh</code> method:</caption>
     * $( ".selector" ).ojCollapsible( "refresh" );
     */
    refresh : function ()
    {
      this._super();
      this._cleanup();
      this._processPanels();
      this._destroyIcons();
      this._refresh();
    },

    _processPanels : function ()
    {
      //Bug 18633679 - Stop using ui-helper-reset in the layout widgets.
      this.header = this.element.children(":first-child")
                      .addClass("oj-collapsible-header");

      this.content = this.header.next()
        .addClass("oj-collapsible-content oj-component-content");

      this.content.wrap("<div></div>");
      this.wrapper = this.content.parent()
        .addClass("oj-collapsible-wrapper");

      //Note: must set tabIndex=-1 to focusable elements
      //to avoid tabbing in a disabled header
      if (this.options.disabled)
        this.element.addClass("oj-disabled");

      if (this._isDisabled())
      {
        this._findFocusables(this.header)
          .attr("tabIndex",  -1);
      }
    },

    /**
     * Used for explicit cases where the component needs to be refreshed 
     * (e.g., when the value option changes or other UI gestures).
     * @private
     */
    _refresh : function ()
    {
      var header = this.header, 
          content = this.content, 
          options = this.options;

      var collapsibleId = this.collapsibleId = 
        "oj-collapsible-" + (this.element.attr("id") || ++uid);

      var headerId = header.attr("id"), 
          contentId = content.attr("id");

      if (!headerId)
      {
        headerId = collapsibleId + "-header";
        header.attr("id", headerId);
      }
      if (!contentId)
      {
        contentId = collapsibleId + "-content";
        content.attr("id", contentId);
      }

      //aria
      this._createIcons();
      var focusable = this._findFirstFocusableInHeader();
      focusable.attr("role", "button")
        .attr("aria-controls", contentId);

      if (this._isDisabled())
      {
        focusable.attr("aria-disabled", true);
      }

      if (!this._isDisabled())
      {
        this._setContentTabIndex(options.expanded ? "0" : "-1");
      }

      this.element.toggleClass("oj-collapsible-collapsed", ! options.expanded);

      if (options.expanded)
      {
        content.attr(
        {
          "aria-hidden" : "false"
        });
        focusable.attr("aria-expanded", "true");
      }
      else 
      {
        this.wrapper.css({
          'max-height': 0,
          'overflow-y': 'hidden',
          'display': 'none'
        });
        this.wrapper.css('max-height', 0);
        content.attr(
        {
          "aria-hidden" : "true"
        });
        focusable.attr("aria-expanded", "false");
      }

      this._setupEvents();
    },

    _setCollapsed : function (expanded)
    {
      if (expanded === this.options.expanded)
        return;

      if (expanded)
        this.expand(true);
      else 
        this.collapse(true);
    },

    _setupEvents : function ()
    {
      var events = 
      {
        "keydown" : this._keydown
      };

      var event = this.options.expandOn;
      if (event)
      {
        var self = this ;
        $.each(event.split(" "), function (index, eventName)
        {
          events[eventName] = self._toggleHandler;
        });
      }

      var expandArea = this.element.find(this._getExpandAreaSelector());

      //add listeners on expandArea (event expandArea)
      this._on(expandArea, events);

      this._on(this.wrapper, 
      {
        "transitionend" : this._transitionEndHandler, 
        "webkitTransitionEnd" : this._transitionEndHandler, 
        "otransitionend" : this._transitionEndHandler, 
        "oTransitionEnd" : this._transitionEndHandler
      });

      if (!this._isDisabled())
      {
        this._on(this.element, 
        {
          "ojafterexpand" : this._expandCollapseHandler, 
          "ojaftercollapse" : this._expandCollapseHandler, 
          "ojfocus" : this._focusHandler,
          "ojfocusout" : this._focusHandler
        });

        this._hoverable(expandArea);
        this._focusable(expandArea);
        this._activatable(expandArea);

      }
    },

    _tearDownEvents : function ()
    {
      this._off(this.element.find(this._getExpandAreaSelector()));

      //remove wrapper listeners
      if (this.wrapper)
        this._off(this.wrapper);
      this._off(this.element.add(this.content));
    },

    _toggleHandler : function (event)
    {
      if (this._isDisabled())
        return;

      if (this.options.expanded)
        this.collapse(true, event);
      else 
        this.expand(true, event);

      event.preventDefault();
      event.stopPropagation();

      //set focus on the disclosure icon
      this.header.find(".oj-collapsible-header-icon").focus();

    },

    _expandCollapseHandler : function (event)
    {
      if (this._isDisabled())
        return;

      if (event.target !== this.element[0])
        return;

      if (!event.isDefaultPrevented())
      {
        var element = this.element, 
            options = this.options, 
            content = this.content,
            wrapper = this.wrapper,
            isCollapse = (event.type === "ojaftercollapse");

        event.preventDefault();

        options.expanded = ! isCollapse;

        wrapper.contentHeight = wrapper.outerHeight();

        //collapsing
        if (isCollapse)
        {
          // disable transitions & set max-height to content height
          wrapper.removeClass("oj-collapsible-transition");
          wrapper.css({
            'max-height': wrapper.contentHeight,
            'overflow-y': 'hidden'
          });

          setTimeout(function()
          {
            // enable & start transition
            wrapper.addClass('oj-collapsible-transition')
              .css({
                'max-height': 0   //!important
              });

            element.addClass("oj-collapsible-collapsed");
          }, 10); // 10ms timeout is the secret ingredient for disabling/enabling transitions
          // chrome only needs 1ms but FF needs ~10ms or it chokes on the first animation for some reason

        }
        else
        {
          //James: set display:none on the wrapper when it is hidden and then remove display:none when its is shown. 
          //This should trigger JAWS into refreshing the buffer.
           wrapper.show();

          setTimeout(function()
          {
            wrapper.contentHeight += content.outerHeight(); // if closed, add inner height to content height
            wrapper.addClass('oj-collapsible-transition').css(
            {
              'max-height': wrapper.contentHeight
            });
            element.removeClass("oj-collapsible-collapsed");
          }, 1);

        }

        this.header
          .find(".oj-collapsible-header-icon").toggleClass(OPEN_ICON, !isCollapse)
            // logic or cause same icon for expanded/collapsed state would remove the oj-icon-class
            .toggleClass(CLOSE_ICON, (isCollapse || OPEN_ICON === CLOSE_ICON))
          .end();

        //aria
        this.content.attr("aria-hidden", isCollapse);

        this._findFirstFocusableInHeader().attr("aria-expanded", !isCollapse);

        this._setContentTabIndex(isCollapse ? "-1" : "0");

      }
    },

    _focusHandler : function (event)
    {
      if (this._isDisabled())
        return null;

      if (event.type == "ojfocusout")
      {
//        this.header.attr("aria-activedescendant", "false");
        this._findFirstFocusableInHeader()
          .attr("tabIndex", -1);

        event.preventDefault();
        event.stopPropagation();
      }
      else if (event.type == "ojfocus")
      {
//        this.header.attr("aria-activedescendant", "true");
        this._findFirstFocusableInHeader()
          .attr("tabIndex", 0)
          .focus();
        event.preventDefault();
        event.stopPropagation();
      }
    },

    _findFirstFocusableInHeader : function ()
    {
      return this._findFocusables(this.header).first();
    },

    _setContentTabIndex : function (value)
    {
      return this._findFocusables(this.content).attr("tabIndex", value);
    },

    _findFocusables : function (start)
    {
      //create <span> or <a> depending on if this.isDisabled
      if (this._isDisabled()) {
        return start.find("span");
      }
      return start.find("a,:input");
    },

    /**
     * Expand a collapsible.
     * 
     * @expose 
     * @memberof! oj.ojCollapsible
     * @instance
     * @param {boolean} vetoable if event is vetoable
     */
    expand : function (vetoable, event)
    {
      if (this._isDisabled())
        return;

      var eventData = 
      {
        /** @expose */
        header : this.header, 
        /** @expose */
        content : this.content
      };

      if (!vetoable || this._trigger("beforeExpand", event, eventData) !== false)
      {
        this._trigger("afterExpand", event, eventData);
        this._fireOptionChange("expanded", false, true, event ? true : false);
      }
    },

    /**
     * Collapse a collapsible.
     * 
     * @expose 
     * @memberof! oj.ojCollapsible
     * @instance
     * @param {boolean} vetoable if event is vetoable
     */
    collapse : function (vetoable, event)
    {
      if (this._isDisabled())
        return;

      var eventData = 
      {
        /** @expose */
        header : this.header, 
        /** @expose */
        content : this.content
      };

      if (!vetoable || this._trigger("beforeCollapse", event, eventData) !== false)
      {
        this._trigger("afterCollapse", event, eventData);
        this._fireOptionChange("expanded", true, false, event ? true : false);
      }
    },

    _transitionEndHandler : function (event)
    {
      if (this._isDisabled())
        return;

      var propName = event.originalEvent? event.originalEvent.propertyName : null;

      //TODO: fire afterExpand and afterCollapse here
      if (propName == "max-height")
      {
        event.preventDefault();
        event.stopPropagation();
      }

      //just completed a collapse transition
      if (this.options.expanded)
      {
        this.wrapper.css({
          'max-height': 9999,
          'overflow-y': ''
        });
//        this._trigger("afterExpand", event);
      }
      else 
      {
        //James: set display:none on the wrapper when it is hidden and then remove display:none when its is shown. 
        //This should trigger JAWS into refreshing the buffer.
        this.wrapper.hide();
//        this._trigger("afterCollapse", event);
      }

      this.wrapper.removeClass("oj-collapsible-transition");
    },

    /**
     * Overridden to set oj-active class
     * @private
     */
    _activatable: function( element )
    {
      this.activatable = this.activatable.add( element );
      this._on( element, 
      {
        mousedown: function( event )
        {
	  $( event.currentTarget ).addClass( "oj-active" );
	},
        mouseup: function( event )
        {
	  $( event.currentTarget ).removeClass( "oj-active" );
	}
      });
    },

    /**
     * Fire optionChange event 
     * @param {String} key - 'expanded'
     * @param {boolean} previousValue 
     * @param {boolean} value
     * @param {Boolean} originalEvent  
     *
     * @private
     */
    _fireOptionChange: function(key, previousValue, value, originalEvent) 
    {
      var ui = {
        "option": key,
        "previousValue": previousValue,
        "value": value,
        // (originalEvent is non-null) iff (option change is due to user interaction) 
        // iff (binding should write back the value)
        "optionMetadata": {'writeback': originalEvent ? "shouldWrite" : "shouldNotWrite"}
      };
      this._trigger('optionChange', originalEvent, ui);
    },

    /**
     * Return the subcomponent node represented by the documented locator 
     * attribute values.
     *
     * To lookup a header the locator object should have the following:
     *          subId: 'oj-collapsible-header'
     *
     * To lookup a disclosure icon the locator object should have the following:
     *          subId: 'oj-collapsible-header-icon'
     *
     * To lookup a panel content the locator object should have the following:
     *          subId: 'oj-collapsible-content'
     *
     * @expose
     * @memberof! oj.ojCollapsible
     * @instance
     * @override
     * @param {Object} locator An Object containing at minimum a subId property 
     *        whose value is a string, documented by the component, that allows 
     *        the component to look up the subcomponent associated with that 
     *        string.  It contains:<p>
     *        component: optional - in the future there may be more than one 
     *        component contained within a page element<p>
     *        subId: the string, documented by the component, that the component 
     *        expects in getNodeBySubId to locate a particular subcomponent
     * @returns {Element|null} the subcomponent located by the subId string passed
     *          in locator, if found.<p>
     */
    getNodeBySubId: function(locator)
    {
      if (locator == null)
      {
        return this.element ? this.element[0] : null;
      }

      var subId = locator['subId'];

      switch (subId)
      {
      case 'oj-collapsible-content':
        return this.content;

      case 'oj-collapsible-header':
        return this.header;

      case 'oj-collapsible-header-icon':
        return this.header.find("." + subId)[0];
      }

      // Non-null locators have to be handled by the component subclasses
      return null;
    }


  });

}
());
/*!
 * jQuery UI Tabs 1.10.3
 * http://jqueryui.com
 *
 * Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/tabs/
 *
 * Depends:
 *  jquery.ui.core.js
 *  jquery.ui.widget.js
 */
/**
 * @class 
 * @name oj.ojTabs
 * @augments oj.baseComponent
 * 
 * @classdesc
 * <h3 id="tabsOverview-section">
 *   JET Tabs Component
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#tabsOverview-section"></a>
 * </h3>
 * 
 * <p>Description: Themeable, WAI-ARIA-compliant tabs with mouse and keyboard interactions for navigation.
 * 
 * <p>A JET Tabs can be created from any valid markup as long as the root element has one or more child elements and 
 * each child element must have at least two children: the first element for the title and the rest of the element(s) for the content.
 * 
 * <pre class="prettyprint">
 * <code>
 * &lt;div id="tabs">
 *   &lt;div id ="tab-1">
 *     &lt;span>Tab 1&lt;/span>
 *     &lt;p>Tab 1 content&lt;/p>
 *     &lt;p>Tab 1 more content&lt;/p>
 *   &lt;/div>
 *   &lt;div id ="tab-2">
 *     &lt;span>Tab 2&lt;/span>
 *     &lt;p>Tab 2 content&lt;/p>
 *   &lt;/div>
 *   &lt;div id ="tab-3">
 *     &lt;span>Tab 3&lt;/span>
 *     &lt;p>Tab 3 content&lt;/p>
 *   &lt;/div>
 * &lt;/div>
 * </code></pre>
 * 
 * <h3 id="keyboard-section">
 *   Keyboard interaction
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
 * </h3>
 * 
 * <p>
 * <h5>When the focus is on the tab bar</h5>
 * </p>
 * 
 * <table class="keyboard-table">
 *   <thead>
 *     <tr>
 *       <th>Key</th>
 *       <th>Use</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td><kbd>Tab</kbd></td>
 *       <td> Only the selected tab is in the tab order.</tr>
 *     <tr>
 *       <td><kbd>UpArrow or LeftArrow</kbd> (<kbd>RightArrow</kbd> in RTL)</td>
 *       <td> Move focus to the previous tab and select it.</tr>
 *     <tr>
 *       <td><kbd>DownArrow or RightArrow</kbd> (<kbd>LeftArrow</kbd> in RTL)</td>
 *       <td> Move focus to the next tab and select it.</tr>
 *     <tr>
 *       <td><kbd>Home</kbd></td>
 *       <td> Move focus to the first tabs item.</tr>
 *     <tr>
 *       <td><kbd>End</kbd></td>
 *       <td> Move focus to the last tabs item.</tr>
 *     <tr>
 *       <td><kbd>Delete</kbd></td>
 *       <td> If deletion is allowed, will delete the current tab.</tr>
 *   </tbody>
 *  </table>
 *
 * <p>
 * <h5>When the focus is on anywhere within the tab content</h5>
 * </p>
 * 
 * <table class="keyboard-table">
 *   <thead>
 *     <tr>
 *       <th>Key</th>
 *       <th>Use</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td><kbd>Shift+Tab</kbd></td>
 *       <td> move focus to the tab for that panel.</tr>
 *   </tbody>
 *  </table>
 * 
 * <h3 id="rtl-section">
 *   Reading direction
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#rtl-section"></a>
 * </h3>
 * 
 * <p>As with any JET component, in the unusual case that the directionality (LTR or RTL) changes post-init, the tabs must be <code class="prettyprint">refresh()</code>ed.
 * 
 * 
 * <h3 id="pseudos-section">
 *   Pseudo-selectors
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#pseudos-section"></a>
 * </h3>
 * 
 * <p>The <code class="prettyprint">:oj-tabs</code> pseudo-selector can be used in jQuery expressions to select JET Tabs.  For example:
 * 
 * <pre class="prettyprint">
 * <code>$( ":oj-tabs" ) // selects all JET Tabs on the page
 * $myEventTarget.closest( ":oj-tabs" ) // selects the closest ancestor that is a JET Tabs
 * </code></pre>
 * 
 * 
 * <h3 id="jqui2jet-section">
 *   JET for jQuery UI developers
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#jqui2jet-section"></a>
 * </h3>
 * 
 * <ol>
 *   <ul>
 *   <li>JQUI Tabs expects the tabs titles either in an ordered or unordered list followed by their content elements. Each tab must have an anchor with the href points to its content element.
 *     <pre class="prettyprint">
 *     <code>
 *       &lt;div id="tabs">
 *         &lt;ul>
 *           &lt;li>&lt;a href="#tabs-1">Tab 1 Title&lt;/a>&lt;/li>
 *           &lt;li>&lt;a href="#tabs-2">Tab 2 Title&lt;/a>&lt;/li>
 *         &lt;/ul>
 *         &lt;div id="tabs-1">
 *           &lt;p>Tab 1 content.&lt;/p>
 *         &lt;/div>
 *         &lt;div id="tabs-2">
 *           &lt;p>Tab 2 content.&lt;/p>
 *           &lt;p>More Tab 2 content.&lt;/p>
 *         &lt;/div
 *       &lt;/div>
 *     </code></pre>
 *   </li>
 *
 *   <li>JET Tabs requires a simplier DOM structures. Like the JQuery Accordion, the tabs is a list of tab where each tab contains its own title and content. It requires no anchors and pointers to the contents.
 *     <pre class="prettyprint">
 *     <code>
 *       &lt;div id="tabs">
 *         &lt;div id="tabs-1">
 *           &lt;span>Tab 1 Title&lt;/span>
 *           &lt;p>Tab 1 content.&lt;/p>
 *         &lt;/div>
 *         &lt;div id="tabs-2">
 *           &lt;span>Tab 2 Title&lt;/span>
 *           &lt;p>Tab 2 content.&lt;/p>
 *           &lt;p>More Tab 2 content.&lt;/p>
 *         &lt;/div
 *       &lt;/div>
 *     </code></pre>
 *   </li>
 *   </ul>
 *   <li>All JQUI and JET components inherit <code class="prettyprint">disable()</code> and <code class="prettyprint">enable()</code> methods from the base class.  This API 
 *       duplicates the functionality of the <code class="prettyprint">disabled</code> option.  In JET, to keep the API as lean as possible, we 
 *       have chosen not to document these methods outside of this section.</li>
 *   <li>JET Tabs supports orientation option: to be placed horizontal (default) or vertical</li>
 *   <li>JET Tabs supports removable option by adding a close icon to each tab which when clicked remove the tab from the DOM.</li>
 *   <li>JET Tabs supports reorderable option allow the tab to be reordered by drag and drop within the Tab bar</li>
 * </ol>
 * 
 * <p>Also, event names for all JET components are prefixed with "oj", instead of component-specific prefixes like "tabs".  
 * E.g. the JQUI <code class="prettyprint">tabscreate</code> event is <code class="prettyprint">ojcreate</code> in JET, as shown in the doc for that event.
 * Reason:  This makes the API more powerful.  It allows apps to listen to "foo" events from <em>all</em> JET components via:
 * 
 * <pre class="prettyprint">
 * <code>$( ".selector" ).on( "ojfoo", myFunc);
 * </code></pre>
 * 
 * or to "foo" events only from JET Tabs (the JQUI functionality) via:
 * 
 * <pre class="prettyprint">
 * <code>$( ".selector" ).on( "ojfoo", ":oj-tabs", myFunc);
 * </code></pre>
 * 
 * <!-- - - - - Above this point, the tags are for the class.
 *              Below this point, the tags are for the constructor (initializer). - - - - - - -->
 * 
 * @desc Creates a JET Tabs. 
 * @example <caption>Initialize the tabs with no options specified:</caption>
 * $( ".selector" ).ojTabs();
 * 
 * @example <caption>Initialize the tabs with some options and callbacks specified:</caption>
 * $( ".selector" ).ojTabs( { "disabled": true, "create": function( event, ui ) {} } );
 * 
 * @example <caption>Initialize the tabs via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;div id="tabs" data-bind="ojComponent: { component: 'ojTabs', 
 *                                             disabled: [1], 
 *                                             reorderable: true }">
 */
(function ()
{
  var _CLOSE_ICON = "oj-tabs-close-icon";
  var _CLOSE_ICON_SIZE = 28;
  var _ID_PREFIX = "ojtabs-id_";
  var _DELETE_KEY = 46;


  oj.__registerWidget("oj.ojTabs", $['oj']['baseComponent'], 
  {
    version : "1.0.0", 
    widgetEventPrefix : "oj", 
    delay : 300, 
    options : 
    {
      /** 
       * The zero-based index of the panel that is selected (open).
       *
       * @expose 
       * @memberof! oj.ojTabs
       * @instance
       * @type {number}
       * @default <code class="prettyprint">0</code>
       */
      selected : 0, 

      /** 
       * Which tabs are disabled.
       *
       * @expose 
       * @memberof! oj.ojTabs
       * @instance
       * @default <code class="prettyprint">false</code>
       * @type {boolean|Array}
       * Boolean: Enable or disable all tabs.
       * Array: An array containing the zero-based indexes of the tabs that should be disabled. 
       * @example [ 0, 2 ] would disable the first and third tab.
       */
      disabled : false, 

      /** 
       * Truncation option applies to the tab titles when there is not enough room to display
       * all tabs.
       * Valid Values: none, progressive and auto.
       *
       * <ul>
       *  <li> none - tabs always take up the space needed by the label texts. When there
       *   is not enough room, the conveyorBelt's navigation arrows are displayed to allow
       *   the label texts be scrolled within the conveyor.</li>
       *
       *  <li> progressive - If not enough space is available to display all of the tabs, 
       *   then the width of each tab label is restricted just enough to allow all tabs to fit. 
       *   All tab labels that are truncated are displayed with ellipses. However the width 
       *   of each tab will not be truncated below tabLabelMinWidth. If after all truncation 
       *   has been applied, there still is not enough room, then the conveyorBelt's navigation 
       *   arrows will appear. When the container of the tabs is resized the truncation will 
       *   be reevaluated.</li>
       *
       *  <li> auto - same as "progressive".</li>
       * </ul>
       *
       * @expose 
       * @memberof! oj.ojTabs
       * @instance
       * @default <code class="prettyprint">auto</code>
       * @type {string}
       */
      truncation : "auto",

      /** 
       * The type of event to select the tab. 
       * To select a tab on hover, use "mouseover".
       *
       * @expose 
       * @memberof! oj.ojTabs
       * @instance
       * @type {string}
       * @default <code class="prettyprint">"click"</code>
       */
      selectOn : "click", 

      /** 
       * The orientation of the tab bar. 
       * Valid Values: horizontal and vertical
       *
       * @expose 
       * @memberof! oj.ojTabs
       * @instance
       * @type {string}
       * @default <code class="prettyprint">"horizontal"</code>
       */
      orientation : "horizontal", 

      /** 
       * Specifies if the tabs can be closed (removed)
       *
       * @expose 
       * @memberof! oj.ojTabs
       * @instance
       * @type {boolean}
       * @default <code class="prettyprint">false</code>
       */
      removable : false, 

      /** 
       * This text is used to provide audible feedback for screen reader users
       *
       * @expose 
       * @memberof! oj.ojTabs
       * @instance
       * @type {string}
       * @default <code class="prettyprint">Removable</code>
       */
      removeCueText : "Removable",

      /** 
       * Specifies if the tabs can be reordered within the tab bar by drag-and-drop
       *
       * @expose 
       * @memberof! oj.ojTabs
       * @instance
       * @type {boolean}
       * @default <code class="prettyprint">false</code>
       */
      reorderable : false,

      // callbacks
      /**
       * Triggered immediately before a tab is selected.
       * The beforeSelect can be cancelled by calling <code class="prettyprint">event.preventDefault()</code>.
       *
       * @expose 
       * @event 
       * @memberof! oj.ojTabs
       * @instance
       * @property {Event} event <code class="prettyprint">jQuery</code> event object
       * @property {Object} ui Parameters
       * @property {jQuery} ui.newHeader The tab that is about to be selected.
       * @property {jQuery} ui.newContent The panel that is about to be selected.
       * @property {jQuery} ui.oldHeader The tab that is about to be deselected.
       * @property {jQuery} ui.oldContent The panel that is about to be deselected.
       * 
       * @example <caption>Initialize the tabs with the <code class="prettyprint">beforeSelect</code> callback specified:</caption>
       * $( ".selector" ).ojTabs({
       *     "beforeSelect": function( event, ui ) {}
       * });
       *
       * @example <caption>Bind an event listener to the <code class="prettyprint">ojbeforeselect</code> event:</caption>
       * $( ".selector" ).on( "ojbeforeselect", function( event, ui ) {} );
       */
      beforeSelect : null,

      /**
       * Triggered after a tab has been selected.
       * The afterSelect can be cancelled by calling <code class="prettyprint">event.preventDefault()</code>.
       *
       * @expose 
       * @event 
       * @memberof! oj.ojTabs
       * @instance
       * @property {Event} event <code class="prettyprint">jQuery</code> event object
       * @property {Object} ui Parameters
       * @property {jQuery} ui.newHeader The tab that was just selected.
       * @property {jQuery} ui.newContent The panel that was just selected.
       * @property {jQuery} ui.oldHeader The tab that was just deselected.
       * @property {jQuery} ui.oldContent The panel that was just deselected.
       * 
       * @example <caption>Initialize the tabs with the <code class="prettyprint">afterSelect</code> callback specified:</caption>
       * $( ".selector" ).ojTabs({
       *     "afterSelect": function( event, ui ) {}
       * });
       *
       * @example <caption>Bind an event listener to the <code class="prettyprint">ojafterselect</code> event:</caption>
       * $( ".selector" ).on( "ojafterselect", function( event, ui ) {} );
       */
      afterSelect : null, 

      /**
       * Triggered immediately before a tab is deselected.
       * The beforeDeselect can be cancelled by calling <code class="prettyprint">event.preventDefault()</code>.
       *
       * @expose 
       * @event 
       * @memberof! oj.ojTabs
       * @instance
       * @property {Event} event <code class="prettyprint">jQuery</code> event object
       * @property {Object} ui Parameters
       * @property {jQuery} ui.newHeader The tab that is about to be deselected.
       * @property {jQuery} ui.newContent The panel that is about to be deselected.
       * @property {jQuery} ui.oldHeader The tab that is about to be selected.
       * @property {jQuery} ui.oldContent The panel that is about to be selected.
       * 
       * @example <caption>Initialize the tabs with the <code class="prettyprint">beforeDeselect</code> callback specified:</caption>
       * $( ".deselector" ).ojTabs({
       *     "beforeDeselect": function( event, ui ) {}
       * });
       *
       * @example <caption>Bind an event listener to the <code class="prettyprint">ojbeforedeselect</code> event:</caption>
       * $( ".deselector" ).on( "ojbeforedeselect", function( event, ui ) {} );
       */
      beforeDeselect : null,

      /**
       * Triggered after a tab has been deselected.
       * The afterDeselect can be cancelled by calling <code class="prettyprint">event.preventDefault()</code>.
       *
       * @expose 
       * @event 
       * @memberof! oj.ojTabs
       * @instance
       * @property {Event} event <code class="prettyprint">jQuery</code> event object
       * @property {Object} ui Parameters
       * @property {jQuery} ui.newHeader The tab that was just deselected.
       * @property {jQuery} ui.newContent The panel that was just deselected.
       * @property {jQuery} ui.oldHeader The tab that was just selected.
       * @property {jQuery} ui.oldContent The panel that was just selected.
       * 
       * @example <caption>Initialize the tabs with the <code class="prettyprint">afterDeselect</code> callback specified:</caption>
       * $( ".deselector" ).ojTabs({
       *     "afterDeselect": function( event, ui ) {}
       * });
       *
       * @example <caption>Bind an event listener to the <code class="prettyprint">ojafterdeselect</code> event:</caption>
       * $( ".deselector" ).on( "ojafterdeselect", function( event, ui ) {} );
       */
      afterDeselect : null, 

      /**
       * Triggered immediately before a tab is removed.
       * The beforeRemove can be cancelled by calling <code class="prettyprint">event.preventDefault()</code>.
       *
       * @expose 
       * @event 
       * @memberof! oj.ojTabs
       * @instance
       * @property {Event} event <code class="prettyprint">jQuery</code> event object
       * @property {Object} ui Parameters
       * @property {jQuery} ui.header The tab that is about to be removed.
       * @property {jQuery} ui.content The panel that is about to be removed.
       * 
       * @example <caption>Initialize the tabs with the <code class="prettyprint">beforeRemove</code> callback specified:</caption>
       * $( ".selector" ).ojTabs({
       *     "beforeRemove": function( event, ui ) {}
       * });
       *
       * @example <caption>Bind an event listener to the <code class="prettyprint">ojbeforeremove</code> event:</caption>
       * $( ".selector" ).on( "ojbeforeremove", function( event, ui ) {} );
       */
      beforeRemove : null,

      /**
       * Triggered after a tab has been removed.
       *
       * @expose 
       * @event 
       * @memberof! oj.ojTabs
       * @instance
       * @property {Event} event <code class="prettyprint">jQuery</code> event object
       * @property {Object} ui Parameters
       * @property {jQuery} ui.header The tab that was just removed.
       * @property {jQuery} ui.content The panel that was just removed.
       * 
       * @example <caption>Initialize the tabs with the <code class="prettyprint">afterRemove</code> callback specified:</caption>
       * $( ".selector" ).ojTabs({
       *     "afterRemove": function( event, ui ) {}
       * });
       *
       * @example <caption>Bind an event listener to the <code class="prettyprint">ojafterremove</code> event:</caption>
       * $( ".selector" ).on( "ojafterremove", function( event, ui ) {} );
       */
      afterRemove : null, 

      /**
       * Fired whenever a supported component option changes, whether due to user interaction or programmatic
       * intervention.  If the new value is the same as the previous value, no event will be fired.
       *
       * Currently there is one supported option, <code class="prettyprint">"selected"</code>.  Additional
       * options may be supported in the future, so listeners should verify which option is changing
       * before taking any action.
       *
       * @expose
       * @event
       * @memberof! oj.ojTabs
       * @instance
       * @property {Event} event <code class="prettyprint">jQuery</code> event object
       * @property {Object} ui Parameters
       * @property {string} ui.option the name of the option that is changing
       * @property {Object} ui.previousValue the previous value of the option
       * @property {Object} ui.value the current value of the option
       * @property {Object} ui.optionMetadata information about the option that is changing
       * @property {string} ui.optionMetadata.writeback <code class="prettyprint">"shouldWrite"</code> or
       *           <code class="prettyprint">"shouldNotWrite"</code>.  For use by the JET writeback mechanism.
       *
       */
      optionChange: null

    },

    _ComponentCreate : function ()
    {
      var self = this, 
          options = this.options;

      this._super();
      this.running = false;

      this._setupOrientation(options.orientation);

      this._processTabs();

      // Take disabling tabs via class attribute from HTML
      // into account and update option properly.
      if (Array.isArray(options.disabled))
      {
        var disabledTabs = this.tabs.filter(".oj-disabled");
        options.disabled = $.unique(options.disabled.concat($.map(disabledTabs, 
          function (li)
          {
            return self.tabs.index(li);
          }))).sort();
      }

      //Bug 18270242 - When ojtab first displays beforeSelect & afterSelect events are not raised  
      // select the selected tab after refresh
      this._initialActivate = options.selected;
      options.selected = -1;

      this._refresh();

    },

    /* 
     * Component developers: This API and functionality is subject to change pending architectural review!
     * See the baseComponent method for preliminary API doc.
     */
    _showContextMenu: function(menu, event)
    {
      // TODO: is this the right logic for this component?
      menu.show(event, {"launcher": this.element.children(".oj-tabs-nav").children("[tabindex=0]"), "focus": "menu"});
    },

    _tabKeydown : function (event)
    {
      /*jshint maxcomplexity:15*/
      var focusedTab = $(this.document[0].activeElement).closest("li"), 
          selectedIndex = this.tabs.index(focusedTab), goingForward = true;

      if (this._handlePageNav(event))
      {
        return;
      }

      switch (event.keyCode)
      {
        case $.ui.keyCode.RIGHT:
        case $.ui.keyCode.DOWN:
          selectedIndex++;
          break;
        case $.ui.keyCode.UP:
        case $.ui.keyCode.LEFT:
          goingForward = false;
          selectedIndex--;
          break;
        case $.ui.keyCode.END:
//TODO: disabled tab 
          selectedIndex = this.tabs.length - 1;
          break;
        case $.ui.keyCode.HOME:
          selectedIndex = 0;
          break;

        case _DELETE_KEY:
        // James: remove tab keystroke doesn't seem to work with JAWS. 
        // ALT+DEL seems to conflict with a JAWS keystroke. I have raised an issue on the Authoring 
        // Practices for this. Could we just use Delete as well or does that sound like a bad idea?
//          if (event.altKey)
//          {
            // simulate a click on the close icon of the current selected header
            var anchor = this.active.find("." + _CLOSE_ICON);
            if (anchor)
            {
              event.preventDefault();
              this._removeTabHandler(
                {
                  target : anchor, 
                  currentTarget : anchor, 
                  preventDefault : $.noop
                });
            }
//          }
          return;

        default :
          return;
      }

      // Focus the appropriate tab, based on which key was pressed
      event.preventDefault();
      clearTimeout(this.activating);
      selectedIndex = this._focusNextTab(selectedIndex, goingForward);

      // Navigating with control key will prevent automatic activation
      if (!event.ctrlKey)
      {
        // Update aria-selected immediately so that AT think the tab is already selected.
        // Otherwise AT may confuse the user by stating that they need to select the tab,
        // but the tab will already be selected by the time the announcement finishes.
        focusedTab.attr("aria-selected", "false");
        this.tabs.eq(selectedIndex).attr("aria-selected", "true");

        this.activating = this._delay(function ()
        {
          this.option("selected", selectedIndex);
        },
        this.delay);
      }
    },

    _panelKeydown : function (event)
    {
      if (this._handlePageNav(event))
        return;

      // Ctrl+up moves focus to the current tab
      if (event.ctrlKey && event.keyCode === $.ui.keyCode.UP)
      {
        event.preventDefault();
        this.active.focus();
      }

    },

    // Ctrl+page up/down moves focus to the previous/next tab (and selects)
    _handlePageNav : function (event)
    {
      if (event.ctrlKey && event.keyCode === $.ui.keyCode.PAGE_UP)
      {
        this._activate(this._focusNextTab(this.options.selected - 1, false));
        return true;
      }
      if (event.ctrlKey && event.keyCode === $.ui.keyCode.PAGE_DOWN)
      {
        this._activate(this._focusNextTab(this.options.selected + 1, true));
        return true;
      }
    },

    _isTabDisabled : function (index)
    {
      return ($.inArray(index, this.options.disabled) !=  - 1);
    },

    _findNextTab : function (index, goingForward)
    {
      var lastTabIndex = this.tabs.length - 1;

      function constrain()
      {
        if (index > lastTabIndex)
        {
          index = 0;
        }
        if (index < 0)
        {
          index = lastTabIndex;
        }
        return index;
      }

      while (this._isTabDisabled(constrain()))
      {
        index = goingForward ? index + 1 : index - 1;
      }

      return index;
    },

    _focusNextTab : function (index, goingForward)
    {
      index = this._findNextTab(index, goingForward);
      this.tabs.eq(index).focus();
      return index;
    },

    _activateNextTab : function (index)
    {
      var lastTabIndex = this.tabs.length - 1;
      var next = index + 1;

      while (next <= lastTabIndex) 
      {
        if (! this._isTabDisabled(next))
        {
          this._activate(next);
          return next - 1;
        }
        next++;
      }
      next = index - 1;
      while (next >= 0)
      {
        if (! this._isTabDisabled(next))
        {
          this._activate(next);
          return next;
        }
        next--;
      }
      return -1;
    },

    _setOption : function (key, value)
    {
      if (key === "selected")
      {
        if (typeof value === "string")
        {
          value = this._parse(value);
        }
        // _activate() will handle invalid values and update this.options
        this._activate(value);
        return;
      }

      if (key === "disabled")
      {
        // don't use the widget factory's disabled handling
        this._setupDisabled(value);
        return;
      }

      if (key === "removable")
      {
        this._setRemovable(value);
        return;
      }

      //allow drag and drop a tab within the tab bar
      if (key === "reorderable")
      {
        if (value !== this.options.reorderable)
        {
          this.options.reorderable = value;
          this._setupReorder();
        }
        return;
      }

      //change orientation need refresh
      if (key === "orientation")
      {
        this._setupOrientation(value);
        this.refresh();
        return;
      }

      this._super(key, value);

      if (key === "selectOn")
      {
        this._tearDownEvents();
        this._super(key, value);
        this._setupEvents();
      }

    },

    /**
     * Refreshes the visual state of the tabs. JET components require a <code class="prettyprint">refresh()</code> or re-init after the DOM is 
     * programmatically changed underneath the component.
     *
     * <p>This method does not accept any arguments.
     * 
     * @expose 
     * @memberof! oj.ojTabs
     * @instance
     * 
     * @example <caption>Invoke the <code class="prettyprint">refresh</code> method:</caption>
     * $( ".selector" ).ojTabs( "refresh" );
     */
    refresh : function ()
    {
      this._super();

/*
      //Bug 18269291 - If user closes tab then index for tabs changes and disabled tab becomes enable
      var options = this.options,
          lis = this.tabs;

      // get disabled tabs from class attribute from HTML
      // this will get converted to a boolean if needed in _refresh()
      options.disabled = $.map(lis.filter(".oj-disabled"), function (tab)
      {
        return lis.index(tab);
      });
*/
      this._destroyCloseIcons();
      this._processTabs();

      this._refresh();
    },

    _refresh : function ()
    {
      var options = this.options;

      // check for length avoids error when initializing empty list
      if (this.tabs.length && options.selected != -1)
        this.active = this._findActive(options.selected);
      else 
        this.active = $();

      this._setupDisabled(options.disabled);

      this._createCloseIcons();

      this._tearDownEvents();
      this._setupEvents();

      this.tabs.not(this.active).attr(
      {
        "aria-selected" : "false", 
        "tabIndex" : "-1"
      });
      this.panels.not(this._getPanelForTab(this.active)).hide().attr(
      {
        "aria-expanded" : "false", 
        "aria-hidden" : "true"
      });

      // Make sure one tab is in the tab order
      if (!this.active.length)
      {
        this.tabs.eq(0).attr("tabIndex", "0");
      }
      else 
      {
        this.active.addClass("oj-tabs-active").attr(
        {
          "aria-selected" : "true", 
          "tabIndex" : "0"
        });
        this._getPanelForTab(this.active).show().attr(
        {
          "aria-expanded" : "true", 
          "aria-hidden" : "false"
        });
      }

      //Bug 18270242 - When ojtab first displays beforeSelect & afterSelect events are not raised  
      // handle active numbers: negative, out of range
      if (this._initialActivate !== undefined)
      {
        var active = this._initialActivate;
        if (active != 0 && (active < 0 || active > this.tabs.length))
          options.selected = 0;
        else
          options.selected = active;

        //Bug 18539151 - ojtabs should not let user set focus on disabled tabs
        //if the selected tab is disabled, select the next enabled tab
        if ($.inArray(active, options.disabled) !==  - 1)
        {
          options.selected = this._activateNextTab(active);
        }

        this._activate(options.selected);
        this._initialActivate = undefined;
      }

      if (options.orientation == "horizontal")
      {
        //always add conveyor
        this._truncateBeforeOverflow();
        this._addConveyor();
      }

      //Bug 18269323 - After a tab is deleted, reorder does not work
      this._setupReorder();
    },

    _addConveyor : function ()
    {
      if (this.options.orientation == "horizontal")
      {
        var tabsId = this.tablist.uniqueId().attr("id");

        var conveyorDiv = this._getTabbarWrapper()
          .wrap("<div>")
          .parent();

        conveyorDiv.uniqueId().attr("id");
        
        //add special class so tabs component can skin the conveyor overflow 
        //indicators to add padding between them and the tabs
        conveyorDiv.addClass("oj-tabs-conveyorbelt");

        this.conveyor = conveyorDiv.ojConveyorBelt(
          {
            orientation: "horizontal", 
            contentParent: "#" + tabsId
          });
      }
    },

    _processTabs : function ()
    {
      var self = this;

      //destroy the old tab bar before creating a new one
      this._destroyTabBar();

      //create a tab bar: create a <ul> and its <li> children based on the 
      //original tabs markup
      //Bug 18633679 - Stop using ui-helper-reset in the layout widgets.
      this.tablist = $("<ul>")
        .addClass("oj-tabs-nav oj-helper-clearfix")
        .attr("role", "tablist")
        .prependTo(this.element);

      //list of tabs
      this.tabs = $();
      //list of contents
      this.panels = $();
      //list of titles
      this.titles = $();

      this.element.children(":not(.oj-tabs-nav)").each(
        function (index)
        {
          var header = $(this).find("> :first-child");
          var headerClone = header.clone();
          headerClone
            .addClass("oj-tabs-title")
            .css(
            {
              "display": ""
            })
            .attr(
            {
              "aria-hidden": "false"
            });

          //make ids unique after clone
          self._removePrefixIds(headerClone);
          self.titles = self.titles.add(headerClone);

          var ohd = header[0];
          if (ohd.id)
            self._addPrefixId(ohd);
          header.find("[id]").each(function() {
            self._addPrefixId(this);
          });

          var anchor = headerClone
              .wrap("<li><div><a href='#'></a></div></li>")
              .parent();

          anchor.addClass("oj-tabs-anchor")
            .attr(
            {
              "role" : "presentation", 
              "tabIndex" : "-1"
            });

          var div = anchor.parent()
            .addClass("oj-tabs-tab-content");

          var tab = div.parent()
            .addClass("oj-tabs-default")
            .attr(
            {
              "role" : "tab", 
              "aria-hidden": "false",
              "tabIndex" : "-1"
            });

          tab.appendTo(self.tablist);
          self.tabs = self.tabs.add(tab);

          //TODO: remove aria-hidden attribute
          header.hide()            
            .attr(
            {
              "aria-hidden": "true"
            });

          var anchorId = anchor.uniqueId().attr("id"),
              originalAriaControls = tab.attr("aria-controls"),
              panel = $(this);

          if (panel.hasClass("oj-disabled")) 
          {
            self.disable(index);
          }

          if (originalAriaControls)
            tab.data("oj-tabs-aria-controls", originalAriaControls);

          tab.attr(
            {
              "aria-controls" : panel.uniqueId().attr("id"),
              "aria-labelledby" : anchorId
            });

          self.panels = self.panels.add(panel);
          panel.attr("aria-labelledby", anchorId);
        });

      if (this.options.orientation == "vertical")
      {
        //find out the longest tab width
        var maxTabWidth = 0,
            sumTabHeight = 0;

        this.tabs
          .addClass("oj-tabs-active")
          .each(function ()
            {
              var tab = $(this);
              maxTabWidth = Math.max(maxTabWidth, tab.width());
              sumTabHeight += tab.outerHeight(true);
            })
          .removeClass("oj-tabs-active");

        if (this.options.removable)
        {
          maxTabWidth += _CLOSE_ICON_SIZE;
        }

        this.tabs.css(
          {
            'width': maxTabWidth + "px"
          });

        var outerWidth = this.tablist.outerWidth(true);
        if (this._GetReadingDirection() == "rtl")
        {
          this.panels.css(
            {
              'margin-right': outerWidth - 1 + "px",
              'min-height': sumTabHeight + "px"
            });
        }
        else
        {
          this.panels.css(        
            {
              'margin-left': outerWidth - 1 + "px",
              'min-height': sumTabHeight + "px"
            });
          }
      }

      this.panels.addClass("oj-tabs-panel")
        .attr("role", "tabpanel");

    },

    _setupDisabled : function (disabled)
    {
      if (Array.isArray(disabled))
      {
        if (!disabled.length)
        {
          disabled = false;
        }
        else if (disabled.length === this.tabs.length)
        {
          disabled = true;
        }
      }

      // disable tabs
      this.tabs.each(function (index)
      {
        if (disabled === true || $.inArray(index, disabled) !==  - 1)
        {
          $(this).addClass("oj-disabled")
            .attr("aria-disabled", "true");
        }
        else 
        {
          $(this).removeClass("oj-disabled")
            .removeAttr("aria-disabled");
        }
      });

      this.options.disabled = disabled;
    },

    _setupEvents : function ()
    {
      // Prevent users from focusing disabled tabs via click
      this.element.on("mousedown" + this.eventNamespace, ".oj-tabs-nav > li",  
        function (event)
        {
          if ($(this).is(".oj-disabled"))
            event.preventDefault();
        });

/*
        // support: IE <9
        // Preventing the default action in mousedown doesn't prevent IE
        // from focusing the element, so if the anchor gets focused, blur.
        // We don't have to worry about focusing the previously focused
        // element since clicking on a non-focusable element should focus
        // the body anyway.
        .on("focus" + this.eventNamespace, ".oj-tabs-anchor", 
          function ()
          {
            if ($(this).closest("li").is(".oj-disabled"))
              this.blur();
          });
*/

      var events = 
      {
        'keydown' : this._tabKeydown
      };

      var event = this.options.selectOn;
      if (event)
      {
        var self = this;
        $.each(event.split(" "), function (index, eventName)
        {
          events[eventName] = self._eventHandler;
        });
      }

      var enabledTabs = this.tabs.not(".oj-disabled");

      this._on(enabledTabs, events);
      this._on(this.panels, 
      {
        'keydown' : this._panelKeydown
      });

      //add listeners on close icon
      if (this.options.removable)
      {
        var revents = 
        {
          "click" : this._removeTabHandler
        }
        this._on(enabledTabs.find("." + _CLOSE_ICON), revents);
      }

      this._focusable(enabledTabs);
      this._hoverable(enabledTabs);
      this._activeable(enabledTabs);

    },

    _tearDownEvents : function ()
    {
      var enabledTabs = this.tabs.not(".oj-disabled");
      this._off(enabledTabs);
      this._off(this.panels);

      this.element.off("mousedown" + this.eventNamespace);
    },

    _eventHandler : function (event)
    {
      var options = this.options, 
          active = this.active, 
          anchor = $(event.currentTarget), 
          tab = anchor.closest("li"), 
          clickedIsActive = tab[0] === active[0], 
          toShow = this._getPanelForTab(tab), 
          toHide = !active.length ? $() : this._getPanelForTab(active), 

          eventData = 
          {
            /** @expose */
            oldHeader : active, 
            /** @expose */
            oldContent : toHide, 
            /** @expose */
            newHeader : tab, 
            /** @expose */
            newContent : toShow
          },

          deselectData = 
          {
            /** @expose */
            oldHeader : eventData.newHeader,
            /** @expose */
            oldContent : eventData.newContent,
            /** @expose */
            newHeader : eventData.oldHeader,
            /** @expose */
            newContent : eventData.oldContent
          };


      event.preventDefault();

      if (tab.hasClass("oj-disabled") || 

      // can't switch durning an animation
      this.running || 
          // click on active header, 
          (clickedIsActive) || 
          // allow canceling deselect
          ((! this._initialActivate) &&
           (this._trigger("beforeDeselect", event, deselectData) === false)) ||
          // allow canceling select
          (this._trigger("beforeSelect", event, eventData) === false))
      {
        return;
      }

      options.selected = this.tabs.index(tab);

      this.active = clickedIsActive ? $() : tab;

      if (!toHide.length && !toShow.length)
      {
        $.error("OJ Tabs: Mismatching fragment identifier.");
      }

      this._toggle(event, eventData);
    },

    // handles show/hide for selecting tabs
    _toggle : function (event, eventData)
    {
      var self = this, 
          toShow = eventData.newContent, 
          toHide = eventData.oldContent;

      this.running = true;

      function complete()
      {
        self.running = false;

        if (! this._initialActivate)
          self._trigger("afterDeselect", event, eventData);
        self._trigger("afterSelect", event, eventData);

        var oldIndex = -1,
            newIndex = -1;
        if (eventData)
        {
          var tab = eventData.oldHeader;
          if (tab)
            oldIndex = self.tabs.index(tab);
          tab = eventData.newHeader;
          if (tab)
            newIndex = self.tabs.index(tab);
        }
        self._fireOptionChange("selected", oldIndex, newIndex, event ? true : false);
      }

      function show()
      {
        var active = eventData.newHeader.closest("li");
        active.addClass("oj-tabs-active");

        toShow.show();
        complete();
      }

      // start out by hiding, then showing, then completing
      var old = eventData.oldHeader.closest("li");
      old.removeClass("oj-tabs-active");

      toHide.hide();
      show();

      toHide.attr(
      {
        "aria-expanded" : "false", 
        "aria-hidden" : "true"
      });

      eventData.oldHeader.attr("aria-selected", "false");
      // If we're switching tabs, remove the old tab from the tab order.
      // If we're opening from collapsed state, remove the previous tab from the tab order.
      if (toShow.length && toHide.length)
      {
        eventData.oldHeader.attr("tabIndex", "-1");
      }
      else if (toShow.length)
      {
        this.tabs.filter(function ()
        {
          return $(this).attr("tabIndex") === "0";
        })
          .attr("tabIndex", "-1");
      }

      toShow.attr(
      {
        "aria-expanded" : "true", 
        "aria-hidden" : "false"
      });

      eventData.newHeader.attr(
      {
        "aria-selected" : "true", "tabIndex" : "0"
      });

    },

    _activate : function (index)
    {
      var anchor, 
          active = this._findActive(index);

      // trying to activate the already active panel
      if (active[0] === this.active[0])
        return;

      // simulate a click on the current active header
      if (!active.length)
        active = this.active;

      this.options.selected = index;

      anchor = active.find(".oj-tabs-anchor")[0];
      this._eventHandler(
      {
        target : anchor, 
        currentTarget : anchor, 
        preventDefault : $.noop
      });
    },

    _findActive : function (index)
    {
      return this.tabs.eq(index);
    },

    _createCloseIcons : function ()
    {
      //create close icon only if it's not disabled
      if (this.options.removable)
      {
//        var removeCueText = this.getTranslatedString("removeCueText");
        var removeCueText = this.options.removeCueText;
        this.tabs.not(".oj-disabled").each(function (index)
        {
          var div = $(this).find("> :first-child");

          //add cue text for removable icon for screen reader users
          var rmId = _ID_PREFIX + "rm_" + index;
          $(this).attr("aria-describedby", rmId);

          $("<a href='#'>")
            .addClass("oj-tabs-icon oj-component-icon oj-clickable-icon " + _CLOSE_ICON)
            .attr(
              {
                "id": rmId,
                "tabIndex" : "-1",
                "aria-label" : removeCueText,
                "role" : "presentation"
              })
            .appendTo(div);

        });
      }
    },

    _destroyCloseIcons : function ()
    {
      this.tabs.find(_CLOSE_ICON).remove();
    },

    _destroyTabBar : function ()
    {
      //remove listener
      this._tabMaxWidthApplied = false;
      if (this._hasResizeListener)
      {
        oj.DomUtils.removeResizeListener(this.element[0], $.proxy(this._handleResize, this));
        this._hasResizeListener = false;
        this._originalWidth = undefined;
      }

      if (this.conveyor) {
        this.conveyor.ojConveyorBelt( "destroy" );
        this.conveyor.remove();
        this.conveyor = null;
        this.active = null;
      }
      else
      {
        this.element.children(".oj-tabs-nav").remove();
      }
    },

    _destroy : function ()
    {
      var orientation = this.options.orientation;
      if (orientation == "vertical")
        this.element.removeClass("oj-tabs-vertical oj-component oj-helper-clearfix");
      else
      this.element.removeClass("oj-tabs oj-component ");

      //destroy tab bar and conveyor
      this._destroyTabBar();

      var self = this;
      this.panels.each(function ()
      {
        $(this).removeAttr("tabIndex")
          .removeAttr("aria-expanded")
          .removeAttr("aria-selected")
          .removeAttr("aria-labelledby")
          .removeAttr("aria-hidden")
          .removeAttr("role")
          .removeClass("oj-active oj-disabled oj-tabs-panel")
          .css("display", "");

        if (orientation == "vertical")
        {
          $(this).css("margin-left", "")
            .css("min-height", "");
        }

        //remove display:none
        var header = $(this).find("> :first-child");
        header.css("display", "")
          .removeAttr("aria-hidden");

        //remove prefix from ids
        self._removePrefixIds(header);

      });
    },

    /**
     * Enables a tab.
     * 
     * @expose 
     * @memberof! oj.ojTabs
     * @instance
     * @param {number} index zero-based index of the tabs to enable
     * @example <caption>Invoke the <code class="prettyprint">enable</code> method:</caption>
     * $( ".selector" ).ojTabs( "enable", 1 );
     */
    enable : function (index)
    {
      var disabled = this.options.disabled;
      if (disabled === false)
        return;

      if (index === undefined)
      {
        disabled = false;
      }
      else 
      {
        if (Array.isArray(disabled))
        {
          disabled = $.map(disabled, function (num)
          {
            return num !== index ? num : null;
          });
        }
        else 
        {
          disabled = $.map(this.tabs, function (li, num)
          {
            return num !== index ? num : null;
          });
        }
      }
      this._setupDisabled(disabled);
    },

    /**
     * Disables a tab.
     * 
     * @expose 
     * @memberof! oj.ojTabs
     * @instance
     * @param {number} index zero-based index of the tabs to disable
     * @example <caption>Invoke the <code class="prettyprint">disable</code> method:</caption>
     * $( ".selector" ).ojTabs( "disable", 1 );
     */
    disable : function (index)
    {
      var disabled = this.options.disabled;
      if (disabled === true)
        return;

      if (index === undefined)
      {
        disabled = true;
      }
      else 
      {
        if ($.inArray(index, disabled) !==  - 1)
          return;

        if (Array.isArray(disabled))
        {
          disabled = $.merge([index], disabled).sort();
        }
        else 
        {
          disabled = [index];
        }
      }
      this._setupDisabled(disabled);
    },

    _setRemovable : function (removable)
    {
      if (removable === this.options.removable)
        return;

      this.options.removable = removable;
      this.refresh();
    },

    _removeTabHandler : function (event)
    {
      var icon = $(event.currentTarget),
          tab = icon.closest("li"),
          panel = this._getPanelForTab(tab),
          eventData = 
          {
            /** @expose */
            header : tab, 
            /** @expose */
            content : panel
          };

      //trigger before delete event and only delete if it's not cancelled
      if (tab && this._trigger("beforeRemove", event, eventData) !== false)
      {
        var idxRmTab = this.tabs.index(tab);

        //if tab to be removed is selected, select the next enabled tab
        if (tab.hasClass("oj-tabs-active"))
        {
          this.options.selected = this._activateNextTab(idxRmTab);
        }
        else if (idxRmTab < this.options.selected)
        {
          this.options.selected = Math.max(0, this.options.selected - 1)
        }

        //Bug 18269291 - If user closes tab then index for tabs changes and disabled tab becomes enable
        // update indexes of disabled tabs 
        if (Array.isArray(this.options.disabled))
        {
          var adis = this.options.disabled;
          for(var i = adis.length - 1; i >= 0; i--) {
            if (idxRmTab == adis[i]) {
              this.options.disabled = adis = adis.splice(i, 1);
            }
            else if (idxRmTab < adis[i])
              adis[i] = adis[i] - 1;
          }
        }

        panel.remove();
        tab.remove();

        //fire select event 
        this._initialActivate = this.options.selected;
        this.refresh();

        //set focus on the active
        this.active.focus();

        this._trigger("afterRemove", event, eventData);
      }
    },

    /**
     * Add a tab to the end of the tabs
     * 
     * @expose 
     * @memberof! oj.ojTabs
     * @instance
     * @param {jQuery} newTab jQuery object of the new tab
     * @example <caption>Invoke the <code class="prettyprint">addTab</code> method:</caption>
     * $( ".selector" ).ojTabs( "addTab", $("&lt;div>&lt;h3>New Tab&lt;/h3>&lt;p>Content of New Tab&lt;/p>&lt;/div>") );
     */
    addTab : function (newTab)
    {
      this.element.append(newTab);
      var options = this.options;

      //in case all tabs are disabled, make sure the new tab is enabled.
      if (options.selected == -1) {
        options.selected = this.tabs.length;

        var disabledTabs = this.tabs.filter(".oj-disabled");
        var self = this;
        options.disabled = $.map(disabledTabs, 
          function (li)
          {
            return self.tabs.index(li);
          });
      }
      this.refresh();
    },

    _setupReorder : function ()
    {
      var tabBar = this.conveyor ? this.conveyor.find(".oj-tabs-nav") :
        this.element.children(".oj-tabs-nav");

      //enable sortable
      if (this.options.reorderable)
      {
        var self = this;
        tabBar.sortable(
        {
          axis: (self.options.orientation == "horizontal") ? "x" : "y",
          stop: function(event, ui) {              
            //find the element that was moved
            //to move its content
            var mvTab = ui.item;
            var mvContent = self._getPanelForTab(mvTab);

            var prevTab = mvTab.prev();
            if (prevTab.length)
            {
              self._getPanelForTab(prevTab).after(mvContent);
            }
            else if (self.panels.length > 0)
            {
              self.panels.first().before(mvContent);
            }

            //Bug 18680706 - calling refresh after reordering tabs causes tabs to loose there disabled state 
            //update disabled and active
            var arr  = [];
            tabBar.children(".oj-disabled").each(
              function() {
                arr.push($(this).index());
              }
            );

            self.options.disabled = arr;
            self.options.selected = tabBar.children(".oj-tabs-active").index();

          }
        })
      }
      //disable sortable
      else
      {
        tabBar.sortable({ disabled: true });
      }
    },

    _setupOrientation : function (value)
    {
      if (! value)
        value = this.options.orientation;

      if (value == "horizontal")
      {
        if (this.options.orientation == "vertical" && this.panels)
        {
          this.panels.each(function ()
          {
            $(this).css("margin-left", "")
              .css("min-height", "");
          });
        }
        this.element.addClass("oj-tabs oj-component");
      }

      //TODO: need refresh
      else if (value == "vertical")
      {
        this.element.addClass( "oj-tabs-vertical oj-component oj-helper-clearfix" );
      }
      else
      {
        return;
      }
      this.options.orientation = value;

    },

    //Bug 18290621 - ojtabs do not work with tabs whose id has '::' 
    _sanitizeSelector: function( hash ) {
      return hash ? hash.replace( /[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g, "\\$&" ) : "";
    },

    _getPanelForTab : function (tab)
    {
      var id = $(tab).attr("aria-controls");
      return this.element.find(this._sanitizeSelector("#" + id));
    },

    _addPrefixId : function (elem)
    {
      if (elem.id.indexOf(_ID_PREFIX) < 0)
        $(elem).attr("id", _ID_PREFIX + elem.id);
    },

    _removePrefixId : function (elem)
    {
      if (elem.id.indexOf(_ID_PREFIX) == 0)
        $(elem).attr("id", elem.id.substring(_ID_PREFIX.length));
    },

    _removePrefixIds : function (header)
    {
      //remove prefix from ids
      var self = this;
      var ohd = header[0];
      if (ohd.id)
        this._removePrefixId(ohd);
      header.find("[id]").each(function() {
        self._removePrefixId(this);
      });
    },

    /**
     * Return the subcomponent node represented by the documented locator 
     * attribute values.
     *
     * To lookup a title text the locator object should have the following:
     *          subId: 'oj-tabs-title'
     *          index: number
     *
     * To lookup a close icon the locator object should have the following:
     *          subId: 'oj-tabs-close-icon'
     *          index: number       
     *
     * To lookup a panel content the locator object should have the following:
     *          subId: 'oj-tabs-panel'
     *          index: number
     *
     * To lookup the conveyorbelt the locator object should have the following:
     *          subId: 'oj-conveyorbelt'
     *
     * @expose
     * @memberof! oj.ojTabs
     * @instance
     * @override
     * @param {Object} locator An Object containing at minimum a subId property 
     *        whose value is a string, documented by the component, that allows 
     *        the component to look up the subcomponent associated with that 
     *        string.  It contains:<p>
     *        component: optional - in the future there may be more than one 
     *        component contained within a page element<p>
     *        subId: the string, documented by the component, that the component 
     *        expects in getNodeBySubId to locate a particular subcomponent
     * @returns {Element|null} the subcomponent located by the subId string passed
     *          in locator, if found.<p>
     */
    getNodeBySubId: function(locator)
    {
      if (locator == null)
      {
        return this.element ? this.element[0] : null;
      }

      var subId = locator['subId'],
          index = locator['index'];

      switch (subId)
      {
      case 'oj-conveyorbelt':
        return this.conveyor ? this.conveyor[0] : null;

      case 'oj-tabs-panel':
        return this.panels[index];

      case 'oj-tabs-title':
        return this.titles[index];

      case 'oj-tabs-close-icon':
        return this.tabs.eq(index).find("." + subId)[0];
      }

      // Non-null locators have to be handled by the component subclasses
      return null;
    },

    _getTabsWidth: function()
    {
      return this.element[0].clientWidth;
    },

    _isOverflow: function()
    {
      return (this._originalWidth > this._getTabsWidth());
    },

    _isMaxWidthApplied: function()
    {
      return this._tabMaxWidthApplied;
    },

    _setMaxWidthApplied: function(bval)
    {
      this._tabMaxWidthApplied = bval;
    },

    _getTabMaxWidth: function()
    {
      var max = Math.floor(this._getTabsWidth()  / this.tabs.length);

      if (this.options.removable)
        max -= _CLOSE_ICON_SIZE;

      return max;
    },

    _applyTabMaxWidth: function()
    {
      if (! this._isMaxWidthApplied())
      {
        var maxWidth = this._getTabMaxWidth();

        this.titles.each(function (index)
        {
          $(this)
            .css("max-width", "" + maxWidth + "px")
            .addClass("oj-tabs-title-overflow");
        });

        this._setMaxWidthApplied(true);
        this._logMessage("apply max width");
      }
    },

    _removeTabMaxWidth: function()
    {
      if (this._isMaxWidthApplied())
      {
        this.titles.each(function (index)
        {
          $(this)
            .css("max-width", "")
            .removeClass("oj-tabs-title-overflow");
        });

        this._setMaxWidthApplied(false);
        this._logMessage("remove max width");
      }
    },

    _logMessage: function(msg)
    {
//      console.log(msg);
    },

    /* resize handler */
    _handleResize: function(width, height)
    {
      this._logMessage("width " + width + " ulWidth " + this._originalWidth +
                       " clientWidth " + this._getTabsWidth());

      if (this._isOverflow())
      {
        this._logMessage("overflow");
        this._applyTabMaxWidth();
      }
      else
      {
        this._logMessage("underflow");
        this._removeTabMaxWidth();
      }
    },

    _getTabbarWrapper: function()
    {
      var ulParent = this.tablist.parent();
      if (! ulParent.hasClass("oj-tabs-conveyor"))
      {
        ulParent = this.tablist
            .wrap("<div>")
            .parent()
            .addClass("oj-tabs-conveyor");
      }
      return ulParent;
    },

    _isProgressive: function()
    {
      return this.options.truncation == "auto" ||
        this.options.truncation == "progressive";
    },

    _truncateBeforeOverflow: function()
    {
      var options = this.options;
      if (options.orientation == "horizontal" && this.tabs.length > 0 && 
          this._isProgressive())
      {
        oj.DomUtils.addResizeListener(this.element[0], $.proxy(this._handleResize, this));
        this._hasResizeListener = true;

        //handle initial overflow
        this._originalWidth = this._getTabbarWrapper()[0].scrollWidth;

        if (this._isOverflow())
          this._applyTabMaxWidth();
      }
    },

    /**
     * Fire optionChange event 
     * @param {String} key - 'selected'
     * @param {Object} previousValue 
     * @param {Object} value
     * @param {Boolean} originalEvent  
     *
     * @private
     */
    _fireOptionChange: function(key, previousValue, value, originalEvent) 
    {
      var ui = {
        "option": key,
        "previousValue": previousValue,
        "value": value,
        // (originalEvent is non-null) iff (option change is due to user interaction) 
        // iff (binding should write back the value)
        "optionMetadata": {'writeback': originalEvent ? "shouldWrite" : "shouldNotWrite"}
      };
      this._trigger('optionChange', originalEvent, ui);
    }

  });
}
());


/**
 * @export
 * A CellSet represents a collection of cells.  The CellSet is an object returned by the success callback
 * of the fetchCells method on DataGridDataSource.  The OJCollectionCellSet is an oj collection specific 
 * implementation of methods on CellSet. 
 * @param {number} startRow the start row index of the cell set
 * @param {number} endRow the end row index of the cell set
 * @param {number} startColumn the start column index of the cell set
 * @param {number} endColumn the end column index of the cell set
 * @param {Object} collection the OJ collection instance
 * @param {Array|null} columns the set of column keys
 * @param {number=} offset the start index used for paging
 * @constructor
 */
oj.CollectionCellSet = function(startRow, endRow, startColumn, endColumn, collection, columns, offset)
{
    // assert startRow/startColumn are number
    oj.Assert.assertNumber(startRow, null);
    oj.Assert.assertNumber(endRow, null);
    oj.Assert.assertNumber(startColumn, null);
    oj.Assert.assertNumber(endColumn, null);
    oj.Assert.assertArrayOrNull(columns);

    this.m_startRow = startRow;
    this.m_endRow = endRow;
    this.m_startColumn = startColumn;
    this.m_endColumn = endColumn;
    this.m_collection = collection;
    this.m_columns = columns;
    this.m_offset = offset;
};

/**
 * Gets the data of the specified index.  An error is throw when 1) the range is not yet available 
 * 2) the index specified is out of bounds. 
 * @param {Object} indexes the index of each axis in which we want to retrieve the data from.  
 * @param {number} indexes.row the index of the row axis.
 * @param {number} indexes.column the index of the column axis.
 * @return {Object} the data object for the specified index.
 * @export
 */
oj.CollectionCellSet.prototype.getData = function(indexes)
{
    var column, model;
    var self = this;
    model = this._getModel(indexes);
    this._getModel(indexes).done(function (model) { self.model = model });
    if (self.model == null)
    {
        return null;
    }

    // extract column index
    column = indexes['column'];

    // make sure index are valid (row index is checked in _getModel
    oj.Assert.assert(column >= this.m_startColumn && column <= this.m_endColumn); 

    return self.model.get(this.m_columns[column]);
};

/**
 * Gets the metadata of the specified index.  An error is throw when 1) the range is not yet available 
 * 2) the index specified is out of bounds. 
 * @param {Object} indexes the index of each axis in which we want to retrieve the metadata from.  
 * @param {number} indexes.row the index of the row axis.
 * @param {number} indexes.column the index of the column axis.
 * @return the metadata object for the specific index.  The metadata that the DataGrid supports are: 
 *         1) keys - the key (of each axis) of the cell.
 * @export
 */
oj.CollectionCellSet.prototype.getMetadata = function(indexes)
{
    var column, model, keys;
    var self = this;
    model = this._getModel(indexes);
    this._getModel(indexes).done(function (model) { self.model = model });
    
    if (self.model == null)
    {
        return null;
    }

    // extract column index
    column = indexes['column'];

    // make sure index are valid (row index is checked in _getModel
    oj.Assert.assert(column >= this.m_startColumn && column <= this.m_endColumn); 

    keys = {"row": oj.CollectionDataGridUtils._getModelKey(self.model), "column": this.m_columns[column]};
    return {"keys": keys};
};

/**
 * Gets the Model based on indexes.
 * @private
 */
oj.CollectionCellSet.prototype._getModel = function(indexes)
{
    var row, column;

    oj.Assert.assertObject(indexes);

    // extract row and column index
    row = indexes['row'];
	if (this.m_offset != null)
	{
		row += this.m_offset;
	}
    column = indexes['column'];

    // make sure index are valid
    oj.Assert.assert(row >= this.m_startRow && row <= this.m_endRow && column >= this.m_startColumn && column <= this.m_endColumn); 

    return this.m_collection.at(row, {'deferred':true});
};

/**
 * Gets the actual count of the result set for the specified axis.  Valid values are "row" and "column".
 * @param {string} axis the axis in which to inquire the actual count of the result set.
 * @return {number} the actual count of the result set for the specified axis.  
 * @export
 */
oj.CollectionCellSet.prototype.getCount = function(axis)
{
    if (axis === "row")
    {
        return Math.max(0, this.m_endRow - this.m_startRow);
    }
    
    if (axis === "column")
    {
        return Math.max(0, this.m_endColumn - this.m_startColumn);
    }

    return 0;
};

/**
 * Gets the m_startRow property
 * @export
 */
oj.CollectionCellSet.prototype.getStartRow = function()
{
    return this.m_startRow;
};

/**
 * Gets the m_endRow property
 * @export
 */
oj.CollectionCellSet.prototype.getEndRow = function()
{
    return this.m_endRow;
};

/**
 * Gets the m_startColumn property
 * @export
 */
oj.CollectionCellSet.prototype.getStartColumn = function()
{
    return this.m_startColumn;
};

/**
 * Gets the m_endColumn property
 * @export
 */
oj.CollectionCellSet.prototype.getEndColumn = function()
{
    return this.m_endColumn;
};

/**
 * Gets the m_collection property
 * @export
 */
oj.CollectionCellSet.prototype.getCollection = function()
{
    return this.m_collection;
};

/**
 * Gets the m_columns property
 * @export
 */
oj.CollectionCellSet.prototype.getColumns = function()
{
    return this.m_columns;
};


/**
 * This class contains all utility methods used by the data grid colelction model.
 * @constructor
 */
oj.CollectionDataGridUtils = function()
{
};

/**
 * Returns the key of the model. It is the id if one is set otherwise
 * it is the cId
 * @param {Object} model the model to chececk for id and cid
 * @return {String} the id or cid for the model
 */
oj.CollectionDataGridUtils._getModelKey = function(model)
{
    var key;
    key = model.GetId();
    if (key == null)
    {
        key = model.GetCid();
    }
    return key;
};
/**
 * @export
 * A HeaderSet represents a collection of headers.  The HeaderSet is an object returned by the success callback
 * of the fetchHeaders method on DataGridDataSource.  This is an oj collection specific implementation of the HeaderSet.
 * @param {number} start the start index of header set.
 * @param {number} end the end index of the header set.
 * @param {Array} headers the array of headers
 * @param {Object=} collection the OJ collection.  Required for row headers.
 * @param {string=} rowHeader the id of the row header column.  Required for row headers.
 * @param {number=} offset the start index used for paging. Required for row headers.
 * @constructor
 */
oj.CollectionHeaderSet = function(start, end, headers, collection, rowHeader, offset)
{
    // assert start/end are number
    oj.Assert.assertNumber(start, null);
    oj.Assert.assertNumber(end, null);
    oj.Assert.assertArrayOrNull(headers);

    this.m_start = start;
    this.m_end = end;
    this.m_headers = headers;
    this.m_collection = collection;
    this.m_rowHeader = rowHeader;
	this.m_offset = offset;	
};

/**
 * Gets the data of the specified index.  An error is throw when 1) the range is not yet available and
 * 2) the index specified is out of bounds. 
 * @param {number} index the index of the header in which we want to retrieve the header from.  
 * @return {Object} the data object for the specific index.
 * @export
 */
oj.CollectionHeaderSet.prototype.getData = function(index)
{
    // make sure index are valid
    oj.Assert.assert(index <= this.m_end && index >= this.m_start); 
    var self = this;
    // row or column header
    if (this.m_rowHeader != null && this.m_collection != null)
    {
		if (this.m_offset != null)
		{
			index += this.m_offset;
		}
        this.m_collection.at(index, {'deferred':true}).done(function (model) { self.model = model });
        return self.model.get(this.m_rowHeader);
    }
    else
    {
        return this.m_headers[index];
    }
};

/**
 * Gets the metadata of the specified index.  An error is throw when 1) the range is not yet available and 
 * 2) the index specified is out of bounds. 
 * The metadata that the data source can optionally return are:
 *  1) sortDirection - the initial sort direction of the header.  Valid values are "ascending" and "descending".
 *  2) key - the key of the row/column header.
 * @param {number} index the index of the header in which we want to retrieve the metadata from.  
 * @return {Object} the metadata object for the specific index.
 * @export
 */
oj.CollectionHeaderSet.prototype.getMetadata = function(index)
{
    var data, self;
    if (this.m_rowHeader != null && this.m_collection != null)
    {
        self = this;
		if (this.m_offset != null)
		{
			index += this.m_offset;
		}		
        this.m_collection.at(index, {'deferred':true}).done(function (model) { self.model = model });
        
        if (self.model == null)
        {
            return null;
        }
        
        return {'key':oj.CollectionDataGridUtils._getModelKey(self.model)};
    }    
    else
    {
        data = this.getData(index);
        return {'key': data};
    }    
    
};

/**
 * Gets the actual count of the result set.
 *
 * @return {number} the actual count of the result set.  
 * @export
 */
oj.CollectionHeaderSet.prototype.getCount = function()
{
    return Math.max(0, this.m_end - this.m_start);
};

/**
 * Gets the m_start property
 * @export
 */
oj.CollectionHeaderSet.prototype.getStart = function()
{
    return this.m_start;
};

/**
 * Gets the m_end property
 * @export
 */
oj.CollectionHeaderSet.prototype.getEnd = function()
{
    return this.m_end;
};

/**
 * Gets the m_headers property
 * @export
 */
oj.CollectionHeaderSet.prototype.getHeaders = function()
{
    return this.m_headers;
};

/**
 * Gets the m_rowHeader property
 * @export
 */
oj.CollectionHeaderSet.prototype.getRowHeader = function()
{
    return this.m_rowHeader;
};

/**
 * Gets the m_collection property
 * @export
 */
oj.CollectionHeaderSet.prototype.getCollection = function()
{
    return this.m_collection;
};


/**
 * An OJ Collection based implementation of the DataGridDataSource.
 * @param {Object} collection the oj collection to adapter the DataGridDataSource
 * @param {Object=} options optional settings on this oj collection data source
 * @param {string=} options.rowHeader the key of the attribute designated as the row header
 * @param {Array.<string>=} options.columns explicitly specifies columns to display and in 
 *        what order.  These columns must be a subset of attributes from Model. * @constructor
 * @export
 * @constructor
 * @extends oj.DataGridDataSource
 */
oj.CollectionDataGridDataSource = function(collection, options)
{
    this.collection = collection;
    if (options != null)
    {
        this.rowHeader = options['rowHeader'];
        this.columns = options['columns'];
    }
    this._startIndex = 0;
    this._pageSize = -1;
    this._totalSize = -1;  
    oj.CollectionDataGridDataSource.superclass.constructor.call(this);
};

//subclass of DataGridDataSource
oj.Object.createSubclass(oj.CollectionDataGridDataSource, oj.DataGridDataSource, "oj.CollectionDataGridDataSource");

/**
 * Initial the OJ collection based data source.
 * @export
 */
oj.CollectionDataGridDataSource.prototype.Init = function()
{
    // call super
    oj.CollectionDataGridDataSource.superclass.Init.call(this);

    this.pendingHeaderCallback = {};

    if (!this._isRemote())
    {
        // extract column info for local collection
        if (this.columns == null && this.collection.length > 0)
        {
            this.columns = this.collection.first().keys();
            if (this.columns.indexOf(this.rowHeader) != -1)
            {
                this.columns.splice(this.columns.indexOf(this.rowHeader),1);
            }
        }
    }
 
    this._registerEventListeners();
};

/**
 * Register event handlers on the underlying OJ collection.
 * @private
 */
oj.CollectionDataGridDataSource.prototype._registerEventListeners = function()
{
    this.collection.on("add", this._handleModelAdded.bind(this));
    this.collection.on("remove", this._handleModelDeleted.bind(this));
    this.collection.on("change", this._handleModelChanged.bind(this));
    this.collection.on("refresh", this._handleCollectionRefresh.bind(this));
};

/**
 * Whether this collection is associated with a remote rest services
 * @private
 */
oj.CollectionDataGridDataSource.prototype._isRemote = function()
{
    // if this is a url specified in the option
    return (this.collection['url'] != null);
};

/**
 * Determines if data is locally available.
 * @return {boolean} true if data is locally available, false otherwise.
 * @private
 */
oj.CollectionDataGridDataSource.prototype._isDataAvailable = function()
{
    if (this._isRemote())
    {
        return (this.data != null);
    }
    // for local collection, always return true;
    return true;
};

/**
 * Determines if header data is locally available.
 * @param {string} axis the axis in which we inquire for the total count.  Valid values are "row" and "column".
 * @return {boolean} true if data is locally available, false otherwise.
 * @private
 */
oj.CollectionDataGridDataSource.prototype._isHeaderAvailable = function(axis)
{
    if (this._isRemote())
    {
        if (axis === "column")
        {
            return (this.columns != null);
        }
        else if (axis === "row")
        {
            // only if row header is specified
            if (this.rowHeader != null)
            {
                return (this.data != null);
            }
        }
    }
    // for local collection, always return true;
    return true;
};

/**
 * Returns the total number of rows or columns.  If the value return is not >= 0 then it is automatically assumed
 * that the total count is unknown. In the case of paging returns the total number of rows/colums on the page.
 * @param {string} axis the axis in which we inquire for the total count.  Valid values are "row" and "column".
 * @return {number} the total number of rows/columns.
 * @export
 */
oj.CollectionDataGridDataSource.prototype.getCount = function(axis)
{
    // not done fetching yet, provide an estimate count
    if (!this._isHeaderAvailable(axis))
    {
        this.precision = "estimate";
        return -1;
    }

    this.precision = "exact";
    if (axis == "row")
    {
        return this.size();
    }
    if (axis == "column")
    {
        return this.columns.length;
    }

    // should not get here
    return 0;
};

/**
 * Returns whether the total count returned in getCount function is an actual or an estimate.
 * @param {string} axis the axis in which we inquire whether the total count is an estimate.  Valid values are 
 *        "row" and "column".
 * @return {string} "actual" if the count returned in getCount function is the actual count, "estimate" if the 
 *         count returned in getCount function is an estimate.  The default value is "actual".
 * @export
 */
oj.CollectionDataGridDataSource.prototype.getCountPrecision = function(axis)
{
    // if precision has not been determine, invoke getCount
    if (this.precision == null)
    {
        this.getCount(axis);
    }
    return this.precision;
};

/**
 * Fetch a range of headers from the data source.
 * @param {Object} headerRange information about the header range, it must contain the following properties:
 *        axis, start, count.
 * @param {string} headerRange.axis the axis of the header that are fetched.  Valid values are "row" and "column".
 * @param {number} headerRange.start the start index of the range in which the header data are fetched.
 * @param {number} headerRange.count the size of the range in which the header data are fetched.  
 * @param {Object} callbacks the callbacks to be invoke when fetch headers operation is completed.  The valid callback
 *        types are "success" and "error".
 * @param {function(HeaderSet)} callbacks.success the callback to invoke when fetch headers completed successfully.
 * @param {function({status: Object})} callbacks.error the callback to invoke when fetch cells failed.
 * @param {Object=} callbackObjects the object in which the callback function is invoked on.  This is optional.  
 *        You can specify the callback object for each callbacks using the "success" and "error" keys.
 * @export
 */
oj.CollectionDataGridDataSource.prototype.fetchHeaders = function(headerRange, callbacks, callbackObjects)
{
    var axis, callback;

    axis = headerRange.axis;
    if (this._isHeaderAvailable(axis))
    {
        // headers are locally available
        this._handleHeaderFetchSuccess(headerRange, callbacks, callbackObjects);
    }
    else
    {
        // still fetching, just store the callback info
        if (callbacks != null)
        {
            callback = {};
            callback.headerRange = headerRange;
            callback.callbacks = callbacks;
            callback.callbackObjects = callbackObjects;
            this.pendingHeaderCallback[axis] = callback;
        }
    }
};

/**
 * Handle success fetchHeaders request
 * @param {Object} headerRange information about the header range, it must contain the following properties:
 *        axis, start, count.
 * @param {string} headerRange.axis the axis of the header that are fetched.  Valid values are "row" and "column".
 * @param {number} headerRange.start the start index of the range in which the header data are fetched.
 * @param {number} headerRange.count the size of the range in which the header data are fetched.  
 * @param {Object} callbacks the callbacks to be invoke when fetch headers operation is completed.  The valid callback
 *        types are "success" and "error".
 * @param {function(HeaderSet)} callbacks.success the callback to invoke when fetch headers completed successfully.
 * @param {function({status: Object})} callbacks.error the callback to invoke when fetch cells failed.
 * @param {Object=} callbackObjects the object in which the callback function is invoked on.  This is optional.  
 *        You can specify the callback object for each callbacks using the "success" and "error" keys.
 */
oj.CollectionDataGridDataSource.prototype._handleHeaderFetchSuccess = function(headerRange, callbacks, callbackObjects)
{
    var axis, start, count, end, callback, headerSet;

    axis = headerRange.axis;
    start = headerRange.start;
    count = headerRange.count;	            

    oj.Assert.assert(axis === 'row' || axis === 'column');
    oj.Assert.assert(count > 0);
		
    if (axis === "column")
    {  
         // column headers, this.columns should be populated by now
        if (this.columns != null)
        {
            end = Math.min(this.columns.length, start+count);
            headerSet = new oj.CollectionHeaderSet(start, end, this.columns);
        }
        else
        {
            // no row header, return empty result set
            headerSet = new oj.ArrayHeaderSet(start, start, axis, null);
        }
    }
    else if (axis === "row")
    {
        // row headers, return non-empty header set if row header is specified
        if (this.rowHeader != null)
        {
            end = Math.min(this.size(), start+count);
            if (this._pageSize > 0)
            {
                end = Math.min(end, this._startIndex + this._pageSize);
                end = Math.min(end, this.totalSize() - this._startIndex);
                headerSet = new oj.CollectionHeaderSet(start, end, this.columns, this.collection, this.rowHeader, this._startIndex);                
            }
            else
            {
                headerSet = new oj.CollectionHeaderSet(start, end, this.columns, this.collection, this.rowHeader);
            }
        }
        else
        {
            // no row header, return empty result set
            headerSet = new oj.ArrayHeaderSet(start, start, axis, null);
        }
    }

    // invoke callback
    if (callbacks != null && callbacks['success'])
    {
        callbacks['success'].call(callbackObjects['success'], headerSet, headerRange);
    }

    // clear any pending callback
    this.pendingHeaderCallback[axis] = null;
};

/**
 * Helper method to extract range information from cellRanges
 * @param {Array.<Object>} cellRanges Information about the cell range.  A cell range is defined by an array 
 *        of range info for each axis, where each range contains three properties: axis, start, count.
 * @param {string} cellRanges.axis the axis associated with this range where cells are fetched.  Valid 
 *        values are "row" and "column".
 * @param {number} cellRanges.start the start index of the range for this axis in which the cells are fetched.
 * @param {number} cellRanges.count the size of the range for this axis in which the cells are fetched. 
 * @return {Object} an object containing rowStart, rowCount, colStart, colCount
 * @private
 */
oj.CollectionDataGridDataSource.prototype._getRanges = function(cellRanges)
{
    var i, cellRange, rowStart, rowCount, colStart, colCount;

    // extract the start and end row/column info from cellRanges (there should only be two, one for each axis)
    for (i=0; i<cellRanges.length; i+=1)
    {
        cellRange = cellRanges[i];   
        oj.Assert.assert(cellRange['axis'] === 'row' || cellRange['axis'] === 'column');
        oj.Assert.assert(cellRange['count'] > 0);
        if (cellRange['axis'] === "row")
        {
            rowStart = cellRange['start'];
            rowCount = cellRange['count'];
        }
        else if (cellRange['axis'] === "column")
        {
            colStart = cellRange['start'];
            colCount = cellRange['count'];
        }
    }			

    // return object containing the ranges
    return {'rowStart': rowStart, 'rowCount': rowCount, 'colStart': colStart, 'colCount': colCount};
};

/**
 * Handle success fetchCells request
 * @param {Array.<Object>} cellRanges Information about the cell range.  A cell range is defined by an array 
 *        of range info for each axis, where each range contains three properties: axis, start, count.
 * @param {string} cellRanges.axis the axis associated with this range where cells are fetched.  Valid 
 *        values are "row" and "column".
 * @param {number} cellRanges.start the start index of the range for this axis in which the cells are fetched.
 * @param {number} cellRanges.count the size of the range for this axis in which the cells are fetched. 
 * @param {Object} callbacks the callbacks to be invoke when fetch cells operation is completed.  The valid callback
 *        types are "success" and "error".
 * @param {function(CellSet)} callbacks.success the callback to invoke when fetch cells completed successfully.
 * @param {function({status: Object})} callbacks.error the callback to invoke when fetch cells failed.
 * @param {Object=} callbackObjects the object in which the callback function is invoked on.  This is optional.  
 *        You can specify the callback object for each callbacks using the "success" and "error" keys.
 * @private
 */
oj.CollectionDataGridDataSource.prototype._handleCellFetchSuccess = function(cellRanges, callbacks, callbackObjects)
{
    var ranges, rowStart, rowEnd, colStart, colEnd, cellSet;

    // extract the start and end row/column info from cellRanges (there should only be two, one for each axis)
    ranges = this._getRanges(cellRanges);
    rowStart = ranges['rowStart'];
    rowEnd = Math.min(this.size(), rowStart + ranges['rowCount']);
    colStart = ranges['colStart'];
    colEnd = Math.min(this.columns.length, colStart + ranges['colCount']);       
    if (this._pageSize > 0)
    {
        rowEnd = Math.min(this._pageSize, this.totalSize() - this._startIndex);                    
        cellSet = new oj.CollectionCellSet(rowStart, rowEnd, colStart, colEnd, this.collection, this.columns, this._startIndex);        
    }
    else
    {
        // create CellSet and invoke callback
        cellSet = new oj.CollectionCellSet(rowStart, rowEnd, colStart, colEnd, this.collection, this.columns);
    }   
    if (callbacks != null && callbacks['success'] != null)
    {
        if (callbacks != null && callbackObjects == null)
        {
            callbackObjects = {};
        }
        callbacks['success'].call(callbackObjects['success'], cellSet, cellRanges);
        this._fetchCalls = 0;
    }

    // clear any pending callback
    this.pendingCellCallback = null;
};

/**
 * Fetch a range of cells from the data source.
 * @param {Array.<Object>} cellRanges Information about the cell range.  A cell range is defined by an array 
 *        of range info for each axis, where each range contains three properties: axis, start, count.
 * @param {string} cellRanges.axis the axis associated with this range where cells are fetched.  Valid 
 *        values are "row" and "column".
 * @param {number} cellRanges.start the start index of the range for this axis in which the cells are fetched.
 * @param {number} cellRanges.count the size of the range for this axis in which the cells are fetched. 
 * @param {Object} callbacks the callbacks to be invoke when fetch cells operation is completed.  The valid callback
 *        types are "success" and "error".
 * @param {function(CellSet)} callbacks.success the callback to invoke when fetch cells completed successfully.
 * @param {function({status: Object})} callbacks.error the callback to invoke when fetch cells failed.
 * @param {Object=} callbackObjects the object in which the callback function is invoked on.  This is optional.  
 *        You can specify the callback object for each callbacks using the "success" and "error" keys.
 * @export
 */
oj.CollectionDataGridDataSource.prototype.fetchCells = function(cellRanges, callbacks, callbackObjects)
{
    var rowEnd, colEnd, cellSet;

    rowEnd = 0;
    colEnd = 0;

    // checks if data is locally available
    if (this._isDataAvailable())
    {
        this._handleCellFetchSuccess(cellRanges, callbacks, callbackObjects);
    }
    else
    {
        // still fetching, just store the callback info
        if (callbacks != null)
        {
            this.pendingCellCallback = {};
            this.pendingCellCallback.cellRanges = cellRanges;
            this.pendingCellCallback.callbacks = callbacks;
            this.pendingCellCallback.callbackObjects = callbackObjects;
        }
        
        // kick start a setRangeLocal call on the collection
        this._fetchCells(cellRanges);
    }
};

/**
 * Processing pending header callbacks.
 * @param {string} axis the axis to check for pending header callbacks.
 * @private
 */
oj.CollectionDataGridDataSource.prototype._processPendingHeaderCallbacks = function(axis)
{
    var pendingCallback, headerRange, callbacks, callbackObjects;

    // check if there's callback remaining for the axis
    pendingCallback = this.pendingHeaderCallback[axis];
    if (pendingCallback != null)
    {
        // todo: check whether pending header range matches result
        headerRange = pendingCallback.headerRange;
        callbacks = pendingCallback.callbacks;
        callbackObjects = pendingCallback.callbackObjects;

        this._handleHeaderFetchSuccess(headerRange, callbacks, callbackObjects);
    }
};

/**
 * Processing pending cell callbacks.
 * @private
 */
oj.CollectionDataGridDataSource.prototype._processPendingCellCallbacks = function()
{
    var cellRanges, callbacks, callbackObjects;

    cellRanges = this.pendingCellCallback.cellRanges;
    callbacks = this.pendingCellCallback.callbacks;
    callbackObjects = this.pendingCellCallback.callbackObjects;

    // handles success cell fetch
    this._handleCellFetchSuccess(cellRanges, callbacks, callbackObjects);
};

/**
 * Internal method to handle fetching of cells for virtualized collection.
 * @param {Array.<Object>} cellRanges Information about the cell range.  A cell range is defined by an array 
 *        of range info for each axis, where each range contains three properties: axis, start, count.
 * @param {string} cellRanges.axis the axis associated with this range where cells are fetched.  Valid 
 *        values are "row" and "column".
 * @param {number} cellRanges.start the start index of the range for this axis in which the cells are fetched.
 * @param {number} cellRanges.count the size of the range for this axis in which the cells are fetched. 
 * @private
 */
oj.CollectionDataGridDataSource.prototype._fetchCells = function(cellRanges)
{
    var ranges, rowStart, rowCount;

    ranges = this._getRanges(cellRanges);
    rowStart = ranges['rowStart']
	if (this._pageSize > 0) 
	{
		rowStart += this._startIndex;
	}
    rowCount = ranges['rowCount'];

    // set the range local for the requested range
    this.collection.setRangeLocal(rowStart, rowCount).done(function (deferred)
    {
        var first = this.collection.at(rowStart, {'deferred':true});

        // check if we need to poach columns from row
        if (first != null && this.columns === undefined)
        {
            first.done(function(model) 
            {
                this.columns = model.keys();
                if (this.columns.indexOf(this.rowHeader) != -1)
                {
                    this.columns.splice(this.columns.indexOf(this.rowHeader),1);
                }
            }.bind(this));
        }

        // check outstanding header calls
        if (this.pendingHeaderCallback != null)
        {
            this._processPendingHeaderCallbacks('column');
            this._processPendingHeaderCallbacks('row');
        }        

        // finally process outstanding cell calls
        if (this.pendingCellCallback != null)
        {
            this._processPendingCellCallbacks();
        }        
		
		//communicates with paging control to indicate fetch end
		if (this._pageSize > 0)
		{
			oj.DataGridDataSource.superclass.handleEvent.call(this, 'sync', true);    
		}
    }.bind(this));
};

/**
 * Returns the keys based on the indexes. 
 * @param {Object} indexes the index for each axis
 * @param {Object} indexes.row the index for the row axis
 * @param {Object} indexes.column the index for the column axis
 * @return {Object.<Object, Object>} an object containing the keys for each axis
 * @export
 */
oj.CollectionDataGridDataSource.prototype.keys = function(indexes)
{
    var rowIndex = indexes['row'] + this._startIndex, columnIndex = indexes['column'], rowKey;
    rowKey =  this.collection['models'][rowIndex] === undefined ? undefined:oj.CollectionDataGridUtils._getModelKey(this.collection['models'][rowIndex]);	
    return {"row": rowKey, "column": this.columns[columnIndex]};
};

/**
 * Returns the row and column index based on the keys.
 * @param {Object} keys the key for each axis
 * @param {Object} keys.row the key for the row axis
 * @param {Object} keys.column the key for the column axis
 * @return {Object.<number, number>} indexes an object containing the index for each axis
 * @export
 */
oj.CollectionDataGridDataSource.prototype.indexes = function(keys)
{
    var rowKey = keys['row'], columnKey = keys['column'];
    return {"row": this.collection['models'].indexOf(this.collection.get(rowKey)), "column": this.columns === undefined ? this.collection.first().keys().indexOf(columnKey):this.columns.indexOf(columnKey)};
};

/**
 * Determines whether this DataGridDataSource supports certain feature.
 * @param {string} feature the feature in which its capabilities is inquired.  Currently the only valid feature is "sort".
 * @return {string|null} the name of the feature.  For sort, the valid return values are: "full", "none".  Returns null if the
 *         feature is not recognized.
 * @export
 */
oj.CollectionDataGridDataSource.prototype.getCapability = function(feature)
{
    if (feature === 'sort')
    {
        // OJ collection based data source supports column sorting only
        return 'column';
    }
    else if (feature === 'move')
    {
        // OJ collection based data source supports row moving only
        return 'row';        
    }
    return null;
};

/**
 * Performs a sort on the data source.
 * @param {Object} criteria the sort criteria. 
 * @param {string} criteria.axis The axis in which the sort is performed, valid values are "row", "column"
 * @param {Object} criteria.key The key that identifies which header to sort
 * @param {string} criteria.direction the sort direction, valid values are "ascending", "descending", "none" (default)
 * @param {Object} callbacks the callbacks to be invoke upon completion of the sort operation.  The callback
 *        properties are "success" and "error".
 * @param {function()} callbacks.success the callback to invoke when the sort completed successfully.  
 * @param {function({status: Object})} callbacks.error the callback to invoke when sort failed.
 * @param {Object=} callbackObjects the object in which the callback function is invoked on.  This is optional.  
 *        You can specify the callback object for each callbacks using the "success" and "error" properties.
 * @export
 */
oj.CollectionDataGridDataSource.prototype.sort = function(criteria, callbacks, callbackObjects)
{
    var comparator, direction = criteria['direction'], key = criteria['key'], axis = criteria['axis'];

    // make sure callbackObjects is not null
    if (callbackObjects == null)
    {
        callbackObjects = {};
    }

    if (axis === "column") {
        //check to see if collection is virtual, if so set the comparator and direction
        if (this.collection.fetchSize > -1 && this.collection.hasMore)
        {
            this.collection['comparator'] = key;
            if (direction === 'ascending') 
            {
                this.collection['sortDirection'] = 1;
            }
            else
            {
                this.collection['sortDirection'] = -1;                
            }
        }
        else
        {
            //if the collection is local supply a comparator to allow date sorting
            if (direction === 'ascending') {
                comparator = function(a, b) {
                    var as, bs;
                    //Get the values from the model objects
                    a = a.get(key);
                    b = b.get(key);
                    //Strings of numbers return false, so we can compare strings of numebers with numbers                
                    as = isNaN(a);
                    bs = isNaN(b);
                    //If they dates, turn them into sortable strings         
                    if (a instanceof Date) {
                        a = a.toISOString();
                        as = true;
                    }
                    if (b instanceof Date) {
                        b = b.toISOString();
                        bs = true;
                    }
                    //both are string
                    if (as && bs)
                    {
                        return a < b ? -1 : a === b ? 0 : 1;
                    }
                    //only a is a string
                    if (as)
                    {
                        return 1;
                    }
                    //only b is a string
                    if (bs)
                    {
                        return -1;
                    }
                    //both are numbers
                    return a - b;
                };
            }
            if (direction === 'descending') {
                comparator = function(a, b) {
                    var as, bs;
                    a = a.get(key);
                    b = b.get(key);
                    as = isNaN(a);
                    bs = isNaN(b); 
                    if (a instanceof Date) {
                        a = a.toISOString();
                    }
                    if (b instanceof Date) {
                        b = b.toISOString();
                    }
                    if (as && bs)
                    {
                        return a > b ? -1 : a === b ? 0 : 1;
                    }
                    if (as)
                    {
                        return -1;
                    }
                    if (bs)
                    {
                        return 1;
                    }
                    return b - a;
                };
            }                
            this.collection['comparator'] = comparator;                
        }

        this.collection.sort();

        if (callbacks != null && callbacks['success'] != null)
        {
            callbacks['success'].call(callbackObjects['success']);
        }
    }
    else
    { 
        if (callbacks != null && callbacks['error'] != null)
        {
            callbacks['error'].call(callbackObjects['error'], "Axis value not supported");
        }
    }
};

/**
 * Move a model to a new index in the collection, if atKey is null adds to the end
 * @export
 */
oj.CollectionDataGridDataSource.prototype.move = function(moveKey, atKey)
{
    var model, newIndex;    
    model = this.collection.get(moveKey);
    if (atKey === null)
    {
        this.collection.remove(model);
        this.collection.add(model);         
    }
    else
    {
        if (moveKey === atKey)
        {
            newIndex = this.collection.indexOf(this.collection.get(atKey));
            this.collection.remove(model);
        }
        else
        {
            this.collection.remove(model);            
            newIndex = this.collection.indexOf(this.collection.get(atKey));
        }
        this.collection.add(model, {at:newIndex});         
    }
};

//////////////////////////////////// Event listeners /////////////////////////////////////
/**
 * Returns an Object for an event 
 * @param {string} operation the operation done on the model
 * @param {Object|null} rowKey the key for the row axis
 * @param {Object|null} columnKey the key for the column axis
 * @return {Object} an object containing the the source, operation, and keys of the event
 * @protected
 */
oj.CollectionDataGridDataSource.prototype._getModelEvent = function(operation, rowKey, columnKey)
{
    var event = {};
    event['source'] = this;
    event['operation'] = operation;
    event['keys'] = {'row': rowKey, 'column': columnKey};

    return event;
};

/**
 * Handle a model add to the collection
 * @param {Object} model The model being added to the collection 
 * @protected
 */
oj.CollectionDataGridDataSource.prototype._handleModelAdded = function(model)
{
    var event, rowKey;
    rowKey = oj.CollectionDataGridUtils._getModelKey(model);
    event = this._getModelEvent('insert', rowKey, null);
    this.handleEvent("change", event);
};

/**
 * Handle a model delete from the collection
 * @param {Object} model The model being deleted from the collection 
 * @protected
 */
oj.CollectionDataGridDataSource.prototype._handleModelDeleted = function(model)
{
    var event, rowKey;
    rowKey = oj.CollectionDataGridUtils._getModelKey(model);
    event = this._getModelEvent('delete', rowKey, null);
    this.handleEvent("change", event);
};

/**
 * Handle a model change in the collection
 * @param {Object} model The model being changed in the collection 
 * @protected
 */
oj.CollectionDataGridDataSource.prototype._handleModelChanged = function(model)
{
    var event, rowKey;
    rowKey = oj.CollectionDataGridUtils._getModelKey(model);
    event = this._getModelEvent('update', rowKey, null);
    this.handleEvent("change", event);
};

/**
 * Handle a colelction reset, by passing refresh to the data grid
 * @protected
 */
oj.CollectionDataGridDataSource.prototype._handleCollectionRefresh = function()
{
    var event = this._getModelEvent('refresh', null, null);
    this.handleEvent("change", event);
};

/**
 * Set or change the number of models in a page
 * @export
 * @param {number} n page size
 */
oj.CollectionDataGridDataSource.prototype.setPageSize = function(n) {
    this._pageSize = n; 
};

/**
 * @export
 * Get the length of the collection. -1 if an initial fetch has not been
 * done yet. Default to the size of the collection. If pageSize is set then
 * limit it.
 * @returns {number} length of the collection
 * @expose
 * @memberof! oj.CollectionDataGridDataSource
 * @instance
 */
oj.CollectionDataGridDataSource.prototype.size = function() 
{
    if (this.collection.length === 0)
    {
        return -1;
    }
    if (this._pageSize != null && this._pageSize > 0)
    {
        if (this.collection.size() > this._pageSize)
        {
            return this._pageSize;
        }
    }
    return this.collection.size();
};

/**
 * @export
 * Return the total size of data available, including server side if not local.
 * @returns {number} total size of data
 * @expose
 * @memberof! oj.CollectionDataGridDataSource
 * @instance
 */
oj.CollectionDataGridDataSource.prototype.totalSize = function() 
{ 
    if (this.collection != null && this._totalSize < 0)
    {
		return this.collection['length'];
    }
    return this._totalSize;
};

/**
 * @export
 * Return whether there is more data which can be fetched.
 * @returns {boolean} whether there is more data
 * @expose
 * @memberof! oj.CollectionDataGridDataSource
 * @instance
 */
oj.CollectionDataGridDataSource.prototype.hasMore = function() 
{    
    if (this.collection != null)
    {
        return this.collection.hasMore;
    }
    return false;
};

/**
 * Perform a fetch call from the options specified
 * @expose
 * @memberof! oj.CollectionDataGridDataSource
 * @instance
 */
oj.CollectionDataGridDataSource.prototype.fetch = function(options) 
{    
    this._startIndex = options != null ? (options['startIndex'] != null ? options['startIndex'] : 0) : 0;    
    this.handleEvent("change", {'operation': 'sync', 'pageSize': this._pageSize});    
};

//////////////////////////////////// Property Getters  /////////////////////////////////////    
/**
 * Gets the collection property
 * @export
 */
oj.CollectionDataGridDataSource.prototype.getCollection = function()
{
    return this.collection;
};    

/**
 * Gets the columns property
 * @export
 */
oj.CollectionDataGridDataSource.prototype.getColumns = function()
{
    return this.columns;
};    

/**
 * Gets the rowHeader property
 * @export
 */
oj.CollectionDataGridDataSource.prototype.getRowHeader = function()
{
    return this.rowHeader;
};

/**
 * Gets the _startIndex property
 * @export
 */
oj.CollectionDataGridDataSource.prototype.getStartIndex = function()
{
    return this._startIndex;
};

/**
 * Gets the _pageSize property
 * @export
 */
oj.CollectionDataGridDataSource.prototype.getPageSize = function()
{
    return this._pageSize;
};

/**
 * Gets the _totalSize property
 * @export
 */
oj.CollectionDataGridDataSource.prototype.getTotalSize = function()
{
    return this._totalSize;
};

/**
 * Gets the _fetchCalls property
 * @export
 */
oj.CollectionDataGridDataSource.prototype.getFetchCalls = function()
{
    return this._fetchCalls;
};

/**
 * Gets the data property
 * @export
 */
oj.CollectionDataGridDataSource.prototype.getData = function()
{
    return this.data;
};
/*!
 * JET InputNumber @VERSION
 * http://jqueryui.com
 *
 * Copyright 2013 jQuery Foundertion and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 *
 * Depends:
 *  jquery.ui.widget.js
 */
/**
 * @class
 * @name oj.ojInputNumber
 * @augments oj.editableValue
 * 
 * @classdesc
 * <h3 id="inputNumberOverview-section">
 *   JET InputNumber Component
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#inputNumberOverview-section"></a>
 * </h3>
 * <p>Description: The ojInputNumber component enhances a browser input element 
 * into one that holds numbers and it has a spinbox to quickly increment or 
 * decrement the number. The <code>value</code> option must be a number and must 
 * be within the <code>min</code> and <code>max</code> range. 
 * </p>
 * <p>A step mismatch is when
 * the value is not a multiple of <code>step</code>, starting at the <code>min</code> 
 * or 0 if no <code>min</code> is set.
 * A step mismatch will not be flagged as a validation error by default, but
 * the step up and step down feature will change the value to be a step match
 * if it isn't already.
 * </p>
 * <p>
 * The component is accessible; it sets and maintains the appropriate aria- attributes, 
 * like aria-valuenow, aria-valuemax, aria-valuemin and aria-valuetext.
 * </p>
 * 
 * <h3 id="keyboard-section">
 *   Keyboard interaction
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
 * </h3>
 * 
 * <table class="keyboard-table">
 *   <thead>
 *     <tr>
 *       <th>Key</th>
 *       <th>Use</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td><kbd>Enter</kbd> or <kbd>Tab</kbd></td>
 *       <td>Submit the value you typed in the input field. If you type in
 *       a value out of range, and press Enter, you will see a validation error.
 *       Step mismatch errors will not cause a validation error.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>UpArrow</kbd></td>
 *       <td>Increment the number in the input field; alternatively you can click 
 *           on the up arrow icon. If the resulting value is above the
 *           <code>max</code>, below the <code>min</code>, or results in a step 
 *           mismatch, the value will be adjusted to the closest valid value.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>DownArrow</kbd></td>
 *       <td>Decrement the number in the input field; alternatively you can click
 *           on the down arrow icon. If the resulting value is above the 
 *           <code>max</code>, below the <code>min</code>, or results in a step
 *           mismatch, the value will be adjusted to the closest valid value.</td>
 *     </tr>
 * </tbody></table>
 *  
 * <h3 id="state-section">
 *   Setting the Value Option
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#state-section"></a>
 * </h3>
 * <p>If the value option is undefined, 
 * then the DOM value property is used, if any; else it is null.</p>
 * <p>The value option (if it is not null or undefined) 
 * is coerced (+ val). e.g., "123a" is coerced to NaN</p>
 * <p>To clear out the value option, you can set it to null.
 * <code>$(".selector").ojInputNumber("option", "value", null);</code>
 * </p>
 *
 * <!-- - - - - Above this point, the tags are for the class.
 *              Below this point, the tags are for the constructor (initializer). - - - - - - -->
 * @desc Creates an ojInputNumber component
 * @example <caption>Initialize component using widget API</caption>
 * &lt;input id="spin" type="text"/&gt;<br/>
 * $("#spin").ojInputNumber({'value': 10, 'max':100, 'min':0, 'step':2});
 * $("#spin").ojInputNumber({'option', 'value', 10});
 * @example <caption>Using knockout, value, min, max bind to observables - salary, salaryMax, salaryMin</caption> 
 * &lt;input id="foo" data-bind="ojComponent: {component: 'ojInputNumber', value: salary, min:salaryMin, max:salaryMax, step:5}"/&gt;
 * 
 * @constructor
 */
oj.__registerWidget("oj.ojInputNumber", $['oj']['editableValue'],
{
  version : "1.0.0",  
  defaultElement : "<input>", 
  widgetEventPrefix : "oj", 
  options : 
  {
    /**
     * The default converter for ojInputNumber.
     *
     * If one wishes to provide a custom converter for the ojInputNumber 
     * override the factory returned for
     * oj.Validation.converterFactory(oj.ConverterFactory.CONVERTER_TYPE_NUMBER).
     * When initialized with no options, 
     * the default options for the current locale are assumed.
     *
     * @expose
     * @memberof! oj.ojInputNumber
     * @instance
     * @default <code class="prettyprint">
     *  oj.Validation.converterFactory(oj.ConverterFactory.CONVERTER_TYPE_NUMBER).createConverter()</code>
     */
    converter : oj.Validation.converterFactory(
            oj.ConverterFactory.CONVERTER_TYPE_NUMBER).createConverter(), 
    /** 
     * The maximum allowed value. The element's max attribute is used if it 
     * exists and the option is not explicitly set. If null, there is no maximum enforced.
     * The max must not be less than the min.
     * @expose 
     * @public
     * @instance
     * @memberof! oj.ojInputNumber */
    max : undefined, 
    /** 
     * The minimum allowed value. The element's min attribute is used if it 
     * exists and the option is not explicitly set. If null, there is no minimum enforced.
     * The min must not be greater than the max.
     * @expose 
     * @public 
     * @instance
     * @memberof! oj.ojInputNumber */
    min : undefined, 
    /** 
     * whether the component is readOnly. The element's readOnly property is used as its initial 
     * value if it exists, when the option is not explicitly set. When neither is set, readOnly 
     * defaults to false.
     * 
     * @example <caption>Initialize component with <code class="prettyprint">readOnly</code> option:</caption>
     * $(".selector").ojInputNumber({"readOnly": true});
     * 
     * @expose 
     * @type {?boolean|undefined}
     * @default <code class="prettyprint">false</code>
     * @public
     * @instance
     * @memberof! oj.ojInputNumber
     */
    readOnly: undefined,
    /**
     * This option allows setting HTML5's placeholder attribute. Though it is possible to set 
     * placeholder attribute on the element itself, the component will only read the value during 
     * creation time; meaning any subsequent changes to the element's placeholder attribute will 
     * not be picked up.
     * 
     * @example <caption>Initialize the component with the <code class="prettyprint">placeholder</code> option:</caption>
     * &lt;input id="number" data-bind="ojComponent: {component: 'ojInputNumber', placeholder: 'Please enter a number'}" /&gt;
     * 
     * @example <caption>Initialize <code class="prettyprint">placeholder</code> option from html attribute:</caption>
     * &lt;input id="number" data-bind="ojComponent: {component: 'ojInputNumber'}" placeholder="Please enter a number" /&gt;
     * 
     * @expose 
     * @instance
     * @memberof! oj.ojInputNumber
     * @type {string|null|undefined}
     */    
    placeholder: undefined,
    /** 
     * The size of the step to take when spinning via buttons or via the 
     * stepUp()/stepDown() methods. The element's step attribute is used if it 
     * exists and the option is not explicitly set. Step must be a number 
     * greater than 0, otherwise it defaults to 1.
     * @expose 
     * @public
     * @instance
     * @memberof! oj.ojInputNumber */
    step : undefined
  },
  // P U B L I C    M E T H O D S
   /**
 * <p>Increments the value by the specified number of steps. 
 * Without the parameter, a single step is incremented.</p>
   <p>If the resulting value is above the max, below the min, 
   or results in a step mismatch, the value will be adjusted to the closest valid value.</p>
 * @public
 * @param {Number} steps - Number of steps to increment, defaults to 1.
 * @expose
 * @memberof! oj.ojInputNumber 
 */
  stepUp : function (steps)
  {
    this._step(steps, true);
  },
 /**
 * <p>Decrements the value by the specified number of steps. 
 * Without the parameter, a single step is decremented.</p>
   <p>If the resulting value is above the max, below the min, 
   or results in a step mismatch, the value will be adjusted to the closest valid value.</p>
 * @public
 * @param {Number} steps - Number of steps to decrement, defaults to 1.
 * @expose
 * @memberof! oj.ojInputNumber 
 */
  stepDown : function (steps)
  {
    this._step(steps, false);
  }, 
  /**
   * Reacts to changes to the 'min' and/or 'max' option by
   * resetting the NumberRangeValidator.
   * 
   * @param {String|Object|string=} key a single string representing a 
   * key or an object representing a group 
   * of options
   * @param {Object=} value of the key
   */
  option : function (key, value)
  {
    var retVal = this._superApply(arguments);
    
    // key === max, key === min, key is both min and max, so it's an object
    
    if (key === "max" || key === "min" || 
        (typeof key === "object" && 
         (key['min'] !== undefined || key['max'] !== undefined)))
    {
      var min = undefined, max = undefined;
      if (key === "max")
      {      
        max = value != null ? value : undefined;
      }
      else if (key === "min")
      {
        min = value != null ? value : undefined;
      }
      else
      {
        // it's an object
        if (key['max'] !== undefined)
          max = key['max'] != null ? key['max'] : undefined;
        if (key['min'] !== undefined)
          min = key['min'] != null ? key['min'] : undefined;
      }
      // since validators are immutable, they will contain min + max as local values. 
      // Because of this will need to recreate
      var numberRangeOptions = {'min': min, 
          'max': max,
          'converter': this._GetConverter()};

      this._createRangeValidator(numberRangeOptions);
      this._ResetAllValidators();
    }
    return retVal;
  },
  /**
   * Return the subcomponent node represented by the documented locator attribute values.
   * Test authors should target inputNumber's sub elements using the following names:
   * <ul>
   * <li><b>oj-inputnumber-up</b>: the inputNumber's up arrow</li>
   * <li><b>oj-inputnumber-down</b>: the inputNumber's down arrow</li>
   * <li><b>oj-inputnumber-input</b>: the inputNumber's input</li>
   * </ul>
   * @expose
   * @override
   * @memberof! oj.ojInputNumber
   * @instance
   * @param {Object} locator An Object containing at minimum a subId property 
   * whose value is a string, documented by the component, that allows the component to 
   * look up the subcomponent associated with that string.  It contains:
   * <ul>
   * <li>
   * component: optional - in the future there may be more than one component 
   *   contained within a page element
   * </li>
   * <li>
   * subId: the string, documented by the component, that the component expects 
   * in getNodeBySubId to locate a particular subcomponent 
   * </li>
   * </ul>  
   * @returns {Element|null} the subcomponent located by the subId string 
   * passed in locator, if found.
   */
  getNodeBySubId: function(locator)
  {
    if (locator == null)
    {
      return this.element ? this.element[0] : null;
    }
    
    var subId = locator['subId'];
    if (subId === "oj-inputnumber-up") {
      return this.widget().find(".oj-inputnumber-up")[0];
    }
    if (subId === "oj-inputnumber-down") {
      return this.widget().find(".oj-inputnumber-down")[0];
    }
    if (subId === "oj-inputnumber-input") {
      return this.widget().find(".oj-inputnumber-input")[0];
    }
    
    
    // Non-null locators have to be handled by the component subclasses
    return null;
  }, 
        
  // P R O T E C T E D    C O N S T A N T S   A N D   M E T H O D S

  // *********** START WIDGET FACTORY METHODS (they retain _camelcase naming convention) **********
  /**
   * Initializes the option represented by the 'key' using either the option
   *  value or the element value. If option is undefined, we get it from the DOM.
   *  This method sets options 'value', 'min', 'max', 'step'. 
   * <br/>
   * @memberof! oj.ojInputNumber
   * @instance
   * @protected
   */        
  _InitOptions : function ()
  {
    this._super();
    
    // READONLY:
    // if options.readOnly is not set (undefined), read from DOM not saved attributes
    // if options.readOnly is set to a valid value (boolean), set it on the 
    // element to keep the two in sync. 
    // Since inputNumber has no subclasses we will default to false. Otherwise,
    // we want to default to null so that the subclass knows that the app
    // dev didn't set the field see EditableValue's disabled (radioset needs
    // disabled to be null because it treats disabled as a tri-state: true,
    // false, not set - the children's disabled field on the html wins)
    if (this.options['readOnly'] === undefined)
    {
      // In the absence of attribute set default value to false
      this.options['readOnly'] = this.element.attr("readonly") !== undefined ? 
        !!this.element.prop("readonly") : false;
    }
    if (typeof this.options['readOnly'] !== "boolean")
    {
      throw new Error("InputNumber's option 'readOnly' has a invalid value set; \n\
            it should be a boolean: " + this.options['readOnly']);
    }
    
    // EditableValue basically does the same thing. Instead of getting it
    // from this.element.val(), it gets it from the savedAttributes. 
    // This doesn't always work for numbers, though. savedAttribute for 'value'
    // is null when the html's value attribute is set to a number when
    // you do element.val(15). So I have to get it using this.element.val().
    // this.element.val(15).ojInputNumber() -> savedAttributes does not have a value prop.
    // $("#inputnumber-id").val(5555).ojInputNumber()
    // $("#inputnumber-id").prop("value")
    // "5555" // WORKS!
    // BUT "value" in savedAttributes is false
    // 
    // We coerce the input number's value if not null, and we do the 
    // same thing in _setOption
    // 1) "" on the DOM ==  null on the option.value
    // 2) Conversely, null on the option.value means 
    // that we set "" on the input element's value even if it was alreayd set.
    var valueOption = this.options['value'];
    // TODO: change to valueOptioin === undefined, and have value option's constructor default be undefined.
    // I'll need a way so that my superclass won't set null for me if I need to do something different, like
    // set the option to null if the dom is "" (regular inputText's don't convert "" attribute value to null value option.
    if (valueOption == null)
    {
      this.options['value'] = (this.element.val() !== "") 
        ? this.element.val() : null;
    }

    // html-5 input type=number seems to coerce the value option using +
    this.options['value'] = this._coerceInputNumberValue(this.options['value']);
    
    // For min, max, step, if option is not set, get it from the dom
    // Also, if not a number, try to coerce it to a number
    // In html-5 input type=number, e.g., min="40a", it treats it as null.
    // it doesn't seem to coerce it.
    // e.g.,
    //"345.67 abc" coerces to NaN (+ val)
    //"ab34.56" coerces to NaN 
    // "" coerces to 0. html-5 min="" acts like there is no min
    // html-5 number,  null acts like there is no min
    var that = this;
    $.each(['min','max','step'], function (index, value)
    {
      if (that.options[value] === undefined)
      {
        // get it from the dom
        that.options[value] = that.element.attr(value);
        // if it is still null or undefined, then default
        if (that.options[value] == null)
          that.options[value] = (value === "step" ? 1 : null);
      }
      // coerce to a number if it isn't; the app dev could have used "5" string
      // to mean 5. We are pretty strict when coercing options that the 
      // app dev types in, and more lenient for user values.
      // we don't coerce for null, so the user can clear these
      // out with null.
      if (that.options[value] != null)
      {
        if (value === "step")
          that.options[value] = that._parseStep(that.options[value]);
        else
          that.options[value] = that._parse(that.options[value]);
      }
    });
  },
  /**
   * After _ComponentCreate and _AfterCreate, 
   * the widget should be 100% set up. this._super should be called first.
   * @override
   * @protected
   * @instance
   * @memberof! oj.ojInputNumber
   */
  _ComponentCreate : function ()
  {
    var node = this.element;
    this._super();
    // update element DOM for readOnly
    if (typeof this.options['readOnly'] === "boolean")
    {
      node.prop("readonly", this.options['readOnly']);
    }
    
    this._draw();
    
    this._on(this._events);

    // turning off autocomplete prevents the browser from remembering the
    // value when navigating through history, so we re-enable autocomplete
    // if the page is unloaded before the widget is destroyed. #7790
    this._on(this.window, 
    {
      "beforeunload" : function ()
      {
        node.removeAttr("autocomplete");
      }
    });

    // input type=number does not support the 'pattern' attribute, so
    // neither should ojInputNumber.
    // remove this before EditableValue grabs it and uses it.
    node.removeAttr("pattern");
    
    this._inputNumberDefaultValidators = {};
  },
  /**
   * This is where we do things right after the component was created.
   * this._super should be called first.
   * 
   * @override
   * @memberof! oj.ojInputNumber
   * @instance
   * @protected
   */
  _AfterCreate : function ()
  {
    this._super();
    this._refreshAriaMinMaxValue();
    this._refreshStateTheming("readOnly", this.options.readOnly);
    this._updateButtons();
  },
  /**
   * Handles options specific to inputnumber.
   * Note that _setOption does not get called during create in the super class. 
   * It only gets called when the component has already been created.
   * However, we do call _setOption in _draw for certain attributes 
   * (disabled)
   * @override
   * @protected
   * @memberof! oj.ojInputNumber
   */
  _setOption : function (key, value)
  {
    // we don't coerce value for null or undefined, so to clear out value
    // they can set it to null or undefined.
    if (key === "value")
      value = this._coerceInputNumberValue(value);

    if (key === "max" || key === "min")
    {
      if (typeof value === "string")
      {
        value = this._parse(value);
      }
    } 
    if (key === "step")
    {
      value = this._parseStep(value);
    }
    
    // the superclass calls _Refresh. Our _Refresh calls _updateButton
    // and _refreshAriaMinMaxValue.
    this._super(key, value);

    // when a dom element supports disabled, use that, and not aria-disabled.
    // having both is an error. 
    // having aria-disabled on root dom element is ok (if it is added in base class)
    if (key === "disabled")
    {
      if (value)
      {
        this.element.prop("disabled", true);
      }
      else 
      {
        this.element.prop("disabled", false);
      }
    }
    // when a dom element supports readonly, use that, and not aria-readonly.
    // having both is an error
    if (key === "readOnly")
    {
      this.element.prop("readonly", !!value);
      this._refreshStateTheming("readOnly", this.options.readOnly);   
    }
  }, 
 /**
   * Override of protected base class method.  
   * Method name needn't be quoted since is in externs.js.
   * @protected
   * @memberof! oj.ojInputNumber
   * @instance
   */
  _destroy : function ()
  {    
    this.element.removeClass("oj-inputnumber-input")
            .prop("disabled", false)
            .removeAttr("autocomplete")
            .removeAttr("aria-valuemin")
            .removeAttr("aria-valuemax")
            .removeAttr("aria-valuenow")
            .removeAttr("aria-valuetext")
            .removeAttr("aria-disabled");
    // don't have to remove the root styles since we remove the root element in _destroy
    // TODO: need a generic way to save off attributes and then restore them.
    // attribute name/value array.
    this.element.attr("type", this.saveType);
    this._super();
    this._off(this.element, "keydown keyup focus blur mousedown mouseup mouseenter mouseleave");
    this.uiInputNumber.replaceWith(this.element);
    clearTimeout(this.timer);
  }, 
  /**
   * Used for explicit cases where the component needs to be refreshed 
   * (e.g., when the value option changes or other UI gestures).
   * @override
   * @protected
   * @memberof! oj.ojInputNumber
   */
  _Refresh : function (name, value)
  {
    this._super(name, value);
    if (name === "value" || name === "max" || name === "min")
    {
      this._refreshAriaMinMaxValue();
    }
    this._updateButtons();
  },
  // *********** END WIDGET FACTORY METHODS **********
     /**
   * Whether the a value can be set on the component. 
   * If the component is disabled (or readOnly) then 
   * then setting value on component is a no-op. 
   * 
   * @see #_SetValue
   * @memberof! oj.ojInputNumber
   * @instance
   * @protected
   */
  _CanSetValue: function ()
  {
    var canSetValue = this._super();
    
    if (!canSetValue)
      return false;
    
    var readOnly = this.options['readOnly'] || false;
    
    if (readOnly)
    {
      return false;
    }
    
    return true;
  }, 
  /**
   * Sets up the default numberRange validators.
   * 
   * @ignore
   * @protected
   * @override
   * @instance
   * @memberof! oj.ojInputNumber
   */
  _GetDefaultValidators : function ()
  {
    var ret = this._superApply(arguments),
        // min and max need to be 'undefined' to be reset in the numberrangevalidator
        min = this.options['min'] != null ? this.options['min'] : undefined, 
        max = this.options['max'] != null ? this.options['max'] : undefined,
        numberRangeOptions = {};
    
    if (min != null || max != null)
    {
      numberRangeOptions = {'min': min, 
                          'max': max,
                          'converter': this._GetConverter()};
      this._createRangeValidator(numberRangeOptions);

    }
 
    return $.extend(this._inputNumberDefaultValidators, ret);
  },
  /**
   * Returns the default styleclass for the component.
   * 
   * @return {string}
   * @memberof! oj.ojInputNumber
   * @override
   * @protected
   */
  _GetDefaultStyleClass : function ()
  {
    return "oj-inputnumber";
  },
  _events : 
  {
    'keydown' : function (event)
    {
      var keyCode = $.ui.keyCode;
      if(event.keyCode === keyCode.ENTER)
      {
        this._blurEnterSetValue(event);
        event.preventDefault();
      }
      else if (this._start() && this._keydown(event))
      {
        event.preventDefault();
      }
    },
    'keyup' : function(event){this._stop(event);}, 
    'focus' : function ()
    {
      this.previous = this.element.val();
    },
    'blur' : function (event)
    {
      if (this.cancelBlur)
      {
        delete this.cancelBlur;
        return;
      }
      this._blurEnterSetValue(event);
    },
    "mousedown .oj-inputnumber-button" : function (event)
    {
      var previous;

      // We never want the buttons to have focus; whenever the user is
      // interacting with the inputnumber, the focus should be on the input.
      // If the input is focused then this.previous is properly set from
      // when the input first received focus. If the input is not focused
      // then we need to set this.previous based on the value before spinning.
      previous = this.element[0] === this.document[0].activeElement ? 
        this.previous : this.element.val();

      function checkFocus()
      {
        var isActive = this.element[0] === this.document[0].activeElement;
        if (!isActive)
        {
          this.element.focus();
          this.previous = previous;
          // support: IE
          // IE sets focus asynchronously, so we need to check if focus
          // moved off of the input because the user clicked on the button.
          this._delay(function ()
          {
            this.previous = previous;
          });
        }
      }

      // ensure focus is on (or stays on) the text field
      event.preventDefault();
      checkFocus.call(this);

      // support: IE
      // IE doesn't prevent moving focus even with event.preventDefault()
      // so we set a flag to know when we should ignore the blur event
      // and check (again) if focus moved off of the input.
      this.cancelBlur = true;
      this._delay(function ()
      {
        delete this.cancelBlur;
        checkFocus.call(this);
      });

      this._start();

	    this._repeat(null, $(event.currentTarget).hasClass("oj-inputnumber-up") ? 1 :  - 1, event);
    },
    "mouseup .oj-inputnumber-button" : function(event)
    { 
      this._stop(event);
    }, 
    "mouseenter .oj-inputnumber-button" : function (event)
    {
      // button will add oj-active if mouse was down while mouseleave and kept down
      if (!$(event.currentTarget).hasClass("oj-active"))
      {
        return;
      }

      this._start();
	  
      this._repeat(null, $(event.currentTarget).hasClass("oj-inputnumber-up") ? 1 :  - 1, event);
    },
    // TODO: do we really want to consider this a stop?
    // shouldn't we just stop the repeater and wait until mouseup before
    // we trigger the stop event?
    "mouseleave .oj-inputnumber-button" : function(event)
    { 
      this._stop(event);
    }
  },
  
  // I N T E R N A L   P R I V A T E   C O N S T A N T S    A N D   M E T H O D S 
  // Subclasses should not override or call these methods
 /**
  * @private
  * @const
  */
  _BUNDLE_KEY:
  {
    _TOOLTIP_DECREMENT: 'tooltipDecrement',
    _TOOLTIP_INCREMENT: 'tooltipIncrement'    
  },
  /**
   * when below listed options are passed to the component, corresponding CSS will be toggled
   * @private
   * @const
   * @type {Object}
   */
  _OPTION_TO_CSS_MAPPING: {
    "readOnly": "oj-read-only"
  },
  /**
   * @private
   */
  _draw : function ()
  {
    var uiInputNumber = this.uiInputNumber = this.element.addClass("oj-inputnumber-input")
            .attr("autocomplete", "off")
            .wrap(this._uiInputNumberHtml()).parent()
            // add buttons
            .append(this._buttonHtml());

    // we decided not to add role=spinbutton since A screen reader user hearing 
    // it is a spinbutton is a little confusing as you obviously can't do 
    // any of the spinbutton controls on it..
    // 
    // TODO: need to save off attributes and reset on destroy generically.
    // EditableValue renames attributes with data-oj-. Should we do that or 
    // should we overwrite? I think we should overwrite for these... discuss
    this.saveType = this.element.prop("type");
    this.element.attr("type", "text");

    // button bindings. interesting.
    var incrementString = 
            this.getTranslatedString(this._BUNDLE_KEY._TOOLTIP_INCREMENT);
    var decrementString = 
            this.getTranslatedString(this._BUNDLE_KEY._TOOLTIP_DECREMENT);
    uiInputNumber.find(".oj-inputnumber-up").ojButton({display: 'icons', 
                      icons: {start:'oj-component-icon oj-inputnumber-up-icon'}, 
                      label: incrementString});
    uiInputNumber.find(".oj-inputnumber-down").ojButton({display: 'icons', 
                      icons: {start:'oj-component-icon oj-inputnumber-down-icon'}, 
                      label: decrementString});                    
    // add aria-hidden=true to buttons. As they are not in the keyboard sequence 
    // we decided it makes more sense to just add aria-hidden="true" to them 
    // and rely on the up/down arrow keys
    this.buttons = uiInputNumber.find(".oj-inputnumber-button")
            .attr("tabIndex",  "-1").attr("aria-hidden",true);
  },
  /**
   * @private
   */
  _keydown : function (event)
  {
    var options = this.options, keyCode = $.ui.keyCode;

    switch (event.keyCode)
    {
      // keeping the up/down pressed repeats
      // using the up and down arrows will adjust the value so that it is 
      // a multiple of step and it is in min/max, same as if you used the 
      // up and down buttons
      case keyCode.UP:
        this._repeat(null, 1, event);
        return true;
      case keyCode.DOWN:
        this._repeat(null,  - 1, event);
        return true;
    }

    return false;
  },
  /**
   * @private
   */
  _uiInputNumberHtml : function ()
  {
    return "<span class='oj-inputnumber oj-component'></span>";
  },
  /**
   * @private
   */
  _buttonHtml : function ()
  {
    return "" + "<a class='oj-inputnumber-button oj-inputnumber-down'></a>" + 
            "<a class='oj-inputnumber-button oj-inputnumber-up'></a>";
  },
  /**
   * @private
   */
  _start : function ()
  {
    this.spinning = true;
    return true;
  },
  /**
   * @private
   */
  _repeat : function (i, steps, event)
  {
    // repeat spinning as long as the key is down and min/max isn't reached
    i = i || 500;

    clearTimeout(this.timer);
    this.timer = this._delay(function ()
    {
      this._repeat(40, steps, event);
    },
    i);

    this._spin(steps * this.options.step, event);
  },
  /**
   * @private
   * @param {Number} step - Number of steps to increment.
   * @param {Object=} event an optional event if this was a result of ui interaction.
   */
  _spin : function (step, event)
  {
    // When the component's 'value' changes, the displayValue is automatically updated.
    // So reading the component's display value should always give you the element's value
    var displayValue = this._GetDisplayValue() || 0;
    var value = this._parseValue(displayValue);
    value = this._adjustValue(value, step);
    
    this._SetValue(value, event, this._VALIDATION_MODE.VALIDATORS_ONLY);
  },
  /**
   * called from _adjustValue
   * @private
   */
  _precision : function ()
  {
    var precision = this._precisionOf(this.options.step);
    if (this.options.min != null)
    {
      precision = Math.max(precision, this._precisionOf(this.options.min));
    }
    return precision;
  },
  /**
   * return the number of digits after the '.'
   * called from _adjustValue->_precision
   * @private
   * @param {Number} num - Number from which to calculate the precision
   */
  _precisionOf : function (num)
  {
    var str = num.toString(), decimal = str.indexOf(".");
    return decimal ===  - 1 ? 0 : str.length - decimal - 1;
  },
  /**
   * adjust the value to be "valid".
   * The logic follows that of HTML-5's input number.
   * http://www.w3.org/TR/html5/forms.html#dom-input-stepup
   * A valid value is one that is a multiple of 
   * step starting at stepBase, where stepBase is min (if present),
   * else initial value (if present) TODO,
   * else (if type == number) 0 
   * If max is not a valid value, stepUp/stepDown will never go to max. It
   * will go to the calculated valid max (one that is the largest value 
   * that is an integral multiple of the step, and that is less than or equal
   * to the maximum.
   * @private
   */
  _adjustValue : function (value, step)
  {
    var newValue;
    var stepBase, aboveMin, options = this.options;
    var precision = this._precision();

    // make sure we're at a valid step when we step up or down.
    // - find out where we are relative to the base (min or 0)
    stepBase = options.min != null ? options.min : 0;
     
    // From http://www.w3.org/TR/html5/forms.html#dom-input-stepup:
    // If value subtracted from the step base is not an integral multiple 
    // of the step, then set value to the nearest value that, when subtracted
    // from the step base, is an integral multiple of the allowed value step,
    // and that is less than value if the method invoked was stepDown() and
    // more than value if the method invoked was stepUp().
    
    // is value-stepBase an integral multiple of step?
    aboveMin = value - stepBase;
    var rounded = Math.round(aboveMin / options.step) * options.step;
    rounded = parseFloat(rounded.toFixed(precision));
    var multiple = (rounded === aboveMin);
    
    if (!multiple)
    {
      if (step < 0)
        aboveMin = Math.ceil(aboveMin / options.step) * options.step;
      else
      {
        aboveMin = Math.floor(aboveMin / options.step) * options.step;
      }

      // rounding is based on 0, so adjust back to our base
      newValue = stepBase + aboveMin + step;
    }
    else
    {
      newValue = value + step;
    }
    
    // fix precision from bad JS floating point math
    // toFixed returns the newValue with a specific # of digits after the 
    // decimal point (this_precision() looks at max of step/min's # of 
    // digits.
    newValue = parseFloat(newValue.toFixed(precision));
    
    if (options.min != null && newValue < options.min)
      return options.min;
    
    if (options.max != null && newValue > options.max)
    {
      var validMax = (Math.floor((options.max - stepBase)/ options.step) * 
                  options.step) + stepBase;
      // fix precision from bad JS floating point math
      validMax = parseFloat(validMax.toFixed(precision));
      return validMax;
    }
    
    return newValue;
  },
  /**
   * @private
   */
  _stop : function (event)
  {
    if (!this.spinning)
    {
      return;
    }
    clearTimeout(this.timer);
    this.spinning = false;
  },
  /**
   * @private
   */
  _updateButtons: function()
  {
    var value = this._GetDisplayValue() || 0;
    var min = this.options.min, max = this.options.max;
    if (!this.uiInputNumber)
      return;
    var downButton = this.uiInputNumber.find(".oj-inputnumber-down").ojButton();
    var upButton = this.uiInputNumber.find(".oj-inputnumber-up").ojButton();
    if (this.options.disabled)
    {
      downButton.ojButton("disable");
      upButton.ojButton("disable");      
    }
    else if (max != null && value >= max)
    {
      downButton.ojButton("enable");
      upButton.ojButton("disable");
    }
    else if (min != null && value <= min)
    {
      downButton.ojButton("disable");
      upButton.ojButton("enable");
    }
    else
    {
      downButton.ojButton("enable");
      upButton.ojButton("enable");      
    }    
  },
  /**
   * @private
   */
  _blurEnterSetValue: function(event)
  {
      this._stop();
      if (this.previous !== this.element.val())
      {
        // _SetValue triggers valuechange event
        this._SetValue(this.element.val(), event);
      }    
  },
  /**
   * @private
   */
  _createRangeValidator : function(options)
  {
    this._inputNumberDefaultValidators[oj.ValidatorFactory.VALIDATOR_TYPE_NUMBERRANGE] = 
      oj.Validation.validatorFactory(oj.ValidatorFactory.VALIDATOR_TYPE_NUMBERRANGE)
      .createValidator(options);
  },
  /**
   * @private
   */
  _coerceInputNumberValue : function (val)
  {
    // 
    if (val !== null)
      return val = + val;
    else
      return val;
  },
  // The user can clear out min/max by setting the option to null, so we
  // do not coerce null.
  /**
   * @private
   */
  _parse : function (val)
  {
    // do not coerce if null
    if (val === null)
      return val;
    // coerce non-null
    // Invalid options provided by the application are errors.  We do not continue.
    // be strict: we coerce if string so that "312123abc" becomes NaN 
    // and doesn't make it through. What about "", should that become null? + "" is 0
    // parseFloat("") is NaN
    var parsedVal;
    if (typeof val === "string" && val !== "")
      parsedVal = + val;
    else
      parsedVal = parseFloat(val);
    
    if (isNaN(parsedVal))
    {
      oj.Logger.error("min or max or step is not a number");// TODO throw an exception
      return null; // TODO change to an exception and blow up
    }
    else
      return parsedVal;

    // 
    // this was too lenient. It passed through Objects, like new Object(1),
    // and returned the Object, but I think I want the number! I decided to
    // use parseFloat for _parse/_parseStep since these are what the app developer
    // sets, not the user. We can be more strict for app develoers.
//    if (typeof val === "string" && val !== "")
//       val = + val;
//    
//    return val === "" || isNaN(val) ? null : val;

  },
  /**
   * parse the step's value
   * We are following the behavior of HTML-5 the best we can. According
   * to the spec, it says step must be a number greater than 0. 
   * Chrome defaults it to 1 if it is not. 
   * @private
   */
  _parseStep : function (val)
  {
    var defaultStep = 1;
    if (val === null)
      return defaultStep;
    var parsedStep = this._parse(val);
    // DEFAULT to 1 if it isn't > 0
    if (parsedStep === null || parsedStep <= 0)
      parsedStep = defaultStep;
    return parsedStep;
  },
  /**
   * Toggles css selector on the widget. E.g., when readOnly option changes, 
   * the oj-read-only selector needs to be toggled.
   * @param {string} option
   * @param {Object|string} value 
   * @private
   */        
  _refreshStateTheming : function (option, value)
  {
    if (this._OPTION_TO_CSS_MAPPING.hasOwnProperty(option)) 
    {
      // value is a boolean
      this.widget().toggleClass(this._OPTION_TO_CSS_MAPPING[option], !!value);
    }
  },
  /* updates the aria-value information */
  _refreshAriaMinMaxValue : function ()
  {
    var valuenow = this._coerceInputNumberValue(this.options.value);
    var valuetext = this.element.val();
    
    this.element.attr(
    {
      "aria-valuemin" : this.options.min, "aria-valuemax" : this.options.max, 
      // TODO: what should we do with values that can't be parsed?
      // TODO: Ask Pavitra, do we need to parse the value?
      "aria-valuenow" : valuenow
    });
    if (!this._ValueEquals(""+valuenow, valuetext))
      this.element.attr({"aria-valuetext" : valuetext});
  },
  
  /**
   * step the inputnumber value up or down
   * @private
   * @param {Number} steps - Number of steps to increment.
   * @param {boolean} up If true step up, else step down.
   */
  _step : function (steps, up)
  {
    this._start();
    if (up)
      this._spin((steps || 1) * this.options.step);
    else
     this._spin((steps || 1) *  - this.options.step);     
    this._stop();
  },
  /**
   * Returns a jQuery object containing the element visually representing the inputnumber. 
   * 
   * <p>This method does not accept any arguments.
   * 
   * @expose
   * @memberof! oj.ojInputNumber
   * @instance
   * @return {jQuery} the inputnumber
  */
  widget : function ()
  {
    return this.uiInputNumber;
  }
 
});
/**
 * @class Utility methods for blending Knockout observables with the data model
 * @export
 */
oj.KnockoutUtils = function () {};

oj.KnockoutUtils.internalObjectProperty = "oj._internalObj";
oj.KnockoutUtils.underUpdateProp = "oj._underUpdate";
oj.KnockoutUtils.collUpdatingProp = "oj.collectionUpdating";

/**
 * Turns the attributes in a model object (or the attributes of all models in a collection object) into Knockout observables for use with components' view models.  
 * @param {Object} m The model or collection containing the attributes to be converted to Knockout observables. 
 * @param {function(Object)=} callback Called once per model so that a caller can add their own Knockout computed observables to the model. 
 * @param {boolean=} array Should function return an observable array if m is an oj.Collection, vs. an array of observables?
 * 
 * @return {Object|undefined} array of Knockout observables or an observable array
 * @export
 */
oj.KnockoutUtils.map = function (m, callback, array) 
{
  var koObject, i, updateCollection, updateObservableArrayRemove, updateObservableArrayAdd,
      data, prop, converted, updateModel, updateObservable, updateObservableArrayReset, updateObservableArraySort;

  function _makeUpdateModel(argProp) {
      return function(value) {
          //arguments.callee refers to the callback function itself, so we can use the stored '_prop' object (see below)
          if (!koObject[oj.KnockoutUtils.underUpdateProp]) {
              // Make sure we don't circuluarly fire the event
              m.set(argProp, value);
          }
        };
      }
      
  if (m instanceof oj.Collection)
  {
    /*koObject = array ? ko.observableArray() : oj.KnockoutUtils._createArray(m,
                                                        function (index) {
                                                            var defer = $.Deferred();
                                                            m.at(index, true).done(function(model) {
                                                                defer.resolve(oj.KnockoutUtils.map(model, callback));
                                                            });
                                                            return defer.promise();
                                                        });*/
    koObject = array ? ko.observableArray() : [];
    
    // Need access to original wrapped collection
    oj.KnockoutUtils._storeOriginalObject(koObject, m);
    
    for (i = 0; i < m._getLength(); i=i+1) 
    {
        koObject.push(oj.KnockoutUtils.map(m._atInternal(i, null, true, false), callback));
    }
            
    // Subscribe to the observable Array, if it is one
    updateCollection = function(changes)
    {
       var modArray, i, len;
       try {
            if (!koObject[oj.KnockoutUtils.underUpdateProp]) {
                koObject[oj.KnockoutUtils.collUpdatingProp] = true;
/*                // Pull out an array of model objects from the new observable array
                modArray = oj.KnockoutUtils._getModels(value);
                m.set(modArray);
                */
                // Process change information
                for (i = 0; i < changes.length; i++) {
                    var index = changes[i]['index'];
                    var model = oj.KnockoutUtils._getModel(changes[i]['value']);
                    var status = changes[i]['status'];
                    if (status === 'added') {
                        if (index >= m.length-1) {
                            m.add(model);
                        }
                        else {
                            m.add(model, {'at':index});
                        }
                    }                    
                    else if (status === 'deleted') {
                        m._removeInternal(model, index);
                    }
                }
                if (m['comparator']) {
                    koObject[oj.KnockoutUtils.underUpdateProp] = true;
                    // These could have been resorted--need to alter the observable array
                   koObject.sort(function(a, b) { 
                                        return oj.Collection.SortFunc(a, b, m['comparator'], m, this);
                                    });       
                    koObject[oj.KnockoutUtils.underUpdateProp] = false;
                }
            }
       }
       catch (e) {
           throw e;
       }
       finally {
           koObject[oj.KnockoutUtils.collUpdatingProp] = false;
       }           
    };    
    if (array && koObject['subscribe']) {
        koObject['subscribe'](updateCollection, null, 'arrayChange');
    }
    
     updateObservableArrayRemove = function(model, collection, options) {
         var index;
         try
         {
            if (koObject[oj.KnockoutUtils.collUpdatingProp]) {
                return;
            }
            if (collection instanceof oj.Collection) {
                koObject[oj.KnockoutUtils.underUpdateProp] = true;
                index = options['index'];
                koObject.splice(index, 1);
            }
         }
         catch (e) {
             throw e;
         }
         finally {
            koObject[oj.KnockoutUtils.underUpdateProp] = false;         
         }
     };
     updateObservableArrayAdd = function(model, collection, options) {
         var index, newObservable, len;
         try
         {
            if (koObject[oj.KnockoutUtils.collUpdatingProp]) {
                return;
            }
            if (collection instanceof oj.Collection) {
                koObject[oj.KnockoutUtils.underUpdateProp] = true;
                index = collection._localIndexOf(model);
                if (index !== undefined && index > -1) {
                    // Make sure to map with original callback from closure, if any
                    newObservable = oj.KnockoutUtils.map(model, callback);
                    if (options['fillIn']) {
                        // First, make sure there's enough room, that index actually exists in koObject...
                        var currLen = Array.isArray(koObject) ? koObject.length : koObject().length;
                        for (var i = currLen; i < index; i++) {
                            koObject.splice(i, 0, oj.KnockoutUtils.map(collection._atInternal(i, null, true, false), callback));
                        }
                        // If we're just filling in on a virtual collection, for example, then just set don't add
                        koObject.splice(index, 1, newObservable);
                    }
                    else {
                        koObject.splice(index, 0, newObservable);
                    }
                }                   
            }
         }
         catch (e) {
             throw e;
         }
         finally {
            koObject[oj.KnockoutUtils.underUpdateProp] = false;         
         }
     };     
     updateObservableArrayReset = function(collection, options) {
         try
         {
            if (koObject[oj.KnockoutUtils.collUpdatingProp]) {
                return;
            }
            if (collection instanceof oj.Collection) {
                koObject[oj.KnockoutUtils.underUpdateProp] = true;
               // koObject.splice(0, koObject().length);
                    if (ko.isObservable(koObject)) {
                        koObject.removeAll();
                    }
                    else {
                        koObject = [];
                    }
            }
         }
         catch (e) {
             throw e;
         }
         finally {
            koObject[oj.KnockoutUtils.underUpdateProp] = false;         
         }
     };     
     
     updateObservableArraySort = function(collection, options) {
         try
         {
            var len;
            if (koObject[oj.KnockoutUtils.collUpdatingProp]) {
                return;
            }
            if (collection instanceof oj.Collection) {
                koObject[oj.KnockoutUtils.underUpdateProp] = true;
                // Redo the knockout observable array

                koObject.sort(function(a, b) { 
                                return oj.Collection.SortFunc(a, b, m['comparator'], collection, this);
                             });   
            }
         }
         catch (e) {
             throw e;
         }
         finally {
            koObject[oj.KnockoutUtils.underUpdateProp] = false;         
         }
     };
     
     // Register these, ignoring the silent flags from normal API calls--knockout always needs to be updated
     m.OnInternal(oj.Events.EventType['ADD'], updateObservableArrayAdd, undefined, undefined, true);    
     m.OnInternal(oj.Events.EventType['REMOVE'], updateObservableArrayRemove, undefined, undefined, true);    
     m.OnInternal(oj.Events.EventType['RESET'], updateObservableArrayReset, undefined, undefined, true);
     m.OnInternal(oj.Events.EventType['SORT'], updateObservableArraySort, undefined, undefined, true);
  }
  else
  {
    if (m === undefined) {
        return;
    }
    
    koObject = {};
    
    data = m.attributes;
    prop = null;
    
    for (prop in data)
    {
      if (data.hasOwnProperty(prop)) {
        converted = ko.observable(m.get(prop));
        koObject[prop] = converted;

        updateModel = _makeUpdateModel(prop);
        updateModel._prop = prop;

        // Subscribe to any changes pushed by Knockout into the observable
        if (converted['subscribe']) {
            converted['subscribe'](updateModel);
        }
      }
     }

     updateObservable = function(model, options) {
         var attrs, prop;
         try
         {
            koObject[oj.KnockoutUtils.underUpdateProp] = true;
            attrs = model.changedAttributes();
            for (prop in attrs) {
                if (attrs.hasOwnProperty(prop)) {
                 koObject[prop](model.get(prop));
                }
            }
         }
         catch (e) {
             throw e;
         }
         finally {
            koObject[oj.KnockoutUtils.underUpdateProp] = false;         
         }
     };
     m.OnInternal(oj.Events.EventType['CHANGE'], updateObservable, undefined, undefined, true);
     // Need access to original wrapped model
    oj.KnockoutUtils._storeOriginalObject(koObject, m);

    // Activate user callback if specified, to allow user computed observables, etc.
    if (callback) {
        callback(koObject);
    }
  }
  
  return koObject;     
};

oj.KnockoutUtils._getModels = function(arr) {
    var modelArray = [], i, model;
    for (i = 0; i < arr.length; i=i+1) {
        model = oj.KnockoutUtils._getModel(arr[i]);
        modelArray.push(model);
    }
    return modelArray;
};

oj.KnockoutUtils._getModel = function(val) {
    if (val instanceof oj.Model) {
        return val;
    }
    
    return val[oj.KnockoutUtils.internalObjectProperty];
};


// Attempt to hide original object from enumeration of properties
oj.KnockoutUtils._storeOriginalObject = function(object, value) {
    // Store any callback along with model for use in event-driven mapping of new additions
       Object.defineProperty(object, oj.KnockoutUtils.internalObjectProperty, {value: value, enumerable:false});
};

/*oj.KnockoutUtils._createArray = function(collection, getCallback) {
    if (collection._isVirtual()) {
        return oj.KnockoutUtils._augment(collection.length, getCallback);
    }
    return [];
};

oj.KnockoutUtils._augment = function(len, getCallback) {
    var array;
    if (len.constructor === Array) {
        array = new Array(len.length);
        array.storage = len;
    }
    else {
        array = new Array(len);
        array.storage = new Array(len);
    }
    function makePropDef(arr) {
        return function (index, callback) {
                Object.defineProperty(arr, index.toString(), {
                    configurable:true,
                    get: function() { 
                        // Someone is accessing this location: if not set, set it using the callback before returning
                        if (!arr.storage[index]) {
                            arr.storage[index] = callback.call(this, index);
                        }
                        return arr.storage[index];
                    },
                    set: function(val) {
                        arr.storage[index] = val;
                    }
                });
            };
    }

    array.getCallback = getCallback;
        
    function setup(arr) {
        var i;
        arr.length = arr.storage.length;
        for (i = 0; i < arr.storage.length; i++) {
            makePropDef(arr)(i, arr.getCallback);
        }
    }
    setup(array);
    
    array.length = array.storage.length;
    
    array['pop'] = function() {
        var retVal = this.storage.pop();
        this.length = this.storage.length;
        return retVal;
    };
    array['push'] = function(val) {
        var index = this.length;
        this.storage.push(val);
        Object.defineProperty(this, index.toString(), {
                configurable:true,
                get: function() { 
                        // Someone is accessing this location: if not set, set it using the callback before returning
                        if (!this.storage[index]) {
                            this.storage[index] = this.getCallback.call(this, index);
                        }
                        return this.storage[index];
                },
                set: function(val) {
                    this.storage[index] = val;
                }
            });    
        return this.length;
    };
    array['shift'] = function() {
        var self = this;
        var retVal = self.storage.shift();
        setup(self);
        return retVal;
    };
    array['unshift'] = function() {
        var args = Array.prototype.slice.call(arguments), i;
        for (i = 0; i < args.length; i++) {
            this.storage.unshift(args[i]);
        }
        setup(this);
        return this.length;
    };
    array['reverse'] = function() {
        this.storage = this.storage.reverse();
        setup(this);
        return this;
    };
    array['slice'] = function(start, end) {
        var newArr = oj.KnockoutUtils._augment(this.storage.slice(start, end), this.getCallback);
        return newArr;
    };
    array['splice'] = function() {
        var args = Array.prototype.slice.call(arguments);    
        // Just redo the array after modifying storage
        Array.prototype.splice.apply(this.storage, args);
        setup(this);
    };
    return array;
};*/
/**
 * The ojTrain component allows a user to display a navigation visual that allows a user to go between different "steps"
 * Each step can display information about the state of the step("visited", "unvisited", "diabled")
 * and display a message type("error", "complete", "warning", "infromation")
 *
 *
 * @example <caption>Initialize component using widget API</caption>
 * &lt;div id="train"/&gt;<br/>
 * $("#train").ojTrain({'currentStep': "stp1", 'steps': [{name:'Step One', id:'stp1'},
 * {name:'Step Two', id:'stp2'},{name:'Step Three', id:'stp3'}]});
 * @example <caption>Using knockout, currentStep bind to observables - selectedStep</caption>
 * &lt;div id="train" data-bind="ojComponent:{component: 'ojTrain', currentStep: selectedStep, steps:[{name:'Step One', id:'stp1'},
 * {name:'Step Two', id:'stp2'},{name:'Step Three', id:'stp3'}]}"/&gt;gt;
 *
 * @class
 * @constructor
 * @name oj.ojTrain
 * @augments oj.baseComponent
 */
(function() {

    oj.__registerWidget("oj.ojTrain", $['oj']['baseComponent'], {
        version: "1.0.0",
        defaultElement: "<div>",
        widgetEventPrefix: "oj",
        options: {
            /**
             * The array of step objects. Each step must have an 'id' and 'name' variable, optional additonal variables are:
             * 'selection' - Indicates if the step is selectable and overrides the 'selection' variable passed in the options. Values are 'on' or 'off'.
             * 'state' - Indicates the state of the step. Possible options are 'visited', 'unvisited', 'disabled'. Default value is 'unvisited'
             * 'messageType' - The messageType icon to display on the step. Possible options are 'none', 'complete', 'error', or 'warning'. Default value is 'none'
             * @expose
             * @public
             * @instance
             * @memberof! oj.ojTrain
             */
            steps: [],
			
            /**
             * The global selection variable that sets a default section on all steps. By default, selection is set to "next",
             * meaning only the step after the selected one can be selected.
             * @expose
             * @public
             * @instance
             * @memberof! oj.ojTrain
             */
            selection: "next",
			
            /**
             * The currentStep variable indicates the id of the current selected step.
             * @expose
             * @public
             * @instance
             * @memberof! oj.ojTrain
             */
            currentStep: "",
            // Events

            /**
             * Fired whenever a supported component option changes, whether due to user interaction or programmatic
             * intervention.  If the new value is the same as the previous value, no event will be fired.
             *
             * Currently there is one supported option, <code class="prettyprint">"currentStep"</code>.  Additional
             * options may be supported in the future, so listeners should verify which option is changing
             * before taking any action.
             *
             * @expose
             * @event
             * @memberof! oj.ojTrain
             * @instance
             * @property {Event} event <code class="prettyprint">jQuery</code> event object
             * @property {Object} ui Parameters
             * @property {string} ui.option the name of the option that is changing
             * @property {string} ui.previousValue the previous value of the option
             * @property {string} ui.value the current value of the option
             * @property {Object} ui.optionMetadata information about the option that is changing
             * @property {string} ui.optionMetadata.writeback <code class="prettyprint">"shouldWrite"</code> or
             *           <code class="prettyprint">"shouldNotWrite"</code>.  For use by the JET writeback mechanism.
             *
             */
            optionChange: null

			/**
			 * Triggered when the train is created.
			 *
			 * @event
			 * @name create
			 * @memberof! oj.ojTrain
			 * @instance
			 * @property {Event} event <code class="prettyprint">jQuery</code> event object
			 * @property {Object} ui Empty object included for consistency with other events
			 *
			 */
        },
        /**
         * Variable for storing the number of steps in the train
         *
         * @private
         */
        _stepNum: 0,
		
        /**
         * Variable for storing the train information about each step in 2D Array form
         *
         * @private
         */
        _stepArray: null,
		
        /**
         * _create contains all actions that are needed fo the initialization of the train and is only called once.
         *
         * @override
         * @private
         */
        _create: function() {
            // Constrain initial value
            var options = this.options;
            this._super();
            var steps = options.steps;
            this._stepNum = steps.length;
            this._isRtl = this._GetReadingDirection() === "rtl";

            // Use margin-left normally and margin-right for rtl, same with alignment
            this._marginType = this._isRtl ? 'margin-right' : 'margin-left';
            this._alignType = this._isRtl ? 'right' : 'left';

            // Draw the background bar for the train
            var bar = $("<div class='oj-train-bar'></div>");
            this._maxStepWidth = this.element.width() < 107 * (this._stepNum - 1) + 72 ? (this.element.width() - 72) / (this._stepNum - 1) : 107;
            this._centerMargin = (this.element.width() - this._maxStepWidth * (this._stepNum - 1) - 72) / 2
            this._stepList = $("<ul>")
                    .attr({'aria-label': "Train Component"})
                    .css({'margin': "0", 'padding': "0"});
            if (this._stepNum > 1) {
                bar.css({'margin-top': "7px", 'width': ((this._stepNum - 1) * this._maxStepWidth) + "px"})
                        .css(this._marginType, 36 + this._centerMargin + "px")
                        .css(this._alignType, 0);
            }
            bar.appendTo(this.element);

            // Initialize the background progressbar object that will be updated to have the correct width based on the current step.
            this._progressbar = $("<div class='oj-train-bar-overlay'></div>");
            this._progressbar.appendTo(this.element);

            // Setup array that stores train information for each step.
            this._setupArray();
            this._currentStepIndex = this._getCurrentStepIndex(options.currentStep);

            // Draw each step. Visually each step consists of a background circle, a button, an icon, and a label.
            for (var i = 0; i < this._stepNum; i++)
            {
                // Create a list item to store each step.
                var stepTag = $("<li>")
                        .attr({'id': this._stepArray[i][1]})
                        .css({'list-style-type': "none", 'position': "absolute"})
                        .css(this._marginType, this._centerMargin + (this._maxStepWidth * i) + "px")
                        .css(this._alignType, 0);
                this._stepList.append(stepTag);
                if (i == (this._currentStepIndex + 1) && options.selection == "next")
                    this._stepArray[i][2] = "on";
                this._drawLabel(i);
                this._drawStepFill(i);
                this._drawButton(i);
                this._drawMessageType(i);
            }
            ;
            // Update background progressbar width to show the progress.
            this._updateProgressWidth();

            this.element.addClass("oj-train oj-component oj-component-content oj-corner-all");
        },
		
        /**
         * Updates the overlay progressbar width based on the currentStepIndex variable
         *
         * @private
         */
        _updateProgressWidth: function() {
            var progressWidth = this._currentStepIndex === (this._stepNum - 1) ? ((this._stepNum - 1) * this._maxStepWidth) : (this._maxStepWidth * this._currentStepIndex + 53.5 * (this._maxStepWidth / 107));
            this._progressbar.css({'margin-top': "7px", 'width': progressWidth + "px"})
                    .css(this._marginType, this._centerMargin + 36 + "px")
                    .css(this._alignType, 0);
            this._stepList.appendTo(this.element);
        },
		
        /**
         * Set up the _stepArray(). The first dimension indicates the step index and the second dimension indicates the step variables.
         * The order of the step variables are: name, id, selection, state, messageType
         *
         * @private
         */
        _setupArray: function() {
            var options = this.options;
			this._stepArray = new Array();
            for (var i = 0; i < this._stepNum; i++) {
                var step = options.steps[i];
                this._stepArray[i] = new Array(5);
                this._stepArray[i][2] = options.selection && options.selection != "next" ? options.selection : "off";
                this._stepArray[i][3] = "unvisited";
                for (var key in step) {
                    if (key === "name")
                    {
                        this._stepArray[i][0] = step[key];
                    }
                    else if (key === "id")
                    {
                        this._stepArray[i][1] = step[key];
                    }
                    else if (key === "selection")
                    {
                        this._stepArray[i][2] = step[key];
                    }
                    else if (key === "state")
                    {
                        this._stepArray[i][3] = step[key];
                    }
                    else if (key === "messageType")
                    {
                        this._stepArray[i][4] = step[key];
                    }
                }
            }
        },
		
        /**
         * Draw the button object for the step based on the index. If a button for that step alread exists remove it and draw the new one.
         * @param {Number} index - The index of the step for which the button is being drawn.
         *
         * @private
         */
        _drawButton: function(index)
        {
            var button = $("<div/>");
            var scrnRead = $("<span/>");
            var self = this;
            var desc = "";
            if (this._stepArray[index])
            {
                var state = this._stepArray[index][3];
                if (this._currentStepIndex === index) {
                    button.addClass("oj-train-button-current");
                    desc = ". This is the current step.";
                }
                else
                {
                    if (state === "visited") {
                        button.addClass("oj-train-button-visited");
                        desc = ". This step has been visited.";
                    }
                    else if (state === "unvisited") {
                        button.addClass("oj-train-button-unvisited");
                        desc = ". This step has not been visited yet.";
                    }
                    else
                        button.addClass("oj-train-button-disabled");
                }
                if (this._stepArray[index][3] !== "disabled" && (this.options.disabled == null || !this.options.disabled)) {
                    if (this._stepArray[index][2] === "on") {
                        this._hoverable(button);
                        button.bind("click" + this.eventNamespace, function() {
                            var oldStep = self.options.currentStep;
                            self.options.currentStep = this.parentNode.id;
                            self._fireOptionChange("currentStep", oldStep, this.parentNode.id, true);
                        });
                    }
                }
                button.css({'margin-top': "4px", 'width': "12px", 'height': "12px"})
                        .css(this._marginType, "29px")
                        .css(this._alignType, 0);
                var stepLi = this._stepList.children().eq(index).children();

                // Check that there are at least 3 items in the list item indicating that a button has already been created for this step.
                // If there is remove it and insert the new button in the same position. If there isn't a preexsisting button, simply add one.
                if (stepLi.length >= 3) {
                    stepLi[2].remove();
                    button.insertAfter(stepLi[1]);
                }
                else
                    this._stepList.children().eq(index).append(button);
                scrnRead.text(desc);
                scrnRead.css("display", "none");
                this._stepList.children().eq(index).find('a').append(scrnRead);
            }
        },
		
        /**
         * Draw the icon that displays the messageType for the step based on the index. If there already is an icon remove it and draw the new one.
         * @param {Number} index - The index of the step for which the icon is being drawn.
         *
         * @private
         */
        _drawMessageType: function(index)
        {
            var icon = $("<div/>");
            var scrnRead = $("<span/>");
            var desc = "";
            var self = this;
            if (this._stepArray[index])
            {
                var messageType = this._stepArray[index][4];
                if (messageType === "complete") {
                    icon.addClass("oj-train-icon-complete");
                    desc = " Complete";
                }
                else if (messageType === "info") {
                    icon.addClass("oj-train-icon-info");
                    desc = " Info";
                }
                else if (messageType === "error") {
                    icon.addClass("oj-train-icon-error");
                    desc = " Error";
                }
                else if (messageType === "warning") {
                    icon.addClass("oj-train-icon-warning");
                    desc = " Warning";
                }

                // Remove previous messageType
                var stepLi = this._stepList.children().eq(index).children();
                if (stepLi.length >= 4) {
                    stepLi[3].remove();
                }
                // Make icon clickable
                if (this._stepArray[index][3] !== "disabled" && (this.options.disabled == null || !this.options.disabled)) {
                    if (this._stepArray[index][2] === "on") {
                        this._hoverable(icon);
                        icon.bind("click" + this.eventNamespace, function() {
                            var oldStep = self.options.currentStep;
                            self.options.currentStep = this.parentNode.id;
                            self._fireOptionChange("currentStep", oldStep, this.parentNode.id, true);
                        });
                    }
                }
                // Add new message
                if (messageType != null && messageType != "none") {
                    icon.css({'margin-top': "9px", 'height': "9px", 'width': "9px"})
                            .css(this._marginType, "34px")
                            .css(this._alignType, 0);
                    // If there is remove it and insert the new icon in the same position.
                    // Add description to span
                    scrnRead.text(desc);
                    scrnRead.css("display", "none");
                    this._stepList.children().eq(index).find('a').append(scrnRead);
                    this._stepList.children().eq(index).append(icon);

                }
            }
        },
		/**
         * Fire optionChange event 
         * @param {String} key - 'currentStep'
		 * @param {String} previousValue 
		 * @param {String} value
		 * @param {Boolean} originalEvent  
         *
         * @private
         */
        _fireOptionChange: function(key, previousValue, value, originalEvent) 
        {

            var ui = {
                "option": key,
                "previousValue": previousValue,
                "value": value,
                // (originalEvent is non-null) iff (option change is due to user interaction) iff (binding should write back the value)
                "optionMetadata": {'writeback': originalEvent ? "shouldWrite" : "shouldNotWrite"}
            };
            this._trigger('optionChange', originalEvent, ui);

        },
		
        /**
         * Draw the background circle for the step which is either light or dark base on if the step is before or after the selected step.
         * @param {Number} index - The index of the step for which the icon is being drawn.
         *
         * @private
         */
        _drawStepFill: function(index)
        {
            var stepFill = $("<div/>");
            if (this._stepArray[index])
            {
                if (index <= this._currentStepIndex)
                    stepFill.addClass("oj-train-stepBackground-overlay");
                else
                    stepFill.addClass("oj-train-stepBackground");
                stepFill.css(this._marginType, "25px")
                        .css(this._alignType, 0);
                var stepLi = this._stepList.children().eq(index).children();
                if (stepLi.length > 1)
                    stepLi[1].remove();
                stepFill.insertAfter(stepLi[0]);

            }
        },
		
        /**
         * Draw the label for the step.
         * @param {Number} index - The index of the step for which the icon is being drawn.
         *
         * @private
         */
        _drawLabel: function(index)
        {
            var self = this;
            if (this._stepArray[index])
            {
                var name = this._stepArray[index][0];
                var label = $("<a>" + name + "</a>");
                label.addClass("oj-train-label");
                label.css('margin-bottom', "7px");
                label.css(this._alignType, 0);
                if (index === this._currentStepIndex)
                    label.addClass("oj-selected");
                else if (this._stepArray[index][3] === "visited")
                    label.addClass("oj-visited");
                else if (this._stepArray[index][3] === "disabled")
                    label.addClass("oj-disabled");
                if (this._stepArray[index][2] === "on" && (this.options.disabled == null || !this.options.disabled)) {
                    label.attr("href", "#");
                    this._hoverable(label);
                    label.bind("click keydown" + this.eventNamespace, function(e) {
                        if (e.keyCode == 13 || e.type == "click") {
                            var oldStep = self.options.currentStep;
                            self.options.currentStep = this.parentNode.id;
                            self._fireOptionChange("currentStep", oldStep, this.parentNode.id, true);
                        }
                    });
                }
                var stepLi = this._stepList.children().eq(index).children();
                if (stepLi.length >= 1)
                    stepLi[0].remove();
                this._stepList.children().eq(index).prepend(label);
            }
        },
		
        /**
         * Draw the label for the step.
         * @param {String} id - The index of the id whose id is being passed in.
         *
         * @private
         */
        _getCurrentStepIndex: function(id)
        {
            for (var i = 0; i < this._stepNum; i++) {
                if (this._stepArray[i] && this._stepArray[i][1] === id)
                    return i;
            }
            return 0;
        },
		
        /**
         * <p>Returns the name of the step based on the id passed in. If the step doesn't have a name, return null;</p>
         * @public
         * @param {String} id - The id of the step.
         * @return {String} name of step.
         * @expose
         * @instance
         * @memberof! oj.ojTrain
         */
        getStepName: function(id)
        {
            for (var i = 0; i < this._stepNum; i++) {
                if (this._stepArray[i] && this._stepArray[i][1] === id)
                    return this._stepArray[i][0];
            }
            return null;
        },
		
        /**
         * <p>Returns the id of the step based on the name passed in. If the step doesn't have an id, return null;</p>
         * @public
         * @param {String} name - The name of the step.
         * @return {String} id of step.
         * @expose
         * @instance
         * @memberof! oj.ojTrain
         */
        getStepId: function(name)
        {
            for (var i = 0; i < this._stepNum; i++) {
                if (this._stepArray[i] && this._stepArray[i][0] === name)
                    return this._stepArray[i][1];
            }
            return null;
        },
		
        /**
         * <p>Select the step based on the id provided. </p>
         * <p>Select should be run after running the deselect function on the previously selected step.  </p>
         * @public
         * @param {String} id - The id of the step being selected.
         * @expose
         * @memberof! oj.ojTrain
         * @instance
         */
        select: function(id)
        {
            for (var i = 0; i < this._stepNum; i++) {
                if (this._stepArray[i] && this._stepArray[i][1] === id)
                {
                    if (this.options.selection === "next" && (i + 1 < this._stepNum))
                    {
                        this._stepArray[i + 1][2] = "on";
                        this._drawLabel(i + 1);
                        this._drawButton(i + 1);
                    }
                    this._stepArray[i][3] = "current";
                    this._currentStepIndex = i;
                    this.options.currentStep = id;
                    this._drawLabel(i);
                    this._drawButton(i);
                    this._updateProgressWidth();
					break;
                }
            }
            for (var i = 0; i < this._stepNum; i++)
                this._drawStepFill(i);
        },
		
        /**
         * <p>Deselect the step based on the id provided. When deselecting a step selection, state, and messageType can be changed.</p>
         * <p>Deselect should be run before running select().  </p>
         * @public
         * @param {String} id - The id of the step being deselected.
         * @param {String} selection - Selection on the step once it is deselected, if this parameter isn't selection is set to "off" on this step.
         * @param {String} state - The state of the step once it is deselected, if this parameter isn't provided the state is set by default to "visited".
         * @param {String} messageType - The messageType to display for the deselected step, if this parameter isn't provided the messageType remains unchanged.
         * @expose
         * @instance
         * @memberof! oj.ojTrain
         */
        deselect: function(id, selection, state, messageType)
        {
            for (var i = 0; i < this._stepNum; i++) {
                if (this._stepArray[i] && this._stepArray[i][1] === id)
                {
                    selection ? this._stepArray[i][2] = selection : this._stepArray[i][2] = "off";
                    state ? this._stepArray[i][3] = state : this._stepArray[i][3] = "visited";
                    messageType ? this._stepArray[i][4] = messageType : this._stepArray[i][4] = "none";
                    this._currentStepIndex = -1;
                    if (this.options.selection === "next" && (i + 1 < this._stepNum))
                    {
                        this._stepArray[i + 1][2] = "off";
                        this._drawLabel(i + 1);
                        this._drawButton(i + 1);
                    }
                    this._drawLabel(i);
                    this._drawButton(i);
                    this._drawMessageType(i);
					break;
                }
            }
        },
		
        /**
         * <p>Returns the id of the next selectable step based on the currentStep id. If the current step is the last selectable step, returns null</p>
         * @public
         * @return {String} next selectable Id
         * @expose
         * @instance
         * @memberof! oj.ojTrain
         */
        nextSelectableStep: function()
        {
            for (var i = this._currentStepIndex; i < this._stepNum; i++) {
                if (i + 1 < this._stepNum && this._stepArray[i + 1] && this._stepArray[i + 1][2] === "on")
                {
                    return this._stepArray[i + 1][1];
                }
            }
            return this._stepArray[this._currentStepIndex][1];

        },
		
        /**
         * <p>Returns the id of the previous selectable step based on the currentStep id. If the current step is the first selectable step, returns null</p>
         * @public
         * @return {String} previous selectable Id
         * @expose
         * @instance
         * @memberof! oj.ojTrain
         */
        previousSelectableStep: function()
        {
            for (var i = this._currentStepIndex; i >= 0; i--) {
                if (this._stepArray[i - 1] && this._stepArray[i - 1][2] === "on")
                {
                    return this._stepArray[i - 1][1];
                }
            }
            return this._stepArray[this._currentStepIndex][1];
        }

    });
}( ));
/*!
 * JET Radioset @VERSION
 * http://jqueryui.com
 *
 * Copyright 2013 jQuery Foundertion and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * Depends:
 *  jquery.ui.widget.js
 */
/**
 * @class
 * @name oj.ojRadioset
 * @augments oj.editableValue
 * @classdesc
 * <p>
 * The JET Radioset component (ojRadioset) enhances a group of 
 * <code class="prettyprint">input type="radio"</code> elements. It 
 * manages the selected value of the group and it adds required validation. 
 * It also adds and removes the correct
 * oj-* styles to the dom elements so it has the JET styling and is themable.
 * </p>
 * <p>To use an ojRadioset, group all the inputs and their labels within a 
 * container dom element, e.g., div. 
 *   For accessibility, set <code class="prettyprint">aria-labelledby</code> on 
 *   this container dom element.
 *   Also set each input's <code class="prettyprint">id</code> attribute, and 
 *   refer to that in the input's label's 
 *   <code class="prettyprint">for</code> attribute.
 *   Then create the ojRadioset on this container dom element.  
 * </p>
 * <p>
 *  Radioset is used by selecting a container element which contains the 
 *  radio input elements and calling <code class="prettyprint">ojRadioset()</code>. 
 *  You can enable and disable a radio set, 
 *  which will enable and disable all contained radios. 
 * </p>
 * <p>
 *  Radioset does not have a readOnly option since HTML does not support
 *  readonly on radios and checkboxes.
 * </p>
 * 
 * <h3 id="keyboard-section">
 *   Keyboard interaction
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
 * </h3>
 * 
 * <p>The radioset does not add any extra keyboard navigation to the input radios. 
 * The keyboard interaction comes from the native browser.
 * </p>
 * <h3 id="a11y-section">
 *   Accessibility
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
 * </h3>
 * 
 * <p>JET Radioset takes care of setting 
 * <code class="prettyprint">role="radiogroup"</code> on the radioset element.  
 * 
 * <p>As shown in the online demos, the application is responsible for applying 
 * <code class="prettyprint">aria-labelledby</code>
 * to point to the main label element for the group of radios.
 * <h3 id="jqui2jet-section">
 *   JET for jQuery UI developers
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#jqui2jet-section"></a>
 * </h3>
 * 
 * <p>
 *   All JQUI and JET components inherit <code class="prettyprint">disable()</code> 
 *   and <code class="prettyprint">enable()</code> methods from the base class. 
 *    This API duplicates the functionality of the 
 *    <code class="prettyprint">disabled</code> option.  
 *    In JET, to keep the API as lean as possible, we have chosen not to document 
 *    these methods outside of this section.
 * </p>
 * <!-- - - - - Above this point, the tags are for the class.
 *              Below this point, the tags are for the constructor (initializer). - - - - - - -->
 * 
 * @desc Creates a JET Radioset.
 *  For JET Radioset, if the DOM changes (for example, you add/remove a radio), 
 *  you should <code class="prettyprint">refresh()</code>.
 * 
 * @param {Object=} options a map of option-value pairs to set on the component
 * 
 * @example <caption>Initialize the radioset with no options specified:</caption>
 * $(".selector").ojRadioset();
 * 
 * @example <caption>Initialize the radioset with some options and callbacks specified:</caption>
 * $( ".selector" ).ojRadioset( { "value": "copy", "valuechange": 
 * function( event, ui ) {alert("valuechanged from " + ui.previousValue + " to " + ui.value);} } );             
 * @example <caption>Initialize component using widget API</caption>
 * &lt;label id="grouplabel">Greetings&lt;/label>
 * &lt;div id="radioset" aria-labelledby="grouplabel">
 *   &lt;input id="helloid" value="hello" type="radio" name="greetings"/&gt;
 *   &lt;label for="helloid"/&gt;Hello&lt;/label>
 *   &lt;input id="bonjourid" value="bonjour" type="radio" name="greetings"/&gt;
 *   &lt;label for="bonjourid"/&gt;Bonjour&lt;/label>
 *   &lt;input id="ciaoid" value="ciao" type="radio" name="greetings"/&gt;
 *   &lt;label for="ciaoid"/&gt;Ciao&lt;/label>
 * &lt;div>
 * <br/>
 * // set the value to "ciao". (The 'ciao' radio will be checked)
 * $("#radioset").ojRadioset({'option', 'value', 'ciao'});
 * 
 * @example <caption>Initialize a radioset via the JET 
 * <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;label id="grouplabel">Time&lt;/label>
 * &lt;div id="radioset" data-bind="ojComponent: {component: 'ojRadioset', value: 'night'} 
 *   aria-labelledby="grouplabel" >
 *   &lt;input id="morningid" value="morning" type="radio" name="time"/&gt;
 *   &lt;label for="morningid"/&gt;Morning&lt;/label>
 *   &lt;input id="nightid" value="night" type="radio" name="time"/&gt;
 *   &lt;label for="nightid"/&gt;Night&lt;/label>
 * &lt;div>
 * <br/>
  * @example <caption>Using knockout, value bind to observable:</caption>
 * &lt;label id="grouplabel">Time&lt;/label>
 * &lt;div id="radioset" data-bind="ojComponent: {component: 'ojRadioset', 
 * value: currentTime} 
 *   aria-labelledby="grouplabel" >
 *   &lt;input id="morningid" value="morning" type="radio" name="time"/&gt;
 *   &lt;label for="morningid"/&gt;Morning&lt;/label>
 *   &lt;input id="nightid" value="night" type="radio" name="time"/&gt;
 *   &lt;label for="nightid"/&gt;Night&lt;/label>
 * &lt;div>
 * <br/>
 * // in the model, make the currentTime variable a knockout observable.
 * // The model and the component's value option will stay in sync. Change the
 * // component's value option and the model will change. Change the model,
 * // and the component's value option will change. Click on a radio, and both
 * // will change.
 * self.currentTime = ko.observable("night");
 * @constructor
 */
oj.__registerWidget("oj.ojRadioset", $['oj']['editableValue'],
{
  version : "1.0.0",  
  defaultElement : "<div>", 
  widgetEventPrefix : "oj", 
  options : 
  {
 
  },
  /**** start Public APIs ****/
      
   /**
   * Refreshes the radioset
   * <p>A <code class="prettyprint">refresh()</code> is required 
   * when a radioset is programatically changed, like in the following circumstances:
   * <ul>
   *   <li>After radios are added or removed or modified (without using ojRadioset) in the DOM.</li>
   * </ul>    
   * @expose 
   * @memberof! oj.ojRadioset
   * @instance
   * @example <caption>Invoke the <code class="prettyprint">refresh</code> method:</caption>
   * $( ".selector" ).ojRadioset( "refresh" );
   */
  refresh: function() 
  {
    this._super();
    // refresh the ojRadioCheckbox's that exist, and  of the type=radio inputs that 
    // are not yet ojRadioCheckboxs, make them ojRadioCheckboxs.
    this.$radios = this._findRadiosWithMatchingName()
                    .filter( ".oj-radio" )
                    ._ojRadioCheckbox("refresh")
                    .end()                  
                    // Create ojRadioCheckbox out of any 'new' radios.
                     // the END is key here. It makes it so that 
                     // this.$radios has ALL the radios.
                     // .not if a filter, it removes elements that do not have the
                     // oj-radio style class from the list of all input[type=radio]s.
                    .not( ".oj-radio" )
                    ._ojRadioCheckbox()
                    .end();
         
    this._setup();
  },
  /**
   * Returns a jQuery object containing the element visually representing the radioset. 
   * 
   * <p>This method does not accept any arguments.
   * 
   * @expose
   * @memberof! oj.ojRadioset
   * @instance
   * @return {jQuery} the radio
  */
  widget : function ()
  {
    return this.uiRadioset;
  },
          
   /**** end Public APIs ****/         
          
  /**** start internal widget functions ****/   
       
  /**
   * After _ComponentCreate and _AfterCreate, 
   * the widget should be 100% set up. this._super should be called first.
   * @override
   * @protected
   */
  _ComponentCreate : function ()
  {
    this._super();
    // turn each radio into ojRadioCheckbox. Do this first, since we need it
    // in calls from 'create'.
    this.$radios = this._findRadiosWithMatchingName()._ojRadioCheckbox();

    this.uiRadioset = this.element.addClass("oj-radioset oj-component")
                                  .attr( "role", "radiogroup" );
    this._on(this._events);
    this._setup(); // TODO: by this time the option is already defaulted to true or false. Hmm...

  },
  /**
   * Returns a jquery object that is a set of elements that are input type radio
   * and have the name of the first radio found.
   * 
   * @return {Object} jquery object of all the radios within the root dom element
   * that have the same 'name' attribute as the first radio found.
   * @private
   */
  _findRadiosWithMatchingName : function ()
  {
    //return this.element.find('input[type=radio]'); // simplest thing to do.
    
    var first = this.element.find("input[type=radio]:first");
    if (first.length === 0)
    {
      oj.Logger.warn("Could not find any input type=radio within this element");
    }
    // get the name attribute of the first input radio
    var name = first.attr("name");
    // find all input radios with matching name
    if (name === undefined)
    {
    	// search for all radios with no name
      var allradios = this.element.find("input[type=radio]");
      // now loop and find the ones without 'name' attribute
      return allradios.not("[name]");
    }
    else
    {
    	// search for all radios with the name
      var selector = "input[type=radio][name=" + name + "]";
      return this.element.find(selector);
    	
    }
  },
  /* 
   * Component developers: This API and functionality is subject to change pending architectural review!
   * See the baseComponent method for preliminary API doc.
   */
  _showContextMenu: function(menu, event)
  {
    // TODO: confirm this logic
    var radios = this.element.find("input[type=radio]");
    var checked = radios.filter(":checked");
    var launcher = checked.length ? checked : radios.first(); 
    menu.show(event, {"launcher": launcher, "focus": "menu"});
  },
  /**
   * _setup is called on create and refresh. Use the disabled option to 
   * update the component. If the component's option is disabled, then
   * leave it alone.
   */
  _setup: function() 
  {

    // disable radio if element was already disabled
    if (this.options.disabled === true)
    {
      // calls _setOption disable is true, which in turn disables all radios.
      this.disable();
    }
    else if (this.options.disabled === false)
    {
      this.enable();
    }
  },   
  _events : 
  {
    'change' : function (event)
    {
      
      this._HandleChangeEvent(event);
    }
  },

  /**
   * @param {Event} event DOM event 
   * @override
   * @protected
   * @memberof! oj.ojRadioset
   */
  _HandleChangeEvent: function(event)
  {
    // TODO make sure the target is an input radio?
    // TODO any more checks I need to do?
    //alert("XYZ In _changeSetValue target is " + event.target + " And the value of the input is " + event.target.value);

    // should I double check that the event.target is the same as the 'checked'?
    // if (event.target === this.$radios.filter(":checked"))???
    // _SetValue triggers valuechange event
    this._super(event);
  },
                  
  /**
   * Returns the display value that is ready to be passed to the converter.
   * 
   * @param {Object} value the stored value if available that needs to be formatted for display
   * @override
   * @protected
   * @memberof! oj.ojRadioset
   */
  _GetDisplayValue : function (value) 
  {
    // return the value of the 'checked' radio
    return this._GetElementValue();
  },
  /**
   * Called when the display value on the element needs to be updated 
   * as a result of a value change. 
   * ojRadioset stores a String value, and this value matches the value
   * of the currently checked radio. So, if we need to set the display value,
   * what this means is we need to 'check' the radio whose value matches the
   * displayValue.
   * 
   * @param {String} displayValue of the new string to be displayed
   * @override
   * @protected
   * @memberof! oj.ojRadioset
  */  
  _SetDisplayValue : function (displayValue) 
  {

    if (displayValue != null)
    {
      // If we found a radio with a matching value, and it isn't already checked,
      // then check it. If it is already checked, do nothing.
      // If we can't find a radio with a matching value, then we uncheck 
      // all the radios. We do this so that the radio state matches the value option
      // value.
      
      var valueFilter = "[value='" + displayValue + "']"; 
      if (valueFilter !== undefined && this.$radios !== undefined)
      {
        var radioWithMatchingValue = 
            this.$radios.filter(valueFilter);
        // found a radio with a matching value
        if (radioWithMatchingValue !== undefined && radioWithMatchingValue.length > 0)
        {
          // if not already checked, then mark as checked.
          if (!radioWithMatchingValue.prop('checked'))
          {
            radioWithMatchingValue._ojRadioCheckbox("option", "checked", true);
          }
        }
        else
        {
          // did not find any radios with a matching value, so uncheck
          // all of them.
          this.$radios._ojRadioCheckbox("option", "checked", false);
        }
      }
      // TODO Do I need to refresh
    } 
  },
  /**
   * Returns the element's value. Normally, this is a call to this.element.val(),
   * but in the case of ojRadioset, the element's value is really the value
   * of the checked radio in the set.
   * @override
   * @protected
   * @memberof! oj.ojRadioset
   */
  _GetElementValue : function () 
  {
    // "input:checked" selects radios that are currently checked as 
    // reflected in their boolean (true or false) checked property, 
    // which is affected when the user clicks the radio for example.
    // for radio, there will be one or none checked; 
    // if none are checked, return null (checkedRadio.val() is undefined if nothing is checked)
    var checkedRadio = this.$radios.filter(":checked");
    if (checkedRadio.length === 0)
      return null;
    else
      return checkedRadio.val();
  },
          
  /**
   * Overridden to set the default value for options.value when it's null or undefined.
   * 
   * @memberof! oj.ojRadioset
   * @instance
   * @protected
   */    
  _InitOptions : function ()
  {
    var radios, checkedRadio, result;
    this._super();
    
    if (this.options["value"] == null) // null or undefined
    {
      // return the checked values by simply looking at DOM node
      radios = this._findRadiosWithMatchingName();
      checkedRadio = radios.filter(":checked");
      result = (checkedRadio.length === 0) ? null : checkedRadio.val();
      this.options['value'] = result;
    }
  },
  
  /**
   * Returns the default styleclass for the component. Currently this is 
   * used to pass to the _ojLabel component, which will append -label and 
   * add the style class onto the label. This way we can style the label
   * specific to the input component. For example, for inline labels, the
   * radioset/checkboxset components need to have margin-top:0, whereas all the
   * other inputs need it to be .5em. So we'll have a special margin-top style 
   * for .oj-label-inline.oj-radioset-label
   * All input components must override
   * 
   * @return {string}
   * @memberof! oj.ojRadioset
   * @override
   * @protected
   */
  _GetDefaultStyleClass : function ()
  {
    return "oj-radioset";
  },
  /**
   * Returns a jquery object of the elements representing the 
   * content nodes (input type=radio). This is used in EditableValue to add
   * aria-describedby to the input when there is a help icon, to add
   * aria-required and aria-invalid
   * @protected
   * @override
   * @memberof! oj.ojRadioset
   */
  _GetContentElement : function ()
  {
    return this._findRadiosWithMatchingName();
  },
   /**
   * Called when a aria-required attribute needs to be set or removed. 
   * Most inputs/selects need aria-required on the input element (aka 'content')
   * But it is not legal to have aria-required on radio/checkboxes.
   * Subclasses can override to put aria-required where they want.
   * 
   * @param {Object=} value the current value of the required option
   * @memberof! oj.ojRadioset
   * @instance
   * @protected
   */
  _RefreshAriaRequired : function (value)
  {
    var ariaValue, rootNode = this.uiRadioset;

    ariaValue = (value == "required") ? true : false;
    if (ariaValue && rootNode) 
    {
      rootNode.attr("aria-required", ariaValue);
    }
    else
    {
      rootNode.removeAttr("aria-required");
    }
  }, 
  /**
   * Note that _setOption does not get called during create in the super class. 
   * It only gets called when the component has already been created.
   * @override
   * @private
   */
  _setOption : function (key, value)
  {
    this._super(key, value);
    
    if ( key === "disabled" ) {
      // disables/enables all the radios
      this.$radios._ojRadioCheckbox( "option", key, value );
    }
  },
  /**
   * Return the subcomponent node represented by the documented locator attribute values.
   * Test authors should target spinner sub elements using the following names:
   * <ul>
   * <li><b>oj-radioset-inputs</b>: the radioset's input elements</li>
   * </ul>
   * 
   * @expose
   * @override
   * @memberof! oj.ojRadioset
   * @instance
   * @param {Object} locator An Object containing at minimum a subId property 
   * whose value is a string, documented by the component, that allows the component to 
   * look up the subcomponent associated with that string.  It contains:
   * <ul>
   * <li>
   * component: optional - in the future there may be more than one component 
   *   contained within a page element
   * </li>
   * <li>
   * subId: the string, documented by the component, that the component expects 
   * in getNodeBySubId to locate a particular subcomponent 
   * </li>
   * </ul>  
   * @returns {Element|null} the subcomponent located by the subId string 
   * passed in locator, if found.
   */
  getNodeBySubId: function(locator)
  {
    if (locator == null)
    {
      return this.element ? this.element[0] : null;
    }
    
    var subId = locator['subId'];
    if (subId === "oj-radioset-inputs") {
      return this.$radios;
    }
    
    // Non-null locators have to be handled by the component subclasses
    return null;
  },  
  /**
   * TODO: What is our 'destroy' strategy with regards to html attributes that 
   * they have initially on their dom, but we change? like disabled? Do we store 
   * on data at the beginning, then restore from this data, and then call removeData?
   * @override
   * @private
   */
  _destroy : function ()
  {  
    this._super();
    // base class removes oj-disabled
    this.element.removeClass("oj-radioset oj-enabled oj-component")
                .removeAttr( "role" );
    if (this.$radios)
    {
      this.$radios._ojRadioCheckbox( "destroy" );
    }
  }
  /**** end internal widget functions ****/ 
 
});
/*!
 * JET Radio This component is private. @VERSION
 * http://jqueryui.com
 *
 * Copyright 2013 jQuery Foundertion and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * Depends:
 *  jquery.ui.widget.js
 */
/**
 * The _ojRadio component enhances a browser input element into one that is 
 * of type=radio. This is a private component used by ojRadioset.
 * 
 * <h3>Events:</h3>
 * <ul>
 *   <li>clicked/checked?<p>
 *   Triggered if the checkbox is clicked; or if the checkbox was checked programatically
 *   with the checked option.
 *   </li>
 * </ul>
 * 
 * @class
 * @private
 * @constructor
 * @name oj._ojRadioCheckbox
 * @augments oj.baseComponent TODO: Should I extend this? 
 * Pros: it gives me oj-disabled/oj-enabled. (easy to add myself)
 * Cons: It gives me tooltip stuff that I don't want. I want that on the div or on the first checkbox only.
 * Pro/Con?: it rewrites required for me if it is on the dom node, but then it makes it required??? Should I rewrite required or don't care?
 */
oj.__registerWidget("oj._ojRadioCheckbox", $['oj']['baseComponent'],
{
  version : "1.0.0",  
  defaultElement : "<input>", 
  widgetEventPrefix : "oj", 
  options : 
  {	 
    /** 
     * First we look for the disabled option to be explicitly set. If not, then
     * we look if disabled is on the dom. If null, disabled defaults to false.
     * @expose 
     * @type {?boolean}
     * @default <code class="prettyprint">false</code>
     * @public
     * @instance
     * @memberof! oj._ojRadioCheckbox
     */
    disabled: null,
    /** 
     * First we look for the checked option to be explicitly set. If not, then
     * we look if checked is on the dom. If null, checked defaults to false.
     * @expose 
     * @public
     * @instance
     * @memberof! oj._ojRadioCheckbox */
    checked : null,
    /** 
     * First we look for the disabled option to be explicitly set. If not, then
     * we look if disabled is on the dom. If null, disabled defaults to false.
     * @expose 
     * @type {?boolean}
     * @default <code class="prettyprint">false</code>
     * @public
     * @instance
     * @memberof! oj._ojRadioCheckbox
     */
     type: null	
  },
  /**** start Public APIs ****/
  /**
   * 
   * <p>This method does not accept any arguments.
   * 
   * @public
   * @expose
   * @memberof! oj.RadioCheckbox 
   * @return {jQuery} the label(s) for the checkbox/radio input
  */
  label : function ()
  {
    if (this.$label === undefined)
    {
      this.$label = this._getLabelsForElement();
    }
    return this.$label;
  },  
  /*
   * @expose 
   * @memberof! oj._ojRadioCheckbox
   * @instance
   * @override
   * @example <caption>Invoke the <code class="prettyprint">refresh</code> method:</caption>
   * $( ".selector" )._ojRadioCheckbox( "refresh" );
   */
  refresh: function() 
  {
    this._super();
    
    var isDisabled = this.element.is( ":disabled" );

    if ( isDisabled !== this.options.disabled ) 
    {
      this._setOption( "disabled", isDisabled );
    }
    this._setup();
  },    
  /**
   * Returns a jQuery object containing the element visually representing the checkbox. 
   * 
   * <p>This method does not accept any arguments.
   * 
   * @expose
   * @memberof! oj._ojRadioCheckbox
   * @instance
   * @return {jQuery} the checkbox or radio
  */
  widget : function ()
  {
      return this.uiRadioCheckbox;
  },
          
   /**** end Public APIs ****/         
          
  /**** start internal widget functions ****/   
       
  /**
   * @override
   * @private
   */
  _create : function ()
  {
    this._super();
    
    // CHECKED:
    // if options.checked is not set, or not valid, get it from the element
    // if options.checked is set to a valid value (boolean), set it on the 
    // element to keep the two in sync. 
    if ( typeof this.options.checked !== "boolean" ) 
    {
      // !! ensures it is a boolean
      this.options.checked = !!this.element.prop( "checked" );
    }
    
    // DISABLED:
    // if options.disabled is not set, or not valid, get it from the element
    // if options.disabled is set to a valid value (boolean), set it on the 
    // element to keep the two in sync. 
    if ( typeof this.options.disabled !== "boolean" ) 
    {
      // !! ensures it is a boolean
      this.options.disabled = !!this.element.prop( "disabled" );
    }
	
	// TYPE:
	// Get's the type which will be either radio or checkbox
    this.options.type = this.element.prop( "type" );
	
    this._drawOnCreate();
    
    this._on(this._events);
  },
  /** Called every time ojCheckboxset or ojRadioSet is called without attributes. It's essentially
   * a hard-reset.
   * @override
   * @private
   */
  _init : function ()
  {
    this._super();
    this._setup();
  },
  _setup : function() 
  {

    // disable checkbox or radio dom if component disabled option is true
    if (this.options.disabled)
    {
      // calls _setOption disable is true
      this.disable();
    }
    else
    { 
      this.enable();
    }

    // set checked checkbox or radio dom if component checked option is true
    if (this.options.checked)
    {
      this._setOption("checked", true);
    }
    else
    {
      this._setOption("checked", false);
    }
  },
  _events : 
  {

  },
  /**
   * set up styles on create
   * @private
   */
  _drawOnCreate : function ()
  {
    var type = this.options.type;
	if (type == "checkbox") {
      this.uiRadioCheckbox = this.element.addClass("oj-checkbox oj-component");
      this.$label = this._getLabelsForElement();
      this.$label.addClass("oj-checkbox-label");
	}
	else if (type == "radio") {
      this.uiRadioCheckbox = this.element.addClass("oj-radio oj-component");
      this.$label = this._getLabelsForElement();
      this.$label.addClass("oj-radio-label");
	}	
    // oj-hover/oj-focus/oj-active should be added/removed in code as needed, 
    // however these should only be added when the item is enabled. 
    // When the item is disabled these classes should not be added.
    var self = this;
    this._hoverable( this.element );
    this._focusable( this.element );
    this._activeable( this.element );
    // loop through each label
    $.each(self.$label, function ()
    {
      self._hoverable(this);
      self._focusable(this);
      self._activeable(this);
    });
   },
  /**
   * @override
   * @private
   */
  _setOption : function (key, value)
  {

    this._super(key, value);

    if (key === "disabled")
    {
      value = !!value;
      if (value)
      {
        // when a dom element supports disabled, use that, and not aria-disabled.
        // having both is an error.
        this.element.prop("disabled", true).removeAttr( "aria-disabled")
        .removeClass("oj-enabled").addClass("oj-disabled");

        this.$label.removeClass("oj-enabled")
        .addClass("oj-disabled");
      }
      else 
      {
        // when a dom element supports disabled, use that, and not aria-disabled.
        // having both is an error.
        this.element.prop("disabled", false)
        .removeAttr( "aria-disabled").removeClass("oj-disabled")
        .addClass("oj-enabled");
        this.$label.addClass("oj-enabled")
        .removeClass("oj-disabled");
      }
    }
 
    if (key === "checked")
    {
      if (value)
      {
        this.element.prop("checked", true);
      }
      else 
      {
        this.element.prop("checked", false);
      }
      this.element.toggleClass("oj-selected", value);
    }
  }, 
  /**
   * Returns the list of labels for the element. Most likely this will be 
   * one label, not multiple labels.
   * We do not guarantee that the returned list is live
   * We do not guarantee that the returned list is in document order
   * We first check if we are nested in a label, and then we check a jquery 
   * selector query on <label>s with a 'for' id equal to our id.
   * NOTE: The .labels DOM property does not work on most browsers, so we don't use it.
   * e.g,
   * <pre>
   * <input id="opt3" type="checkbox" name="rb" value="opt3">
   * <label class="oj-choice-label" for="opt3">Checkbox Option 3</label>
   * </pre>
   * @private
   */
  _getLabelsForElement: function() 
  {
    // .closest("label") - For each element in the set, get the first element   
    // that matches the selector by testing the element itself and traversing up 
    // through its ancestors in the DOM tree.   
    var labelClosestParent = this.element.closest("label");
    var id = this.element.prop("id");
    var labelForQuery = "label[for='" + id + "']";
    // combine these two query results to return the label we are nested in
    //  and/or the label with the for attribute pointing to the checkbox's id.
    return labelClosestParent.add($(labelForQuery)); 
  },
  /**
   * Return the subcomponent node represented by the documented locator attribute values.
   * Test authors should target spinner sub elements using the following names:
   * <ul>
   * <li><b>oj-radiocheckbox-input</b>: the radio/checkbox's input</li>
   * <li><b>oj-radiocheckbox-label</b>: the radio/checkbox's label</li>
   * </ul>
   * 
   * @expose
   * @override
   * @memberof! oj._ojRadioCheckbox
   * @instance
   * @param {Object} locator An Object containing at minimum a subId property 
   * whose value is a string, documented by the component, that allows the component to 
   * look up the subcomponent associated with that string.  It contains:
   * <ul>
   * <li>
   * component: optional - in the future there may be more than one component 
   *   contained within a page element
   * </li>
   * <li>
   * subId: the string, documented by the component, that the component expects 
   * in getNodeBySubId to locate a particular subcomponent 
   * </li>
   * </ul>  
   * @returns {Element|null} the subcomponent located by the subId string 
   * passed in locator, if found.
   */
  getNodeBySubId: function(locator)
  {
    if (locator == null)
    {
      return this.element ? this.element[0] : null;
    }
    
    var subId = locator['subId'];
    if (subId === "oj-radiocheckbox-input") {
      return this.element[0];
    }
    if (subId === "oj-radiocheckbox-label") {
      // this.label() returns a jquery object. we want to return a dom element
      return this.label()[0];
    }
    
    // Non-null locators have to be handled by the component subclasses
    return null;
  },  
  /**
   * TODO Do I need to save off the html attributes and restore later? like disabled? name (if they change it with the option?) YES
   * @override
   * @private
   */
  _destroy : function ()
  { 
    this._super();
    // base class removes oj-disabled
	var type = this.options.type;
	if (type == "checkbox") {
      this.element.removeClass("oj-checkbox oj-selected oj-disabled oj-enabled oj-component");
	  // label isn't a widget, so remove oj-disabled
	  this.$label.removeClass("oj-enabled oj-disabled oj-checkbox-label");
	}
	else if (type == "radio") {
	  this.element.removeClass("oj-radio oj-selected oj-disabled oj-enabled oj-component");
      this.$label.removeClass("oj-enabled oj-disabled oj-radio-label");
	}
  }
  
  /**** end internal widget functions ****/ 
 
});
/**
 * The ojPagingControl component provides paging functionality.
 * 
 * <h3>Events:</h3>
 * <ul>
 * </ul>
 * 
 * @example  <caption>Initialize the paging control via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;div id="paging" data-bind="ojComponent: {component: 'ojPagingControl', data: pagingDatasource, pageSize: 10}"&gt;
 *     
 * 
 * @class
 * @constructor
 * @name oj.ojPagingControl
 * @augments oj.baseComponent
 */
(function() {
  oj.__registerWidget("oj.ojPagingControl", $['oj']['baseComponent'],
    {
      version: '1.0.0',
      defaultElement: '<div>',
      widgetEventPrefix: 'oj',
      options:
        {
          /** 
           * The data to bind to the component.
           * <p>
           * Must be of type oj.PagingDataSource {@link oj.PagingDataSource} 
           * @expose 
           * @public 
           * @instance
           * @memberof! oj.ojPagingControl
           * @default <code class="prettyprint">null</code>
           */
          data: null,
          /** 
           * Page size.
           * <p>
           * @expose 
           * @public 
           * @instance
           * @memberof! oj.ojPagingControl
           * @default <code class="prettyprint">25</code>
           */
          pageSize: 25,
          /** 
           * Options for page mode. 
           * <p>
           * Supported options are:
           * <ul>
           *   <li>layout: Array of paging navigation controls to be displayed.
           *   <ul>Valid array values are:
           *     <li>auto: Automatically display as many controls as can fit in the parent width</li>
           *     <li>input: Display the page input control</li>
           *     <li>rangeText: Display the page range text control</li>
           *     <li>pages: Display the page links</li>
           *     <li>nav: Display the navigation arrows</li>
           *   </ul>
           *   </li>
           *   <li>maxPageLinks: The maximum number of page links to display. 
           *   An ellipsis '...' will be displayed for pages which exceed the maximum.
           *   maxPageLinks must be greater than 4.</li>
           * </ul>
           * @expose 
           * @public 
           * @instance
           * @memberof! oj.ojPagingControl
           * @default <code class="prettyprint">{layout: ['auto'], maxPageLinks: 6}</code>
           * @example <caption>Initialize the paging control with the <code class="prettyprint">pageOptions</code> option specified:</caption>
           * &lt;div id="paging" data-bind="ojComponent: {component: 'ojPagingControl', data: pagingDatasource, pageSize: 10, pageOptions: {layout: ['auto', 'input', 'rangeText'], maxPageLinks: 8}}"&gt;
           */
          pageOptions: {'layout': ['auto'], 'maxPageLinks': 6},
          /** 
           * Options for loadMore mode. 
           * <p>
           * Supported options are:
           * <ul>
           *   <li>maxCount: Integer</li>
           * </ul> 
           * @expose 
           * @public 
           * @instance
           * @memberof! oj.ojPagingControl
           * @default <code class="prettyprint">{maxCount: 500}</code>
           */
          loadMoreOptions: {'maxCount': 500},
          /** 
           * Paging mode. 
           * <p>
           * Valid values are:
           * <ul>
           *   <li>page: Display paging control in pagination mode</li>
           *   <li>loadMore: Display paging control in high watermark mode</li>
           * </ul>
           * @expose 
           * @public 
           * @instance
           * @memberof! oj.ojPagingControl
           * @default <code class="prettyprint">page</code>
           */
          mode: 'page'
        },
      /**
       * @private
       * @const
       */
      _BUNDLE_KEY:
        {
          _LABEL_ACC_PAGING:                              'labelAccPaging',
          _LABEL_ACC_NAV_FIRST_PAGE:                      'labelAccNavFirstPage',
          _LABEL_ACC_NAV_LAST_PAGE:                       'labelAccNavLastPage',
          _LABEL_ACC_NAV_NEXT_PAGE:                       'labelAccNavNextPage',
          _LABEL_ACC_NAV_PREVIOUS_PAGE:                   'labelAccNavPreviousPage',
          _LABEL_ACC_NAV_PAGE:                            'labelAccNavPage',
          _LABEL_LOAD_MORE:                               'labelLoadMore',
          _LABEL_NAV_INPUT_PAGE:                          'labelNavInputPage',
          _LABEL_NAV_INPUT_PAGE_MAX:                      'labelNavInputPageMax',
          _LABEL_NAV_INPUT_PAGE_SUMMARY:                  'labelNavInputPageSummary',
          _MSG_ITEM_RANGE:                                'msgItemRange',
          _MSG_ITEM_RANGE_UNKNOWN:                        'msgItemRangeUnknown',
          _TIP_NAV_INPUT_PAGE:                            'tipNavInputPage',
          _TIP_NAV_PAGE_LINK:                             'tipNavPageLink',
          _TIP_NAV_NEXT_PAGE:                             'tipNavNextPage',
          _TIP_NAV_PREVIOUS_PAGE:                         'tipNavPreviousPage',
          _TIP_NAV_FIRST_PAGE:                            'tipNavFirstPage',
          _TIP_NAV_LAST_PAGE:                             'tipNavLastPage',
          _ERR_PAGE_INVALID_SUMMARY:                      'pageInvalid.summary',
          _ERR_PAGE_INVALID_DETAIL:                       'pageInvalid.detail',
          _ERR_DATA_INVALID_TYPE_SUMMARY:                 'dataInvalidType.summary',
          _ERR_DATA_INVALID_TYPE_DETAIL:                  'dataInvalidType.detail',
          _ERR_MAXPAGELINKS_INVALID_SUMMARY:              'maxPageLinksInvalid.summary',
          _ERR_MAXPAGELINKS_INVALID_DETAIL:               'maxPageLinksInvalid.detail'
        },
      /**
       * @private
       * @const
       */
      _MARKER_STYLE_CLASSES:
        {
          _WIDGET:                                        'oj-component',
          _ACTIVE:                                        'oj-active',
          _CLICKABLE_ICON:                                'oj-clickable-icon',
          _DISABLED:                                      'oj-disabled',
          _ENABLED:                                       'oj-enabled',
          _FOCUS:                                         'oj-focus',
          _HOVER:                                         'oj-hover',
          _SELECTED:                                      'oj-selected'
        },
      /**
       * @private
       * @const
       */
      _CSS_CLASSES:
        {
          _PAGING_CONTROL_CLASS:                          'oj-pagingcontrol',
          _PAGING_CONTROL_ACC_LABEL_CLASS:                'oj-pagingcontrol-acc-label',
          _PAGING_CONTROL_CONTENT_CLASS:                  'oj-pagingcontrol-content',
          _PAGING_CONTROL_LOAD_MORE_CLASS:                'oj-pagingcontrol-loadmore',
          _PAGING_CONTROL_LOAD_MORE_LINK_CLASS:           'oj-pagingcontrol-loadmore-link',
          _PAGING_CONTROL_LOAD_MORE_RANGE_CLASS:          'oj-pagingcontrol-loadmore-range',
          _PAGING_CONTROL_NAV_CLASS:                      'oj-pagingcontrol-nav',
          _PAGING_CONTROL_NAV_ARROW_SECTION_CLASS:        'oj-pagingcontrol-nav-arrow-section',
          _PAGING_CONTROL_NAV_PAGE_CLASS:                 'oj-pagingcontrol-nav-page',
          _PAGING_CONTROL_NAV_PAGE_ACC_LABEL_CLASS:       'oj-pagingcontrol-nav-page-acc-label',
          _PAGING_CONTROL_NAV_LABEL_CLASS:                'oj-pagingcontrol-nav-label',
          _PAGING_CONTROL_NAV_INPUT_SECTION_CLASS:        'oj-pagingcontrol-nav-input-section',
          _PAGING_CONTROL_NAV_INPUT_CLASS:                'oj-pagingcontrol-nav-input',
          _PAGING_CONTROL_NAV_INPUT_MAX_CLASS:            'oj-pagingcontrol-nav-input-max',
          _PAGING_CONTROL_NAV_INPUT_SUMMARY_CLASS:        'oj-pagingcontrol-nav-input-summary',
          _PAGING_CONTROL_NAV_PAGES_SECTION_CLASS:        'oj-pagingcontrol-nav-pages-section',
          _PAGING_CONTROL_NAV_PAGES_LINKS_CLASS:          'oj-pagingcontrol-nav-pages-links',
          _PAGING_CONTROL_NAV_FIRST_CLASS:                'oj-pagingcontrol-nav-first',
          _PAGING_CONTROL_NAV_FIRST_ACC_LABEL_CLASS:      'oj-pagingcontrol-nav-first-acc-label',
          _PAGING_CONTROL_NAV_PREVIOUS_CLASS:             'oj-pagingcontrol-nav-previous',
          _PAGING_CONTROL_NAV_PREVIOUS_ACC_LABEL_CLASS:   'oj-pagingcontrol-nav-previous-acc-label',
          _PAGING_CONTROL_NAV_NEXT_CLASS:                 'oj-pagingcontrol-nav-next',
          _PAGING_CONTROL_NAV_NEXT_ACC_LABEL_CLASS:       'oj-pagingcontrol-nav-next-acc-label',
          _PAGING_CONTROL_NAV_LAST_CLASS:                 'oj-pagingcontrol-nav-last',
          _PAGING_CONTROL_NAV_LAST_ACC_LABEL_CLASS:       'oj-pagingcontrol-nav-last-acc-label',
          _PAGING_CONTROL_NAV_FIRST_ICON_CLASS:           'oj-pagingcontrol-nav-first-icon',
          _PAGING_CONTROL_NAV_PREVIOUS_ICON_CLASS:        'oj-pagingcontrol-nav-previous-icon',
          _PAGING_CONTROL_NAV_NEXT_ICON_CLASS:            'oj-pagingcontrol-nav-next-icon',
          _PAGING_CONTROL_NAV_LAST_ICON_CLASS:            'oj-pagingcontrol-nav-last-icon',
          _WIDGET_ICON_CLASS:                             'oj-component-icon',
          _HIDDEN_CONTENT_ACC_CLASS:                      'oj-helper-hidden-accessible'
        },
      /**
       * @private
       * @const
       * @type {string}
       */
      _DATA_ATTR_PAGE_NUM: 'data-oj-pagenum',
      /**
       * @private
       * @const
       * @type {string}
       */
      _OPTION_ENABLED: 'enabled',
      /**
       * @private
       * @const
       * @type {string}
       */
      _OPTION_DISABLED: 'disabled',
      /**
       * @private
       * @const
       */
      _MODE:
        {
          _LOAD_MORE:   'loadMore',
          _PAGE:        'page'
        },
      _PAGE_OPTION_LAYOUT:
        {
          _AUTO:  'auto',
          _INPUT: 'input',
          _RANGE_TEXT: 'rangeText',
          _PAGES: 'pages',
          _NAV:   'nav'
        },
      /**** start Public APIs ****/

      /**
       * Load the first page of data
       * @expose
       * @memberof! oj.ojPagingControl
       * @instance
       * @return {boolean} Whether loading the page was sucessful
       * @throws {Error}
       * @export
       * @example <caption>Invoke the <code class="prettyprint">firstPage</code> method:</caption>
       * $( ".selector" ).ojPagingControl( "firstPage" );
       */
      'firstPage': function()
      {
        var data = this._getData();
        if (data != null)
        {
          try
          {
            this._startIndex = 0;
            data.fetch({startIndex: 0});
          }
          catch (err)
          {
            return false;
          }
          return true;
        }
        return false;
      },
      /**
       * Load the previous page of data
       * @expose
       * @memberof! oj.ojPagingControl
       * @instance
       * @return {boolean} Whether loading the page was sucessful
       * @throws {Error}
       * @export
       * @example <caption>Invoke the <code class="prettyprint">previousPage</code> method:</caption>
       * $( ".selector" ).ojPagingControl( "previousPage" );
       */
      'previousPage': function()
      {
        var data = this._getData();
        if (data != null)
        {
          var page = this._getCurrentPage();
          try
          {
            this._startIndex = this._getStartIndexForPage(page - 1);
            data.fetch({startIndex: this._startIndex});
          }
          catch (err)
          {
            return false;
          }
          return true;
        }
        return false;
      },
      /**
       * Load the next page of data
       * @expose
       * @memberof! oj.ojPagingControl
       * @instance
       * @return {boolean} Whether loading the page was sucessful
       * @throws {Error}
       * @export
       * @example <caption>Invoke the <code class="prettyprint">nextPage</code> method:</caption>
       * $( ".selector" ).ojPagingControl( "nextPage" );
       */
      'nextPage': function()
      {
        var data = this._getData();
        if (data != null)
        {
          var page = this._getCurrentPage();
          try
          {
            this._startIndex = this._getStartIndexForPage(page + 1);
            data.fetch({startIndex: this._startIndex});
          }
          catch (err)
          {
            return false;
          }
          return true;
        }
        return false;
      },
      /**
       * Load the last page of data
       * @expose
       * @memberof! oj.ojPagingControl
       * @instance
       * @return {boolean} Whether loading the page was sucessful
       * @throws {Error}
       * @export
       * @example <caption>Invoke the <code class="prettyprint">lastPage</code> method:</caption>
       * $( ".selector" ).ojPagingControl( "lastPage" );
       */
      'lastPage': function()
      {
        var data = this._getData();
        if (data != null)
        {
          try
          {
            this._startIndex = this._getStartIndexForPage(this._getTotalPages());
            data.fetch({startIndex: this._startIndex});
          }
          catch (err)
          {
            return false;
          }
          return true;
        }
        return false;
      },
      /**
       * Load the specified page of data
       * @expose
       * @memberof! oj.ojPagingControl
       * @instance
       * @param {number} page  Page number. 
       * @return {boolean} Whether loading the page was sucessful
       * @throws {Error}
       * @export
       * @example <caption>Invoke the <code class="prettyprint">page</code> method:</caption>
       * $( ".selector" ).ojPagingControl( "page", 5 );
       */
      'page': function(page)
      {
        try
        {
          this._startIndex = this._getStartIndexForPage(page);
          this._getData().fetch({startIndex: this._startIndex});
        }
        catch (err)
        {
          return false;
        }
        return true;
      },
      /**
       * Load the next set of data
       * @expose
       * @memberof! oj.ojPagingControl
       * @instance
       * @return {boolean} Whether loading the next set was sucessful
       * @throws {Error}
       * @export
       * @example <caption>Invoke the <code class="prettyprint">loadNext</code> method:</caption>
       * $( ".selector" ).ojPagingControl( "loadNext" );
       */
      'loadNext': function()
      {
        var data = this._getData();
        if (data != null)
        {
          try
          {
            this._getData().next();
          }
          catch (err)
          {
            return false;
          }
          return true;
        }
        return false;
      },
      /**
       * Refresh the paging control.
       * @expose
       * @memberof! oj.ojPagingControl
       * @instance
       * @export
       * @example <caption>Invoke the <code class="prettyprint">refresh</code> method:</caption>
       * $( ".selector" ).ojPagingControl( "refresh" );
       */
      'refresh': function()
      {
        this._super();
        this._refresh();
      },
      /**** end Public APIs ****/

      /**** start internal widget functions ****/

      /**
       * @override
       * @private
       */
      _init: function()
      {
        this._super();
        this._startIndex = 0;
        this._registerDataSourceEventListeners();
        this._refresh();
      },
      /**
       * @override
       * @private
       */
      _create: function()
      {
        this._super();
        this._registerDataSourceEventListeners();
        this._draw();
        this._registerResizeListener(this._getPagingControlContainer());
        this._on(this._events);
      },
      /**
       * @override
       * @private
       */
      _destroy: function()
      {

      },
      /**
       * @override
       * @private
       */
      _draw: function()
      {
        var options = this.options;
        // add main css class to element
        this.element.addClass(this._CSS_CLASSES._PAGING_CONTROL_CLASS);
        this.element.addClass(this._MARKER_STYLE_CLASSES._WIDGET);
        this._startIndex = 0;

        this._createPagingControlAccLabel();
        this._createPagingControlContent();
        if (options['mode'] == this._MODE._LOAD_MORE)
        {
          this._createPagingControlLoadMore();
          this._createPagingControlLoadMoreLink();
          this._createPagingControlLoadMoreRange();
        }
        else
        {
          this._createPagingControlNav();
        }
        // do an initial fetch if not done already
        if (this._getData() != null && 
            this._getData().size() == 0)
        {
          this._getData().setPageSize(options['pageSize']);
          this._getData().fetch({startIndex: this._startIndex});
        }
      },
      /**
       * @override
       * @private
       */
      _events:
        {
          /**
           * invoke loading next page of data
           */
          'click .oj-pagingcontrol-loadmore-link': function(event)
          {
            this['loadNext']();
            event.preventDefault();
          },
          /**
           * invoke loading page of data
           */
          'click .oj-pagingcontrol-nav-page': function(event)
          {
            var pageNum = $(event.target).attr('data-oj-pagenum');
            this['page'](pageNum);  
            event.preventDefault();
          },
          /**
           * invoke loading first page of data
           */
          'click .oj-pagingcontrol-nav-first': function(event)
          {
            this['firstPage']();
            event.preventDefault();
          },
          /**
           * invoke loading previous page of data
           */
          'click .oj-pagingcontrol-nav-previous': function(event)
          {
            this['previousPage']();
            event.preventDefault();
          },
          /**
           * invoke loading next page of data
           */
          'click .oj-pagingcontrol-nav-next': function(event)
          {
            this['nextPage']();
            event.preventDefault();
          },
          /**
           * invoke loading next page of data
           */
          'click .oj-pagingcontrol-nav-last': function(event)
          {
            this['lastPage']();
            event.preventDefault();
          },
          /**
           * invoke loading next page of data
           */
          'change .oj-pagingcontrol-nav-input': function(event)
          {
            try
            {
              var pageNum = parseInt($(event.target).val(), 10);
              this['page'](pageNum);  
            }
            catch (err)
            {
              var errSummary = this.getTranslatedString(this._BUNDLE_KEY._ERR_PAGE_INVALID_SUMMARY);
              var errDetail = this.getTranslatedString(this._BUNDLE_KEY._ERR_PAGE_INVALID_DETAIL);
              throw new oj.Message(errSummary, errDetail, oj.Message.SEVERITY_LEVEL['ERROR']);
            }
          }
        },
      /**
       * @override
       * @private
       */
      _refresh: function()
      {
        if (this.options['mode'] == this._MODE._LOAD_MORE)
        {
          // hide loadMore if there are no more rows to fetch
          var data = this._getData();
          var pagingControlLoadMore = this._getPagingControlLoadMore();
          if (data != null && data.size() == data.totalSize())
          {
            pagingControlLoadMore.css('display', 'none');
          }
          else
          {
            pagingControlLoadMore.css('display', '');
            this._refreshPagingControlLoadMoreRange();
          }
        }
        else
        {
          this._refreshPagingControlNav();
        }
      },
      /**
       * @override
       * @private
       */
      _setOption: function(key, value)
      {
        this._super(key, value);
        this._refresh();
      },
      /**** end internal widget functions ****/

      /**** start internal functions ****/

      /**
       * Clear cached range text DOM
       * @private
       */
      _clearCachedDomLoadMoreRange: function()
      {
        this._cachedDomPagingControlLoadMoreRange = null;
      },
      /**
       * Clear any cached DOM nav elements
       * @private
       */
      _clearCachedDomPagingControlNav: function()
      {
        this._cachedDomPagingControlNav = null;
        this._cachedDomPagingControlNavInput = null;
        this._cachedDomPagingControlNavInputSummary = null;
      },
      /**
       * Return the current page
       * @return {number} Current page.
       * @throws {Error}
       * @private
       */
      _getCurrentPage: function()
      {
        if (this._startIndex == 0)
        {
          return 1;
        }
        return Math.ceil((this._startIndex + 1) / this.options['pageSize']);
      },
      /**
       * Return the datasource object defined for this paging control
       * @return {Object} Datasource object.
       * @throws {Error}
       * @private
       */
      _getData: function()
      {
        if (!this._data && this.options['data'] != null)
        {
          var data = this.options['data'];
          if ((data instanceof oj.PagingDataSource) || 
              (data instanceof oj.PagingTableDataSource))
          {
            this._data = data;
          }
          else
          {
            var errSummary = this.getTranslatedString(this._BUNDLE_KEY._ERR_DATA_INVALID_TYPE_SUMMARY);
            var errDetail = this.getTranslatedString(this._BUNDLE_KEY._ERR_DATA_INVALID_TYPE_DETAIL);
            throw new oj.Message(errSummary, errDetail, oj.Message.SEVERITY_LEVEL['ERROR']);
          }
          this._data.setPageSize(this.options['pageSize']);
          this._dataMetadata = this.options['data'];
        }
        return this._data;
      },
      /**
       * Return the item range text
       * @return {String} Item range text.
       * @throws {Error}
       * @private
       */
      _getItemRangeText: function()
      {
        var data = this._getData();
        var itemRangeText = this.getTranslatedString(this._BUNDLE_KEY._MSG_ITEM_RANGE, {'pageFrom': this._startIndex, 'pageTo': 0, 'pageTotal': 0});
        if (data != null)
        {
          if (data.totalSize() != -1)
          {
            itemRangeText = this.getTranslatedString(this._BUNDLE_KEY._MSG_ITEM_RANGE, {'pageFrom': this._startIndex + 1, 'pageTo': this._startIndex + data.size(), 'pageTotal': data.totalSize()});
          }
          else
          {
            itemRangeText = this.getTranslatedString(this._BUNDLE_KEY._MSG_ITEM_RANGE_UNKNOWN, {'pageFrom': this._startIndex + 1, 'pageTo': this._startIndex + data.size()});
          }
        }
        return itemRangeText;
      },
      /**
       * Return maximum number of page links
       * @return {number} Max page links.
       * @private
       */
      _getMaxPageLinks: function()
      {
        var maxPageLinks = this.options['pageOptions']['maxPageLinks'];
        return maxPageLinks;
      },
      /**
       * Return the start index for the page
       * @param {number} page page number.
       * @return {number} start index.
       * @throws {Error}
       * @private
       */
      _getStartIndexForPage: function(page)
      {
        var startIndex = (page - 1) * this.options['pageSize'];
        var totalPages = this._getTotalPages();

        if (startIndex < 0)
        {
          throw 'Value must be greater than 0';
        }
        else if (totalPages > 0 && page > totalPages)
        {
          throw 'Value cannot be greater than the total number of pages';
        }
        return startIndex;
      },
      /**
       * Return the total number of pages
       * @return {number} Total pages.
       * @throws {Error}
       * @private
       */
      _getTotalPages: function()
      {
        var data = this._getData();
        var totalSize = 0;
        if (data != null)
        {
          totalSize = data.totalSize();
        }
        return totalSize == -1 ? -1 : Math.ceil(totalSize / this.options['pageSize']);
      },
      /**
       * Callback handler for fetch completed in the datasource.
       * status message.
       * @param {Object} event 
       * @private
       */
      _handleDataFetchEnd: function(event)
      {
        this._refresh();
      },
      /**
       * @override
       * @private
       */
      _refreshPagingControlLoadMoreRange: function()
      {
        var pagingControlLoadMoreRange = this._getPagingControlLoadMoreRange();
        pagingControlLoadMoreRange[0].parentNode.removeChild(pagingControlLoadMoreRange[0]);
        this._createPagingControlLoadMoreRange();
        this._clearCachedDomLoadMoreRange();
      },
      /**
       * @override
       * @private
       */
      _refreshPagingControlNav: function()
      {
        var pageOptionLayout = this.options['pageOptions']['layout'];
        var pagingControlContent = this._getPagingControlContent();
        pagingControlContent.empty();
        this._clearCachedDomPagingControlNav();
        this._createPagingControlNav();
        this._refreshPagingControlNavArrows();
        
        if ($.inArray(this._PAGE_OPTION_LAYOUT._AUTO, pageOptionLayout) > -1)
        {
          // dynamically hide controls based on available width
          var elementWidth = this.element.width();
          var pagingControlNavArrowSection = this._getPagingControlNavArrowSection();
          var pagingControlNavInputSection = this._getPagingControlNavInputSection();
          var pagingControlNavPageLinks = this._getPagingControlNavPageLinks();
          var pagingControlNavInputSummary = this._getPagingControlNavInputSummary();
          var pagingControlNavWidth = pagingControlNavArrowSection[0].offsetWidth + pagingControlNavInputSection[0].offsetWidth;
          
          if (pagingControlNavWidth > elementWidth)
          {
            if (pagingControlNavWidth 
                - pagingControlNavPageLinks.width() <= elementWidth)
            {
              // hide only the page links
              pagingControlNavPageLinks.css('display', 'none'); 
            }
            else if (pagingControlNavWidth 
                     - pagingControlNavPageLinks.width() 
                     - pagingControlNavInputSummary.width() <= elementWidth)
            {
              // hide the range text too
              pagingControlNavPageLinks.css('display', 'none');
              pagingControlNavInputSummary.css('display', 'none');
            }
            else
            {
              // hide the arrows too
              pagingControlNavPageLinks.css('display', 'none');
              pagingControlNavInputSummary.css('display', 'none');
              pagingControlNavArrowSection.css('display', 'none'); 
            }
          }
          else if (pagingControlNavWidth > 0)
          {
            pagingControlNavPageLinks.css('display', '');
            pagingControlNavInputSummary.css('display', '');
            pagingControlNavArrowSection.css('display', '');
          }
        }
      },
      /**
       * @override
       * @private
       */
      _refreshPagingControlNavArrows: function()
      {
        var pagingControlNavArrowSection = this._getPagingControlNavArrowSection();
        var pagingControlNavFirst = pagingControlNavArrowSection.children('.' + this._CSS_CLASSES._PAGING_CONTROL_NAV_FIRST_CLASS);
        if (pagingControlNavFirst && pagingControlNavFirst.length > 0)
        {
          pagingControlNavFirst = $(pagingControlNavFirst[0]);
          
          if (this._getCurrentPage() == 1)
          {
            pagingControlNavFirst.addClass(this._MARKER_STYLE_CLASSES._DISABLED);
            pagingControlNavFirst.removeClass(this._MARKER_STYLE_CLASSES._ENABLED);
            pagingControlNavFirst.attr('tabindex', '-1');
          }
          else
          {
            pagingControlNavFirst.addClass(this._MARKER_STYLE_CLASSES._ENABLED);
            pagingControlNavFirst.removeClass(this._MARKER_STYLE_CLASSES._DISABLED);
            pagingControlNavFirst.attr('tabindex', '0');
          }
        }
        var pagingControlNavPrevious = pagingControlNavArrowSection.children('.' + this._CSS_CLASSES._PAGING_CONTROL_NAV_PREVIOUS_CLASS);
        if (pagingControlNavPrevious && pagingControlNavPrevious.length > 0)
        {
          pagingControlNavPrevious = $(pagingControlNavPrevious[0]);
          
          if (this._getCurrentPage() == 1)
          {
            pagingControlNavPrevious.addClass(this._MARKER_STYLE_CLASSES._DISABLED);
            pagingControlNavPrevious.removeClass(this._MARKER_STYLE_CLASSES._ENABLED);
            pagingControlNavPrevious.attr('tabindex', '-1');
          }
          else
          {
            pagingControlNavPrevious.addClass(this._MARKER_STYLE_CLASSES._ENABLED);
            pagingControlNavPrevious.removeClass(this._MARKER_STYLE_CLASSES._DISABLED);
            pagingControlNavPrevious.attr('tabindex', '0');
          }
        }
        var pagingControlNavLast = pagingControlNavArrowSection.children('.' + this._CSS_CLASSES._PAGING_CONTROL_NAV_LAST_CLASS);
        if (pagingControlNavLast && pagingControlNavLast.length > 0)
        {
          pagingControlNavLast = $(pagingControlNavLast[0]);
          
          if (this._getCurrentPage() == this._getTotalPages())
          {
            pagingControlNavLast.addClass(this._MARKER_STYLE_CLASSES._DISABLED);
            pagingControlNavLast.removeClass(this._MARKER_STYLE_CLASSES._ENABLED);
            pagingControlNavLast.attr('tabindex', '-1');
          }
          else
          {
            pagingControlNavLast.addClass(this._MARKER_STYLE_CLASSES._ENABLED);
            pagingControlNavLast.removeClass(this._MARKER_STYLE_CLASSES._DISABLED);
            pagingControlNavLast.attr('tabindex', '0');
          }
        }
        var pagingControlNavNext = pagingControlNavArrowSection.children('.' + this._CSS_CLASSES._PAGING_CONTROL_NAV_NEXT_CLASS);
        if (pagingControlNavNext && pagingControlNavNext.length > 0)
        {
          pagingControlNavNext = $(pagingControlNavNext[0]);
          
          if (this._getCurrentPage() == this._getTotalPages())
          {
            pagingControlNavNext.addClass(this._MARKER_STYLE_CLASSES._DISABLED);
            pagingControlNavNext.removeClass(this._MARKER_STYLE_CLASSES._ENABLED);
            pagingControlNavNext.attr('tabindex', '-1');
          }
          else
          {
            pagingControlNavNext.addClass(this._MARKER_STYLE_CLASSES._ENABLED);
            pagingControlNavNext.removeClass(this._MARKER_STYLE_CLASSES._DISABLED);
            pagingControlNavNext.attr('tabindex', '0');
          }
        }
      },
      /**
       * Register event listeners which need to be registered datasource. 
       * @private
       */
      _registerDataSourceEventListeners: function()
      {
        // register the listeners on the datasource
        var data = this._getData();
        if (data != null)
        {
          this._dataSourceEventHandlers = [];
          this._dataSourceEventHandlers.push({'eventType': oj.PagingDataSource.EventType['SYNC'], 'eventHandler': this._handleDataFetchEnd.bind(this)});

          var i;
          for (i = 0; i < this._dataSourceEventHandlers.length; i++)
            data.on(this._dataSourceEventHandlers[i]['eventType'], this._dataSourceEventHandlers[i]['eventHandler']);
        }
      },
      /**
       * Register event listeners for resize the container DOM element.
       * @param {jQuery} element  DOM element
       * @private
       */
      _registerResizeListener: function(element)
      {         
        if (!this._isResizeListenerAdded)
        {
          var self = this;
          oj.DomUtils.addResizeListener(element[0], function(width, height)
                                                    {
                                                      self._refresh();
                                                    });
          this._isResizeListenerAdded = true;
        }
      },
      /**** end internal functions ****/
      /**
       * Create a span element for acc purposes
       * @param {string} text span text
       * @param {string} className css class
       * @return {jQuery} jQuery div DOM element
       * @private
       */
      _createAccLabelSpan: function(text, className)
      {
        var accLabel = $(document.createElement('span'));
        accLabel.addClass(className);
        accLabel.addClass(this._CSS_CLASSES._HIDDEN_CONTENT_ACC_CLASS);
        accLabel.append(text);

        return accLabel;
      },
      /**** start internal DOM functions ****/
      /**
       * Create the acc paging control label
       * @return {jQuery} jQuery div DOM element
       * @private
       */
      _createPagingControlAccLabel: function()
      {
        var pagingControlContainer = this._getPagingControlContainer();
        var pagingControlAccLabelText = this.getTranslatedString(this._BUNDLE_KEY._LABEL_ACC_PAGING);
        var pagingControlAccLabel = this._createAccLabelSpan(pagingControlAccLabelText, this._CSS_CLASSES._PAGING_CONTROL_ACC_LABEL_CLASS);
        var pagingControlAccLabelId = this.element.attr('id') + '_oj_pgCtrl_acc_label';
        pagingControlAccLabel.attr('id', pagingControlAccLabelId);
        pagingControlContainer.append(pagingControlAccLabel);

        return pagingControlAccLabel;
      },
      /**
       * Create the acc page link label
       * @return {jQuery} jQuery div DOM element
       * @private
       */
      _createPagingControlAccNavPageLabel: function()
      {
        var pagingControlAccNavPageLabelText = this.getTranslatedString(this._BUNDLE_KEY._LABEL_ACC_NAV_PAGE);
        var pagingControlAccNavPageLabel = this._createAccLabelSpan(pagingControlAccNavPageLabelText, this._CSS_CLASSES._PAGING_CONTROL_NAV_PAGE_ACC_LABEL_CLASS);

        return pagingControlAccNavPageLabel;
      },
      /**
       * Create the acc first page label
       * @return {jQuery} jQuery div DOM element
       * @private
       */
      _createPagingControlAccNavFirstLabel: function()
      {
        var pagingControlAccNavFirstLabelText = this.getTranslatedString(this._BUNDLE_KEY._LABEL_ACC_NAV_FIRST_PAGE);
        var pagingControlAccNavFirstLabel = this._createAccLabelSpan(pagingControlAccNavFirstLabelText, this._CSS_CLASSES._PAGING_CONTROL_NAV_FIRST_ACC_LABEL_CLASS);

        return pagingControlAccNavFirstLabel;
      },
      /**
       * Create the acc last page label
       * @return {jQuery} jQuery div DOM element
       * @private
       */
      _createPagingControlAccNavLastLabel: function()
      {
        var pagingControlAccNavLastLabelText = this.getTranslatedString(this._BUNDLE_KEY._LABEL_ACC_NAV_LAST_PAGE);
        var pagingControlAccNavLastLabel = this._createAccLabelSpan(pagingControlAccNavLastLabelText, this._CSS_CLASSES._PAGING_CONTROL_NAV_LAST_ACC_LABEL_CLASS);

        return pagingControlAccNavLastLabel;
      },
      /**
       * Create the acc next page label
       * @return {jQuery} jQuery div DOM element
       * @private
       */
      _createPagingControlAccNavNextLabel: function()
      {
        var pagingControlAccNavNextLabelText = this.getTranslatedString(this._BUNDLE_KEY._LABEL_ACC_NAV_NEXT_PAGE);
        var pagingControlAccNavNextLabel = this._createAccLabelSpan(pagingControlAccNavNextLabelText, this._CSS_CLASSES._PAGING_CONTROL_NAV_NEXT_ACC_LABEL_CLASS);

        return pagingControlAccNavNextLabel;
      },
      /**
       * Create the acc previous page label
       * @return {jQuery} jQuery div DOM element
       * @private
       */
      _createPagingControlAccNavPreviousLabel: function()
      {
        var pagingControlAccNavPreviousLabelText = this.getTranslatedString(this._BUNDLE_KEY._LABEL_ACC_NAV_PREVIOUS_PAGE);
        var pagingControlAccNavPreviousLabel = this._createAccLabelSpan(pagingControlAccNavPreviousLabelText, this._CSS_CLASSES._PAGING_CONTROL_NAV_PREVIOUS_ACC_LABEL_CLASS);

        return pagingControlAccNavPreviousLabel;
      },
      /**
       * Create an paging content div
       * @return {jQuery} jQuery div DOM element
       * @private
       */
      _createPagingControlContent: function()
      {
        var pagingControlContainer = this._getPagingControlContainer();
        var pagingControlContent = $(document.createElement('div'));
        pagingControlContent.addClass(this._CSS_CLASSES._PAGING_CONTROL_CONTENT_CLASS);
        var pagingControlAccLabelId = this._getPagingControlAccLabel().attr('id');
        pagingControlContent.attr('role', 'navigation');
        pagingControlContent.attr('aria-labelledby', pagingControlAccLabelId);
        pagingControlContainer.append(pagingControlContent);

        return pagingControlContent;
      },
      /**
       * Create an paging load more div
       * @return {jQuery} jQuery div DOM element
       * @private
       */
      _createPagingControlLoadMore: function()
      {
        var pagingControlContent = this._getPagingControlContent();
        var pagingControlLoadMore = $(document.createElement('div'));
        pagingControlLoadMore.addClass(this._CSS_CLASSES._PAGING_CONTROL_LOAD_MORE_CLASS);
        pagingControlContent.append(pagingControlLoadMore);

        return pagingControlLoadMore;
      },
      /**
       * Create an paging load more link
       * @return {jQuery} jQuery a DOM element
       * @private
       */
      _createPagingControlLoadMoreLink: function()
      {
        var pagingControlLoadMore = this._getPagingControlLoadMore();
        var pagingControlLoadMoreLink = $(document.createElement('a'));
        pagingControlLoadMoreLink.addClass(this._CSS_CLASSES._PAGING_CONTROL_LOAD_MORE_LINK_CLASS);
        var loadMoreText = this.getTranslatedString(this._BUNDLE_KEY._LABEL_LOAD_MORE);
        pagingControlLoadMoreLink.append(loadMoreText);
        pagingControlLoadMoreLink.attr('tabindex', '0');
        pagingControlLoadMoreLink.attr('href', '#');
        pagingControlLoadMore.append(pagingControlLoadMoreLink);

        return pagingControlLoadMoreLink;
      },
      /**
       * Create an paging load more link
       * @return {jQuery} jQuery a DOM element
       * @private
       */
      _createPagingControlLoadMoreRange: function()
      {
        var data = this._getData();
        var pagingControlLoadMore = this._getPagingControlLoadMore();
        var pagingControlLoadMoreRange = $(document.createElement('span'));
        pagingControlLoadMoreRange.addClass(this._CSS_CLASSES._PAGING_CONTROL_LOAD_MORE_RANGE_CLASS);
        var loadMoreRangeText = this._getItemRangeText();
        pagingControlLoadMoreRange.append(loadMoreRangeText);
        pagingControlLoadMore.append(pagingControlLoadMoreRange);

        return pagingControlLoadMoreRange;
      },
      /**
       * Create the paging nav bar div
       * @return {jQuery} jQuery div DOM element
       * @private
       */
      _createPagingControlNav: function()
      {
        var options = this.options;
        var pageOptionLayout = options['pageOptions']['layout'];
        if (pageOptionLayout == null)
        {
          pageOptionLayout = [this._PAGE_OPTION_LAYOUT._AUTO];
        }
        var pagingControlContent = this._getPagingControlContent();
        var pagingControlNav = $(document.createElement('div'));
        pagingControlNav.addClass(this._CSS_CLASSES._PAGING_CONTROL_NAV_CLASS);
        pagingControlContent.append(pagingControlNav);

        // page input section
        if ($.inArray(this._PAGE_OPTION_LAYOUT._AUTO, pageOptionLayout) != -1 ||
            $.inArray(this._PAGE_OPTION_LAYOUT._INPUT, pageOptionLayout) != -1)
        {
          var pagingControlNavInputSection = $(document.createElement('div'));
          pagingControlNavInputSection.addClass(this._CSS_CLASSES._PAGING_CONTROL_NAV_INPUT_SECTION_CLASS);
          pagingControlNav.append(pagingControlNavInputSection);
          var pagingControlNavLabel = $(document.createElement('label'));
          pagingControlNavLabel.addClass(this._CSS_CLASSES._PAGING_CONTROL_NAV_LABEL_CLASS);
          var navInputPageLabel = this.getTranslatedString(this._BUNDLE_KEY._LABEL_NAV_INPUT_PAGE);
          pagingControlNavLabel.append(navInputPageLabel);
          pagingControlNavInputSection.append(pagingControlNavLabel);

          var pagingControlNavInput = $(document.createElement('input'));
          pagingControlNavInput.addClass(this._CSS_CLASSES._PAGING_CONTROL_NAV_INPUT_CLASS);
          var navInputPageTip = this.getTranslatedString(this._BUNDLE_KEY._TIP_NAV_INPUT_PAGE);
          this._focusable(this.element);
          pagingControlNavInput.attr('title', navInputPageTip);
          pagingControlNavInput.attr('tabindex', '0');
          pagingControlNavInput.val(this._getCurrentPage());
          pagingControlNavLabel.append(pagingControlNavInput);
          
          if (this._getTotalPages() > 0)
          {
            var pagingControlNavMaxLabel = $(document.createElement('span'));
            pagingControlNavMaxLabel.addClass(this._CSS_CLASSES._PAGING_CONTROL_NAV_INPUT_MAX_CLASS);
            var navInputPageMaxLabel = this.getTranslatedString(this._BUNDLE_KEY._LABEL_NAV_INPUT_PAGE_MAX, {'pageMax': this._getTotalPages()});
            pagingControlNavMaxLabel.append(navInputPageMaxLabel);
            pagingControlNavInputSection.append(pagingControlNavMaxLabel);
          }
          
          if ($.inArray(this._PAGE_OPTION_LAYOUT._AUTO, pageOptionLayout) != -1 ||
              $.inArray(this._PAGE_OPTION_LAYOUT._RANGE_TEXT, pageOptionLayout) != -1)
          {
            var pagingControlNavSummaryLabel = $(document.createElement('span'));
            pagingControlNavSummaryLabel.addClass(this._CSS_CLASSES._PAGING_CONTROL_NAV_INPUT_SUMMARY_CLASS);
            var itemRangeText = this._getItemRangeText();
            var navInputPageSummaryLabel = this.getTranslatedString(this._BUNDLE_KEY._LABEL_NAV_INPUT_PAGE_SUMMARY, {'pageSummary': itemRangeText});
            pagingControlNavSummaryLabel.append(navInputPageSummaryLabel);
            pagingControlNavInputSection.append(pagingControlNavSummaryLabel);
          }
        }

        // nav arrow section
        var pagingControlNavArrowSection = $(document.createElement('div'));
        pagingControlNavArrowSection.addClass(this._CSS_CLASSES._PAGING_CONTROL_NAV_ARROW_SECTION_CLASS);
        pagingControlNav.append(pagingControlNavArrowSection);
        
        if ($.inArray(this._PAGE_OPTION_LAYOUT._AUTO, pageOptionLayout) != -1 ||
            $.inArray(this._PAGE_OPTION_LAYOUT._NAV, pageOptionLayout) != -1)
        {
          var pagingControlNavFirst = $(document.createElement('a'));
          pagingControlNavFirst.addClass(this._CSS_CLASSES._PAGING_CONTROL_NAV_FIRST_CLASS);
          pagingControlNavFirst.addClass(this._CSS_CLASSES._PAGING_CONTROL_NAV_FIRST_ICON_CLASS);
          pagingControlNavFirst.addClass(this._CSS_CLASSES._WIDGET_ICON_CLASS);
          pagingControlNavFirst.addClass(this._MARKER_STYLE_CLASSES._CLICKABLE_ICON);
          pagingControlNavFirst.addClass(this._MARKER_STYLE_CLASSES._DISABLED);
          var navFirstPageTip = this.getTranslatedString(this._BUNDLE_KEY._TIP_NAV_FIRST_PAGE);
          this._hoverable(pagingControlNavFirst);
          this._focusable(pagingControlNavFirst);
          pagingControlNavFirst.attr('title', navFirstPageTip);
          pagingControlNavFirst.attr('tabindex', '0');
          pagingControlNavFirst.attr('href', '#');
          var pagingControlNavFirstAccLabel = this._createPagingControlAccNavFirstLabel();
          pagingControlNavFirst.append(pagingControlNavFirstAccLabel);
          pagingControlNavArrowSection.append(pagingControlNavFirst);

          var pagingControlNavPrevious = $(document.createElement('a'));
          pagingControlNavPrevious.addClass(this._CSS_CLASSES._PAGING_CONTROL_NAV_PREVIOUS_CLASS);
          pagingControlNavPrevious.addClass(this._CSS_CLASSES._PAGING_CONTROL_NAV_PREVIOUS_ICON_CLASS);
          pagingControlNavPrevious.addClass(this._CSS_CLASSES._WIDGET_ICON_CLASS);
          pagingControlNavPrevious.addClass(this._MARKER_STYLE_CLASSES._CLICKABLE_ICON);
          pagingControlNavPrevious.addClass(this._MARKER_STYLE_CLASSES._DISABLED);
          var navPreviousPageTip= this.getTranslatedString(this._BUNDLE_KEY._TIP_NAV_PREVIOUS_PAGE);
          this._hoverable(pagingControlNavPrevious);
          this._focusable(pagingControlNavPrevious);
          pagingControlNavPrevious.attr('title', navPreviousPageTip);
          pagingControlNavPrevious.attr('tabindex', '0');
          pagingControlNavPrevious.attr('href', '#');
          var pagingControlNavPreviousAccLabel = this._createPagingControlAccNavPreviousLabel();
          pagingControlNavPrevious.append(pagingControlNavPreviousAccLabel);
          pagingControlNavArrowSection.append(pagingControlNavPrevious);
        }

        // nav pages section
        if ($.inArray(this._PAGE_OPTION_LAYOUT._AUTO, pageOptionLayout) != -1 ||
            $.inArray(this._PAGE_OPTION_LAYOUT._PAGES, pageOptionLayout) != -1)
        {
          var pagingControlNavPagesSection = $(document.createElement('div'));
          pagingControlNavPagesSection.addClass(this._CSS_CLASSES._PAGING_CONTROL_NAV_PAGES_SECTION_CLASS);
          pagingControlNavArrowSection.append(pagingControlNavPagesSection);
          this._createPagingControlNavPages(pagingControlNavPagesSection, this._getMaxPageLinks());
        }

        if ($.inArray(this._PAGE_OPTION_LAYOUT._AUTO, pageOptionLayout) != -1 ||
            $.inArray(this._PAGE_OPTION_LAYOUT._NAV, pageOptionLayout) != -1)
        {
          var pagingControlNavNext = $(document.createElement('a'));
          pagingControlNavNext.addClass(this._CSS_CLASSES._PAGING_CONTROL_NAV_NEXT_CLASS);
          pagingControlNavNext.addClass(this._CSS_CLASSES._PAGING_CONTROL_NAV_NEXT_ICON_CLASS);
          pagingControlNavNext.addClass(this._CSS_CLASSES._WIDGET_ICON_CLASS);
          pagingControlNavNext.addClass(this._MARKER_STYLE_CLASSES._CLICKABLE_ICON);
          pagingControlNavNext.addClass(this._MARKER_STYLE_CLASSES._DISABLED);
          var navNextPageTip = this.getTranslatedString(this._BUNDLE_KEY._TIP_NAV_NEXT_PAGE);
          this._hoverable(pagingControlNavNext);
          this._focusable(pagingControlNavNext);
          pagingControlNavNext.attr('title', navNextPageTip);
          pagingControlNavNext.attr('tabindex', '0');
          pagingControlNavNext.attr('href', '#');
          var pagingControlNavNextAccLabel = this._createPagingControlAccNavNextLabel();
          pagingControlNavNext.append(pagingControlNavNextAccLabel);
          pagingControlNavArrowSection.append(pagingControlNavNext);

          var pagingControlNavLast = $(document.createElement('a'));
          pagingControlNavLast.addClass(this._CSS_CLASSES._PAGING_CONTROL_NAV_LAST_CLASS);
          pagingControlNavLast.addClass(this._CSS_CLASSES._PAGING_CONTROL_NAV_LAST_ICON_CLASS);
          pagingControlNavLast.addClass(this._CSS_CLASSES._WIDGET_ICON_CLASS);
          pagingControlNavLast.addClass(this._MARKER_STYLE_CLASSES._CLICKABLE_ICON);
          pagingControlNavLast.addClass(this._MARKER_STYLE_CLASSES._DISABLED);
          var navLastPageTip = this.getTranslatedString(this._BUNDLE_KEY._TIP_NAV_LAST_PAGE);
          this._hoverable(pagingControlNavLast);
          this._focusable(pagingControlNavLast);
          pagingControlNavLast.attr('title', navLastPageTip);
          pagingControlNavLast.attr('tabindex', '0');
          pagingControlNavLast.attr('href', '#');
          var pagingControlNavLastAccLabel = this._createPagingControlAccNavLastLabel();
          pagingControlNavLast.append(pagingControlNavLastAccLabel);
          pagingControlNavArrowSection.append(pagingControlNavLast);
        }

        return pagingControlNav;
      },
      /**
       * Create the page links
       * @param {jQuery} parentDiv parent element
       * @param {number} numLinks number of page links
       * @return {jQuery} jQuery div DOM element
       * @private
       */
      _createPagingControlNavPages: function(parentDiv, numLinks)
      {
        if (numLinks < 5)
        {
          var errSummary = this.getTranslatedString(this._BUNDLE_KEY._ERR_MAXPAGELINKS_INVALID_SUMMARY);
          var errDetail = this.getTranslatedString(this._BUNDLE_KEY._ERR_MAXPAGELINKS_INVALID_DETAIL);
          throw new oj.Message(errSummary, errDetail, oj.Message.SEVERITY_LEVEL['ERROR']);
        }
        var pagingControlNavPagesLinks = $(document.createElement('div'));
        pagingControlNavPagesLinks.addClass(this._CSS_CLASSES._PAGING_CONTROL_NAV_PAGES_LINKS_CLASS);
        parentDiv.append(pagingControlNavPagesLinks);
        var totalPages = this._getTotalPages();
        var currentPage = this._getCurrentPage();
        
        var numPagesToAdd = numLinks;
        // this will hold our page list
        var pageList = [];

        if (currentPage >= 1)
        {
          var i;
          if (totalPages != -1 && totalPages <= numPagesToAdd)
          {
            // always add the first page
            pageList[0] = 1;
            
            // just enumerate the pages
            for (i = 1; i < totalPages; i++)
            {
              pageList[i] = i + 1;
            }
          }
          else
          {
            // add the first, current, and last page
            pageList.push(1);
            if (currentPage != 1)
            {
              pageList.push(currentPage);
            }
            // add last page if known row count
            if (currentPage != totalPages && totalPages != -1)
            {
              pageList.push(totalPages);
            }
            numPagesToAdd = numPagesToAdd - pageList.length;
            // keep adding before the current page till we get to the
            // first page or we've added numPagesToAdd - 1.
            // If the last page or 2nd to last page then add until numPagesToAdd
            var pageBeforeCurrent = currentPage - 1;
            // number of pages to add after current
            var numPagesAfterCurrent = 1;
            // if at last page or second to last page then don't add any pages
            // after current
            if (currentPage == totalPages || currentPage == totalPages - 1)
            {
              numPagesAfterCurrent = 0;
            }
            while (numPagesToAdd > numPagesAfterCurrent && pageBeforeCurrent > 1)
            {
              pageList.push(pageBeforeCurrent);
              pageBeforeCurrent--;
              numPagesToAdd--;
            }
            // keep adding after the current page
            var pageAfterCurrent = currentPage + 1;
            // if unknown row count, only add one page after current
            if (totalPages == -1)
            {
              numPagesToAdd = 1;
            }
            while (numPagesToAdd > 0 && (pageAfterCurrent <= totalPages || totalPages == -1))
            {
              pageList.push(pageAfterCurrent);
              pageAfterCurrent++;
              numPagesToAdd--;
            }
          }

          // sort the pageList array
          var compareNumbers = function (a, b) {
            return a - b;
          };
          
          pageList.sort(compareNumbers);

          for (i = 0; i < pageList.length; i++)
          {
            var pageNum = pageList[i];
            this._createPagingControlNavPage(pagingControlNavPagesLinks, pageNum);
            // check if we have a gap
            if (i != pageList.length - 1)
            {
              if (pageNum != pageList[i + 1] - 1)
              {
                this._createPagingControlNavPage(pagingControlNavPagesLinks, -1);
              }
            }
          }
          if (totalPages == -1)
          {
            this._createPagingControlNavPage(pagingControlNavPagesLinks, -1);
          }
        }
        return pagingControlNavPagesLinks;
      },
      /**
       * Create the page link or page gap
       * @param {jQuery} parentDiv parent element
       * @param {number} pageNum page number
       * @return {jQuery} jQuery div DOM element
       * @private
       */
      _createPagingControlNavPage: function(parentDiv, pageNum)
      {
        var currentPage = this._getCurrentPage();
        var pagingControlNavPage = null;
        if (pageNum == -1)
        {
          pagingControlNavPage = $(document.createElement('span'));
          pagingControlNavPage.append("...");
          parentDiv.append(pagingControlNavPage);
        }
        else
        {          
          if (currentPage == pageNum)
          {
             pagingControlNavPage = $(document.createElement('div'));
             pagingControlNavPage.addClass(this._MARKER_STYLE_CLASSES._SELECTED);
             pagingControlNavPage.addClass(this._MARKER_STYLE_CLASSES._ACTIVE);
             pagingControlNavPage.addClass(this._MARKER_STYLE_CLASSES._DISABLED);
             pagingControlNavPage.removeClass(this._MARKER_STYLE_CLASSES._ENABLED);
          }
          else
          {
            pagingControlNavPage = $(document.createElement('a'));
            pagingControlNavPage.removeClass(this._MARKER_STYLE_CLASSES._SELECTED);
            pagingControlNavPage.removeClass(this._MARKER_STYLE_CLASSES._ACTIVE);
            pagingControlNavPage.removeClass(this._MARKER_STYLE_CLASSES._DISABLED);
            pagingControlNavPage.addClass(this._MARKER_STYLE_CLASSES._ENABLED);
          }
          pagingControlNavPage.attr('data-oj-pagenum', pageNum);
          pagingControlNavPage.addClass(this._CSS_CLASSES._PAGING_CONTROL_NAV_PAGE_CLASS);
          var pageTitle = this.getTranslatedString(this._BUNDLE_KEY._TIP_NAV_PAGE_LINK, {'pageNum': pageNum.toString()});
          this._hoverable(pagingControlNavPage);
          this._focusable(pagingControlNavPage);
          pagingControlNavPage.attr('title', pageTitle);
          pagingControlNavPage.attr('tabindex', '0');
          pagingControlNavPage.attr('href', '#');
          // create the acc label for the page link
          var accPageLabel = this._createPagingControlAccNavPageLabel();
          pagingControlNavPage.append(accPageLabel);
          pagingControlNavPage.append(pageNum.toString());
          this._hoverable(pagingControlNavPage);
          parentDiv.append(pagingControlNavPage);
        }
        return pagingControlNavPage;
      },
      /**
       * Return the paging content acc label
       * @return {jQuery|null} jQuery div DOM element
       * @private
       */
      _getPagingControlAccLabel: function()
      {
        var pagingControlContainer = this._getPagingControlContainer();
        var pagingControlContentAccLabel = null;
        
        if (pagingControlContainer)
        {
          pagingControlContentAccLabel = pagingControlContainer.find('.' + this._CSS_CLASSES._PAGING_CONTROL_ACC_LABEL_CLASS);
          if (pagingControlContentAccLabel && pagingControlContentAccLabel.length > 0)
          {
            pagingControlContentAccLabel = $(pagingControlContentAccLabel.get(0));
          }
        }
        
        return pagingControlContentAccLabel;
      },
      /**
       * Return the paging container
       * @return {jQuery|null} jQuery div DOM element
       * @private
       */
      _getPagingControlContainer: function()
      {
        return $(this.element);
      },
      /**
       * Return the paging content
       * @return {jQuery|null} jQuery div DOM element
       * @private
       */
      _getPagingControlContent: function()
      {
        if (!this._cachedDomPagingControlContent)
        {
          var pagingControlContainer = this._getPagingControlContainer();
          var pagingControlContent = null;
          if (pagingControlContainer)
          {
            pagingControlContent = pagingControlContainer.find('.' + this._CSS_CLASSES._PAGING_CONTROL_CONTENT_CLASS);
            if (pagingControlContent && pagingControlContent.length > 0)
            {
              this._cachedDomPagingControlContent = $(pagingControlContent.get(0));
            }
          }
        }

        return this._cachedDomPagingControlContent;
      },
      /**
       * Return the Load More div
       * @return {jQuery|null} jQuery a DOM element
       * @private
       */
      _getPagingControlLoadMore: function()
      {
        if (!this._cachedDomPagingControlLoadMore)
        {
          var pagingControlContent = this._getPagingControlContent();
          var pagingControlLoadMore = null;
          if (pagingControlContent)
          {
            pagingControlLoadMore = pagingControlContent.children('.' + this._CSS_CLASSES._PAGING_CONTROL_LOAD_MORE_CLASS);
            if (pagingControlLoadMore && pagingControlLoadMore.length > 0)
            {
              this._cachedDomPagingControlLoadMore = $(pagingControlLoadMore.get(0));
            }
          }
        }

        return this._cachedDomPagingControlLoadMore;
      },
      /**
       * Return the Load More link
       * @return {jQuery|null} jQuery a DOM element
       * @private
       */
      _getPagingControlLoadMoreLink: function()
      {
        if (!this._cachedDomPagingControlLoadMoreLink)
        {
          var pagingControlLoadMore = this._getPagingControlLoadMore();
          var pagingControlLoadMoreLink = null;
          if (pagingControlLoadMore)
          {
            pagingControlLoadMoreLink = pagingControlLoadMore.children('.' + this._CSS_CLASSES._PAGING_CONTROL_LOAD_MORE_LINK_CLASS);
            if (pagingControlLoadMoreLink && pagingControlLoadMoreLink.length > 0)
            {
              this._cachedDomPagingControlLoadMoreLink = $(pagingControlLoadMoreLink.get(0));
            }
          }
        }

        return this._cachedDomPagingControlLoadMoreLink;
      },
      /**
       * Return the Load More Range
       * @return {jQuery|null} jQuery span DOM element
       * @private
       */
      _getPagingControlLoadMoreRange: function()
      {
        if (!this._cachedDomPagingControlLoadMoreRange)
        {
          var pagingControlLoadMore = this._getPagingControlLoadMore();
          var pagingControlLoadMoreRange = null;
          if (pagingControlLoadMore)
          {
            pagingControlLoadMoreRange = pagingControlLoadMore.children('.' + this._CSS_CLASSES._PAGING_CONTROL_LOAD_MORE_RANGE_CLASS);
            if (pagingControlLoadMoreRange && pagingControlLoadMoreRange.length > 0)
            {
              this._cachedDomPagingControlLoadMoreRange = $(pagingControlLoadMoreRange.get(0));
            }
          }
        }

        return this._cachedDomPagingControlLoadMoreRange;
      },
      /**
       * Return the paging nav bar
       * @return {jQuery|null} jQuery a DOM element
       * @private
       */
      _getPagingControlNav: function()
      {
        if (!this._cachedDomPagingControlNav)
        {
          var pagingControlContent = this._getPagingControlContent();
          var pagingControlNav = null;
          if (pagingControlContent)
          {
            pagingControlNav = pagingControlContent.children('.' + this._CSS_CLASSES._PAGING_CONTROL_NAV_CLASS);
            if (pagingControlNav && pagingControlNav.length > 0)
            {
              this._cachedDomPagingControlNav = $(pagingControlNav.get(0));
            }
          }
        }

        return this._cachedDomPagingControlNav;
      },
      /**
       * Return the paging nav input
       * @return {jQuery|null} jQuery input DOM element
       * @private
       */
      _getPagingControlNavInput: function()
      {
        if (!this._cachedDomPagingControlNavInput)
        {
          var pagingControlNav = this._getPagingControlNav();
          var pagingControlNavInput = null;
          if (pagingControlNav)
          {
            pagingControlNavInput = pagingControlNav.find('.' + this._CSS_CLASSES._PAGING_CONTROL_NAV_INPUT_CLASS);
            if (pagingControlNavInput && pagingControlNavInput.length > 0)
            {
              this._cachedDomPagingControlNavInput = $(pagingControlNavInput.get(0));
            }
          }
        }

        return this._cachedDomPagingControlNavInput;
      },
      /**
       * Return the paging nav input summary
       * @return {jQuery|null} jQuery input DOM element
       * @private
       */
      _getPagingControlNavInputSummary: function()
      {
        if (!this._cachedDomPagingControlNavInputSummary)
        {
          var pagingControlNav = this._getPagingControlNav();
          var pagingControlNavInputSummary = null;
          if (pagingControlNav)
          {
            pagingControlNavInputSummary = pagingControlNav.find('.' + this._CSS_CLASSES._PAGING_CONTROL_NAV_INPUT_SUMMARY_CLASS);
            if (pagingControlNavInputSummary && pagingControlNavInputSummary.length > 0)
            {
              this._cachedDomPagingControlNavInputSummary = $(pagingControlNavInputSummary.get(0));
            }
          }
        }

        return this._cachedDomPagingControlNavInputSummary;
      },
      /**
       * Return the page links
       * @private
       */
      _getPagingControlNavPageLinks: function()
      {
        var pagingControlNav = this._getPagingControlNav();
        var pagingControlNavPageLinks = null;
        if (pagingControlNav)
        {
          pagingControlNavPageLinks = pagingControlNav.find('.' + this._CSS_CLASSES._PAGING_CONTROL_NAV_PAGES_LINKS_CLASS);
          if (pagingControlNavPageLinks && pagingControlNavPageLinks.length > 0)
          {
            pagingControlNavPageLinks = $(pagingControlNavPageLinks.get(0));
          }
        }

        return pagingControlNavPageLinks;
      },
      /**
       * Return the nav arrows
       * @private
       */
      _getPagingControlNavArrowSection: function()
      {
        var pagingControlNav = this._getPagingControlNav();
        var pagingControlNavArrowSection = null;
        if (pagingControlNav)
        {
          pagingControlNavArrowSection = pagingControlNav.find('.' + this._CSS_CLASSES._PAGING_CONTROL_NAV_ARROW_SECTION_CLASS);
          if (pagingControlNavArrowSection && pagingControlNavArrowSection.length > 0)
          {
            pagingControlNavArrowSection = $(pagingControlNavArrowSection.get(0));
          }
        }

        return pagingControlNavArrowSection;
      }
      ,
      /**
       * Return the nav input section
       * @private
       */
      _getPagingControlNavInputSection: function()
      {
        var pagingControlNav = this._getPagingControlNav();
        var pagingControlNavInputSection = null;
        if (pagingControlNav)
        {
          pagingControlNavInputSection = pagingControlNav.find('.' + this._CSS_CLASSES._PAGING_CONTROL_NAV_INPUT_SECTION_CLASS);
          if (pagingControlNavInputSection && pagingControlNavInputSection.length > 0)
          {
            pagingControlNavInputSection = $(pagingControlNavInputSection.get(0));
          }
        }

        return pagingControlNavInputSection;
      }
      /**** end internal DOM functions ****/
    })
}());
/*jslint browser: true,devel:true*/
/**
 * The base class for PagingDataSource.
 * @export
 * @class oj.PagingDataSource
 * @classdesc Decorator for DataSource to enable paging functionality to be used by the paging control.
 * @param {Object} dataSource
 * @param {Object|null} options Array of options for the PagingControlDataSource
 * @constructor
 */
oj.PagingDataSource = function(dataSource, options)
{
  this.dataSource = dataSource;
  this.Init();
};

// Subclass from oj.DataSource 
oj.Object.createSubclass(oj.PagingDataSource, oj.DataSource, "oj.PagingDataSource");

/**
 * Initializes the instance.
 * @export
 */
oj.PagingDataSource.prototype.Init = function()
{
  oj.PagingDataSource.superclass.Init.call(this);
};

/**
 * Calls fetch on the datasource with paging options.
 * @param {Object=} options Options to control fetch<p>
 *                  startIndex: The index at which to start fetching records.<p>
 *                  pageSize: The number of records to be fetched.<p>
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.PagingDataSource
 * @instance
 */
oj.PagingDataSource.prototype.fetch = function(options)
{
  oj.Assert.failedInAbstractFunction();
};

/**
 * @export
 * Return whether there is more data which can be fetched.
 * @returns {boolean} whether there is more data
 * @expose
 * @memberof! oj.PagingDataSource
 * @instance
 */
oj.PagingDataSource.prototype.hasMore = function()
{
  oj.Assert.failedInAbstractFunction();
  return false;
};

/**
 * Calls fetch for the next page of data. No-op if no more data.
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.PagingDataSource
 * @instance
 */
oj.PagingDataSource.prototype.next = function()
{
  oj.Assert.failedInAbstractFunction();
};

/**
 * Calls fetch for the previous page of data. No-op if at the beginning.
 * @throws {Error}
 * @export
 * @expose
 * @memberof! oj.PagingDataSource
 * @instance
 */
oj.PagingDataSource.prototype.previous = function()
{
  oj.Assert.failedInAbstractFunction();
};

/**
 * Set or change the number of models in a page
 * 
 * @param {number} n page size
 */
oj.PagingDataSource.prototype.setPageSize = function(n)
{
  oj.Assert.failedInAbstractFunction();
};

/**
 * @export
 * Return current start index. -1 if initial fetch has not been done yet.
 * @returns {number} start index
 * @expose
 * @memberof! oj.PagingDataSource
 * @instance
 */
oj.PagingDataSource.prototype.startIndex = function()
{
  oj.Assert.failedInAbstractFunction();
  return 0;
};

/**
 * @export
 * Return the size of the data locally in the dataSource. -1 if an initial fetch has not been
 * done yet.
 * @returns {number} size of data
 * @expose
 * @memberof! oj.PagingDataSource
 * @instance
 */
oj.PagingDataSource.prototype.size = function()
{
  oj.Assert.failedInAbstractFunction();
  return 0;
};

/**
 * @export
 * Return the total size of data available, including server side if not local.
 * @returns {number} total size of data
 * @expose
 * @memberof! oj.PagingDataSource
 * @instance
 */
oj.PagingDataSource.prototype.totalSize = function()
{
  oj.Assert.failedInAbstractFunction();
  return 0;
};

/**
 * @export
 * Event types
 * @enum {string}
 */
oj.PagingDataSource.EventType =
  {
    /** Triggered when a model or collection has been updated from the data service */
    'SYNC':     "sync"
  };

/**
 * @class 
 * @name oj.ojLegend
 * @augments oj.baseComponent
 * 
 * @classdesc
 * <h3 id="legendOverview-section">
 *   JET Legend Component
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#legendOverview-section"></a>
 * </h3>
 * 
 * <p>Legend component for JET.</p>
 * 
 * <p>This component should be bound to an HTML div element, and the SVG DOM that it generates should be treated as a 
 * black box, as it is subject to change.  This component should not be extended.</p>
 * 
 * <pre class="prettyprint">
 * <code>
 * &lt;div data-bind="ojComponent: {
 *   component: 'ojLegend',
 *   orientation: 'vertical',
 *   sections: [{text : "Database"},
 *              {text : "Middleware"},
 *              {text : "Applications"}]
 * }"/>
 * </code>
 * </pre>
 * 
 * <h3 id="legendOptions-section">
 *   Options
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#legendOptions-section"></a>
 * </h3>
 * 
 * <p>Full documentation for the options method, including APIs for data, style properties, and interactivity, is 
 * available <a title="Options Documentation" href="dvt/legend.xml">here</a>.</p>
 * 
 * @desc Creates a JET Legend.
 * @example <caption>Initialize the Legend with no options specified:</caption>
 * $(".selector").ojLegend();
 * 
 * @example <caption>Initialize the Legend with some options:</caption>
 * $(".selector").ojLegend({orientation: 'vertical', sections: [{text : "Database"}, {text : "Middleware"}, {text : "Applications"}});
 * 
 * @example <caption>Initialize the Legend via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;div data-bind="ojComponent: {component: 'ojLegend'}">
 */
oj.__registerWidget('oj.ojLegend', $['oj']['dvtBaseComponent'], 
{
  version : "1.0.0", 
  widgetEventPrefix : "oj",  
  options: {
    /**
     * Triggered when a category of data items is hidden or shown. TODO: This event is in development and may change.
     * 
     * @property {Object} ui event payload
     * @property {Object} ui.category the category that was filtered on
     * @property {string} ui.type specifies whether the category is being filtered 'in' or 'out'
     * 
     * @example <caption>Initialize the component with the <code class="prettyprint">categoryFilter</code> callback specified:</caption>
     * $(".selector").ojLegend({
     *   "categoryFilter": function(event, ui){}
     * });
     *
     * @example <caption>Bind an event listener to the <code class="prettyprint">ojcategoryfilter</code> event:</caption>
     * $(".selector").on("ojcategoryfilter", function(event, ui){});
     * 
     * @expose 
     * @event 
     * @memberof! oj.ojLegend
     * @instance
     */
    categoryFilter : null,
    
    /**
     * Triggered when a category of data items is highlighted. TODO: This event is in development and may change.
     * 
     * @property {Object} ui event payload
     * @property {Array} ui.categories the categories that are being highlighted
     * @property {string} ui.type specifies whether highlighting is being turned 'on' or 'off'
     * 
     * @example <caption>Initialize the component with the <code class="prettyprint">categoryHighlight</code> callback specified:</caption>
     * $(".selector").ojLegend({
     *   "categoryHighlight": function(event, ui){}
     * });
     *
     * @example <caption>Bind an event listener to the <code class="prettyprint">ojcategoryhighlight</code> event:</caption>
     * $(".selector").on("ojcategoryhighlight", function(event, ui){});
     * 
     * @expose 
     * @event 
     * @memberof! oj.ojLegend
     * @instance
     */
    categoryHighlight : null
  },
  
  /**
   * @override
   */
  _CreateComponent : function(context, callback, callbackObj) {
    return DvtLegend.newInstance(context, callback, callbackObj);
  },
  
  /**
   * @override
   */
  _GetChildStyleClasses : function() {
    var styleClasses = this._super();
    styleClasses['oj-legend'] = {'path' : 'textStyle', 'property' : 'CSS_TEXT_PROPERTIES'};
    styleClasses['oj-legendTitle'] = {'path' : 'titleStyle', 'property' : 'CSS_TEXT_PROPERTIES'};
    // TODO HZHANG: Need to support a default sectionTitleStyle property
    styleClasses['oj-legendSectionTitle'] = {'path' : '_sectionTitleStyle', 'property' : 'CSS_TEXT_PROPERTIES'};
    return styleClasses;
  },
  
  /**
   * @override
   */
  _HandleEvent : function(event) {
    var type = event && event.getType ? event.getType() : null, filterType, highlightType;
    if(type === DvtCategoryHideShowEvent.TYPE_HIDE || type === DvtCategoryHideShowEvent.TYPE_SHOW) {
      filterType = (type === DvtCategoryHideShowEvent.TYPE_HIDE) ? 'out' : 'in';
      this._trigger('categoryFilter', null, {'category': event.getCategory(), 'type': filterType});
    }
    else if(type === DvtCategoryRolloverEvent.TYPE_OVER || type === DvtCategoryRolloverEvent.TYPE_OUT) {
      highlightType = (type === DvtCategoryRolloverEvent.TYPE_OVER) ? 'on' : 'off';
      this._trigger('categoryHighlight', null, {'categories': [event.getCategory()], 'type': highlightType});
    }
    else {
      this._super(event);
    }
  }
});
/*!
 * jQuery UI Popup @VERSION
 * http://jqueryui.com
 *
 * Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/menu/
 *
 * Depends:
 *  jquery.ui.core.js
 *  jquery.ui.widget.js
 *  jquery.ui.position.js
 */(function ()
{

  /**
   * List of all pseudo marker selectors that defines rules for where a tail is aligned.
   * @private
   * @const
   */
  var _TAIL_STYLES = ["oj-left", "oj-center", "oj-right", "oj-top", "oj-middle", "oj-bottom"];

  /**
   * Mapping of horizontal-vertical (x,y) positon using alignment to jet tail pseudo marker selectors.
   *
   * horizontal: right, left, center
   * vertical: top, bottom, middle
   *
   * @private
   * @const
   */
  var _TAIL_ALIGN_RULES = 
  {
    'right-top' : 'oj-right oj-top', 'right-middle' : 'oj-right oj-middle', 'right-bottom' : 'oj-right oj-bottom', 'left-top' : 'oj-left oj-top', 'left-middle' : 'oj-left oj-middle', 'left-bottom' : 'oj-left oj-bottom', 'center-top' : 'oj-center oj-top', 'center-middle' : 'oj-left oj-middle', 'center-bottom' : 'oj-center oj-bottom'
  };

  /**
   * @class
   * @name oj.ojPopup
   * @augments oj.baseComponent
   *
   * @classdesc
   * <h3 id="popupOverview-section">
   *   JET Popup Component
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#popupOverview-section"></a></h3>
   *
   * <p>Description: Themeable, WAI-ARIA-compliant popup that can display arbitrary content.</p>
   *
   * <p>A JET popup can be created from a block ( <code class="prettyprint">&lt;div></code> ) or inline element
   *   ( <code class="prettyprint">&lt;span></code> ).  This element will become the immediate child of the content element.
   *   Dynamic content can be inserted under this element.</p>
   *
   * <pre class="prettyprint">
   * <code>&lt;span id="popup">
   *   Hello World!
   * &lt;/span>
   * </code></pre>
   *
   * <p>For WAI-ARIA compliance, JET automatically adds <code class="prettyprint">role="tooltip"</code> to
   * the root popup dom element.  It also adds the <code class="prettyprint">aria-describedby="popup-id"</code>
   * to the launcher while the popup is open.
   * </p>
   *
   * <h3 id="keyboard-section">
   *   Keyboard interaction
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
   * </h3>
   *
   * <table class="keyboard-table">
   *   <thead>
   *     <tr>
   *       <th>Key</th>
   *       <th>Use</th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td><kbd>Tab</kbd></td>
   *       <td>Forward or backward (<kbd>Shift+Tab</kbd>) tabbing will traverse within the content of the popup.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>F6</kbd></td>
   *       <td>Focus can be toggled from the launcher to the popups content and back using the F6 function key.</td>
   *     </tr>
   *     <tr>
   *       <td><kbd>Esc</kbd></td>
   *       <td>Esc key from within the content of the popup or from the launcher will close the popup.</td>
   *     </tr>
   * </tbody></table>
   * <br/><br/>
   * <p>There are two general configurations for a ojPopup, basic popup and notewindow.  However,
   *    both types share common behaviors.</p>
   *
   * <h3 id="common-popup-behaviors-section">
   *  Common Popup Behaviors
   *  <a class="bookmarkable-link" title="Bookmarkable Link" href="#common-popup-behaviors-section"></a>
   * </h3>
   *
   * The following are behaviors common to both general types of popups:
   * <ul>
   *  <li>The popup will auto-dismiss when <kbd>Esc</kbd> is pressed and focus is within the content.</li>
   *  <li>It will auto-dismiss if <kbd>Esc</kbd> is pressed when focus is on the launcher node.</li>
   *  <li>Forward or backward tabbing at the first or last tab stop will cycle back within the content of the popup.</li>
   *  <li>The popup will always be aligned to the launcher. If a launcher is not provided, the default will be the active element
   *      in the document. The fallback will be to the document body.</li>
   *  <li>At the point when a popup is closed and active focus is within its content, and attempt will be made to establish focus
   *      back to the launcher.</li>
   *  <li>The popup will have a border, shadow, and z-index defined by the active theme.</li>
   *  <li>After creation, the popup will be hidden. Calling the <code class="prettyprint">open</code> method will show the popup
   *      aligned to the provided <code class="prettyprint">position</code> option object.</li>
   *  <li>Focus can be toggled from the launcher to the popup's content and back using the <kbd>F6</kbd> function key.</li>
   *  <li>After the component binding with the associated element, the popup's content will be hidden by default.
   *      The root dom element that defines the popup will be positioned in the document reltative to the binding element.
   *      This means that the page developer will need to manage the stacking context of the document.</li>
   * </ul>
   *
   * <h3 id="basic-popup-behaviors-section">
   *  Basic Popup Behaviors
   *  <a class="bookmarkable-link" title="Bookmarkable Link" href="#basic-popup-behaviors-section"></a>
   * </h3>
   *
   * Default options define the following basic popup behaviors:
   * <ul>
   *   <li>It will steal focus from the launcher to the first focusable element within its content,
   *       provided that a focusable element exists. The default <code class="prettyprint">initialFocus</code>
   *       option is <code class="prettyprint">firstFocusable</code>.</li>
   *   <li>The popup will not auto dismiss when focus moves from the popups content or associated launcher.
   *       The default for the <code class="prettyprint">autoDismiss</code> option is <code class="prettyprint">none</code>.</li>
   * </ul>
   *
   * <h3 id="notewindow-popup-behaviors-section">
   *  Notewindow Popup Behaviors
   *  <a class="bookmarkable-link" title="Bookmarkable Link" href="#notewindow-popup-behaviors-section"></a>
   * </h3>
   *
   * <ul>
   *  <li>This type of popup will not initially grab focus when open. The <code class="prettyprint">initialFocus</code>
   *       option is <code class="prettyprint">none</code>.</li>
   *  <li>When focus leaves the content of the popup or the launcher, the popup will auto dismiss.
   *      The <code class="prettyprint">autoDismiss</code> option is set to <code class="prettyprint">focusLoss</code></li>
   *  <li>A tail overlaping the border will point to the launcher the popup is aligned to. The <code class="prettyprint">tail</code>
   *      option of <code class="prettyprint">simple</code>.</li>
   * </ul>
   *
   * <h3 id="eventHandling-section">
   *   Event Handling
   *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#eventHandling-section"></a>
   * </h3>
   * <ul>
   *  <li>beforeClose(event, ui) - Triggered before a popup closes. Event can prevent closing the popup.</li>
   *  <li>beforeOpen(event, ui) - Triggered before a popup closes. Event can prevent opening the popup.</li>
   *  <li>close(event, ui) - Triggered after the popup has closed.</li>
   *  <li>create(event, ui) - Triggered after the component has been bound to an associated dom element.</li>
   *  <li>focus(event, ui) - Triggered when initial focus is established on opening, depending on the value of the initalFocus 
   *      option, or <kbd>F6</kbd> focus toggle from the associated launcher.</li>
   *  <li>open(event, ui) - Triggered after the popup has been made visible.</li>
   * </ul>
   *
   * @desc Creates a JET Popup.  If called after the popup is already created, it is equivalent to the
   * "set many options" overload of <code class="prettyprint">option()</code>.
   *
   * @param {Object=} options a map of option-value pairs to set on the component
   *
   * @example <caption>Initialize the popup with no options specified:</caption>
   * $( ".selector" ).ojPopup();
   *
   * @example <caption>Initialize the popup with behaviors of a notewindow:</caption>
   * $( ".selector" ).ojPopup({initialFocus: 'none', autoDismiss: 'focusLoss', tail: 'simple'});
   *
   * @example <caption>Initialize a popup via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
   * &lt;div id="popup1" data-bind="ojComponent: {component: 'ojPopup'}">This is a popup!&lt;/div>
   *
   */
  oj.__registerWidget("oj.ojPopup", $['oj']['baseComponent'], 
  {
    version : "1.0.0", widgetEventPrefix : "oj", options : 
    {
      /**
       * Defines conditions that will cause an open popup to auto close dismiss.  A value of <code class="prettyprint">focusLoss</code>
       * defines the dismissal condition where focus has left the content of the popup or from the associated
       * launcher.
       *
       * @expose
       * @memberof! oj.ojPopup
       * @instance
       * @type {string}
       * @default <code class="prettyprint">"none"</code>
       * @ojvalue {string} "none" disables auto dismissal behaviors.
       * @ojvalue {string} "focusLoss" defines auto dismissal behavior when focus leaves the content of the popup or
       *                   associated launcher.
       *
       * @example <caption>Initialize the popup with <code class="prettyprint">autoDismiss</code> option specified:</caption>
       * $( ".selector" ).ojPopup( { "autoDismiss": "focusLoss" } );
       *
       * @example <caption>Get or set the <code class="prettyprint">autoDismiss</code> option, after initialization:</caption>
       * // getter
       * var autoDismiss = $( ".selector" ).ojPopup( "option", "autoDismiss" );
       * // setter
       * $( ".selector" ).ojPopup( "option", "autoDismiss", "none" );
       */
      autoDismiss : 'none', 
      /**
       * Defines the presents of border, shadow and background color of the root popup dom.  Value of
       * <code class="prettyprint">none</code> applies the <code class="prettyprint">oj-popup-no-chrome</code>
       * selector defined by the active theme to the root dom of the popup to remove the default chrome.
       *
       * @expose
       * @memberof! oj.ojPopup
       * @instance
       * @type {string}
       * @default <code class="prettyprint">"default"</code>
       * @ojvalue {string} "default" describes the popups border, shadow, and background color defined by the active theme.
       * @ojvalue {string} "none" turns of the outer chrome defined by the active theme.
       *
       * @example <caption>Initialize the popup with <code class="prettyprint">chrome</code> option specified:</caption>
       * $( ".selector" ).ojPopup( { "chrome": "none" } );
       *
       * @example <caption>Get or set the <code class="prettyprint">chrome</code> option, after initialization:</caption>
       * // getter
       * var chrome = $( ".selector" ).ojPopup( "option", "chrome" );
       *
       * // setter
       * $( ".selector" ).ojPopup( "option", "chrome", "none" );
       */
      chrome : 'default', 
      /**
       * Determines if the popup should steal focus to its content when initially open. A value of <code class="prettyprint">none</code>
       * prevents the popup from grabbing focus when open.
       *
       * @expose
       * @memberof! oj.ojPopup
       * @instance
       * @type {string}
       * @default <code class="prettyprint">"firstFocusable"</code>
       * @ojvalue {string} "none" prevents the popup from stealing focus when open.
       * @ojvalue {string} "initialFocus" defines that a popup should grab focus to its content when open.
       *
       * @example <caption>Initialize the popup with <code class="prettyprint">initialFocus</code> option specified:</caption>
       * $( ".selector" ).ojPopup( { "initialFocus": "none" } );
       *
       * @example <caption>Get or set the <code class="prettyprint">initialFocus</code> option, after initialization:</caption>
       * // getter
       * var initialFocus = $( ".selector" ).ojPopup( "option", "initialFocus" );
       *
       * // setter
       * $( ".selector" ).ojPopup( "option", "initialFocus", "none" );
       */
      initialFocus : 'firstFocusable', 
      /**
       * <p>Position object is defined by the jquery position API and is used to establish the location the
       * popup will appear relative to another element.  The postion object contains the following properties:
       * "my", "at", "of", "colision", "using" and "within".</p>
       *
       * <p>The "my" and "at" properties defines aligment points relative to the popup and other element.  The
       * "my" property represents the popups alignment where the "at" property represents the other element
       * that can be identified by "of" or defauts to the launcher when the popup opens.  The values of these
       * properties describe a "horizontal vertical" location.</p>
       *
       * <p>Acceptable "horizontal" alignments values are: "right", "center", "left", "start", "end".  Note: Jet has
       * added "start" and "end" options to be more RTL friendly.  The Jet values of "start" and "end" normalize
       * to "right" or "left" depending on the direction of the document.</p>
       *
       * <p>Acceptable "vertical" alignment values are: "top", "center" and "bottom".</p>
       *
       * The following is a short summary of the most interesting positon properties:
       * <ul>
       *   <li><code class="prettyprint">my</code> - A "vertical horizontal" rule that defines the location of the popup
       *       used for alignment.</li>
       *   <li><code class="prettyprint">at</code> - A "vertical horizontal" rule that defines the location of the
       *       other element for used alignment. The other element is defined by "of" or defaults to the open launcher
       *       argument if not specified.</li>
       * </ul>
       *
       * @expose
       * @memberof! oj.ojPopup
       * @instance
       * @type {Object}
       * @default <code class="prettyprint">{my: "start top", at: "start bottom", collision: "flip"}</code>
       *
       * @example <caption>Initialize the popup with <code class="prettyprint">position</code> option specified:</caption>
       * $( ".selector" ).ojPopup( { "position": {"my": "left top", "at": "right top"} } );
       *
       * @example <caption>Get or set the <code class="prettyprint">position</code> option, after initialization:</caption>
       * // getter
       * var position = $( ".selector" ).ojPopup( "option", "position" );
       *
       * // setter
       * $( ".selector" ).ojPopup( "option", "position", {"my": "start bottom", "at": "end+14 top" } );
       */
      position : 
      {
        /**
         * Defines which position on the popup to align with the target ("of") element: "horizontal vertical" alignment.
         * A single value such as "right" will be normalized to "right center", "top" will be normalized to "center top"
         * (following CSS convention). Acceptable horizontal values: "left", "center", "right".
         * Acceptable vertical values: "top", "center", "bottom". Example: "left top" or "center center".
         * Each dimension can also contain offsets, in pixels or percent, e.g., "right+10 top-25%". Percentage offsets are relative
         * to the popup being positioned.
         *
         *
         * @expose
         * @memberof! position#
         * @alias position.my
         * @type {string}
         * @default <code class="prettyprint">left top</code>
         */
         'my' : 'start top', 
        /**
         * Defines which position on the target element ("of") to align the positioned element against: "horizontal vertical"
         * alignment. See the my option for full details on possible values. Percentage offsets are relative to the target element.
         *
         * @expose
         * @type {string}
         * @memberof! position#
         * @alias position.at
         * @default <code class="prettyprint">left bottom</code>
         */
         'at' : 'start bottom', 
        /**
         * Which element to position the popup against.  The default is the <code class="prettyprint">launcher</code> argument
         * passed to the <code class="prettyprint">open</code> method. If you provide a selector or jQuery object,
         * the first matching element will be used. If you provide an event object, the pageX and pageY properties
         * will be used.
         *
         * @expose
         * @memberof! position#
         * @alias position.of
         * @type {string}
         * @default <code class="prettyprint">''</code>
         */
         'of' : '', 
        /**
         *  When the positioned element overflows the window in some direction, move it to an alternative position. Similar to my and
         *  at, this accepts a single value or a pair for horizontal/vertical, e.g., "flip", "fit", "fit flip", "fit none".
         *
         *  <ul>
         *    <li>"flip": Flips the element to the opposite side of the target and the collision detection is run again to see if it
         *        will fit. Whichever side allows more of the element to be visible will be used.</li>
         *    <li>"fit": Shift the element away from the edge of the window.</li>
         *    <li>"flipfit": First applies the flip logic, placing the element on whichever side allows more of the element to be
         *        visible. Then the fit logic is applied to ensure as much of the element is visible as possible.</li>
         *    <li>"none": Does not apply any collision detection.</li>
         *  </ul>
         * @expose
         * @memberof! position#
         * @alias position.collision
         * @type {string}
         * @default <code class="prettyprint">flip</code>
         */
         'collision' : 'flip'
      },
      /**
       * Determines if a decoration will be displayed from the popup that points to the element the popup is aligned to.
       * The <code class="prettyprint">simple</code> value enables the tail defined by the current theme.  In addtion,
       * the <code class="prettyprint">oj-popup-tail-simple</code> selector will be applied to the root dom element.  This
       * is to allow the box-shadow, z-index and other chrome styling to vary per tail decoration.
       *
       * @expose
       * @memberof! oj.ojPopup
       * @instance
       * @type {string}
       * @default <code class="prettyprint">"none"</code>
       * @ojvalue {string} "none" no decoration will be displayed from the popup pointing to the launcher.
       * @ojvalue {string} "simple" enables showing the tail defined by the current theme.
       *
       * @example <caption>Initialize the popup with <code class="prettyprint">tail</code> option specified:</caption>
       * $( ".selector" ).ojPopup( { "tail": "simple" } );
       *
       * @example <caption>Get or set the <code class="prettyprint">tail</code> option, after initialization:</caption>
       * // getter
       * var tail = $( ".selector" ).ojPopup( "option", "tail" );
       *
       * // setter
       * $( ".selector" ).ojPopup( "option", "tail", "simple" );
       */
      tail : 'none', 

      // Events 
      /**
       * Triggered before the popup is launched via the <code class="prettyprint">open()</code> method.
       * The launch can be cancelled by calling <code class="prettyprint">event.preventDefault()</code>.
       *
       * @expose 
       * @event 
       * @memberof! oj.ojPopup
       * @instance
       * @property {Event} event <code class="prettyprint">jQuery</code> event object
       * @property {Object} ui dom element that the popup was bound to
       * 
       * @example <caption>Initialize the popup with the <code class="prettyprint">beforeOpen</code> callback specified:</caption>
       * $( ".selector" ).ojPopup({
       *     "beforeOpen": function( event, ui ) {}
       * });
       *
       * @example <caption>Bind an event listener to the <code class="prettyprint">ojbeforeopen</code> event:</caption>
       * $( ".selector" ).on( "ojbeforeopen", function( event, ui ) {} );
       */
      beforeOpen : null, 
      /**
       * Triggered after the popup is launched via the <code class="prettyprint">open()</code> method.
       *
       * @expose
       * @event
       * @memberof! oj.ojPopup
       * @instance
       * @property {Event} event <code class="prettyprint">jQuery</code> event object
       * @property {Object} ui dom element that the popup was bound to
       *
       * @example <caption>Initialize the popup with the <code class="prettyprint">open</code> callback specified:</caption>
       * $( ".selector" ).ojPopup({
       *     "open": function( event, ui ) {}
       * });
       *
       * @example <caption>Bind an event listener to the <code class="prettyprint">ojopen</code> event:</caption>
       * $( ".selector" ).on( "ojopen", function( event, ui ) {} );
       */
      open : null, 
      /**
       * Triggered before the popup is dismissed via the <code class="prettyprint">close()</code> method.
       * The close can be cancelled by calling <code class="prettyprint">event.preventDefault()</code>.
       *
       * @expose
       * @event
       * @memberof! oj.ojPopup
       * @instance
       * @property {Event} event <code class="prettyprint">jQuery</code> event object
       * @property {Object} ui dom element that the popup was bound to
       *
       * @example <caption>Initialize the popup with the <code class="prettyprint">beforeClose</code> callback specified:</caption>
       * $( ".selector" ).ojPopup({
       *     "beforeClose": function( event, ui ) {}
       * });
       *
       * @example <caption>Bind an event listener to the <code class="prettyprint">ojbeforeclose</code> event:</caption>
       * $( ".selector" ).on( "ojbeforeclose", function( event, ui ) {} );
       */
      beforeClose : null, 
      /**
       * Triggered after the popup is dismissed via the <code class="prettyprint">close()</code> method.
       *
       * @expose
       * @event
       * @memberof! oj.ojPopup
       * @instance
       * @property {Event} event <code class="prettyprint">jQuery</code> event object
       * @property {Object} ui dom element that the popup was bound to
       *
       * @example <caption>Initialize the popup with the <code class="prettyprint">close</code> callback specified:</caption>
       * $( ".selector" ).ojPopup({
       *     "close": function( event, ui ) {}
       * });
       *
       * @example <caption>Bind an event listener to the <code class="prettyprint">ojclose</code> event:</caption>
       * $( ".selector" ).on( "ojclose", function( event, ui ) {} );
       */
      close : null,
      /**
       * Triggered after focus has been transfered to the popup. This will occur after the 
       * <code class="prettyprint">open()</code> method is called, depending on the value
       * of the <code class="prettyprint">initialFocus</code> option.  It's also triggered when using the
       * <kbd>F6</kbd> key to toggle focus from the associated launcher element to the content of the popup.
       *
       * @expose
       * @event
       * @memberof! oj.ojPopup
       * @instance
       * @property {Event} event <code class="prettyprint">jQuery</code> event object
       * @property {Object} ui dom element that the popup was bound to
       *
       * @example <caption>Initialize the popup with the <code class="prettyprint">focus</code> callback specified:</caption>
       * $( ".selector" ).ojPopup({
       *     "focus": function( event, ui ) {}
       * });
       *
       * @example <caption>Bind an event listener to the <code class="prettyprint">ojfocus</code> event:</caption>
       * $( ".selector" ).on( "ojfocus", function( event, ui ) {} );
       */
      focus : null
    },
   /**
    * @memberof! oj.ojPopup
    * @instance
    * @protected
    * @override 
    * @return {void}
    */
     _ComponentCreate: function ()
    {
      this._super();
      
      var rootStyle = this._getRootStyle();
      var rootElement = $("<div>");
      this._rootElement = rootElement.hide().addClass(rootStyle).attr("aria-hidden", "true");
      rootElement.addClass("oj-helper-reset-inheritable oj-component");

      var content = $("<div>").addClass([rootStyle, "content"].join("-"));
      content.appendTo(rootElement);
      this.element.after(rootElement);
      this.element.appendTo(content);
      this.element.show();

      this._createTail();
      this._setChrome();
      this._createLiveRegion();

      // callback that overrides the positon['using'] for setting the tail.
      this._usingCallback = $.proxy(this._usingHandler, this);
    },
   /**
    * @memberof! oj.ojPopup
    * @instance
    * @protected
    * @override 
    * @return {void}
    */
    _destroy : function ()
    {
      this._super();

      if (this.isOpen())
        this.close();

      this._destroyTail();
      this._destroyLiveRegion();
      delete this._usingCallback;

      this._rootElement.replaceWith(this.element);
      this.element.hide();

    },
    /**
     * Returns a <code class="prettyprint">jQuery</code> object containing the generated wrapper.
     * This method does not accept any arguments.
     *
     * @expose
     * @name oj.ojpopup#widget
     * @memberof! oj.ojPopup
     * @instance
     * @return {jQuery} the popup
     *
     * @example <caption>Invoke the <code class="prettyprint">widget</code> method:</caption>
     * var widget = $( ".selector" ).ojPopup( "widget" );
     */
    widget : function ()
    {
      return this._rootElement;
    },
    /**
     * Opens the popup. This method accepts two arguments but both are optional.
     *
     * @expose
     * @method
     * @name oj.ojPopup#open
     * @memberof! oj.ojPopup
     * @instance
     * @param {?(string|jQuery|Element)} launcher of the popup
     * @param {?Object} position an element relative to another
     * @return {void}
     * @fires oj.ojPopup#beforeOpen
     * @fires oj.ojPopup#open
     *
     * @example <caption>Invoke the <code class="prettyprint">open</code> method:</caption>
     * var open = $( ".selector" ).ojPopup( "open" );
     */
    open : function (launcher, position)
    {

      if (this.isOpen())
      {
        this.close();

        //if beforeClose handler prevents that action, just bail out.
        if (this.isOpen())
          return;
      }

      this._setLauncher(launcher);

      var rootElement = this._rootElement;
      launcher = this._launcher;
      oj.Assert.assertPrototype(rootElement, jQuery);
      oj.Assert.assertPrototype(launcher, jQuery);

      if (oj.StringUtils.isEmptyOrUndefined(rootElement.attr("id")))
        rootElement.uniqueId();

      if (this._trigger("beforeOpen") === false)
        return;

      this._setPosition(position);


      var options = this.options;
      this._setAutoDismiss(options["autoDismiss"]);

      this._on(true, $(window), 
      {
        'resize' : this._resizeHandler
      });
      this._on(true, rootElement, 
      {
        'keydown' : this._keydownHandler
      });
      this._on(true, launcher, 
      {
        'keydown' : this._keydownHandler
      });

      this._addDescribedBy();

      rootElement.removeAttr("aria-hidden");
      rootElement.attr("role", "tooltip");

      position = options["position"];
      rootElement.show();
      var isRtl = this._GetReadingDirection() === "rtl";
      rootElement.position(oj.PositionUtils.normalizeHorizontalAlignment(position, isRtl));

      this._trigger("open");

      this._intialFocus();

      var message = this.getTranslatedString("none" === options["initialFocus"] ?
                                             "ariaLiveRegionInitialFocusNone":
                                             "ariaLiveRegionInitialFocusFirstFocusable");
      this._announceLiveRegion(message);
    },
    /**
     * Closes the popup. This method does not accept any arguments.
     *
     * @expose
     * @method
     * @name oj.ojPopup#close
     * @memberof! oj.ojPopup
     * @instance
     * @return {void}
     * @fires oj.ojPopup#beforeClose
     * @fires oj.ojPopup#close
     *
     * @example <caption>Invoke the <code class="prettyprint">close</code> method:</caption>
     * var close = $( ".selector" ).ojPopup( "close" );
     */
    close : function ()
    {
      if (!this.isOpen())
        return;

      if (this._trigger("beforeClose") === false)
        return;

      // if the content has focus, restore the the launcher
      this._restoreFocus();

      var launcher = this._launcher;
      var rootElement = this._rootElement;
      oj.Assert.assertPrototype(rootElement, jQuery);
      oj.Assert.assertPrototype(launcher, jQuery);

      rootElement.hide();
      rootElement.attr("aria-hidden", "true");

      this._removeDescribedBy();
      this._setAutoDismiss();

      this._off($(window), "resize");
      this._off(rootElement, "keydown");
      this._off(launcher, "keydown");

      delete this._launcher;

      var position = this.options["position"];

      // if the open has set the of because one was not provided by default,
      // remove the override to the launcher.
      if (position["_ofo"])
      {
        delete position["_ofo"];
        delete position["of"];
      }

      this._trigger("close");
    },
    /**
     * Returns the state of whether the popup is currently open. This method does not accept any arguments.
     *
     * @expose
     * @method
     * @name oj.ojPopup#isOpen
     * @memberof! oj.ojPopup
     * @instance
     * @return {boolean} <code>true</code> if the popup is open.
     *
     * @example <caption>Invoke the <code class="prettyprint">isOpen</code> method:</caption>
     * var isOpen = $( ".selector" ).ojPopup( "isOpen" );
     */
    isOpen : function ()
    {
      return this._rootElement.is(":visible");
    },
   /**
    * @memberof! oj.ojPopup
    * @instance
    * @protected
    * @param {string} key option name
    * @param {?Object} value of the target option identified by the key
    * @override
    */
    _setOption : function (key, value)
    {

      var options = this.options;
      switch (key)
      {
        case "tail":
          if (value !== options["tail"])
          {
            this._setTail(value);
          }
          break;
        case "chrome":
          if (value !== options["chrome"])
            this._setChrome(value);
          break;
        case "position":
          this._setPosition(value);
          if (this.isOpen())
            this._resizeHandler();
          // don't call super because setPosition sets the option after creating a new
          // instance.  This prevents the same position instance from getting registered
          // with multiple component instances.
          return;
        case "autoDismiss":
          if (this.isOpen() && value !== options["autoDismiss"])
            this._setAutoDismiss(value);
          break;
      }

      this._super(key, value);
    },
   /**
    * Returns the root selector prefix for the popup components.  In the future if the popup is subcassed,
    * this method can be made protected and override to change the root selector names for the target
    * component.
    *
    * @memberof! oj.ojPopup
    * @instance
    * @private 
    * @return {string}
    */
    _getRootStyle : function ()
    {
      return "oj-popup";
    },
   /**
    * Handles setting up the target tail.
    *
    * @memberof! oj.ojPopup
    * @instance
    * @private 
    * @param {string} tail option value
    * @return {void}
    */
    _setTail : function (tail)
    {
      this._destroyTail();
      this._createTail(tail);
      this._resizeHandler();
    },
   /**
    * @memberof! oj.ojPopup
    * @instance
    * @private 
    * @param {string} tail option value
    * @return {void}
    */
    _createTail : function (tail)
    {
      var tailDecoration = tail ? tail : this.options['tail'];
      if ("none" === tailDecoration)
        return;

      var rootStyle = this._getRootStyle();
      var tailMarkerStyle = [rootStyle, "tail"].join("-");
      var tailStyle = [tailMarkerStyle, tailDecoration].join("-");

      var tailDom = $("<div>").hide().addClass(tailMarkerStyle).addClass(tailStyle);

      // id over "marker style" due to nesting popups in popups
      this._tailId = "#" + tailDom.uniqueId().attr("id");
      var rootElement = this._rootElement;
      oj.Assert.assertPrototype(rootElement, jQuery);
      tailDom.appendTo(rootElement);

      // tail "value" style is applied to the root dom for shadow and z-index adjustments
      rootElement.addClass(tailStyle);
    },
   /**
    * @memberof! oj.ojPopup
    * @instance
    * @private 
    * @return {jQuery}
    */
    _getTail : function ()
    {
      var tailId = this._tailId;
      if (!tailId)
        return null;

      return $(tailId);
    },
   /**
    * @memberof! oj.ojPopup
    * @instance
    * @private 
    * @return {void}
    */
    _destroyTail : function ()
    {

      var tail = this._getTail();
      if (tail)
        tail.remove();

      delete this._tailId;

      var tailDecoration = this.options['tail'];
      var rootStyle = this._getRootStyle();
      var tailStyle = [rootStyle, "tail", tailDecoration].join("-");

      var rootElement = this._rootElement;
      oj.Assert.assertPrototype(rootElement, jQuery);
      rootElement.removeClass(tailStyle);
    },
   /**
    * @memberof! oj.ojPopup
    * @instance
    * @private 
    * @param {string} chrome option value
    * @return {void}
    */
    _setChrome : function (chrome)
    {
      var chromeDecoration = (chrome ? chrome : this.options["chrome"]);
      var noChromeStyle = [this._getRootStyle(), "no-chrome"].join("-");
      var rootElement = this._rootElement;
      oj.Assert.assertPrototype(rootElement, jQuery);

      if ("default" === chromeDecoration && rootElement.hasClass(noChromeStyle))
        rootElement.removeClass(noChromeStyle);
      else if ("none" === chromeDecoration && !rootElement.hasClass(noChromeStyle))
        rootElement.addClass(noChromeStyle);
    },
   /**
    * @memberof! oj.ojPopup
    * @instance
    * @private 
    * @param {string|Node|jQuery|null} launcher provided when the popup is open
    * @return {void}
    */
    _setLauncher: function (launcher)
    {
      if (!launcher)
        launcher = $(document.activeElement);
      else if ($.type(launcher) === "string")//id jquery selector    
        launcher = $(launcher);
      else if (launcher.nodeType !== 1)//dom element
        launcher = $(launcher);

      // if a jquery collection, select the first dom node not in the popups content
      if (launcher instanceof jQuery && launcher.length > 1)
      {
        var rootElement = this._rootElement;
        oj.Assert.assertPrototype(rootElement, jQuery);

        for (var i = 0;i < launcher.length;i++)
        {
          var target = launcher[0];
          //if (rootElement.has(target).length === 0) {
          if (!oj.DomUtils.isAncestorOrSelf(rootElement[0], target))
          {
            launcher = $(target);
            break;
          }
        }
      }
      else if (!(launcher instanceof jQuery) || //object is not a jq
               ((launcher instanceof jQuery) && launcher.length === 0))// empty jq collection
        launcher = $(document.activeElement);

      oj.Assert.assertPrototype(launcher, jQuery);
      this._launcher = launcher;
    },
   /**
    * @memberof! oj.ojPopup
    * @instance
    * @private 
    * @param {?Object} position object set as an option or passed as an argument to the open method.
    * @return {void}
    */
    _setPosition : function (position)
    {

      var options = this.options;

      // new postion extends the existing object
      if (position)
        options["position"] = $.extend(options[position], position);

      // grab the updated postion
      position = options["position"];

      var usingCallback = this._usingCallback;
      oj.Assert.assertFunction(usingCallback);

      // if they provided a using function that is not our callback, stash it
      // away so that we can delegate to it in our proxy.
      if ($.isFunction(position["using"]) && position["using"] !== usingCallback)
        position["origUsing"] = position["using"];

      // override with our proxy to handle positioning of the tail
      position["using"] = usingCallback;

      //override "of" alignment node to the launcher if not specified
      var launcher = this._launcher;
      oj.Assert.assertPrototype(launcher, jQuery);

      if (!position["of"])
      {
        position["of"] = launcher;
        position["_ofo"] = true;
      }
    },
   /**
    * @memberof! oj.ojPopup
    * @instance
    * @private 
    * @param {Object} pos "my" element associated with the postion object
    * @param {Object} props directions as to where the element should be moved
    * @return {void}
    */
    _usingHandler : function (pos, props)
    {
      var rootElement = props["element"]["element"];
      oj.Assert.assertPrototype(rootElement, jQuery);

      var tail = this._getTail();
      if (!tail)
      {
        rootElement.css(pos);
        return;
      }

      tail.hide();

      for (var i = 0;i < _TAIL_STYLES.length;i++)
      {
        tail.removeClass(_TAIL_STYLES[i]);
        rootElement.removeClass(_TAIL_STYLES[i]);
      }
      tail.removeAttr("style");

      var alignMnemonic = [props["horizontal"], props["vertical"]].join("-");
      var tailStyle = _TAIL_ALIGN_RULES[alignMnemonic];
      oj.Assert.assertString(tailStyle);
      tail.addClass(tailStyle);
      rootElement.addClass(tailStyle);
      tail.show();

      // adjust the vertical and horizontal positioning to account for the tail
      // so that the page developer doesn't have to factor that in
      if ("left" === props["horizontal"] || "right" === props["horizontal"])
      {
        var tailHOffset = (tail.outerWidth() - 1) * ("left" === props["horizontal"] ? 1 :  - 1);
        pos["left"] = pos["left"] + tailHOffset;
      }
      else if ("center" === props["horizontal"])
      {
        var tailVOffset = (tail.outerHeight() - 1) * ("top" === props["vertical"] ? 1 :  - 1);
        pos["top"] = pos["top"] + tailVOffset;
      }
      rootElement.css(pos);

      // adjustments to the vertical or horizontal centering.  The 50% alignment is from
      // the edge of the tail versus the center of the image.  The tail can't be located
      // at cetner, middle so the vertical alignment wins.
      if ("middle" === props["vertical"])
      {
        var rootHeight = rootElement.height();
        var topPercent = Math.round((((rootHeight / 2) - (tail.outerHeight() / 2)) / rootHeight) * 100);
        tail.css(
        {
          top : topPercent + '%'
        });
      }
      else if ("center" === props["horizontal"])
      {
        var rootWidth = rootElement.width();
        var leftPercent = Math.round((((rootWidth / 2) - (tail.outerWidth() / 2)) / rootWidth) * 100);
        tail.css(
        {
          left : leftPercent + '%'
        });
      }

      var options = this.options;
      var origUsing = options["position"]["origUsing"];
      if (origUsing)
        origUsing(pos, props);
    },
   /**
    * @memberof! oj.ojPopup
    * @instance
    * @private 
    * @param {jQuery=} event jQuery event triggered from a window resize
    * @return {void}
    */
    _resizeHandler : function (event)
    {
      var rootElement = this._rootElement;
      oj.Assert.assertPrototype(rootElement, jQuery);

      var position = this.options["position"];
      oj.Assert.assertObject(position);

      var isRtl = this._GetReadingDirection() === "rtl";
      rootElement.position(oj.PositionUtils.normalizeHorizontalAlignment(position, isRtl));
    },
   /**
    * @memberof! oj.ojPopup
    * @instance
    * @private 
    * @param {?boolean} skipOptionCheck focus established via keyboard versus from open API
    * @return {void}
    */
    _intialFocus : function (skipOptionCheck)
    {
      var options = this.options;
      if (!skipOptionCheck && "none" === options["initialFocus"])
        return;

      if (skipOptionCheck || "firstFocusable" === options["initialFocus"])
      {
        var nodes = this.element.find(":focusable");
        if (nodes.length > 0)
        {
          var first = nodes[0];
          oj.Assert.assertDomElement(first);
          $(first).focus();
        }
        else
        {
          var rootElement = this._rootElement;
          oj.Assert.assertPrototype(rootElement, jQuery);
          rootElement.attr("tabindex", "-1");
          rootElement.focus();
        }

        this._trigger("focus");
      }
    },
   /**
    * @memberof! oj.ojPopup
    * @instance
    * @private 
    * @param {Element} activeElement from the event being handled
    * @return {boolean} <code>true</code> if the active element is within the content of the popup
    */
    _isFocusInPopup : function (activeElement)
    {
      if (!activeElement)
        activeElement = document.activeElement;
      oj.Assert.assertDomElement(activeElement);

      var rootElement = this._rootElement;
      oj.Assert.assertPrototype(rootElement, jQuery);

      // return rootElement.is(activeElement) || rootElement.has(activeElement).length > 0;
      return oj.DomUtils.isAncestorOrSelf(rootElement[0], activeElement);
    },
   /**
    * @memberof! oj.ojPopup
    * @instance
    * @private 
    * @param {Element} activeElement from the event being handled
    * @return {boolean} <code>true</code> if the active element the launcher or a decedent of the launcher
    */
    _isFocusInLauncher : function (activeElement)
    {
      if (!activeElement)
        activeElement = document.activeElement;
      oj.Assert.assertDomElement(activeElement);

      var launcher = this._launcher;
      oj.Assert.assertPrototype(launcher, jQuery);

      // return launcher.is(activeElement) || launcher.has(activeElement).length > 0;
      return oj.DomUtils.isAncestorOrSelf(launcher[0], activeElement);
    },
   /**
    * @memberof! oj.ojPopup
    * @instance
    * @private 
    * @return {void}
    */
    _restoreFocus : function ()
    {

      if (this._isFocusInPopup())
      {
        var launcher = this._launcher;
        oj.Assert.assertPrototype(launcher, jQuery);

        launcher.focus();
      }
    },
   /**
    * @memberof! oj.ojPopup
    * @instance
    * @private 
    * @param {jQuery.Event|Event} event jquery event wrapper
    * @return {void}
    */
    _keydownHandler : function (event)
    {
      if (event.isDefaultPrevented())
        return;

      var target = event.target;
      oj.Assert.assertDomElement(target);
      if (event.keyCode === 27)
      {
        event.preventDefault();
        this.close();
      }
      else if (event.keyCode === 117)
      {
        //F6 - toggle focus to launcher or popup
        if (this._isFocusInPopup(target))
        {
          event.preventDefault();
          var launcher = this._launcher;
          oj.Assert.assertPrototype(launcher, jQuery);
          launcher.focus();
        }
        else if (this._isFocusInLauncher(target))
        {
          event.preventDefault();
          this._intialFocus(true);
        }
      }
      else if (event.keyCode === 9 && this._isFocusInPopup(target))
      {
        // TAB within popup
        var nodes = this.element.find(":tabbable");
        if (nodes.length > 0)
        {
          var firstNode = nodes[0];
          oj.Assert.assertDomElement(firstNode);

          var lastNode = nodes[nodes.length - 1];
          oj.Assert.assertDomElement(lastNode);

          if (firstNode === target && event.shiftKey)
          {
            //tabbing backwards, cycle focus to last node
            event.preventDefault();
            $(lastNode).focus();
          }
          else if (lastNode === target && !event.shiftKey)
          {
            //tabbing forwards, cycle to the first node
            event.preventDefault();
            $(firstNode).focus();
          }
        }
      }
    },
   /**
    * @memberof! oj.ojPopup
    * @instance
    * @private 
    * @param {string|null} autoDismiss option value
    * @return {void}
    */
    _setAutoDismiss : function (autoDismiss)
    {

      var documentElement = document.documentElement;
      // unregister any existing handlers, might need to add mouseOut in the future
      var focusLossCallback = this._focusLossCallback;
      if (focusLossCallback)
      {
        documentElement.removeEventListener("mousedown", focusLossCallback, true);
        documentElement.removeEventListener("focus", focusLossCallback, true);
        delete this._focusLossCallback;
      }

      if ("focusLoss" === autoDismiss)
      {
        focusLossCallback = this._focusLossCallback = $.proxy(this._dismissalHandler, this);
        documentElement.addEventListener("mousedown", focusLossCallback, true);
        documentElement.addEventListener("focus", focusLossCallback, true);
      }
    },
   /**
    * @memberof! oj.ojPopup
    * @instance
    * @private 
    * @param {Object} event native dom
    * @return {void}
    */
    _dismissalHandler : function (event)
    {
      var launcher = this._launcher;
      var rootElement = this._rootElement;
      oj.Assert.assertPrototype(launcher, jQuery);
      oj.Assert.assertPrototype(rootElement, jQuery);

      var target = event.target;
      oj.Assert.assertDomElement(target);

      // if event target is not under the laucher or popup root dom subtrees, dismiss
      if (!oj.DomUtils.isAncestorOrSelf(launcher[0], target) && !oj.DomUtils.isAncestorOrSelf(rootElement[0], target))
        this.close();
    },
   /**
    * @memberof! oj.ojPopup
    * @instance
    * @private 
    * @return {void}
    */
    _addDescribedBy: function () 
    {
      var launcher = this._launcher;
      var rootElement = this._rootElement;
      oj.Assert.assertPrototype(launcher, jQuery);
      oj.Assert.assertPrototype(rootElement, jQuery);

      var popupId = rootElement.attr("id");
      var describedby = launcher.attr("aria-describedby");
      var tokens = describedby ? describedby.split(/\s+/) : [];
      tokens.push(popupId);
      describedby = $.trim(tokens.join(" "));
      launcher.attr("aria-describedby", describedby);
    },
   /**
    * @memberof! oj.ojPopup
    * @instance
    * @private 
    * @return {void}
    */
    _removeDescribedBy: function() {
      var launcher = this._launcher;
      var rootElement = this._rootElement;
      oj.Assert.assertPrototype(launcher, jQuery);
      oj.Assert.assertPrototype(rootElement, jQuery);

      var popupId = rootElement.attr("id");
      var describedby = launcher.attr("aria-describedby");
      var tokens = describedby ? describedby.split(/\s+/) : [];
      var index = $.inArray(popupId, tokens);
      if (index !== -1)
        tokens.splice(index, 1);

      describedby = $.trim(tokens.join(" "));
      if (describedby)
        launcher.attr("aria-describedby", describedby);
      else
        launcher.removeAttr("aria-describedby");
    },
   /**
    * @memberof! oj.ojPopup
    * @instance
    * @private 
    * @return {void}
    */
    _createLiveRegion: function()
    {
      var rootElement = this._rootElement;
      oj.Assert.assertPrototype(rootElement, jQuery);

      // append the aria-live region communicating navigation keys
      var popupId = rootElement.attr("id");
      var liveRegionId = this._getSubId("ariaLive");
      var liveRegion = this._liveRegion = $( "<div>" );
      liveRegion.attr({'id': liveRegionId, 'role': 'log', 'aria-live': 'assertive', 'aria-relevant': 'additions'});
      liveRegion.addClass("oj-helper-hidden-accessible");
      liveRegion.appendTo(document.body);
      rootElement.attr("aria-controls", liveRegionId);
    },
   /**
    * @memberof! oj.ojPopup
    * @instance
    * @private 
    * @param {string} message to be announced in the live region
    * @return {void}
    */
    _announceLiveRegion: function(message)
    {
      var liveRegion = this._liveRegion;
      oj.Assert.assertPrototype(liveRegion, jQuery);
      liveRegion.children().remove();
      $("<div>").text(message).appendTo(liveRegion);
    },
   /**
    * @memberof! oj.ojPopup
    * @instance
    * @private 
    * @return {void}
    */
    _destroyLiveRegion: function()
    {
      var liveRegion = this._liveRegion;
      oj.Assert.assertPrototype(liveRegion, jQuery);
      liveRegion.remove();
      delete this._liveRegion;

      var rootElement = this._rootElement;
      oj.Assert.assertPrototype(rootElement, jQuery);
      rootElement.removeAttr("aria-controls");
    },
   /**
    * @memberof! oj.ojPopup
    * @instance
    * @private 
    * @param {string} sub id that will become a composite id prefixed with the components uuid
    * @return {string}
    */
    _getSubId: function(sub)
    {
      return this["uuid"] + "_" + sub;
    }
  });

}
());
/**
 * @class 
 * @name oj.ojRowExpander
 * @augments oj.baseComponent
 *
 * @classdesc
 * <h3 id="rowexpanderOverview-section">
 *   JET DataGrid Component
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#rowexpanderOverview-section"></a>
 * </h3>
 * <p>Description: A JET RowExpander is a component that is primarily used inside the JET Table and JET DataGrid widgets.  It enables hierarchical data to be display in a JET Table and JET DataGrid.</p>
 *
 * <p>To enable expand and collapse of rows, developers must specify oj.FlattenedTreeTableDataSource as data when used within JET Table and oj.FlattenedTreeDataGridDataSource as data when used within JET DataGrid.</p>
 *
 * <h3 id="keyboard-section">
 *   Keyboard interaction
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
 * </h3>
 * <table class="keyboard-table">
 *   <thead>
 *     <tr>
 *       <th>Key</th>
 *       <th>Use</th>
 *     </tr>
 *   </thead>
 *   <tbody>
 *     <tr>
 *       <td><kbd>Ctrl+Right Arrow</kbd></td>
 *       <td>Expand the currently focused row that contains a row expander.</td>
 *     </tr>
 *     <tr>
 *       <td><kbd>Ctrl+Left Arrow</kbd></td>
 *       <td>Collapse the currently focused row that contains a row expander.</td>
 *     </tr>
 *   </tbody>
 * </table>
 *
 * <h3 id="rtl-section">
 *   Reading direction
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#rtl-section"></a>
 * </h3>
 * 
 * <p>The location of the row expander will be reversed in RTL reading direction.</p>
 * <p>As with any JET component, in the unusual case that the directionality (LTR or RTL) changes post-init, the component containing the row expander (JET Table or JET DataGrid) must be <code class="prettyprint">refresh()</code>ed.  
 */
oj.__registerWidget('oj.ojRowExpander', $['oj']['baseComponent'],
{
    version: "1.0.0",
    widgetEventPrefix: 'oj',
    options:
            {
                /**
                 * The context object obtained from the column renderer (Table) or cell renderer (DataGrid)
                 * 
                 * @expose 
                 * @memberof! oj.ojRowExpander
                 * @instance
                 * @type {Object}
                 * @default <code class="prettyprint">null</code>
                 * 
                 */
                context: null,
                /**
                 * The number of pixels to indent for each level
                 * 
                 * @expose 
                 * @memberof! oj.ojRowExpander
                 * @instance
                 * @type {number}
                 * @default <code class="prettyprint">10</code>
                 * 
                 */
                indent: 10,
                /**
                 * Triggered when a expand is performed on the row expander
                 *
                 * @expose 
                 * @event 
                 * @memberof! oj.ojRowExpander
                 * @instance
                 * @property {Event} event <code class="prettyprint">jQuery</code> event object
                 * 
                 * @example <caption>Initialize the row expander with the <code class="prettyprint">expand</code> callback specified:</caption>
                 * $( ".selector" ).ojRowExpander({
                 *     "expand": function( event, ui ) {}
                 * });
                 *
                 * @example <caption>Bind an event listener to the <code class="prettyprint">ojexpand</code> event:</caption>
                 * $( ".selector" ).on( "ojexpand", function( event, ui ) {} );
                 */
                expand: null,
                /**
                 * Triggered when a collapse is performed on the row expander
                 *
                 * @expose 
                 * @event 
                 * @memberof! oj.ojRowExpander
                 * @instance
                 * @property {Event} event <code class="prettyprint">jQuery</code> event object
                 * 
                 * @example <caption>Initialize the row expander with the <code class="prettyprint">collapse</code> callback specified:</caption>
                 * $( ".selector" ).ojRowExpander({
                 *     "collapse": function( event, ui ) {}
                 * });
                 *
                 * @example <caption>Bind an event listener to the <code class="prettyprint">ojcollapse</code> event:</caption>
                 * $( ".selector" ).on( "ojcollapse", function( event, ui ) {} );
                 */
                collapse: null
            },
    classNames:
            {
                'root': 'oj-rowexpander',
                'icon': 'oj-component-icon',
                'clickable': 'oj-clickable-icon',
                'expand': 'oj-rowexpander-expand-icon',
                'collapse': 'oj-rowexpander-collapse-icon',
                'leaf': 'oj-rowexpander-leaf-icon',
                'lazyload': 'oj-rowexpander-lazyload-icon'
            },
    /**
     * Create the row expander
     * @memberof! oj.ojRowExpander
     * @private
     */
    _create: function()
    {
        this._super();
        this.element.addClass(this.classNames['root']);
    },
    /**
     * Initialize the row expander
     * @memberof! oj.ojRowExpander
     * @private
     */
    _init: function()
    {
        var self = this, context;
        this._super();
        this._addIcon();
        
        context = this.options['context'];
        this.component = context['component'];
        this.datasource = context['datasource'];

        //root hidden so subtract 1
        this.indentation = (context['depth'] - 1) * this.options['indent'];
        this.iconState = context['state'];
        this.rowKey = context['key'];

        // description of row expander for screen reader
        this.desc = this.getTranslatedString('accessibleRowDescription', {'level': context['depth'], 'num': context['index']+1, 'total': this.datasource.getWrappedDataSource().getChildCount(context['parentKey'])});

        this._setIndentationWidth();
        this._setIconStateClass();

        if (this.iconState === 'expanded' || this.iconState === 'collapsed')
        {
            $(this.icon).on('click', function() {
                self._fireExpandCollapse();
            });
            $(this.element).on('keypress', function(event) {
                var code = event.keyCode || event.which;
                if (code === $.ui.keyCode.ENTER || $.ui.keyCode.SPACE)
                {
                    self._fireExpandCollapse();
                }
            });

            // listen for key down event from host component
            if (this.component != null)
            {
                this.handleKeyDownCallback = this._handleKeyDownEvent.bind(this);
                $(this.component.element).on('ojkeydown', this.handleKeyDownCallback);
            }

            // listens for expand and collapse event from flattened datasource
            // this could be due to user clicks, keyboard shortcuts or programmatically
            if (this.datasource != null)
            {
                this.handleExpandCallback = this._handleExpandEvent.bind(this);
                this.handleCollapseCallback = this._handleCollapseEvent.bind(this);

                this.datasource.on("expand", this.handleExpandCallback, this);
                this.datasource.on("collapse", this.handleCollapseCallback, this);
            }
        }

        // listen for active key change event from host component
        if (this.component != null)
        {
            this.handleActiveKeyChangeCallback = this._handleActiveKeyChangeEvent.bind(this);
            $(this.component.element).on('ojactive', this.handleActiveKeyChangeCallback);
        }
    },
    /**
     * Refresh the row expander having made external modifications
     *      
     * <p>This method does not accept any arguments.
     * 
     * @expose 
     * @memberof! oj.ojRowExpander
     * @instance
     * 
     * @example <caption>Invoke the <code class="prettyprint">refresh</code> method:</caption>
     * $( ".selector" ).ojRowExpander( "refresh" );
     */
    refresh: function()
    {
        this.element.empty();
        this._init();
    },
    /**
     * destroy the row expander
     *      
     * <p>This method does not accept any arguments.
     * 
     * @expose 
     * @memberof! oj.ojRowExpander
     * @instance
     * @private     
     * @example <caption>Invoke the <code class="prettyprint">refresh</code> method:</caption>
     * $( ".selector" ).ojRowExpander( "destroy" );
     */
    _destroy: function()
    {
        // unregister keydown and active key change handlers
        if (this.component != null)
        {
            $(this.component.element).off('ojkeydown', this.handleKeyDownCallback);
            $(this.component.element).off('ojactive', this.handleActiveKeyChangeCallback);
        }

        // unregister expand/collapse events
        if (this.datasource != null)
        {
            this.datasource.off("expand", this.handleExpandCallback, this);
            this.datasource.off("collapse", this.handleCollapseCallback, this);
        }

        this.removeClass(this.classNames['root']);
        this.element.empty();
    },
    /**
     * Add an icon to the row expander with appropriate class names for a clickable icon.
     * @private	 
     */
    _addIcon: function()
    {
        this.icon = $('<a></a>').addClass(this.classNames['icon']).addClass(this.classNames['clickable']);
        this.element.append(this.icon);
    },
    /**
     * Add a class name on the icon
     * @private	 
     * @param {string} classKey the key of the appropriate icon class expand/collapse/leaf
     */
    _addIconClass: function(classKey)
    {
        this.icon.addClass(this.classNames[classKey]);
    },
    /**
     * Remove a class name on the icon
     * @private
     * @param {string} classKey the key of the appropriate icon class expand/collapse/leaf
     */
    _removeIconClass: function(classKey)
    {
        this.icon.removeClass(this.classNames[classKey]);
    },
    /**
     * Set the icon class to the the iconState property
     * @private
     */
    _setIconStateClass: function()
    {
        switch (this.iconState)
        {
            case 'leaf':
                this._addIconClass('leaf');
                break;
            case 'collapsed':
                this._addIconClass('expand');
                this._ariaExpanded(false);
                break;
            case 'expanded':
                this._addIconClass('collapse');
                this._ariaExpanded(true);
                break;
        }

    },
    /**
     * Removes the icon class of the iconState property
     * @private
     */
    _removeIconStateClass: function()
    {
        switch (this.iconState)
        {
            case 'leaf':
                this._removeIconClass('leaf');
                break;
            case 'collapsed':
                this._removeIconClass('expand');
                break;
            case 'expanded':
                this._removeIconClass('collapse');
                break;
        }

    },
    /**
     * Handles active key change event from host component (ojDataGrid or ojTable)
     * @param {Event} event
     * @param {Object} ui
     * @private
     */
    _handleActiveKeyChangeEvent: function(event, ui)
    {
        var rowKey, message;

        if (ui['activeKey'] != null)
        {
            rowKey = ui['activeKey']['rowKey'];
            // if the event is for this row and the active key change event is triggered
            // by row change and not column change
            if (this.rowKey === rowKey && (ui['previousActiveKey'] == null || ui['previousActiveKey']['row'] != ui['activeKey']['row']))
            {   
                // if the component allows AccessibleContext to be set
                if (this.component._setAccessibleContext)
                {
                    this.component._setAccessibleContext({'message': this.desc});
                }
            }
        }
    },
    /**
     * Handles keydown event from host component (ojDataGrid or ojTable)
     * @param {Event} event
     * @param {Object} ui
     * @private
     */
    _handleKeyDownEvent: function(event, ui)
    {
        var rowKey, code;

        rowKey = ui['rowKey'];
        if (this.rowKey === rowKey)
        {
            code = event.keyCode || event.which;
            // ctrl (or equivalent) is pressed
            if (event.ctrlKey)
            {
                // Ctrl+Right expands, Ctrl+Left collapse in accordance with WAI-ARIA best practice
                // consume the event as it's processed
                if (code == $.ui.keyCode.RIGHT)
                {
                    this.datasource.expand(this.rowKey);
                }
                else if (code == $.ui.keyCode.LEFT)
                {
                    this.datasource.collapse(this.rowKey);
                }
            }
        }
    },
    /**
     * Handle an expand event coming from the datasource, 
     * update the icon and the aria-expand property
     * @private
     */
    _handleExpandEvent: function(event)
    {
        var rowKey = event['rowKey'];
        if (rowKey === this.rowKey)
        {
            this._removeIconStateClass();
            this.iconState = 'expanded';
            this._setIconStateClass();
            this._ariaExpanded(true);
            this._trigger('expand');
        }
    },
    /**
     * Handle a collapse event coming from the datasource, 
     * update the icon and the aria-expand property
     * @private
     */
    _handleCollapseEvent: function(event)
    {
        var rowKey = event['rowKey'];
        if (rowKey === this.rowKey)
        {
            this._removeIconStateClass();
            this.iconState = 'collapsed';
            this._setIconStateClass();
            this._ariaExpanded(false);
            this._trigger('collapse');        
        }
    },
    /**
     * Fire the expand or collapse on the datasource and the oj event on the widget 
     * @private
     */
    _fireExpandCollapse: function()
    {
        if (this.iconState === 'collapsed')
        {
            this.datasource.expand(this.rowKey);
        }
        else if (this.iconState === 'expanded')
        {
            this.datasource.collapse(this.rowKey);
        }
    },
    /**
     * Sets the indentation width to the original width plus the indentation
     * @private
     */
    _setIndentationWidth: function()
    {
        if (this._GetReadingDirection() === "rtl")
        {
            this.element.width((this.element.width() + this.indentation) + 'px');
        }
        else
        {
            this.element.width((this.element.width() + this.indentation) + 'px');
        }
    },
    /**
     * Sets the icon's aria-expanded property to the boolean passed in
     * @param {boolean|null} bool true if expanded false if not
     * @private
     */
    _ariaExpanded: function(bool)
    {
        this.icon.attr('aria-expanded', bool);
    }
});

(function() { // Toolbar wrapper function, to keep "private static members" private

/**
 * @class
 * @name oj.ojToolbar
 * @augments oj.baseComponent
 * 
 * @classdesc
 * <h3 id="toolbarOverview-section">
 *   JET Toolbar Component
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#toolbarOverview-section"></a>
 * </h3>
 * 
 * <p>Description: Themeable, WAI-ARIA-compliant toolbar component.
 * 
 * <p>The JET Toolbar component can contain [JET Buttons]{@link oj.ojButton}, [JET Buttonsets]{@link oj.ojButtonset}, and non-focusable content 
 * such as separator icons.  Toolbar provides WAI-ARIA-compliant focus management.
 * 
 * <p>A toolbar that contains radios should contain all radios in the radio group.
 * 
 * 
 * <h3 id="keyboard-section">
 *   Keyboard interaction and Focus management
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
 * </h3>
 * 
 * <p>JET Toolbar manages its own focus.  It maintains a single tabstop, with arrow-key navigation within the toolbar.  This navigation 
 * skips disabled buttons, wraps around at the end, and adjusts correctly in RTL.
 * 
 * <p> When tabbing back into the toolbar, focus goes to the most recently focused button.  (To address a browser limitation, if that button is an 
 * unchecked radio having a checked groupmate, the latter is focused instead.)
 * 
 * <p>As with any JET Button, buttons in a toolbar are activated with <kbd>Enter</kbd> or <kbd>Spacebar</kbd>.  
 * 
 * <p>Any buttonsets placed in the toolbar should have <code class="prettyprint">focusManagement</code> set to <code class="prettyprint">"none"</code>, 
 * so as not to compete with the toolbar's focus management.  
 * 
 * <p>The application should not do anything to interfere with the focus management.  E.g. it should not set the <code class="prettyprint">tabindex</code> of the buttons, or 
 * do anything that prevents enabled buttons from being a tabstop.  Also, enabled buttons should remain user-visible, without which arrow-key
 * navigation to the button would cause the focus to seemingly disappear.
 * 
 * 
 * <h3 id="a11y-section">
 *   Accessibility
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
 * </h3>
 * 
 * <p>JET Toolbar takes care of focus management, as noted above, and setting <code class="prettyprint">role="toolbar"</code> on the toolbar element.  
 * 
 * <!-- TODO: REVIEW WHETHER ANY PART OF THE FOLLOWING BUTTONSET VERBIAGE WAS RELEVANT TO TOOLBAR, AND UPATE ACCORDINGLY
 * 
 * <p>In addition, as shown in the online demos, the application is responsible for applying <code class="prettyprint">aria-label</code> and/or 
 * <code class="prettyprint">aria-controls</code> attributes like the following to the buttonset element, if applicable per the instructions that follow:
 * 
 * <pre class="prettyprint">
 * <code>aria-label="Choose only one beverage.  Use left and right arrow keys to navigate."
 * aria-controls="myTextEditor"
 * </code></pre>
 * 
 * <p>A sentence like the first is appropriate for a buttonset consisting of a radio group, in order to convey the "select one" semantics 
 * to AT users.  It should be omitted for checkboxes and push buttons.
 * 
 * <p>The second sentence lets the user know how to navigate.  It should be omitted if the buttonset's focus management is overridden 
 * by another component such as a containing Toolbar. (Note that Buttonsets inside Toolbars are not yet supported in v0.5.)
 * 
 * <p>The <code class="prettyprint">aria-controls</code> attribute is appropriate if the buttonset is controlling something else on the page, e.g. 
 * bold/italic/underline buttons controlling a rich text editor.  
 * 
 * END OF TODO - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
 * 
 * 
 * <h3 id="rtl-section">
 *   Reading direction
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#rtl-section"></a>
 * </h3>
 * 
 * <p>As with any JET component, in the unusual case that the directionality (LTR or RTL) changes post-init, the toolbar must be <code class="prettyprint">refresh()</code>ed.  
 * 
 * 
 * <h3 id="pseudos-section">
 *   Pseudo-selectors
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#pseudos-section"></a>
 * </h3>
 * 
 * <p>The <code class="prettyprint">:oj-toolbar</code> pseudo-selector can be used in jQuery expressions to select JET Toolbars.  For example:
 * 
 * <pre class="prettyprint">
 * <code>$( ":oj-toolbar" ) // selects all JET Toolbars on the page
 * $myEventTarget.closest( ":oj-toolbar" ) // selects the closest ancestor that is a JET Toolbar
 * </code></pre>
 * 
 * <!-- 
 * <h3 id="binding-section">
 *   Declarative Binding
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#binding-section"></a>
 * </h3>
 * 
 * <p>For components like Toolbar and Menu that contain a number of like items, applications may wish to use a <code class="prettyprint">foreach</code> Knockout binding 
 * to stamp out the contents.  This binding cannot live on the same node as the JET <code class="prettyprint">ojComponent</code> binding, and must instead live on a nested 
 * virtual element as follows:
 * 
 * TODO: COPY EXAMPLE FROM BUTTONSET AND UPDATE 
 * 
 * -->
 * 
 * <h3 id="jqui2jet-section">
 *   JET for jQuery UI developers
 *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#jqui2jet-section"></a>
 * </h3>
 * 
 * <ol>
 *   <li>All JQUI and JET components inherit <code class="prettyprint">disable()</code> and <code class="prettyprint">enable()</code> methods from the base class.  This API 
 *       duplicates the functionality of the <code class="prettyprint">disabled</code> option.  In JET, to keep the API as lean as possible, we 
 *       have chosen not to document these methods outside of this section.</li>
 * </ol>
 * 
 * <p>Also, event names for all JET components are prefixed with "oj", instead of component-specific prefixes like "toolbar" or "menu".  
 * E.g. if JQUI had a toolbar component, and if it followed the usual pattern, then it would have a <code class="prettyprint">toolbarcreate</code> 
 * event, while JET's is called <code class="prettyprint">ojcreate</code>, as shown in the doc for that event.
 * Reason:  This makes the API more powerful.  It allows apps to listen to "foo" events from <em>all</em> JET components via:
 * 
 * <pre class="prettyprint">
 * <code>$( ".selector" ).on( "ojfoo", myFunc);
 * </code></pre>
 * 
 * or to "foo" events only from JET Toolbars (the JQUI functionality) via:
 * 
 * <pre class="prettyprint">
 * <code>$( ".selector" ).on( "ojfoo", ":oj-toolbar", myFunc);
 * </code></pre>
 * 
 * 
 * <!-- - - - - Above this point, the tags are for the class.
 *              Below this point, the tags are for the constructor (initializer). - - - - - - -->
 * 
 * 
 * @desc Creates a JET Toolbar.  If called after the toolbar is already created, is equivalent to the 
 * "set many options" overload of <code class="prettyprint">option()</code>.  
 * 
 * @param {Object=} options a map of option-value pairs to set on the component
 * 
 * @example <caption>Initialize the toolbar with no options specified:</caption>
 * $( ".selector" ).ojToolbar();
 * 
 * @example <caption>Initialize the toolbar with some options and callbacks specified:</caption>
 * $( ".selector" ).ojToolbar( { "disabled": true, "create": function( event, ui ) {} } );
 * 
 * @example <caption>Initialize the toolbar via the JET <code class="prettyprint">ojComponent</code> binding:</caption>
 * &lt;div id="beverages" data-bind="ojComponent: { component: 'ojToolbar', 
 *                                               disabled: true, 
 *                                               create: setupToolbar }">
 */
oj.__registerWidget("oj.ojToolbar", $['oj']['baseComponent'], {
    version: "1.0.0", // TODO: doesn't get renamed even when unquoted and not in (our) externs.js file, so I'm leaving it for now.  Is it used anywhere, e.g. build tool?  If so, should prob quote or extern or something.  If not, should it get moved to @version (if that exists) or similar, or just remove, or...?
    
    _items: "button, input[type=button], input[type=submit], input[type=reset], input[type=checkbox], input[type=radio], a",
    
    widgetEventPrefix : "oj", 

    options: { // options is in externs.js.  TODO: same as other prototype fields.
        /**
         * The exact semantics of disabling a toolbar is currently under review.
         * 
         * @member
         * @name disabled
         * @memberof! oj.ojToolbar
         * @instance
         * @type {boolean}
         * @default <code class="prettyprint">false</code>
         * 
         * @example <caption>Initialize the toolbar with the <code class="prettyprint">disabled</code> option specified:</caption>
         * $( ".selector" ).ojToolbar( { "disabled": true } );
         * 
         * @example <caption>Get or set the <code class="prettyprint">disabled</code> option, after initialization:</caption>
         * // getter (does not reflect changes made directly to the buttons)
         * var disabled = $( ".selector" ).ojToolbar( "option", "disabled" );
         * 
         * // setter
         * $( ".selector" ).ojToolbar( "option", "disabled", true );
         */
        // disabled option declared in superclass, but we still want the above API doc

        // Events
        
        /**
         * Triggered when the toolbar is created.
         *
         * @event 
         * @name create
         * @memberof! oj.ojToolbar
         * @instance
         * @property {Event} event <code class="prettyprint">jQuery</code> event object
         * @property {Object} ui Empty object included for consistency with other events
         * 
         * @example <caption>Initialize the toolbar with the <code class="prettyprint">create</code> callback specified:</caption>
         * $( ".selector" ).ojToolbar({
         *     "create": function( event, ui ) {}
         * });
         * 
         * @example <caption>Bind an event listener to the <code class="prettyprint">ojcreate</code> event:</caption>
         * $( ".selector" ).on( "ojcreate", function( event, ui ) {} );
         */
        // create event declared in superclass, but we still want the above API doc
    },

    _create: function() { // Override of protected base class method.  Method name needn't be quoted since is in externs.js.
        this.element
            .addClass( "oj-toolbar oj-component" )
            .attr( "role", "toolbar" );

        // call _setup from _create, not _init, so create listeners (called after _create before _init) see a fully inited component.
        // We don't implement _init at all, since it's intended to perform startup behaviors like autoOpen, 
        // not initing state or performing a refresh, and we have no such startup behaviors.
        this._setup(true);
        
        this._super(); // TODO: call this at beginning of method.  This will happen as part of the JET create-time refactoring.
    },

    /* 
     * Component developers: This API and functionality is subject to change pending architectural review!
     * See the baseComponent method for preliminary API doc.
     */
    _showContextMenu: function(menu, event)
    {
      menu.show(event, {"launcher": this.element.find(":oj-button[tabindex=0]"), "focus": "menu"});
    },

    _setOption: function( key, value ) { // Override of protected base class method.  Method name needn't be quoted since is in externs.js.
        // TODO: TOOLBAR IS LESS TIGHTLY BOUND TO ITS CONTENTS THAN BUTTONSET.  POST-V1, IT CAN CONTAIN MUCH MORE THAN JUST 
        //       BUTTONS.  DO WE WANT TO GO DOWN THE PATH WHERE IT IS EXPECTED TO BE ABLE AND WILLING TO DISABLE ALL ITS CONTENTS?
        //       IF SO, THEN WE SHOULD ADD THE "DISABLED" CODE TO _SETUP THAT WE ADDED TO BUTTONSET.  WE'VE ALREADY DECIDED "NO" FOR 
        //       REFRESH()'ING THE CONTENTS, WHY DISABLE THE CONTENTS?
        if ( key === "disabled" ) {
            this.$buttons.ojButton( "option", key, value );
        }

        this._super( key, value );
    },

    /**
     * Refreshes the toolbar, including the following:
     * 
     * <ul>
     *   <li>Re-applies focus management / keyboard navigation.
     *   <li>Rechecks the reading direction (LTR vs. RTL).
     * </ul>
     * 
     * 
     * <p>A <code class="prettyprint">refresh()</code> is required in the following circumstances:
     * <ul>
     *   <li>After buttons are added to or removed from the toolbar.</li>
     *   <li>After a change to the <code class="prettyprint">disabled</code> status of any of the buttons in the toolbar.</li>
     *   <li>After a programmatic change to the <code class="prettyprint">checked</code> status of a radio button in the toolbar
     *       (which should be done via Buttonset's <code class="prettyprint">checked</code> option).  This applies only to radios, 
     *       not to checkboxes or push buttons.</li>
     *   <li>After the reading direction (LTR vs. RTL) changes.</li>
     * </ul>
     * 
     * <p>This method does not accept any arguments.
     * 
     * @expose 
     * @memberof! oj.ojToolbar
     * @instance
     * 
     * @example <caption>Invoke the <code class="prettyprint">refresh</code> method:</caption>
     * $( ".selector" ).ojToolbar( "refresh" );
     */
    refresh: function() {
        this._super();
        this._setup(false);
    },
    
    _setup: function(isCreate) { // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        var self = this;
        this.isRtl = this._GetReadingDirection() === "rtl";
        
        // When toolbar is binding listeners to buttons, use the Toolbar's eventNamespace, not the Button's 
        // eventNamespace, to facilitate later unbinding only the Toolbar listeners.

        // For checkbox/radio, we're binding to inputs, not labels.

        // Put listeners on every button, b/c it's too unreliable to put them on the toolbar node and rely on event bubbling.
        // - E.g. bubbling doesn't work for antonym buttons (is this still true after the refactoring?) -- see comment on Button._setLabelOption().
        // - Likewise, focus mgmt can't just break if app listener stops propagation.
        // - Both of these problems still happen when using the delegation / selector overload of .on(); there is no special JQ bubbling magic.

        this.$buttons = this.element.find( this._items )
            .unbind( "keydown" + this.eventNamespace )
            .bind( "keydown" + this.eventNamespace, function(event) { 
                self._handleKeyDown(event, $(this)); 
            })
            
            .unbind( "click" + this.eventNamespace )
            .bind( "click" + this.eventNamespace, function(event) {
                if ( !$(this).ojButton("option", "disabled") ) { 
                    // Normally the button will be tabbable after the click, since (a) if we reach here, the clicked button is enabled, and 
                    // (b) an unchecked radio before the click will normally be checked after the click.  But just in case it's unchecked 
                    // (e.g. due to app listener), we let callee run it thru _mapToTabbable() before using, as usual.
                    self._setTabStop( $(this) );
                }
            })
            .unbind( "focus" + this.eventNamespace )
            .bind( "focus" + this.eventNamespace, function(event) { 
                self._setTabStop( $(this) );
            });
        
        // the subset of Toolbar buttons that are enabled.  Disabled buttons are not tabbable.
        this.$enabledButtons = this.$buttons.filter(function(index) {
            return !$( this ).ojButton( "option", "disabled" );
        });
        
        this._initTabindexes(isCreate);
    },
    
    // For create, make only the first enabled button tabbable.  (We decided to have Shift-Tab go to first, not last, button.)
    // For refreshes, keep the existing tabstop if we can, otherwise proceed as with create.
    // Either way, if that button is a radio and some radio in its group is checked, make that one tabbable instead.
    // If there are no enabled buttons, makes them all untabbable.
    // No return value.
    _initTabindexes: function(isCreate) { // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        // even for refreshes where we'll wind up keeping the same tabstop, must make everything untabbable first, to ensure any new buttons become untabbable.
        var $last = $(this._lastTabStop);
        this._lastTabStop = undefined;
        this.$buttons.attr( "tabindex", "-1" );
        var $newTabStop; // callee might map this to radio groupmate
        
        // TBD: for refreshes when $last is a disabled radio with a checked enabled groupmate and they are in the toolbar, the groupmate would be 
        // a valid tabstop, but this defaults to the first.
        if (isCreate || !$last.is(this.$enabledButtons)) {
            // is create, or is refresh but must treat like create b/c $last is empty, or not enabled, or no longer in the toolbar
            $newTabStop = this.$enabledButtons.first(); // if empty (none enabled), no tabstop will be set
        } else {
            // is a refresh, and $last is non-empty and is an enabled button still in the toolbar.  May be a radio whose groupmate
            // has become checked, in which case callee will map it to that groupmate.
            $newTabStop = $last;
        }
        this._setTabStop( $newTabStop );
    },
    
    // For each button in $button (in our usage always 0-1 button hence $button singular), if that button is an unchecked radio 
    // with a checked groupmate (which means it's not tabbable), then map it to the checked one (checked enabled radios are 
    // tabbable, and we know it's enabled per the argument below).
    // 
    // $button contains 0 or more buttons to map.  Must be enabled since disabled buttons aren't tabbable.
    // Returns the mapped JQ object (which the caller will make the tabstop).
    // 
    // We know that this.$enabledButtons contains all buttons in $button, and all of their potentially checked radio-groupmates, since:
    // - The above "enabled" requirement guarantees that $button's contents are all in $enabledButtons.
    // - The prohibition against radio groupmates that are not in the toolbar, and the prohibition against checked disabled groupmates 
    //   of enabled radios, guarantee that if $button is a radio, then all of its potentially checked groupmates are enabled and thus in 
    //   $enabledButtons.
    // 
    // Firefox browser issue:   (TODO: should we doc this?  File FF and/or JET bug?)
    // 
    // When this method maps an unchecked radio to its checked groupmate, the caller ensures that the former still has focus, but the latter
    // is the tabstop for when the user tabs out and back in.  When tabbing / Shift-Tabbing from the unchecked radio in the direction of the 
    // checked one, Chrome and IE9 are smart enough to tab out of the radio group to the adjacent tabstop as desired.  But in FF, focus goes to 
    // the checked one, which is not what we want.
    // 
    // Reason: Chrome and IE9 are smart enough never to tab within a radio group.  If focus is in the radio group, Tab and Shift-Tab exit the radio group.
    // But in FF, [a radio is reachable via Tab/Shift-Tab from within the group] if [it's enabled, tabindex != -1, and either checked or has no 
    // checked groupmates], i.e. [it would be reachable via Tab/Shift-Tab from outside the group if all its groupmates happened to be untabbable 
    // (e.g. disabled)].  In other words, FF is the only one that fails to distinguish between radios that could be valid tabstops from outside, and
    // those that should be valid tabstops from inside.  
    // 
    // This impl improves on the native behavior.  In FF, in an unchecked radio group, every single radio is a tabstop.  Our use of tabindex=-1 
    // guarantees that we never tab within the group in that case.  It's only a checked groupmate that can be tabbed to from within. (So at 
    // most one unwanted tabstop.)
    // 
    // After much time and effort, the latter issue seems to be infeasible to fix in any robust, non-brittle way.  E.g.:
    // - Clearing all tabstops and restoring on tab-out of toolbar:  FF provides no reliable way to find out whether a blur is exiting the entire 
    //   toolbar.  The obvious setTimeout workaround needed to be unacceptably long (e.g. 250ms) and even then was unreliable.  If we ever fail 
    //   to restore the tabstop, the toolbar becomes untabbable and inaccessible.
    // - Every other approach had similar robustness issues. 
    _mapToTabbable: function( $button ) { // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        var $enabledButtons = this.$enabledButtons;
        return $button.map(function(index, elem) {
            // Buttons other than radios, and checked radios, are always tabbable if they're enabled, which this method requires.
            // Radios w/ name="" (incl name omitted) are not in a radio group, not even with other radios with w/ name="".  Radios 
            // with no groupmates are always tabbable, since either they're checked, or they're unchecked with no checked groupmate.
            if (elem.type != "radio" || elem.checked || elem.name == "") { 
                return elem;
            } else {
                // elem is unchecked radio in real (not "") group, which is tabbable iff no groupmate is checked.  Per above doc, we know that 
                // all of its potentially checked groupmates are in $enabledButtons.
                var $checkedRadio = _radioGroup(elem, $enabledButtons).filter(":checked");
                return ($checkedRadio.length ? $checkedRadio[0] : elem);
            }
        });
    },
    
    // Set which button is in the tab sequence.
    // $button should contain 0 or 1 button to be made tabbable (since at most one should be tabbable at a time).
    //   If 0 (i.e. no enabled buttons), all will become untabbable.  If 1, it must be tabbable in every way (e.g. enabled) except possibly 
    //   being an unchecked radio with a checked groupmate, which this method will map to its checked groupmate, which 
    //   we know is enabled thus tabbable since we require that checked radios with enabled groupmates not be disabled.  
    // No return value.
    _setTabStop: function( $button ) { // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
//        if (!window.setTabStopCounter) window.setTabStopCounter=1; // REMOVE, is only for console.log's
//        console.log("in _setTabStop: " + window.setTabStopCounter++ + ".  Orig (premap) button checked: " + $button[0].checked); // + " and is:");
//        console.log($button[0]);
        
        $button = this._mapToTabbable( $button );
        var button = $button[0]; // button is undefined iff $button is empty iff we need to clear all tabstops b/c there are no enabled buttons to make tabbable
        var last = this._lastTabStop; // last is undefined iff $(last) is empty iff there are no existing tabstops to clear (b/c _initTabindexes just ran 
                                      // or previously there were no enabled buttons to make tabbable)
        
//        console.log("mapped button and last button are:");  console.log(button);  console.log(last);  console.log(".");
        
        // Cases: both are undefined: have no tabstops; want to keep it that way (b/c none enabled), so do nothing
        //        both are node X: X is the tabstop; want to keep it that way, so do nothing
        //        last is node X; button is undefined: X is the tabstop; want to clear it w/o replacing it (b/c none enabled).  This logic does that.
        //        last is undefined; button is node X: no existing tabstop; want to make X the tabstop.  This logic does that.
        //        last is node X; button is node Y: X is the tabstop; want to clear it and make Y the tabstop.  This logic does that.
        if ( button !== last) {
            //console.log("setting tab stop to " + $button.attr("id"));  console.log("$(last).length:");  console.log($(last).length);
            
            $(last).attr( "tabindex", "-1" ); // no-op iff $(last) is empty iff (see comment above)
            $button.attr( "tabindex", "0" ); // no-op iff $button is empty iff (see comment above)
            this._lastTabStop = button;
        }
    },
    
    // No return value.
    _handleKeyDown: function(event, $button) { // Private, not an override (not in base class).  Method name unquoted so will be safely optimized (renamed) by GCC as desired.
        switch (event.which) {
            case $.ui.keyCode.LEFT:  // left arrow
            case $.ui.keyCode.RIGHT: // right arrow
                event.preventDefault();
                
                var $enabledButtons = this.$enabledButtons;
                var length = $enabledButtons.length;
                if (length<2) // nowhere to navigate to; currently focused button is the only enabled one in toolbar
                    break;
                
                var oldIndex = $enabledButtons.index($button);
                var increment = ((event.which == $.ui.keyCode.RIGHT) ^ this.isRtl) ? 1 : -1;
                var newIndex = (oldIndex+increment+length)%length; // wrap around if at start/end of toolbar
                
                // A11y office recommended treating radios like other buttons: Arrow moves focus without selecting, Spacebar selects, 
                // which we prefer too.  Since we're using role='button', not 'radio', we don't need to follow the WAI-ARIA radio behavior 
                // where Arrow moves focus and selects, Ctrl-Arrow moves focus without selecting.  
                $enabledButtons.eq(newIndex).focus();
                break;
            case $.ui.keyCode.UP:   // up arrow
            case $.ui.keyCode.DOWN: // down arrow
                // Per above comment, treating radios like buttons, which have no native or WAI-ARIA-mandated up/down arrow behavior, 
                // so disable native focus-and-select behavior.  
                if ( $button.attr("type")=="radio" )
                    event.preventDefault();
                break;
            
            // Don't need Space/Enter handlers.  For all buttons except already-checked radios in some browsers, Space/Enter fire a click event 
            // (natively or manually), which already calls _setTabStop.  For checked radios (which are focused if they're getting 
            // this key event), _setTabStop has already been called for whichever happened 2nd:  focus (an already checked radio) or
            // check (an already focused radio) via click/Space/Enter.  If checking was done programmatically (via Bset.checked option), we require a refresh().
        }
    },
    
    _destroy: function() { // Override of protected base class method.  Method name needn't be quoted since is in externs.js.
        this.element
            .removeClass( "oj-toolbar oj-component" )
            .removeAttr( "role" );
        this.$buttons
            .attr( "tabindex", "0" ) // bsets in a toolbar should not have focusMgmt turned on, so this is OK, but should revert to orig value, not assume 0.
            .map(function() {
                return $( this ).ojButton( "widget" )[ 0 ];
            });
    }
    
    // API doc for inherited methods with no JS in this file:

    /**
     * Returns a <code class="prettyprint">jQuery</code> object containing the toolbar element.  
     * 
     * <p>This method does not accept any arguments.
     * 
     * @method
     * @name oj.ojToolbar#widget
     * @memberof! oj.ojToolbar
     * @instance
     * @return {jQuery} the toolbar element
     * 
     * @example <caption>Invoke the <code class="prettyprint">widget</code> method:</caption>
     * var widget = $( ".selector" ).ojToolbar( "widget" );
     */

    /**
     * Removes the toolbar functionality completely. This will return the element back to its pre-init state, 
     * and remove the toolbar's focus management from the contained buttons.
     * 
     * <p>This method does not accept any arguments.
     * 
     * @method
     * @name oj.ojToolbar#destroy
     * @memberof! oj.ojToolbar
     * @instance
     * 
     * @example <caption>Invoke the <code class="prettyprint">destroy</code> method:</caption>
     * $( ".selector" ).ojToolbar( "destroy" );
     */
});

// -----------------------------------------------------------------------------
// "private static members" shared by all toolbars: 
// -----------------------------------------------------------------------------

/**
 * In all cases, the return value includes only radios that are an :oj-button, i.e. radios that have been buttonized.
 * 
 * Where this method looks for radio groupmates:
 *
 * - If $elems is present (even if empty), 
 *     - This method will only look in that set, and will not attempt to weed out any false positives as defined below. 
 *       (So in this case, return value includes the specified radio iff it's an :oj-button in $elems.)
 * - Else this method looks in exactly the places where groupmates (including the original radio) would live, i.e. not in 
 *   the places false positives would live.  (So in both of the following cases, return value includes the specified radio 
 *   iff it's an :oj-button.)  Specifically:
 *     - If radio is in a form, this method will only look in that form.
 *     - Else, this method will look in the radio's document, but not in any forms.
 * 
 * Radios w/ name="" (incl name omitted) are not in a radio group (i.e. no SelectOne semantics), not even with other radios with 
 * w/ name="".  So if radio is nameless, the return value will include only radio (or nothing at all if it isn't an :oj-button, or 
 * if $elems is passed and it doesn't include radio).  
 * 
 * False positives: radios with nonempty names that match radio's name, but are actually not groupmates (i.e. no SelectOne 
 * relationship), e.g. because they're from a different form.
 * 
 * 
 * @param {!Element} radio  a radio button.  Not a JQ object, other button or element type, or null.
 * @param {jQuery=} $elems  optional JQ object, containing 0 or more elems that aren't necessarily radios or buttons, in which to look for groupmates.
 *                          E.g. the elements in a buttonset or toolbar.  Must not contain any false positives as defined above.
 */
var _radioGroup = function( radio, $elems ) {
    var name = radio.name,
        form = radio.form,
        $radios;
    if ( name ) {
        name = name.replace( /'/g, "\\'" ); // escape single quotes
        var selector = ":radio[name='" + name + "']:oj-button";
        if ( $elems ) {
            $radios = $elems.filter( selector );
        } else if ( form ) {
            $radios = $( form ).find( selector );
        } else {
            $radios = $( selector, radio.ownerDocument )
                .filter(function() {
                    return !this.form;
                });
        }
    } else {
        $radios = ($elems ? $elems.filter( radio ) : $( radio )).filter(":oj-button");
    }
    return $radios;
};

}() ); // end of Toolbar wrapper function

//ojprogressbar is based of JQueryUI porgressbar and was modified by Eugene
/*!
 * jQuery UI Progressbar 1.10.3
 * http://jqueryui.com
 *
 * Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/progressbar/
 *
 * Depends:
 *   jquery.ui.core.js
 *   jquery.ui.widget.js
 */
 
 /**
 * The ojProgressbar component allows a user to display progress of an input in a rectangular horizontal meter. 
 * If a developer does not witsh to display the exact value, a value of '-1' can be passed in to display an indeterminate value.
 * 
 * 
 * @example <caption>Initialize component using widget API</caption>
 * &lt;div id="progressBar"/&gt;<br/>
 * $("#progressBar").ojProgressbar({'value': loadValue, 'max':100});
 * @example <caption>Using knockout, value bind to observables - loadValue</caption> 
 * &lt;div id="progressBar" data-bind="ojComponent: {role: 'ojProgressbar', value: loadValue, max:100}"/&gt;gt;
 * 
 * @class
 * @constructor
 * @name oj.ojProgressbar
 * @augments oj.baseComponent
 */
(function() {

oj.__registerWidget("oj.ojProgressbar",  $['oj']['baseComponent'], {
	version: "1.0.0",
	defaultElement : "<div>", 
    widgetEventPrefix : "oj", 
	options: {
		/** 
		 * The maximum allowed value. The element's max attribute is used if it 
		 * is provided, otherwise the default value of 100 is used. 
		 * @expose 
		 * @public
		 * @instance
		 * @memberof! oj.ojProgressbar 
		 * @default <code class="prettyprint">100</code>
		 */
		max: 100,
		/** 
		 * The value of the progressbar. The element's value attribute is used if it 
		 * is provided, otherwise the default value of 0 is used.
		 * @expose 
		 * @public
		 * @instance
		 * @memberof! oj.ojProgressbar 
		 * @default <code class="prettyprint">0</code>
		 */
		value: 0,
		/** 
		 * If disbled is set to true, then the progressbar will not change if a new value is passed in.
		 * By default this parameter is set to false.
		 * @expose 
		 * @public
		 * @instance
		 * @memberof! oj.ojProgressbar 
		 * @default <code class="prettyprint">false</code>
		 */
		disabled: false
		
		/**
         * Triggered when the progressbar is created.
         *
         * @event 
         * @name create
         * @memberof! oj.ojProgressbar
         * @instance
         * @property {Event} event <code class="prettyprint">jQuery</code> event object
         * @property {Object} ui Empty object included for consistency with other events
         * 
         */
	},
    // The min value is a constant and 0 is the value set for it.
	min: 0,
	
	 /** 
	   * Variable used to indicate that the value is indeterminate
	   *
	   * @override
	   * @private
	   */
	_indeterminate: false,
	
	 /**
	   * 
	   * _create contains all actions that are needed fo the initialization of the progressbar and is only called once.
	   *
	   * @override
	   * @private
	   */
	_create: function() {
		// Constrain initial value
		this.oldValue = this.options.value = this._constrainedValue();

		this.element
			.addClass( "oj-progressbar oj-component oj-component-content oj-corner-all" )
			.attr({
				// Only set static values, aria-valuenow and aria-valuemax are
				// set inside _refreshValue()
				"role": "progressbar",
				"aria-valuemin": this.min
			});

		this.valueDiv = $( "<div class='oj-progressbar-value oj-component-header oj-corner-left'></div>" )
			.appendTo( this.element );

		this._refreshValue();
		
		this._super();
	},
	
  /** 
   * Called when creating widget. Looks for attributes on the dom, and sets
   * the options.
   * @override
   * @private
   */
  _InitOptions : function ()
  {
    var element = this.element, savedAttributes = this._GetSavedAttributes(element);
    
    this._super();
    // MAX: (number)
    if (this.options['max'] == null) // null or undefined
    {
      this.options['max'] = 'max' in savedAttributes ? savedAttributes['max']['prop'] : undefined;
    }
  },
	
  /**
	 * Check that value is valid and within the correct bounds. A value of -1 indicates an indeterminate value.
	 * @param {Object} newValue - The newValue of the progressbar being passed in.
   * @override
   * @public
 	 * @memberof! oj.ojProgressbar 
   * 
   */	 
	value : function(newValue) {
		if ( newValue === undefined) {
			return this.options.value;
		}

		this.options.value = this._constrainedValue( newValue );

	},
  /**
   * Check that value is valid and within the correct bounds. A value of -1 indicates an indeterminate value.
   * @param {number} newValue - The new value of the progressbar being passed in.
   * @override
   * @private
   */
	_constrainedValue: function( newValue ) {
		if ( newValue === undefined ) {
			newValue = this.options.value;
		}
		
        // Indicates that the value is indeterminate.
		this._indeterminate = (newValue == -1 );

		// sanitize value
		if ( typeof newValue !== "number" ) {
			newValue = isNaN(newValue) ? 0 : Number(newValue);

		}

		return this._indeterminate ? -1 :
			Math.min( this.options.max, Math.max( this.min, newValue ) );
	},
  /**
   * Set the value
   * @param {Object} options - The options being set
   * @override
   * @private
   */
	_setOptions: function( options ) {
		// Ensure "value" option is set after other values (like max)
		if( !this.options.disabled) {
		    var value = options.value;
		    delete options.value;

		    this._super( options );
		    this.options.value = this._constrainedValue( value );
		    this._refreshValue();
		}
	},

   /**
   * Check that the max value is not less than the min 
   * @param {string} key - The key for the option being set
   * @param {string|number} value - The value being set
   * @override
   * @private
   */
	_setOption: function( key, value ) {
		if ( key === "max" ) {
			// Don't allow a max less than min
			value = Math.max( this.min, value );
		}

		this._super( key, value );
	},
  /**
   * Calculates the percentage of the progressbar that has been loaded based on min, max, and value.
   *
   * @override
   * @private
   */
	_percentage: function() {
		return this._indeterminate ? 100 : 100 * ( this.options.value - this.min ) / ( this.options.max - this.min );
	},

   /**
    * This function is used to update the value when the value has changed.
    *
    * @override
    * @private
    */
	_refreshValue: function() {
		var value = this.options.value,
			percentage = this._percentage();

		this.valueDiv
			.toggle( this._indeterminate || value > this.min )
			.toggleClass( "oj-corner-right", value === this.options.max )
			.width( percentage.toFixed(0) + "%" );

		this.element.toggleClass( "oj-progressbar-indeterminate", this._indeterminate );


		if ( this._indeterminate) {
			this.element.attr({
				"aria-valuetext": "In Progress"
			});
			this.element.removeAttr( "aria-valuenow" );
			this.element.removeAttr( "aria-valuemin" );
			this.element.removeAttr( "aria-valuemax" );
			if ( !this.overlayDiv ) {
				this.overlayDiv = $( "<div class='oj-progressbar-overlay'></div>" ).appendTo( this.valueDiv );
			}
		} else {
			this.element.attr({
				"aria-valuemax": this.options.max,
				"aria-valuenow": value
			});
			if ( this.overlayDiv ) {
				this.overlayDiv.remove();
				this.overlayDiv = null;
			}
		}
	},
	
   /**
    * Overide the destory function to remove appropriate class and atrributes.
    *
    * @override
    * @private
    */	
	_destroy: function() {
		this.element
			.removeClass( "oj-progressbar oj-component oj-component-content oj-corner-all" )
			.removeAttr( "role" )
			.removeAttr( "aria-valuemin" )
			.removeAttr( "aria-valuemax" )
			.removeAttr( "aria-valuenow" );

		this.valueDiv.remove();
	}
});

}( ));

})();